
########## NEXT FILE ##########
acc_testsuite.h:::
/* Global headerfile of the OpenACC Testsuite */

/* This file was created with the accts_makeHeader.pl script using the following opions: */
/* -f=accts-c.conf -t=c  */


#ifndef ACC_TESTSUITE_H
#define ACC_TESTSUITE_H

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>
#include <limits.h>
#include <complex.h>
#ifdef _OPENACC
#include <openacc.h>
#endif
#include <string.h>
/* Version info                                           */
/**********************************************************/
#define ACCTS_VERSION "2.5"


/* General                                                */
/**********************************************************/
#define ARRAYSIZE   100
long long n = ARRAYSIZE;
#define PRECISION   1e-8
typedef double real_t;

#ifdef __cplusplus
template<typename acctype>
class data_container{
  public:
    acctype* data;
    size_t length;
    inline acctype& operator[](int i){
        return this->data[i];
    }
    acctype* get_data(){
        return this->data;
    }
    data_container(int size){
        this->length = size;
        this->data = (acctype *)malloc(size * sizeof(acctype));
    }
    ~data_container(){
        free(data);
    }
};
#else
typedef enum { false, true } bool;
#endif

#define ARRAYSIZE_NEW 256
#define ARRAYSIZE_SMALL 10

#define REPETITIONS 1
#define LOOPCOUNT 100
/* following times are in seconds */
#define SLEEPTIME	 0.01
#define SLEEPTIME_LONG	 0.5

typedef struct {
  double real;
  double imag;
} dcomplex;


#endif

#ifndef SEED
#define SEED time(NULL)
#endif

#ifndef NUM_TEST_CALLS
#define NUM_TEST_CALLS 1
#endif

typedef struct {
  real_t * a;
  real_t * b;
} two_d_array;

########## NEXT FILE ##########
acc_testsuite_declare.h:::
// #include "acc_testsuite.h"
/* Global headerfile of the OpenACC Testsuite */

/* This file was created with the accts_makeHeader.pl script using the following opions: */
/* -f=accts-c.conf -t=c  */


#ifndef ACC_TESTSUITE_DECLARE_H
#define ACC_TESTSUITE_DECLARE_H

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>
#include <limits.h>
#include <complex.h>
#ifdef _OPENACC
#include <openacc.h>
#endif
#include <string.h>
/* Version info                                           */
/**********************************************************/
#define ACCTS_VERSION "2.5"


/* General                                                */
/**********************************************************/
#define ARRAYSIZE   250
long long n = ARRAYSIZE;
#define PRECISION   1e-8
typedef double real_t;

#ifdef DECLARE_TEST
int fixed_size_array[10] = {0, 1, 4, 9, 16, 25, 36, 49, 64, 81};
real_t* datapointer;
int scalar_extern = 10; //For global scalar tests
#endif

#ifdef DECLARE_COPYIN
extern int mult_copyin;
#pragma acc declare copyin(mult_copyin)
#pragma acc routine vector
void extern_multiplyData_copyin(real_t *a, long long n){
    #pragma acc loop
    for (int x = 0; x < n; ++x){
        a[x] = a[x] * mult_copyin;
    }
}
#endif

#ifdef DECLARE_CREATE
extern int mult_create = 2;
#pragma acc declare create(mult_create)

#pragma acc routine vector
void extern_multiplyData(real_t *a){
    #pragma acc data present(a[0:n])
    {
        #pragma acc loop vector
        for (int x = 0; x < n; ++x){
            a[x] = a[x] * 2;
        }
    }

    #pragma acc update host(a[0:n])
}
#endif

#ifdef DECLARE_DEVICE_RESIDENT
extern int mult_device_resident;
#pragma acc declare device_resident(mult_device_resident)
#pragma acc routine vector
void extern_multiplyData_device_resident(real_t *a, long long n){
    #pragma acc loop
    for (int x = 0; x < n; ++x){
        a[x] = a[x] * mult_device_resident;
    }
}
#endif

#ifdef DECLARE_DEVICEPTR
extern real_t* a_deviceptr;
#pragma acc declare deviceptr(a_deviceptr)
#pragma acc routine vector
void extern_multiplyData_deviceptr(int mult, long long n){
    #pragma acc loop
    for (int x = 0; x < n; ++x){
        a_deviceptr[x] = a_deviceptr[x] * mult;
    }
}
#endif

#ifdef __cplusplus
template<typename acctype>
class data_container{
  public:
    acctype* data;
    size_t length;
    inline acctype& operator[](int i){
        return this->data[i];
    }
    acctype* get_data(){
        return this->data;
    }
    data_container(int size){
        this->length = size;
        this->data = (acctype *)malloc(size * sizeof(acctype));
    }
    ~data_container(){
        free(data);
    }
};
#else
typedef enum { false, true } bool;
#endif

#define ARRAYSIZE_NEW 1024
#define ARRAYSIZE_SMALL 10

#define REPETITIONS 1
#define LOOPCOUNT 1000
/* following times are in seconds */
#define SLEEPTIME        0.01
#define SLEEPTIME_LONG   0.5

typedef struct {
  double real;
  double imag;
} dcomplex;


#endif

#ifndef SEED
#define SEED time(NULL)
#endif

#ifndef NUM_TEST_CALLS
#define NUM_TEST_CALLS 1
#endif
// int main(){
//     int failcode = 0;
//     int testrun;
//     int failed;
//     return failcode;
// }
########## NEXT FILE ##########
debug.h:::
#define BENCHMARK

#define ENABLE_ACC_COMPARE
#define ENABLE_PGI_COMPARE

#ifdef USE_NVTX
#include "nvToolsExt.h"

const uint32_t ProfilerColors[] = { 0xff00ff00, 0xff0000ff, 0xffffff00, 0xffff00ff, 0xff00ffff, 0xffff0000, 0xffffffff };

#define NVPROF_PUSH_RANGE(name,cid) { \
    int color_id = cid; \
    nvtxEventAttributes_t eventAttrib = {0}; \
    eventAttrib.version = NVTX_VERSION; \
    eventAttrib.size = NVTX_EVENT_ATTRIB_STRUCT_SIZE; \
    eventAttrib.colorType = NVTX_COLOR_ARGB; \
    eventAttrib.color = ProfilerColors[color_id]; \
    eventAttrib.messageType = NVTX_MESSAGE_TYPE_ASCII; \
    eventAttrib.message.ascii = name; \
    nvtxRangePushEx(&eventAttrib); \
}
#define NVPROF_POP_RANGE nvtxRangePop();
#else
#define NVPROF_PUSH_RANGE(name,cid)
#define NVPROF_POP_RANGE
#endif

#if defined(ENABLE_PGI_COMPARE) && defined(USE_PGI_COMPARE) && defined(_OPENACC) && defined(__PGI)
#include <openacc.h>
#define PGI_COMPARE(ptr,type,size,name,file,func,line) {\
    type* pgi_compare_ptr = (type*)ptr;\
    pgi_compare(ptr, "type", size, \
    name, file, func, line);\
}
#else
#define PGI_COMPARE(ptr,size,name,file,func,line)
#endif

#if defined(ENABLE_ACC_COMPARE) && defined(USE_ACC_COMPARE) && defined(_OPENACC) && defined(__PGI)
#include <openacc.h>
#define ACC_COMPARE(ptr,type,size) {\
    type* acc_compare_ptr = (type*) ptr;\
    acc_compare(acc_compare_ptr, size);\
}
#else
#define ACC_COMPARE(ptr,type,size)
#endif


########## NEXT FILE ##########
supply.h:::
//
#ifndef SUPPLY
#define SUPPLY

#define PI      3.1415926536

enum bb_carbon  {bb_ca,bb_cb,bb_co};
enum methyl {hydrogen,carbon};


struct dihe_group
{
	int id;
	char code;
	int type;
	bool bgood;


	int x1,x2,x3,x4;
};

struct index_three
{
	int x1,x2,x3;
};

struct index_two
{
	int x1,x2;
};

struct ring_group
{
	int x1;
	int x2,x3,x4,x5,x6,x7;

	int id;
	char code;
	bool bgood;
};

struct double_five
{
	double x[5];
};

struct double_four
{
	double x[4];
};

struct double_three
{
	double x[3];
};

struct methyl_group
{
	int id;
	char code;
	int type;
	int cpos;
	int hpos[6];
	double exp_h;
	double exp_c;
	double shifts_h;
	double shifts_c;
};


struct proton
{
	int id;
	char code;
	int type;
	string name;
	string cname;
	int hpos[6];
	int nh;
	int cpos;
	double exp;
	double exp_c;

	//used for HB2 HB3 ambiguity. 
	bool multy;
	int type2;
	string name2;
	string cname2;
	double exp1;
	double exp2;
};



struct bb_group
{
	int chain;  //chain index
	int id;     //residue index
	int id0;    //ID in PDB file
	char code;  //AA one letter name
	char ss;    //secondary structures

	int exploaded;           //experiment CS exist    
	bool previous_mut; 
	bool follow_mut;

	int hpos;
	int npos;
	int capos;
	int cbpos;
	int copos;
	int opos;
	int hapos;
	int hapos2;
 
	int follow_hpos;
	int follow_npos;
	double follow_exp_h;
	double follow_exp_n;
	double follow_exp_ca;

	double exp_ha;
	double exp_ha2;
	double exp_h;
	double exp_n;
	double exp_ca;
	double exp_cb;
	double exp_co;

	double pre_ca;
	double pre_cb;
	double pre_c;
	double pre_n;
	double pre_h;
	double pre_ha;

	vector<int> previous;
	vector<int> follows;
};

struct nh_group
{
	int id;
	char code;
	int hpos;
	int npos;

	double exp_h;
	double exp_n;

	double sparta_h;
	double sparta_n;
};

struct co_group
{
	int id;
	char code;

	int cpos;
	int opos;

	double exp_c;
	double exp_o;
};

struct ani_group
{
	int id;
	char code;
	int type;
	int pos[3];
};

struct bbhbond_group
{
	int id;
	char code;
	int npos;
	int hpos;
	int cpos;
	int opos;
	int type;
};

struct ehbond
{
	double n_length;
	double n_phi;
	double n_psi;

	double c_length;
	double c_phi;
	double c_psi;
};

struct eschbond
{
	double n_length;
	double n_phi;
	double n_psi;

	double c_length;
	double c_phi;
	double c_psi;

	int id;
	int type;
};

struct noeatoms
{
	vector< vector<int> > atoms;
	double length;
};

struct noeline
{
	int group;
	int id;
	int multi;
	int resid1,resid2;
	string atomname1,atomname2;
	string resname1,resname2; 
	int oldresid1,oldresid2;
	string oldatomname1,oldatomname2;
	double a,b,c;
	vector<double> obs;
	vector<int> pos1;
	vector<int> pos2;
	struct noeatoms index1,index2;
	double d;
	bool bvio;
};

struct diheline
{
	int id;
	vector<int>  resid;
	vector<string> resname;
	vector<string> atomname;
	vector< noeatoms > index;
	double upper;
	double lower;
	double middle;
	double delta;
};



class CCommandline
{
	private:
		int narg;
		vector<string> arguments;
		vector<string> parameters;
		vector<string> informations;
	protected:
	
	public:
		void pharse(int argc, char** argv);
		void init(vector<string>,vector<string>);
		void init(vector<string>,vector<string>,vector<string>);
		void print();
		string query(string);
		CCommandline();
		~CCommandline();
};




class CRmsd
	{
	private:
		float mov_com0;
		float mov_com1;
		float mov_com2;
		float ref_com0;
		float ref_com1;
		float ref_com2;
		float mov_to_ref0;
		float mov_to_ref1;
		float mov_to_ref2;
		float U00,U01,U02,U10,U11,U12,U20,U21,U22; 
		float R00;float R01;float R02;
		float R10;float R11;float R12;
		float R20;float R21;float R22;
		float vec00;float vec01;float vec02;
		float vec10;float vec11;float vec12;
		float vec20;float vec21;float vec22;
		float E0, residual;
		float RtR00,RtR01,RtR02,RtR10,RtR11,RtR12,RtR20,RtR21,RtR22;
		float left_eigenvec00,left_eigenvec01,left_eigenvec02,left_eigenvec10,left_eigenvec11,left_eigenvec12,left_eigenvec20,left_eigenvec21,left_eigenvec22;
		float right_eigenvec00,right_eigenvec01,right_eigenvec02,right_eigenvec10,right_eigenvec11,right_eigenvec12,right_eigenvec20,right_eigenvec21,right_eigenvec22;
		float eigenval0,eigenval1,eigenval2;


		void setup_rotation(float x[],float y[],float z[],
						float x0[],float y0[],float z0[], 
						int n_list);
		int jacobi3(int* n_rot);
		int diagonalize_symmetric();
		void get_rotation_matrix();
		int calculate_rotation_matrix();


	protected:
	public:
		float calculate_rotation_rmsd(float x[],float y[],float z[],float x0[],float y0[],float z0[],int n_list);
		float direct_rmsd(float x[],float y[],float z[],float x0[],float y0[],float z0[],int n_list);
		CRmsd();
		~CRmsd();
	};

namespace Sequence
{
	int code2pos(char code);
	string code2name(char c);
	void code2array(char code, int buffer[20]);
	void code2same(char code, int buffer[20]);
	char name2code(string in);
	vector<double> expand(char ,vector<double> *);
	vector<double> expand2(int ,vector<double> *);
	vector<int> align(string c1,string c2);
	vector<int> aligno(string c1,string c2, string &out1, string &out2,string &out3);
};

namespace ldw_math
{

	const double pi=3.14159265358979;
	double gaussrand(void);
	vector<int> cluster_pick2(int,vector<double>, vector<double>, double);
#pragma acc routine seq
	double veclength(double x[3]);
#pragma acc routine seq
	void cross(double z[3],double x[3],double y[3]);
#pragma acc routine seq
	double dot(double x[3],double y[3]);

#pragma acc routine seq
	double coor_to_angle(double x2,double y2,double z2,double x3,double y3,double z3,double x4,double y4,double z4);
	double coor_to_length(double x3,double y3,double z3,double x4,double y4,double z4);
	double coor_to_dihe(double x1,double y1,double z1,double x2,double y2,double z2,double x3,double y3,double z3,double x4,double y4,double z4);

	void fit(vector<double> x,vector<double> y, vector<double> *z,double *a,double *b,double *rms,double *r);
#pragma acc routine seq
	int dsvd(double a[6][3], int m, int n, double *w, double v[3][3]);
	int dsvd2(double *a, int m, int n, double *w, double v[3][3]);
#pragma acc routine seq
	double area( double a, double b, double c );
#pragma acc routine seq
	double PYTHAG(double a, double b);
#pragma acc routine seq
	double mymax(double a, double b);
#pragma acc routine seq
	double mysign(double a,double b);
#pragma acc routine seq
	double effect(double x[6][3], int m, double ori[3], double p1[3]);
	void project(double ori[3], double p1[3], double p2[3]);
#pragma acc routine seq
	void ring(double x[6][3], int m, double ori[3]);
	void regression_plane(double *x, int m, double ori[3]);


	void rotation_around_axis(double point[3], double ori[3], double theta);
}


#endif

########## NEXT FILE ##########
BioFVM_mesh.h:::
/*
#############################################################################
# If you use BioFVM in your project, please cite BioFVM and the version     #
# number, such as below:                                                    #
#                                                                           #
# We solved the diffusion equations using BioFVM (Version 1.1.7) [1]        #
#                                                                           #
# [1] A. Ghaffarizadeh, S.H. Friedman, and P. Macklin, BioFVM: an efficient #
#    parallelized diffusive transport solver for 3-D biological simulations,#
#    Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730 #
#                                                                           #
#############################################################################
#                                                                           #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)   #
#                                                                           #
# Copyright (c) 2015-2017, Paul Macklin and the BioFVM Project              #
# All rights reserved.                                                      #
#                                                                           #
# Redistribution and use in source and binary forms, with or without        #
# modification, are permitted provided that the following conditions are    #
# met:                                                                      #
#                                                                           #
# 1. Redistributions of source code must retain the above copyright notice, #
# this list of conditions and the following disclaimer.                     #
#                                                                           #
# 2. Redistributions in binary form must reproduce the above copyright      #
# notice, this list of conditions and the following disclaimer in the       #
# documentation and/or other materials provided with the distribution.      #
#                                                                           #
# 3. Neither the name of the copyright holder nor the names of its          #
# contributors may be used to endorse or promote products derived from this #
# software without specific prior written permission.                       #
#                                                                           #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS       #
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED #
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A           #
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER #
# OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  #
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,       #
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR        #
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF    #
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING      #
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS        #
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.              #
#                                                                           #
#############################################################################
*/

#ifndef __BioFVM_mesh_h__
#define __BioFVM_mesh_h__

#include <iostream>
#include <vector> 

#include "BioFVM_matlab.h"

namespace BioFVM{

 /*! \brief Voxels are the basic spatial container for densities, which are networked into meshes. 
  * 
  * Voxels are the basic spatial container for a finite volume method. Voxels are connected to 
  * other voxels into a General_Mesh, here most likely a Cartesian_Mesh. Voxel boundaries are Voxel_Faces. 
  * 
  * A Microenvironment Domain will include a network of Voxels (and Voxel_Faces), 
  * with a vector<double> of densities for each Voxel, along with rate constants, etc. 
  * The Domain may also include a vector<double> of flux coefficients for each Voxel_Face. 
 */
 
class Voxel
{

 private:
	friend std::ostream& operator<<(std::ostream& os, const Voxel& v); 
	/*!< outputs the Voxel to an open ostream 
	 * \param os -- the stream 
	 * \param mv -- the voxel you use this friendly friend operator on
	 * Example: Voxel v; 
	 *          cout << v << endl; 
	*/ 

 public:
	Voxel(); 
	int mesh_index; /*!< voxel's index in a General_Mesh */ 

	double volume; /*!< voxel's volume (cubic spatial units) */ 
	std::vector<double> center; /*!< center of volume */
	bool is_Dirichlet;
	void stream_output_with_units( std::ostream& os , std::string units ) const;
};

class Voxel_Face
{
 private:
	friend std::ostream& operator<<(std::ostream& os , const Voxel_Face& vf ); 
	
 public:
	Voxel_Face(); 
	int mesh_index; 
	
	double surface_area; 
	std::vector<double> center; 
	std::vector<double> outward_normal; 
	std::vector<double> inward_normal; 
	
	void stream_output_with_units( std::ostream& os , std::string units ) const;
};

class General_Mesh
{
 private: 
	friend std::ostream& operator<<(std::ostream& os, const General_Mesh& mesh);  
	
	// this stores the indexing of the voxel faces (connect voxel i to voxel j, face stored at k)
	// only for use in a future release
	// std::unordered_map< int,std::unordered_map<int,int> > voxel_face_index_mapping; 
	
 public:
	General_Mesh();  
	
	// [xmin ymin zmin xmax ymax zmax ]
	std::vector<double> bounding_box; 
	
	std::vector<Voxel> voxels; 
	std::vector<Voxel_Face> voxel_faces; 
	// each voxel[k] has a list of connected voxels -- helpful for some numerical methods 
	std::vector< std::vector<int> > connected_voxel_indices; 
	
	int nearest_voxel_index( std::vector<double>& position );   
	bool is_position_valid(double x, double y, double z);
	/* the following help manage the voxel faces */ 

	// returns the index of the voxel face connecting from voxels[i] to voxels[j] 
	int voxel_face_index( int i, int j ); 
	
	// returns the Voxel_Face connecting voxels[i] to voxels[j] 
	Voxel_Face& voxel_face(int i, int j );   
	// returns the normal vector from voxels[i] to voxels[j] 
	std::vector<double>& outward_normal( int i, int j ); 
	
	/*! This creates a Voxel_Face from voxels[i] to voxels[j], and another from voxels[j] to 
	    voxels[i], both with surface area SA. It also auto-updates connected_voxel_indices[i] 
	    and connected_voxel_indices[j]. */ 
	void connect_voxels(int i,int j, double SA);   
	
	void connect_voxels_faces_only(int i,int j, double SA); 
	void connect_voxels_indices_only(int i,int j, double SA); 
	
	/*! This removes all connections between voxels[i] and voxels[j], and deletes the associated 
	    Voxel_Face(s). */
	void disconnect_voxels(int i, int j); 
	void clear_voxel_face_index_mapping( void );  
	
	bool Cartesian_mesh; 
	bool uniform_mesh; 
	bool regular_mesh;
	bool use_voxel_faces; 
	
	std::string units; 
	
	void display_information( std::ostream& os); 
	
	void write_to_matlab( std::string filename ); 
	void read_from_matlab( std::string filename ); 
};

class Cartesian_Mesh : public General_Mesh
{
 private:
 
 public:
	std::vector<double> x_coordinates; 
	std::vector<double> y_coordinates;
	std::vector<double> z_coordinates; 	
	std::vector< std::vector<int> > moore_connected_voxel_indices; // Keeps the list of voxels in the Moore nighborhood 
	void create_moore_neighborhood(void);
	#pragma acc routine
	unsigned int voxel_index( unsigned int i, unsigned int j, unsigned int k ); 
	std::vector<unsigned int> cartesian_indices( unsigned int n ); 
	
	double dx;
	double dy;
	double dz; 
	
	double dV; 	
	double dS;

	double dS_xy;
	double dS_yz; 
	double dS_xz;
	
	Cartesian_Mesh(); // done 
	
	Cartesian_Mesh( int , int , int );  
	
	void create_voxel_faces( void ); 

	void resize( int,int,int ); 
	void resize( double x_start, double x_end, double y_start, double y_end, double z_start, double z_end , int x_nodes, int y_nodes, int z_nodes ); 
	void resize( double x_start, double x_end, double y_start, double y_end, double z_start, double z_end , double dx, double dy, double dz ); 
	void resize_uniform( double x_start, double x_end, double y_start, double y_end, double z_start, double z_end , double dx ); 
	
	int nearest_voxel_index( std::vector<double>& position );   
	int nearest_voxel_face_index( std::vector<double>& position );  
	std::vector<unsigned int> nearest_cartesian_indices( std::vector<double>& position ); 
	Voxel& nearest_voxel( std::vector<double>& position ); 
	
	void display_information( std::ostream& os ); 
	
	void read_from_matlab( std::string filename ); 
};

class Voronoi_Mesh : public General_Mesh
{
 private:
 
 public:
	void display_information( std::ostream& os); 
};

};

#endif

########## NEXT FILE ##########
BioFVM_microenvironment.h:::
/*
#############################################################################
# If you use BioFVM in your project, please cite BioFVM and the version     #
# number, such as below:                                                    #
#                                                                           #
# We solved the diffusion equations using BioFVM (Version 1.1.7) [1]        #
#                                                                           #
# [1] A. Ghaffarizadeh, S.H. Friedman, and P. Macklin, BioFVM: an efficient #
#    parallelized diffusive transport solver for 3-D biological simulations,#
#    Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730 #
#                                                                           #
#############################################################################
#                                                                           #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)   #
#                                                                           #
# Copyright (c) 2015-2017, Paul Macklin and the BioFVM Project              #
# All rights reserved.                                                      #
#                                                                           #
# Redistribution and use in source and binary forms, with or without        #
# modification, are permitted provided that the following conditions are    #
# met:                                                                      #
#                                                                           #
# 1. Redistributions of source code must retain the above copyright notice, #
# this list of conditions and the following disclaimer.                     #
#                                                                           #
# 2. Redistributions in binary form must reproduce the above copyright      #
# notice, this list of conditions and the following disclaimer in the       #
# documentation and/or other materials provided with the distribution.      #
#                                                                           #
# 3. Neither the name of the copyright holder nor the names of its          #
# contributors may be used to endorse or promote products derived from this #
# software without specific prior written permission.                       #
#                                                                           #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS       #
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED #
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A           #
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER #
# OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  #
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,       #
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR        #
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF    #
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING      #
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS        #
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.              #
#                                                                           #
#############################################################################
*/

#ifndef __BioFVM_microenvironment_h__
#define __BioFVM_microenvironment_h__

#include "BioFVM_mesh.h"
#include "BioFVM_agent_container.h"
#include "BioFVM_MultiCellDS.h"

namespace BioFVM{

/* and now some gradients */ 
typedef std::vector<double> gradient; 

/*! /brief   */

class Basic_Agent; 

class Microenvironment
{
 private:
	friend std::ostream& operator<<(std::ostream& os, const Microenvironment& S);  

	/*! For internal use and accelerations in solvers */ 
	std::vector< std::vector<double> > temporary_density_vectors1; 
	/*! For internal use and accelerations in solvers */ 
	std::vector< std::vector<double> > temporary_density_vectors2; 
	
	/*! for internal use in bulk source/sink solvers */
	std::vector< std::vector<double> > bulk_source_sink_solver_temp1; 
	std::vector< std::vector<double> > bulk_source_sink_solver_temp2; 
	std::vector< std::vector<double> > bulk_source_sink_solver_temp3; 
	bool bulk_source_sink_solver_setup_done; 

	
	/*! stores pointer to current density solutions. Access via operator() functions. */ 
	//std::vector< std::vector<double> >* p_density_vectors;
	// commenting out because PGI complains when its private
	
	std::vector< std::vector<gradient> > gradient_vectors; 
	std::vector<bool> gradient_vector_computed; 

	
	/*! helpful for solvers -- resize these whenever adding/removing substrates */ 
	std::vector<double> one; 
	std::vector<double> zero; 
	std::vector<double> one_half; 
	std::vector<double> one_third; 
	
	/*! for internal use in diffusion solvers : these make the solvers safe across microenvironments ""*/ 
	std::vector< std::vector<double> > thomas_temp1; 
	std::vector< std::vector<double> > thomas_temp2; 
	std::vector<double> thomas_constant1x; 
	std::vector<double> thomas_constant1y; 
	std::vector<double> thomas_constant1z; 
	std::vector<double> thomas_neg_constant1x; 
	std::vector<double> thomas_neg_constant1y; 
	std::vector<double> thomas_neg_constant1z; 
	bool thomas_setup_done; 
	int thomas_i_jump; 
	int thomas_j_jump; 
	int thomas_k_jump; 
	std::vector<double> thomas_constant1; 
	std::vector<double> thomas_constant1a; 
	std::vector<double> thomas_constant2;
	std::vector<double> thomas_constant3;
	std::vector<double> thomas_constant3a;
	std::vector< std::vector<double> > thomas_denomx;
	std::vector< std::vector<double> > thomas_cx;
	std::vector< std::vector<double> > thomas_denomy;
	std::vector< std::vector<double> > thomas_cy;
	std::vector< std::vector<double> > thomas_denomz;
	std::vector< std::vector<double> > thomas_cz;
	bool diffusion_solver_setup_done; 
	
	// on "resize density" type operations, need to extend all of these 
	
	/*
	std::vector<int> dirichlet_indices; 
	std::vector< std::vector<double> > dirichlet_value_vectors; 
	std::vector<bool> dirichlet_node_map; 
	*/
	std::vector< std::vector<double> > dirichlet_value_vectors; 
	std::vector<bool> dirichlet_activation_vector; 	
 public:

	std::vector< std::vector<double> >* p_density_vectors; // must be public for PGI Compiler

	/* variables for GPU  */
	bool openacc_data_bool; // bool for openacc data transfer
	double ** gpu_p_density_vectors; // gpu copy of p_density_vectors
	double ** gpu_thomas_denomx; // gpu copy of thomas_denomx
	double ** gpu_thomas_denomy; // gpu copy of thomas_denomy
	double ** gpu_thomas_denomz; // gpu copy of thomas_denomz
	double * gpu_thomas_constant1; // gpu copy of thomas_constant1
	int * gpu_thomas_i_jump; // gpu copy of thomas_i_jump
	int * gpu_thomas_j_jump; // gpu copy of thomas_j_jump
	int * gpu_thomas_k_jump; // gpu copy of thomas_k_jump
	double ** gpu_thomas_cx; // gpu copy of thomas_cx
	double ** gpu_thomas_cy; // gpu copy of thomas_cy
	double ** gpu_thomas_cz; // gpu copy of thomas_cz
	double ** gpu_dirichlet_value_vectors; // gpu copy of dirichlet_value_vectors
	bool * gpu_dirichlet_activation_vector; //gpu copy of dirichlet_activation_vector
	bool * gpu_voxels_is_dirichlet; //mesh.voxels[iteration].is_Dirichlet value copy, mesh size
	int * sizes_p_density_vectors;
	int * sizes_thomas_denomx;
	int * sizes_thomas_denomy;
	int * sizes_thomas_denomz;
	int * sizes_thomas_cx;
	int * sizes_thomas_cy;
	int * sizes_thomas_cz;
	int * sizes_dirichlet_value_vectors;
	int sizes_thomas_constant1;

	int num_dirichlet;

	/* functions for GPU  */
	void axpy_acc( double* y, double* a, double* x, int size ); //added size to axpy, passes in size of the first array for ease
	void naxpy_acc( double* y, double* a, double* x, int size ); //added size to naxpy, passes in size of the first array for ease

	void transfer_2D();
	void transfer_3D();

	void translate_vector_to_array();
	void translate_array_to_vector();

	void apply_dirichlet_conditions_GPU(void);
	void x_diffusion_GPU_2D();
	void y_diffusion_GPU_2D();

	void x_diffusion_GPU_3D();
	void y_diffusion_GPU_3D();
	void z_diffusion_GPU_3D();

	int get_size_p1(); // gets the size of p_density_vectors
	int get_size_p2(); // gets the size of p_density_vectors[0] = 3


	/*! The mesh for the diffusing quantities */ 
	Cartesian_Mesh mesh;
	Agent_Container * agent_container;	
	std::string spatial_units; 
	std::string time_units; 
	std::string name; 

	// diffusing entities 
	std::vector< std::string > density_names; 
	std::vector< std::string > density_units; 
 
	// coefficients 
	std::vector< double > diffusion_coefficients; 
	std::vector< double > decay_rates; 
	
	std::vector< std::vector<double> > supply_target_densities_times_supply_rates; 
	std::vector< std::vector<double> > supply_rates; 
	std::vector< std::vector<double> > uptake_rates; 
	void update_rates( void ); 
	
	Microenvironment(); 
	Microenvironment(std::string name);
	
	void (*diffusion_decay_solver)( Microenvironment&, double); 
	void (*bulk_supply_rate_function)( Microenvironment* pMicroenvironment, int voxel_index, std::vector<double>* write_destination );
	void (*bulk_supply_target_densities_function)( Microenvironment* pMicroenvironment, int voxel_index, std::vector<double>* write_destination );
	void (*bulk_uptake_rate_function)( Microenvironment* pMicroenvironment, int voxel_index, std::vector<double>* write_destination );
		
	/*! functions to simplify size queries */ 
	
	unsigned int number_of_densities( void ); 
	unsigned int number_of_voxels( void ); 
	unsigned int number_of_voxel_faces( void ); 

 	
	void auto_choose_diffusion_decay_solver( void ); 
	
	// Only use this on non-Cartesian meshes. It's a fail-safe. 
	void resize_voxels( int new_number_of_voxes ); 
	
	void resize_space( int x_nodes, int y_nodes, int z_nodes ); 
	void resize_space( double x_start, double x_end, double y_start, double y_end, double z_start, double z_end , int x_nodes, int y_nodes, int z_nodes );  
	void resize_space( double x_start, double x_end, double y_start, double y_end, double z_start, double z_end , double dx_new , double dy_new , double dz_new ); 
	void resize_space_uniform( double x_start, double x_end, double y_start, double y_end, double z_start, double z_end , double dx_new ); 

	void resize_densities( int new_size );  
	void add_density( void ); 
	void add_density( std::string name , std::string units );
	void add_density( std::string name , std::string units, double diffusion_constant, double decay_rate ); 

	void set_density( int index , std::string name , std::string units ); 
	void set_density( int index , std::string name , std::string units , double diffusion_constant , double decay_rate ); 

	int find_density_index( std::string name ); 

	#pragma acc routine
	int voxel_index( int i, int j, int k ); 
	std::vector<unsigned int> cartesian_indices( int n ); 
	
	int nearest_voxel_index( std::vector<double>& position ); 
	std::vector<unsigned int> nearest_cartesian_indices( std::vector<double>& position ); 
	Voxel& nearest_voxel( std::vector<double>& position ); 
	Voxel& voxels( int voxel_index );
	std::vector<double>& nearest_density_vector( std::vector<double>& position );  
	std::vector<double>& nearest_density_vector( int voxel_index );  

	/*! access the density vector at  [ X(i),Y(j),Z(k) ] */
	std::vector<double>& operator()( int i, int j, int k ); 
	/*! access the density vector at  [ X(i),Y(j),0 ]  -- helpful for 2-D problems */
	std::vector<double>& operator()( int i, int j );  
	/*! access the density vector at [x,y,z](n) */
	std::vector<double>& operator()( int n );  
	
	std::vector<gradient>& gradient_vector(int i, int j, int k); 
	std::vector<gradient>& gradient_vector(int i, int j ); 
	std::vector<gradient>& gradient_vector(int n );  
	
	std::vector<gradient>& nearest_gradient_vector( std::vector<double>& position ); 

	void compute_all_gradient_vectors( void ); 
	void compute_gradient_vector( int n );  
	void reset_all_gradient_vectors( void ); 
	
	/*! access the density vector at  [ X(i),Y(j),Z(k) ] */
	std::vector<double>& density_vector( int i, int j, int k ); 
	/*! access the density vector at  [ X(i),Y(j),0 ]  -- helpful for 2-D problems */
	std::vector<double>& density_vector( int i, int j ); 

	/*! access the density vector at [x,y,z](n) */
	std::vector<double>& density_vector( int n ); 

	#pragma acc routine
	double& density_vector_GPU( int n );
       	
	/*! advance the diffusion-decay solver by dt time */
	void simulate_diffusion_decay( double dt ); 
	
	/*! advance the source/sink solver by dt time */
	void simulate_bulk_sources_and_sinks( double dt ); 
	
	// use the supplied list of cells
	void simulate_cell_sources_and_sinks( std::vector<Basic_Agent*>& basic_agent_list , double dt ); 
	// use the global list of cells 
	void simulate_cell_sources_and_sinks( double dt ); 
	
	void display_information( std::ostream& os ); 
	
	void add_dirichlet_node( int voxel_index, std::vector<double>& value ); 
	void update_dirichlet_node( int voxel_index , std::vector<double>& new_value ); 
	void update_dirichlet_node( int voxel_index , int substrate_index , double new_value );
	void remove_dirichlet_node( int voxel_index ); 
	void apply_dirichlet_conditions( void ); 

	void set_substrate_dirichlet_activation( int substrate_index , bool new_value ); 
	double get_substrate_dirichlet_activation( int substrate_index ); 
	
	bool& is_dirichlet_node( int voxel_index ); 

	friend void diffusion_decay_solver__constant_coefficients_explicit( Microenvironment& S, double dt ); 
	friend void diffusion_decay_solver__constant_coefficients_explicit_uniform_mesh( Microenvironment& S, double dt ); 

	friend void diffusion_decay_solver__constant_coefficients_LOD_3D( Microenvironment& S, double dt ); 
	friend void diffusion_decay_solver__constant_coefficients_LOD_2D( Microenvironment& S, double dt ); 
	
	// GPU functions
	friend void diffusion_decay_solver__constant_coefficients_LOD_3D_GPU( Microenvironment& S, double dt ); 
	friend void diffusion_decay_solver__constant_coefficients_LOD_2D_GPU( Microenvironment& S, double dt ); 
	
	friend void diffusion_decay_explicit_uniform_rates( Microenvironment& M, double dt );
	
	void write_to_matlab( std::string filename );
	void write_mesh_to_matlab( std::string filename ); // not yet written 
	void write_densities_to_matlab( std::string filename ); // not yet written 
	
	void write_to_xml( std::string xml_filename , std::string data_filename ); // not yet written
	void read_from_matlab( std::string filename ); // not yet written 
	void read_from_xml( std::string filename ); // not yet written 
};

extern void diffusion_decay_solver__constant_coefficients_explicit( Microenvironment& S, double dt ); 
extern void diffusion_decay_solver__constant_coefficients_explicit_uniform_mesh( Microenvironment& S, double dt ); 

extern void diffusion_decay_solver__variable_coefficients_explicit( Microenvironment& S, double dt ); 
extern void diffusion_decay_solver__variable_coefficients_explicit_uniform_mesh( Microenvironment& S, double dt ); 


extern void diffusion_decay_solver__constant_coefficients_LOD_3D( Microenvironment& S, double dt ); 
extern void diffusion_decay_solver__constant_coefficients_LOD_2D( Microenvironment& S, double dt ); 

extern void diffusion_decay_solver__variable_coefficients_LOD_3D( Microenvironment& S, double dt ); 
extern void diffusion_decay_solver__variable_coefficients_LOD_2D( Microenvironment& S, double dt ); 

extern void diffusion_decay_source_sink_solver__constant_coefficients_LOD_3D( Microenvironment& S, double dt );

void zero_function( std::vector<double>& position, std::vector<double>& input , std::vector<double>* destination );
void one_function( std::vector<double>& position, std::vector<double>& input , std::vector<double>* destination );

void zero_function( Microenvironment* pMicroenvironment, int voxel_index, std::vector<double>* write_destination );
void one_function( Microenvironment* pMicroenvironment, int voxel_index, std::vector<double>* write_destination );

void set_default_microenvironment( Microenvironment* M );
Microenvironment* get_default_microenvironment( void ); 

class Microenvironment_Options
{
 private:
 
 public: 
	Microenvironment* pMicroenvironment;
	std::string name; 
 
	std::string time_units; 
	std::string spatial_units; 
	double dx;
	double dy; 
	double dz; 
	
	bool outer_Dirichlet_conditions; 
	std::vector<double> Dirichlet_condition_vector; 
	std::vector<bool> Dirichlet_activation_vector; 
	
	std::vector<double> initial_condition_vector; 
	
	bool simulate_2D; 
	std::vector<double> X_range; 
	std::vector<double> Y_range; 
	std::vector<double> Z_range; 
	
	Microenvironment_Options(); 
	
	bool calculate_gradients; 
	
	bool use_oxygen_as_first_field;
	
	bool track_internalized_substrates_in_each_agent; 	
};

extern Microenvironment_Options default_microenvironment_options; 
extern Microenvironment microenvironment;

void initialize_microenvironment( void ); 

};

#endif

########## NEXT FILE ##########
versiontest.c:::
#include <openacc.h>
#include <stdio.h>

int main(){
    if (_OPENACC == 201111){
		printf("1.0");
	}
	else if (_OPENACC == 201306){
		printf("2.0");
	}
	else if (_OPENACC == 201510){
		printf("2.5");
	}
	else if (_OPENACC == 201711){
		printf("2.6");
	}
	else if (_OPENACC == 201811){
		printf("2.7");
	}
	else if (_OPENACC == 201911){
		printf("3.0");
	}
	else if (_OPENACC == 202011){
		printf("3.1");
	}
	else if (_OPENACC == 202111){
		printf("3.2");
	}
	else if (_OPENACC == 202211){
		printf("3.3");
	}
	else{
		return 1;
	}
    return 0;
}

########## NEXT FILE ##########
versiontest.cpp:::
#include <openacc.h>
#include <stdio.h>

int main(){
    if (_OPENACC == 201111){
		printf("1.0");
	}
	else if (_OPENACC == 201306){
		printf("2.0");
	}
	else if (_OPENACC == 201510){
		printf("2.5");
	}
	else if (_OPENACC == 201711){
		printf("2.6");
	}
	else if (_OPENACC == 201811){
		printf("2.7");
	}
	else if (_OPENACC == 201911){
		printf("3.0");
	}
	else if (_OPENACC == 202011){
		printf("3.1");
	}
	else if (_OPENACC == 202111){
		printf("3.2");
	}
	else if (_OPENACC == 202211){
		printf("3.3");
	}
	else{
		return 1;
	}
    return 0;
}

########## NEXT FILE ##########
acc_async_test.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:async,runtime,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *d = (real_t *)malloc(n * sizeof(real_t));
    real_t *e = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = 0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n]) async(1)
    #pragma acc enter data copyin(d[0:n]) create(e[0:n]) async(2)
    #pragma acc parallel present(a[0:n], b[0:n], c[0:n]) async(1)
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = a[x] + b[x];
        }
    }
    #pragma acc parallel present(c[0:n], d[0:n], e[0:n]) async(1) wait(2)
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            e[x] = c[x] + d[x];
        }
    }
    #pragma acc exit data copyout(e[0:n]) async(1)

    while (!acc_async_test(1));
    for (int x = 0; x < n; ++x){
        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:async,runtime,construct-independent,V:1.0-2.7
int test2(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *d = (real_t *)malloc(n * sizeof(real_t));
    real_t *e = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = 0;
    }
    #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) create(c[0:n]) copyout(e[0:n])
    {
        #pragma acc parallel present(a[0:n], b[0:n], c[0:n]) async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc parallel present(c[0:n], d[0:n], e[0:n]) async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                e[x] = c[x] + d[x];
            }
        }
        while (!acc_async_test(1));
    }

    for (int x = 0; x < n; ++x) {
        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION) {
            err += 1;
        }
    }
    return err;
}
#endif

#ifndef T3
//T3:async,runtime,construct-independent,V:2.5-2.7
int test3() {
    int err = 0;
    real_t* a = (real_t*)malloc(n * sizeof(real_t));
    real_t* b = (real_t*)malloc(n * sizeof(real_t));
    real_t* c = (real_t*)malloc(n * sizeof(real_t));
    real_t* d = (real_t*)malloc(n * sizeof(real_t));
    real_t* e = (real_t*)malloc(n * sizeof(real_t));
    int async_val = acc_get_default_async();

    for (int x = 0; x < n; ++x) {
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = 0;
    }
    #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) create(c[0:n]) copyout(e[0:n])
    {
        #pragma acc parallel present(a[0:n], b[0:n], c[0:n]) async
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc parallel present(c[0:n], d[0:n], e[0:n]) async
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                e[x] = c[x] + d[x];
            }
        }
        while (!acc_async_test(async_val));
    }

    for (int x = 0; x < n; ++x) {
        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION) {
            err += 1;
        }
    }
    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x) {
        failed = failed + test3();
    }
    if (failed != 0) {
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_async_test.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:async,runtime,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *d = new real_t[n];
    real_t *e = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = 0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n]) async(1)
    #pragma acc enter data copyin(d[0:n]) create(e[0:n]) async(2)
    #pragma acc parallel present(a[0:n], b[0:n], c[0:n]) async(1)
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = a[x] + b[x];
        }
    }
    #pragma acc parallel present(c[0:n], d[0:n], e[0:n]) async(1) wait(2)
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            e[x] = c[x] + d[x];
        }
    }
    #pragma acc exit data copyout(e[0:n]) async(1)

    while (!acc_async_test(1));
    for (int x = 0; x < n; ++x){
        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:async,runtime,construct-independent,V:1.0-2.7
int test2(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *d = new real_t[n];
    real_t *e = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = 0;
    }
    #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) create(c[0:n]) copyout(e[0:n])
    {
        #pragma acc parallel present(a[0:n], b[0:n], c[0:n]) async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc parallel present(c[0:n], d[0:n], e[0:n]) async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                e[x] = c[x] + d[x];
            }
        }
        while (!acc_async_test(1));
    }

    for (int x = 0; x < n; ++x) {
        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION) {
            err += 1;
        }
    }
    return err;
}
#endif

#ifndef T3
//T3:async,runtime,construct-independent,V:2.5-2.7
int test3() {
    int err = 0;
    real_t* a = new real_t[n];
    real_t* b = new real_t[n];
    real_t* c = new real_t[n];
    real_t* d = new real_t[n];
    real_t* e = new real_t[n];
    int async_val = acc_get_default_async();

    for (int x = 0; x < n; ++x) {
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = 0;
    }
    #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) create(c[0:n]) copyout(e[0:n])
    {
        #pragma acc parallel present(a[0:n], b[0:n], c[0:n]) async
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc parallel present(c[0:n], d[0:n], e[0:n]) async
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                e[x] = c[x] + d[x];
            }
        }
        while (!acc_async_test(async_val));
    }

    for (int x = 0; x < n; ++x) {
        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION) {
            err += 1;
        }
    }
    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x) {
        failed = failed + test3();
    }
    if (failed != 0) {
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_async_test_all.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:async,runtime,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    real_t **a = (real_t **)malloc(10 * sizeof(real_t*));
    real_t **b = (real_t **)malloc(10 * sizeof(real_t*));
    real_t **c = (real_t **)malloc(10 * sizeof(real_t*));
    real_t **d = (real_t **)malloc(10 * sizeof(real_t*));
    real_t **e = (real_t **)malloc(10 * sizeof(real_t*));

    for (int x = 0; x < 10; ++x){
        a[x] = (real_t *)malloc(n * sizeof(real_t));
        b[x] = (real_t *)malloc(n * sizeof(real_t));
        c[x] = (real_t *)malloc(n * sizeof(real_t));
        d[x] = (real_t *)malloc(n * sizeof(real_t));
        e[x] = (real_t *)malloc(n * sizeof(real_t));
        for (int y = 0; y < n; ++y){
            a[x][y] = rand() / (real_t)(RAND_MAX / 10);
            b[x][y] = rand() / (real_t)(RAND_MAX / 10);
            c[x][y] = 0;
            d[x][y] = rand() / (real_t)(RAND_MAX / 10);
            e[x][y] = 0;
        }
    }

    #pragma acc enter data create(a[0:10][0:n], b[0:10][0:n], c[0:10][0:n], d[0:10][0:n], e[0:10][0:n])
    for (int x = 0; x < 10; ++x){
        #pragma acc update device(a[x:1][0:n], b[x:1][0:n], d[x:1][0:n]) async(x)
        #pragma acc parallel present(a[x:1][0:n], b[x:1][0:n], c[x:1][0:n]) async(x)
        {
            #pragma acc loop
            for (int y = 0; y < n; ++y){
                c[x][y] = a[x][y] + b[x][y];
            }
        }
        #pragma acc parallel present(c[x:1][0:n], d[x:1][0:n], e[x:1][0:n]) async(x)
        {
            #pragma acc loop
            for (int y = 0; y < n; ++y){
                e[x][y] = c[x][y] + d[x][y];
            }
        }
        #pragma acc update host(e[x:1][0:n]) async(x)
    }
   
    while(!acc_async_test_all());
    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < n; ++y){
            if (fabs(e[x][y] - (a[x][y] + b[x][y] + d[x][y])) > PRECISION){
                err += 1;
            }
        }
    }
    #pragma acc exit data delete(a[0:10][0:n], b[0:10][0:n], c[0:10][0:n], d[0:10][0:n], e[0:10][0:n])
    for (int x = 0; x < 10; ++x){
        free(a[x]);
        free(b[x]);
        free(c[x]);
        free(d[x]);
        free(e[x]);
    }
    free(a);
    free(b);
    free(c);
    free(d);
    free(e);
    
    return err;
}
#endif

#ifndef T2
//T2:async,runtime,construct-independent,V:1.0-2.7
int test2(){
    int err = 0;
    real_t *a = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t *b = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t *c = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t *d = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t *e = (real_t *)malloc(10 * n * sizeof(real_t));

    for (int x = 0; x < 10*n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = 0;
    }

    #pragma acc data copyin(a[0:10*n], b[0:10*n], d[0:10*n]) copyout(c[0:10*n], e[0:10*n])
    {
        for (int x = 0; x < 10; ++x){
            #pragma acc parallel present(a[0:10*n], b[0:10*n], c[0:10*n]) async(x)
            {
                #pragma acc loop
                for (int y = 0; y < n; ++y){
                    c[x * n + y] = a[x * n + y] + b[x * n + y];
                }
            }
            #pragma acc parallel present(c[0:10*n], d[0:10*n], e[0:10*n]) async(x)
            {
                #pragma acc loop
                for (int y = 0; y < n; ++y){
                    e[x * n + y] = c[x * n + y] + d[x * n + y];
                }
            }
        }
        while(!acc_async_test_all());
    }

    for (int x = 0; x < 10*n; ++x){
        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION){
            err += 1;
        }
    }
    
    free(a);
    free(b);
    free(c);
    free(d);
    free(e);
    
    return err;
}
#endif

#ifndef T3
//T3:async,runtime,construct-independent,V:2.5-2.7
int test3(){
    int err = 0;
    real_t **a = (real_t **)malloc(10 * sizeof(real_t *));
    real_t **b = (real_t **)malloc(10 * sizeof(real_t *));
    real_t **c = (real_t **)malloc(10 * sizeof(real_t *));
    real_t **d = (real_t **)malloc(10 * sizeof(real_t *));
    real_t **e = (real_t **)malloc(10 * sizeof(real_t *));

    for (int x = 0; x < 10; ++x){
        a[x] = (real_t *)malloc(n * sizeof(real_t));
        b[x] = (real_t *)malloc(n * sizeof(real_t));
        c[x] = (real_t *)malloc(n * sizeof(real_t));
        d[x] = (real_t *)malloc(n * sizeof(real_t));
        e[x] = (real_t *)malloc(n * sizeof(real_t));
        for (int y = 0; y < n; ++y){
            a[x][y] = rand() / (real_t)(RAND_MAX / 10);
            b[x][y] = rand() / (real_t)(RAND_MAX / 10);
            c[x][y] = 0;
            d[x][y] = rand() / (real_t)(RAND_MAX / 10);
            e[x][y] = 0;
        }
    }

    #pragma acc data copyin(a[0:10][0:n], b[0:10][0:n], d[0:10][0:n]) copyout(c[0:10][0:n], e[0:10][0:n])
    {
        for (int x = 0; x < 10; ++x){
            acc_set_default_async(x);
            #pragma acc parallel present(a[0:10][0:n], b[0:10][0:n], c[0:10][0:n]) async
            {
                #pragma acc loop
                for (int y = 0; y < n; ++y){
                    c[x][y] = a[x][y] + b[x][y];
                }
            }
            #pragma acc parallel present(c[0:10][0:n], d[0:10][0:n], e[0:10][0:n]) async
            {
                #pragma acc loop
                for (int y = 0; y < n; ++y){
                    e[x][y] = c[x][y] + d[x][y];
                }
            }
        }
        while (!acc_async_test_all());
    }

    int count = 0;
    int total = 0;
    for (int x = 0; x < 10; ++x) {
        for (int y = 0; y < n; ++y) {
            if (fabs(e[x][y]) < PRECISION) {
                count += 1;
            }
            total += 1;
        }
    }
    printf("%d out of %d\n", count, total);

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < n; ++y){
            if (fabs(e[x][y] - (a[x][y] + b[x][y] + d[x][y])) > PRECISION){
                err += 1;
            }
        }
    }
    
    for (int x = 0; x < 10; ++x){
        free(a[x]);
        free(b[x]);
        free(c[x]);
        free(d[x]);
        free(e[x]);
    }
    free(a);
    free(b);
    free(c);
    free(d);
    free(e);
    
    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_async_test_all.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:async,runtime,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    real_t** a = new real_t*[10];
    real_t** b = new real_t*[10];
    real_t** c = new real_t*[10];
    real_t** d = new real_t*[10];
    real_t** e = new real_t*[10];

    for (int x = 0; x < 10; ++x){
        a[x] = new real_t[n];
        b[x] = new real_t[n];
        c[x] = new real_t[n];
        d[x] = new real_t[n];
        e[x] = new real_t[n];
        for (int y = 0; y < n; ++y){
            a[x][y] = rand() / (real_t)(RAND_MAX / 10);
            b[x][y] = rand() / (real_t)(RAND_MAX / 10);
            c[x][y] = 0;
            d[x][y] = rand() / (real_t)(RAND_MAX / 10);
            e[x][y] = 0;
        }
    }

    #pragma acc enter data create(a[0:10][0:n], b[0:10][0:n], c[0:10][0:n], d[0:10][0:n], e[0:10][0:n])
    for (int x = 0; x < 10; ++x){
        #pragma acc update device(a[x:1][0:n], b[x:1][0:n], d[x:1][0:n]) async(x)
        #pragma acc parallel present(a[x:1][0:n], b[x:1][0:n], c[x:1][0:n]) async(x)
        {
            #pragma acc loop
            for (int y = 0; y < n; ++y){
                c[x][y] = a[x][y] + b[x][y];
            }
        }
        #pragma acc parallel present(c[x:1][0:n], d[x:1][0:n], e[x:1][0:n]) async(x)
        {
            #pragma acc loop
            for (int y = 0; y < n; ++y){
                e[x][y] = c[x][y] + d[x][y];
            }
        }
        #pragma acc update host(e[x:1][0:n]) async(x)
    }
   
    while(!acc_async_test_all());
    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < n; ++y){
            if (fabs(e[x][y] - (a[x][y] + b[x][y] + d[x][y])) > PRECISION){
                err += 1;
            }
        }
    }
    #pragma acc exit data delete(a[0:10][0:n], b[0:10][0:n], c[0:10][0:n], d[0:10][0:n], e[0:10][0:n])
    for (int x = 0; x < 10; ++x){
        delete[] a[x];
        delete[] b[x];
        delete[] c[x];
        delete[] d[x];
        delete[] e[x];
    }
    delete[] a;
    delete[] b;
    delete[] c;
    delete[] d;
    delete[] e;
    
    return err;
}
#endif

#ifndef T2
//T2:async,runtime,construct-independent,V:1.0-2.7
int test2(){
    int err = 0;
    real_t *a = new real_t[10 * n];
    real_t *b = new real_t[10 * n];
    real_t *c = new real_t[10 * n];
    real_t *d = new real_t[10 * n];
    real_t *e = new real_t[10 * n];

    for (int x = 0; x < 10*n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = 0;
    }

    #pragma acc data copyin(a[0:10*n], b[0:10*n], d[0:10*n]) copyout(c[0:10*n], e[0:10*n])
    {
        for (int x = 0; x < 10; ++x){
            #pragma acc parallel present(a[0:10*n], b[0:10*n], c[0:10*n]) async(x)
            {
                #pragma acc loop
                for (int y = 0; y < n; ++y){
                    c[x * n + y] = a[x * n + y] + b[x * n + y];
                }
            }
            #pragma acc parallel present(c[0:10*n], d[0:10*n], e[0:10*n]) async(x)
            {
                #pragma acc loop
                for (int y = 0; y < n; ++y){
                    e[x * n + y] = c[x * n + y] + d[x * n + y];
                }
            }
        }
        while(!acc_async_test_all());
    }

    for (int x = 0; x < 10*n; ++x){
        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION){
            err += 1;
        }
    }
    
    delete[] a;
    delete[] b;
    delete[] c;
    delete[] d;
    delete[] e;
    
    return err;
}
#endif

#ifndef T3
//T3:async,runtime,construct-independent,V:2.5-2.7
int test3(){
    int err = 0;
    real_t** a = new real_t*[10];
    real_t** b = new real_t*[10];
    real_t** c = new real_t*[10];
    real_t** d = new real_t*[10];
    real_t** e = new real_t*[10];

    for (int x = 0; x < 10; ++x){
        a[x] = new real_t[n];
        b[x] = new real_t[n];
        c[x] = new real_t[n];
        d[x] = new real_t[n];
        e[x] = new real_t[n];
        for (int y = 0; y < n; ++y){
            a[x][y] = rand() / (real_t)(RAND_MAX / 10);
            b[x][y] = rand() / (real_t)(RAND_MAX / 10);
            c[x][y] = 0;
            d[x][y] = rand() / (real_t)(RAND_MAX / 10);
            e[x][y] = 0;
        }
    }

    #pragma acc data copyin(a[0:10][0:n], b[0:10][0:n], d[0:10][0:n]) copyout(c[0:10][0:n], e[0:10][0:n])
    {
        for (int x = 0; x < 10; ++x){
            acc_set_default_async(x);
            #pragma acc parallel present(a[0:10][0:n], b[0:10][0:n], c[0:10][0:n]) async
            {
                #pragma acc loop
                for (int y = 0; y < n; ++y){
                    c[x][y] = a[x][y] + b[x][y];
                }
            }
            #pragma acc parallel present(c[0:10][0:n], d[0:10][0:n], e[0:10][0:n]) async
            {
                #pragma acc loop
                for (int y = 0; y < n; ++y){
                    e[x][y] = c[x][y] + d[x][y];
                }
            }
        }
        while (!acc_async_test_all());
    }

    int count = 0;
    int total = 0;
    for (int x = 0; x < 10; ++x) {
        for (int y = 0; y < n; ++y) {
            if (fabs(e[x][y]) < PRECISION) {
                count += 1;
            }
            total += 1;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < n; ++y){
            if (fabs(e[x][y] - (a[x][y] + b[x][y] + d[x][y])) > PRECISION){
                err += 1;
            }
        }
    }
    
    for (int x = 0; x < 10; ++x){
        delete[] a[x];
        delete[] b[x];
        delete[] c[x];
        delete[] d[x];
        delete[] e[x];
    }
    delete[] a;
    delete[] b;
    delete[] c;
    delete[] d;
    delete[] e;
    
    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_attach.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    two_d_array data;
    
    data.a = (real_t *)malloc(n * sizeof(real_t));
    data.b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        data.a[x] = rand() / (real_t)(RAND_MAX / 10);
        data.b[x] = 2 * data.a[x];
    }

    #pragma acc enter data copyin(data.a[0:n], data.b[0:n])
    #pragma acc enter data copyin(data)
    acc_attach(&data.a);
    acc_attach(&data.b);

    #pragma acc parallel loop default(present)
    for(int x = 0; x < n; ++x){
        data.a[x] = data.a[x] * 2;
    }

    acc_detach(&data.a);
    acc_detach(&data.b);
    #pragma acc exit data copyout(data.a[0:n], data.b[0:n])
    #pragma acc exit data copyout(data)

    for (int x = 0; x < n; ++x){
        if (fabs(data.a[x] - data.b[x]) > PRECISION){
            err += 1;
        }
    }

    free(data.a);
    free(data.b);

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    two_d_array data;
    
    data.a = (real_t *)malloc(n * sizeof(real_t));
    data.b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        data.a[x] = rand() / (real_t)(RAND_MAX / 10);
        data.b[x] = 2 * data.a[x];
    }

    #pragma acc enter data copyin(data)
    #pragma acc enter data copyin(data.a[0:n], data.b[0:n])

    #pragma acc parallel loop default(present)
    for(int x = 0; x < n; ++x){
        data.a[x] = data.a[x] * 2;
    }

    acc_detach(&data.a);
    acc_detach(&data.b);
    #pragma acc exit data copyout(data.a[0:n], data.b[0:n])
    #pragma acc exit data copyout(data)

    for (int x = 0; x < n; ++x){
        if (fabs(data.a[x] - data.b[x]) > PRECISION){
            err += 1;
        }
    }

    free(data.a);
    free(data.b);
    
    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_copyin.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    acc_copyin(a, n * sizeof(real_t));
    acc_copyin(b, n * sizeof(real_t));

    #pragma acc data copy(c[0:n])
    {
        #pragma acc parallel present(a[0:n], b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    acc_copyout(a, n * sizeof(real_t));
    acc_copyout(b, n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test2(){
    int err = 0;
    srand(time(NULL));
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    acc_copyin(a, n * sizeof(real_t));
    acc_copyin(b, n * sizeof(real_t));

    #pragma acc data copy(c[0:n])
    {
        #pragma acc parallel present(a[0:n], b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    #pragma acc exit data copyout(a[0:n], b[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }
    return err;
}
#endif

#ifndef T3
//T3:runtime,data,executable-data,devonly,construct-independent,reference-counting,V:2.5-2.7
int test3(){
    int err = 0;
    srand(time(NULL));
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    int * dev_test = (int *)malloc(n * sizeof(int));

    dev_test[0] = 1;
    #pragma acc enter data copyin(dev_test[0:1])
    #pragma acc parallel present(dev_test[0:1])
    {
        dev_test[0] = 0;
    }

    if (dev_test[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            a_copy[x] = a[x];
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            b_copy[x] = b[x];
            c[x] = 0.0;
        }

        acc_copyin(a, n * sizeof(real_t));
        acc_copyin(b, n * sizeof(real_t));

        for (int x = 0; x < n; ++x){
            a[x] = 0;
            b[x] = 0;
        }

        #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])
        {
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] = a[x] + b[x];
                }
            }
        }

        acc_copyout(a, n * sizeof(real_t));
        acc_copyout(b, n * sizeof(real_t));

        for (int x = 0; x < n; ++x){
            if (fabs(a[x] - a_copy[x]) > PRECISION){
                err += 1;
            }
            if (fabs(b[x] - b_copy[x]) > PRECISION){
                err += 1;
            }
            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
                err += 1;
            }
        }
    }
    return err;
}
#endif

#ifndef T4
//T4:runtime,data,executable-data,construct-independent,compatibility-features,V:2.0-2.7
int test4(){
    int err = 0;
    srand(time(NULL));
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    acc_pcopyin(a, n * sizeof(real_t));
    acc_pcopyin(b, n * sizeof(real_t));

    #pragma acc data copy(c[0:n])
    {
        #pragma acc parallel present(a[0:n], b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    #pragma acc exit data delete(a[0:n], b[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }
    return err;
}
#endif

#ifndef T5
//T5:runtime,data,executable-data,construct-independent,compatibility-features,V:2.0-2.7
int test5(){
    int err = 0;
    srand(time(NULL));
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    acc_present_or_copyin(a, n * sizeof(real_t));
    acc_present_or_copyin(b, n * sizeof(real_t));

    #pragma acc data copyout(c[0:n]) present(a[0:n], b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    #pragma acc exit data delete(a[0:n], b[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }
    return err;
}
#endif

#ifndef T6
//T6:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7
int test6() {
    int err = 0;
    srand(time(NULL));
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x) {
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    acc_copyin(a, n * sizeof(real_t));
    acc_copyin(a, n * sizeof(real_t));
    acc_copyin(b, n * sizeof(real_t));
    acc_copyin(b, n * sizeof(real_t));

    #pragma acc data copyout(c[0:n])
    {
        #pragma acc parallel present(a[0:n], b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
    }

    #pragma acc exit data delete(a[0:n], b[0:n])
    #pragma acc exit data delete(a[0:n], b[0:n])

    for (int x = 0; x < n; ++x) {
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {
            err += 1;
        }
    }
    return err;
}
#endif

#ifndef T7
//T7:runtime,data,executable-data,construct-independent,reference-counting,devonly,V:2.5-2.7
int test7() {
    int err = 0;
    srand(time(NULL));
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *a_copy = (real_t *)malloc(n * sizeof(real_t));
    real_t *b_copy = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    int * dev_test = (int *)malloc(n * sizeof(int));

    dev_test[0] = 1;
    #pragma acc enter data copyin(dev_test[0:1])
    #pragma acc parallel present(dev_test[0:1])
    {
        dev_test[0] = 0;
    }

    if (dev_test[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            a_copy[x] = a[x];
            b_copy[x] = b[x];
            c[x] = 0;
        }
        
        acc_copyin(a, n * sizeof(real_t));
        acc_copyin(b, n * sizeof(real_t));

        for (int x = 0; x < n; ++x){
            a[x] = 0;
            b[x] = 0;
        }

        acc_copyin(a, n * sizeof(real_t));
        acc_copyin(b, n * sizeof(real_t));

        #pragma acc data copyout(c[0:n])
        {
            #pragma acc parallel present(a[0:n], b[0:n])
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] = a[x] + b[x];
                }
            }
        }

        #pragma acc exit data delete(a[0:n], b[0:n])
        #pragma acc exit data delete(a[0:n], b[0:n])

        for (int x = 0; x < n; ++x){
            if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION){
                err += 1;
            }
        }
    }
    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
#ifndef T5
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test5();
    }
    if (failed != 0){
        failcode = failcode + (1 << 4);
    }
#endif
#ifndef T6
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x) {
        failed = failed + test6();
    }
    if (failed != 0) {
        failcode = failcode + (1 << 5);
    }
#endif
#ifndef T7
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x) {
        failed = failed + test7();
    }
    if (failed != 0) {
        failcode = failcode + (1 << 6);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_copyin.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    acc_copyin(a, n * sizeof(real_t));
    acc_copyin(b, n * sizeof(real_t));

    #pragma acc data copy(c[0:n])
    {
        #pragma acc parallel present(a[0:n], b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    acc_copyout(a, n * sizeof(real_t));
    acc_copyout(b, n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test2(){
    int err = 0;
    srand(time(NULL));
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    acc_copyin(a, n * sizeof(real_t));
    acc_copyin(b, n * sizeof(real_t));

    #pragma acc data copy(c[0:n])
    {
        #pragma acc parallel present(a[0:n], b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    #pragma acc exit data copyout(a[0:n], b[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }
    return err;
}
#endif

#ifndef T3
//T3:runtime,data,executable-data,devonly,construct-independent,reference-counting,V:2.5-2.7
int test3(){
    int err = 0;
    srand(time(NULL));
    real_t * a = new real_t[n];
    real_t * a_copy = new real_t[n];
    real_t * b = new real_t[n];
    real_t * b_copy = new real_t[n];
    real_t * c = new real_t[n];
    int * dev_test = new int[n];

    dev_test[0] = 1;
    #pragma acc enter data copyin(dev_test[0:1])
    #pragma acc parallel present(dev_test[0:1])
    {
        dev_test[0] = 0;
    }

    if (dev_test[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            a_copy[x] = a[x];
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            b_copy[x] = b[x];
            c[x] = 0.0;
        }

        acc_copyin(a, n * sizeof(real_t));
        acc_copyin(b, n * sizeof(real_t));

        for (int x = 0; x < n; ++x){
            a[x] = 0;
            b[x] = 0;
        }

        #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])
        {
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] = a[x] + b[x];
                }
            }
        }

        acc_copyout(a, n * sizeof(real_t));
        acc_copyout(b, n * sizeof(real_t));

        for (int x = 0; x < n; ++x){
            if (fabs(a[x] - a_copy[x]) > PRECISION){
                err += 1;
            }
            if (fabs(b[x] - b_copy[x]) > PRECISION){
                err += 1;
            }
            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
                err += 1;
            }
        }
    }
    return err;
}
#endif

#ifndef T4
//T4:runtime,data,executable-data,construct-independent,compatibility-features,V:2.0-2.7
int test4(){
    int err = 0;
    srand(time(NULL));
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    acc_pcopyin(a, n * sizeof(real_t));
    acc_pcopyin(b, n * sizeof(real_t));

    #pragma acc data copy(c[0:n])
    {
        #pragma acc parallel present(a[0:n], b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    #pragma acc exit data delete(a[0:n], b[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }
    return err;
}
#endif

#ifndef T5
//T5:runtime,data,executable-data,construct-independent,compatibility-features,V:2.0-2.7
int test5(){
    int err = 0;
    srand(time(NULL));
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    acc_present_or_copyin(a, n * sizeof(real_t));
    acc_present_or_copyin(b, n * sizeof(real_t));

    #pragma acc data copyout(c[0:n]) present(a[0:n], b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    #pragma acc exit data delete(a[0:n], b[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }
    return err;
}
#endif

#ifndef T6
//T6:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7
int test6() {
    int err = 0;
    srand(time(NULL));
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];

    for (int x = 0; x < n; ++x) {
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    acc_copyin(a, n * sizeof(real_t));
    acc_copyin(a, n * sizeof(real_t));
    acc_copyin(b, n * sizeof(real_t));
    acc_copyin(b, n * sizeof(real_t));

    #pragma acc data copyout(c[0:n])
    {
        #pragma acc parallel present(a[0:n], b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
    }

    #pragma acc exit data delete(a[0:n], b[0:n])
    #pragma acc exit data delete(a[0:n], b[0:n])

    for (int x = 0; x < n; ++x) {
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {
            err += 1;
        }
    }
    return err;
}
#endif

#ifndef T7
//T7:runtime,data,executable-data,construct-independent,reference-counting,devonly,V:2.5-2.7
int test7() {
    int err = 0;
    srand(time(NULL));
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *a_copy = new real_t[n];
    real_t *b_copy = new real_t[n];
    real_t *c = new real_t[n];
    int * dev_test = new int[n];

    dev_test[0] = 1;
    #pragma acc enter data copyin(dev_test[0:1])
    #pragma acc parallel present(dev_test[0:1])
    {
        dev_test[0] = 0;
    }

    if (dev_test[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            a_copy[x] = a[x];
            b_copy[x] = b[x];
            c[x] = 0;
        }
        
        acc_copyin(a, n * sizeof(real_t));
        acc_copyin(b, n * sizeof(real_t));

        for (int x = 0; x < n; ++x){
            a[x] = 0;
            b[x] = 0;
        }

        acc_copyin(a, n * sizeof(real_t));
        acc_copyin(b, n * sizeof(real_t));

        #pragma acc data copyout(c[0:n])
        {
            #pragma acc parallel present(a[0:n], b[0:n])
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] = a[x] + b[x];
                }
            }
        }

        #pragma acc exit data delete(a[0:n], b[0:n])
        #pragma acc exit data delete(a[0:n], b[0:n])

        for (int x = 0; x < n; ++x){
            if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION){
                err += 1;
            }
        }
    }
    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
#ifndef T5
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test5();
    }
    if (failed != 0){
        failcode = failcode + (1 << 4);
    }
#endif
#ifndef T6
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x) {
        failed = failed + test6();
    }
    if (failed != 0) {
        failcode = failcode + (1 << 5);
    }
#endif
#ifndef T7
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x) {
        failed = failed + test7();
    }
    if (failed != 0) {
        failcode = failcode + (1 << 6);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_copyin_async.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:async,data,executable-data,runtime,construct-independent,V:2.5-2.7
int test1(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));
    real_t *b_host = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        a_host[x] = a[x];
        b_host[x] = b[x];
    }

    acc_copyin_async(a, n * sizeof(real_t), 1);
    acc_copyin_async(b, n * sizeof(real_t), 2);
    #pragma acc data copyout(c[0:n]) present(a[0:n], b[0:n])
    {
        #pragma acc parallel async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                a[x] = a[x] * a[x];
            }
        }
        #pragma acc parallel async(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = b[x] * b[x];
            }
        }
        #pragma acc parallel async(2) wait(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x])) > PRECISION * 4){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));
    real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 1;
    }

    acc_copyin_async(a, n*sizeof(real_t), 1);
    acc_copyin_async(b, n*sizeof(real_t), 2);

    #pragma acc data copyout(c[0:n])
    {
        while (!acc_async_test_all());
        #pragma acc parallel present(a[0:n], b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
    }

    #pragma acc exit data delete(a[0:n], b[0:n])

    for (int x = 0; x < n; ++x) {
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    acc_copyin_async(a, n * sizeof(real_t), 1);
    acc_copyin_async(b, n * sizeof(real_t), 2);

    #pragma acc data copyout(c[0:n])
    {
        #pragma acc wait
        #pragma acc parallel present(a[0:n], b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
    }

    #pragma acc exit data delete(a[0:n], b[0:n])

    for (int x = 0; x < n; ++x) {
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {
            err = err + 1;
        }
    }

    return err;
}
#endif

#ifndef T4
//T4:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7
int test4(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    real_t * d = (real_t *)malloc(n * sizeof(real_t));
    real_t * e = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = 0;
    }

    #pragma acc enter data create(c[0:n])
    #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) copyout(e[0:n])
    {
        #pragma acc parallel present(c[0:n]) async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
        acc_copyin_async(c, n * sizeof(real_t), 1);
        #pragma acc parallel present(c[0:n]) async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                e[x] = c[x] + d[x];
            }
        }
    }
    #pragma acc wait
    #pragma acc exit data copyout(c[0:n])

    for (int x = 0; x < n; ++x) {
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {
            err += 1;
        }
        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T5
//T5:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7
int test5(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));
    real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));
    int * devtest = (int *)malloc(sizeof(int));

    devtest[0] = 0;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 1;
    }

    if (devtest[0] == 0){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            c[x] = 0;
            a_copy[x] = a[x];
            b_copy[x] = b[x];
        }

        acc_copyin_async(a, n * sizeof(real_t), 1);
        acc_copyin_async(b, n * sizeof(real_t), 2);

        for (int x = 0; x < n; ++x) {
            a[x] = 0;
            b[x] = 0;
        }

        #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])
        {
            #pragma acc wait
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x) {
                    c[x] = a[x] + b[x];
                }
            }
        }

        #pragma acc exit data delete(a[0:n], b[0:n])

        for (int x = 0; x < n; ++x) {
            if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION) {
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
#ifndef T5
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test5();
    }
    if (failed != 0){
        failcode = failcode + (1 << 4);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_copyin_async.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:async,data,executable-data,runtime,construct-independent,V:2.5-2.7
int test1(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *a_host = new real_t[n];
    real_t *b_host = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        a_host[x] = a[x];
        b_host[x] = b[x];
    }

    acc_copyin_async(a, n * sizeof(real_t), 1);
    acc_copyin_async(b, n * sizeof(real_t), 2);
    #pragma acc data copyout(c[0:n]) present(a[0:n], b[0:n])
    {
        #pragma acc parallel async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                a[x] = a[x] * a[x];
            }
        }
        #pragma acc parallel async(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = b[x] * b[x];
            }
        }
        #pragma acc parallel async(2) wait(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x])) > PRECISION * 4){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];
    real_t * a_copy = new real_t[n];
    real_t * b_copy = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 1;
    }

    acc_copyin_async(a, n*sizeof(real_t), 1);
    acc_copyin_async(b, n*sizeof(real_t), 2);

    #pragma acc data copyout(c[0:n])
    {
        while (!acc_async_test_all());
        #pragma acc parallel present(a[0:n], b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
    }

    #pragma acc exit data delete(a[0:n], b[0:n])

    for (int x = 0; x < n; ++x) {
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    acc_copyin_async(a, n * sizeof(real_t), 1);
    acc_copyin_async(b, n * sizeof(real_t), 2);

    #pragma acc data copyout(c[0:n])
    {
        #pragma acc wait
        #pragma acc parallel present(a[0:n], b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
    }

    #pragma acc exit data delete(a[0:n], b[0:n])

    for (int x = 0; x < n; ++x) {
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {
            err = err + 1;
        }
    }

    return err;
}
#endif

#ifndef T4
//T4:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7
int test4(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];
    real_t * d = new real_t[n];
    real_t * e = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = 0;
    }

    #pragma acc enter data create(c[0:n])
    #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) copyout(e[0:n])
    {
        #pragma acc parallel present(c[0:n]) async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
        acc_copyin_async(c, n * sizeof(real_t), 1);
        #pragma acc exit data delete(c[0:n]) async(1)
        #pragma acc parallel present(c[0:n]) async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                e[x] = c[x] + d[x];
            }
        }
    }
    #pragma acc wait
    #pragma acc exit data copyout(c[0:n])

    for (int x = 0; x < n; ++x) {
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {
            err += 1;
        }
        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T5
//T5:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7
int test5(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];
    real_t * a_copy = new real_t[n];
    real_t * b_copy = new real_t[n];
    int * devtest = (int *)malloc(sizeof(int));

    devtest[0] = 0;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 1;
    }

    if (devtest[0] == 0){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            c[x] = 0;
            a_copy[x] = a[x];
            b_copy[x] = b[x];
        }

        acc_copyin_async(a, n * sizeof(real_t), 1);
        acc_copyin_async(b, n * sizeof(real_t), 2);

        for (int x = 0; x < n; ++x) {
            a[x] = 0;
            b[x] = 0;
        }

        #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])
        {
            #pragma acc wait
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x) {
                    c[x] = a[x] + b[x];
                }
            }
        }

        #pragma acc exit data delete(a[0:n], b[0:n])

        for (int x = 0; x < n; ++x) {
            if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION) {
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
#ifndef T5
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test5();
    }
    if (failed != 0){
        failcode = failcode + (1 << 4);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_copyout.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    acc_create(c, n * sizeof(real_t));

    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    acc_copyout(c, n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc enter data create(c[0:n])

    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    acc_copyout(c, n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_copyout.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    acc_create(c, n * sizeof(real_t));

    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    acc_copyout(c, n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc enter data create(c[0:n])

    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    acc_copyout(c, n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_copyout_async.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *d = (real_t *)malloc(n * sizeof(real_t));
    real_t *e = (real_t *)malloc(n * sizeof(real_t));
    real_t *f = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = rand() / (real_t)(RAND_MAX / 10);
        f[x] = 0;
    }

    #pragma acc enter data create(c[0:n], f[0:n])

    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n])
    {
        #pragma acc parallel async(1) present(c[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc parallel async(2) present(f[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                f[x] = d[x] + e[x];
            }
        }
        acc_copyout_async(c, n * sizeof(real_t), 1);
        acc_copyout_async(f, n * sizeof(real_t), 2);
        #pragma acc wait
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,async,data,executable-data,internal-control-values,construct-independent,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    int def_async_var = acc_get_default_async();

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc enter data create(c[0:n])

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel present(c[0:n]) async
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
        acc_copyout_async(c, n * sizeof(real_t), def_async_var);
        #pragma acc wait
    }

    for (int x = 0; x < n; ++x) {
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:runtime,async,data,executable-data,internal-control-values,construct-independent,V:2.5-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    int def_async_var = acc_get_default_async();

    acc_set_default_async(def_async_var + 1);

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }
    
    #pragma acc enter data create(c[0:n])
    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel present(c[0:n]) async
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
        acc_copyout_async(c, n * sizeof(real_t), def_async_var + 1);
        #pragma acc wait
    }

    for (int x = 0; x < n; ++x) {
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T4
//T4:runtime,async,data,executable-data,construct-independent,V:2.5-2.7
int test4(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc enter data create(c[0:n])
    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel present(c[0:n]) async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc enter data copyin(c[0:n])
        acc_copyout_async(c, n * sizeof(real_t), 1);
        #pragma acc parallel present(c[0:n]) async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] += a[x] + b[x];
            }
        }
        acc_copyout_async(c, n * sizeof(real_t), 1);
    }
    
    for (int x = 0; x < n; ++x) {
        if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_copyout_async.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *d = new real_t[n];
    real_t *e = new real_t[n];
    real_t *f = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = rand() / (real_t)(RAND_MAX / 10);
        f[x] = 0;
    }

    #pragma acc enter data create(c[0:n], f[0:n])

    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n])
    {
        #pragma acc parallel async(1) present(c[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc parallel async(2) present(f[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                f[x] = d[x] + e[x];
            }
        }
        acc_copyout_async(c, n * sizeof(real_t), 1);
        acc_copyout_async(f, n * sizeof(real_t), 2);
        #pragma acc wait
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,async,data,executable-data,internal-control-values,construct-independent,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];
    int def_async_var = acc_get_default_async();

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc enter data create(c[0:n])

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel present(c[0:n]) async
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
        acc_copyout_async(c, n * sizeof(real_t), def_async_var);
        #pragma acc wait
    }

    for (int x = 0; x < n; ++x) {
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:runtime,async,data,executable-data,internal-control-values,construct-independent,V:2.5-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];
    int def_async_var = acc_get_default_async();

    acc_set_default_async(def_async_var + 1);

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }
    
    #pragma acc enter data create(c[0:n])
    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel present(c[0:n]) async
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
        acc_copyout_async(c, n * sizeof(real_t), def_async_var + 1);
        #pragma acc wait
    }

    for (int x = 0; x < n; ++x) {
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T4
//T4:runtime,async,data,executable-data,construct-independent,V:2.5-2.7
int test4(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc enter data create(c[0:n])
    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel present(c[0:n]) async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc enter data copyin(c[0:n])
        acc_copyout_async(c, n * sizeof(real_t), 1);
        #pragma acc parallel present(c[0:n]) async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] += a[x] + b[x];
            }
        }
        acc_copyout_async(c, n * sizeof(real_t), 1);
    }
    
    for (int x = 0; x < n; ++x) {
        if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_copyout_finalize.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc enter data create(c[0:n])
    #pragma acc enter data create(c[0:n])

    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }
    acc_copyout_finalize(c, n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc enter data copyin(c[0:n])
    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel present(a[0:n], b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
    }
    acc_copyout_finalize(c, n * sizeof(real_t));

    for (int x = 0; x < n; ++x) {
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc enter data copyin(c[0:n])
    #pragma acc enter data copyin(c[0:n])
    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel present(c[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
        acc_copyout_finalize(c, n * sizeof(real_t));
        #pragma acc enter data copyin(c[0:n])
        #pragma acc parallel present(c[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] += a[x] + b[x];
            }
        }
    }
    #pragma acc exit data copyout(c[0:n])

    for (int x = 0; x < n; ++x) {
        if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION) {
            err += 1;
        }
    }
    

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_copyout_finalize.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc enter data create(c[0:n])
    #pragma acc enter data create(c[0:n])

    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }
    acc_copyout_finalize(c, n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc enter data copyin(c[0:n])
    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel present(a[0:n], b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
    }
    acc_copyout_finalize(c, n * sizeof(real_t));

    for (int x = 0; x < n; ++x) {
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc enter data copyin(c[0:n])
    #pragma acc enter data copyin(c[0:n])
    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel present(c[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
        acc_copyout_finalize(c, n * sizeof(real_t));
        #pragma acc enter data copyin(c[0:n])
        #pragma acc parallel present(c[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] += a[x] + b[x];
            }
        }
    }
    #pragma acc exit data copyout(c[0:n])

    for (int x = 0; x < n; ++x) {
        if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION) {
            err += 1;
        }
    }
    

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_copyout_finalize_async.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *d = (real_t *)malloc(n * sizeof(real_t));
    real_t *e = (real_t *)malloc(n * sizeof(real_t));
    real_t *f = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = rand() / (real_t)(RAND_MAX / 10);
        f[x] = 0;
    }

    #pragma acc enter data create(c[0:n], f[0:n])
    #pragma acc enter data create(c[0:n], f[0:n])

    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n]) present(c[0:n], f[0:n])
    {
        #pragma acc parallel async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc parallel async(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                f[x] = d[x] + e[x];
            }
        }
        acc_copyout_finalize_async(c, n * sizeof(real_t), 1);
        acc_copyout_finalize_async(f, n * sizeof(real_t), 2);
        #pragma acc wait
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,async,construct-independent,internal-control-values,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    int def_async_var = acc_get_default_async();

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc enter data create(c[0:n])
    #pragma acc enter data create(c[0:n])
    
    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel present(c[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
        acc_copyout_finalize_async(c, n * sizeof(real_t), def_async_var);
        #pragma acc wait
    }

    for (int x = 0; x < n; ++x) {
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:runtime,data,executable-data,async,construct-independent,internal-control-values,set,V:2.5-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    int def_async_var = acc_get_default_async();

    acc_set_default_async(def_async_var + 1);

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc enter data create(c[0:n])
    #pragma acc enter data create(c[0:n])
    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel present(c[0:n]) async
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
        acc_copyout_async(c, n * sizeof(real_t), def_async_var + 1);
        #pragma acc wait
    }

    for (int x = 0; x < n; ++x) {
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T4
//T4:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
int test4(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc enter data create(c[0:n])
    #pragma acc enter data create(c[0:n])
    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel present(c[0:n]) async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
        acc_copyout_finalize_async(c, n * sizeof(real_t), 1);
        #pragma acc enter data copyin(c[0:n]) async(1)
        #pragma acc parallel present(c[0:n]) async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] += a[x] + b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x) {
        if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION) {
            err += 1;
        }
    }
    

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_copyout_finalize_async.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *d = new real_t[n];
    real_t *e = new real_t[n];
    real_t *f = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = rand() / (real_t)(RAND_MAX / 10);
        f[x] = 0;
    }

    #pragma acc enter data create(c[0:n], f[0:n])
    #pragma acc enter data create(c[0:n], f[0:n])

    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n]) present(c[0:n], f[0:n])
    {
        #pragma acc parallel async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc parallel async(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                f[x] = d[x] + e[x];
            }
        }
        acc_copyout_finalize_async(c, n * sizeof(real_t), 1);
        acc_copyout_finalize_async(f, n * sizeof(real_t), 2);
        #pragma acc wait
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,async,construct-independent,internal-control-values,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];
    int def_async_var = acc_get_default_async();

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc enter data create(c[0:n])
    #pragma acc enter data create(c[0:n])
    
    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel present(c[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
        acc_copyout_finalize_async(c, n * sizeof(real_t), def_async_var);
        #pragma acc wait
    }

    for (int x = 0; x < n; ++x) {
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:runtime,data,executable-data,async,construct-independent,internal-control-values,set,V:2.5-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];
    int def_async_var = acc_get_default_async();

    acc_set_default_async(def_async_var + 1);

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc enter data create(c[0:n])
    #pragma acc enter data create(c[0:n])
    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel present(c[0:n]) async
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
        acc_copyout_async(c, n * sizeof(real_t), def_async_var + 1);
        #pragma acc wait
    }

    for (int x = 0; x < n; ++x) {
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T4
//T4:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
int test4(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc enter data create(c[0:n])
    #pragma acc enter data create(c[0:n])
    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel present(c[0:n]) async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
        acc_copyout_finalize_async(c, n * sizeof(real_t), 1);
        #pragma acc enter data copyin(c[0:n]) async(1)
        #pragma acc parallel present(c[0:n]) async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] += a[x] + b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x) {
        if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION) {
            err += 1;
        }
    }
    

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_create.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    acc_create(c, n * sizeof(real_t));

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel present(c[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    acc_copyout(c, n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    acc_create(c, n * sizeof(real_t));

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel present(c[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    #pragma acc exit data copyout(c[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:runtime,data,executable-data,compatibility-features,construct-independent,V:2.0-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    acc_pcreate(c, n * sizeof(real_t));

    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    #pragma acc exit data copyout(c[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T4
//T4:runtime,data,executable-data,compatibility-features,construct-independent,V:2.0-2.7
int test4(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    acc_present_or_create(c, n * sizeof(real_t));

    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    #pragma acc exit data copyout(c[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T5
//T5:runtime,data,executable-data,devonly,construct-independent,reference-counting,V:2.5-2.7
int test5(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    int * dev_test = (int *)malloc(sizeof(int));

    dev_test[0] = 1;
    #pragma acc enter data copyin(dev_test[0:1])
    #pragma acc parallel present(dev_test[0:1])
    {
        dev_test[0] = 0;
    }
    if (dev_test[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            c[x] = 1;
        }

        #pragma acc enter data copyin(c[0:n])
        for (int x = 0; x < n; ++x){
            c[x] = 0;
        }
        acc_create(c, n * sizeof(real_t));
        #pragma acc data copyin(a[0:n], b[0:n])
        {
            #pragma acc parallel present(c[0:n])
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x) {
                    c[x] += a[x] + b[x];
                }
            }
        }

        #pragma acc exit data copyout(c[0:n])
        #pragma acc exit data delete(c[0:n])
        
	for (int x = 0; x < n; ++x) {
            if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION) {
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
#ifndef T5
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test5();
    }
    if (failed != 0){
        failcode = failcode + (1 << 4);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_create.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    acc_create(c, n * sizeof(real_t));

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel present(c[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    acc_copyout(c, n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    acc_create(c, n * sizeof(real_t));

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel present(c[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    #pragma acc exit data copyout(c[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:runtime,data,executable-data,compatibility-features,construct-independent,V:2.0-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    acc_pcreate(c, n * sizeof(real_t));

    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    #pragma acc exit data copyout(c[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T4
//T4:runtime,data,executable-data,compatibility-features,construct-independent,V:2.0-2.7
int test4(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    acc_present_or_create(c, n * sizeof(real_t));

    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    #pragma acc exit data copyout(c[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T5
//T5:runtime,data,executable-data,devonly,construct-independent,reference-counting,V:2.5-2.7
int test5(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];
    int * dev_test = (int *)malloc(sizeof(int));

    dev_test[0] = 1;
    #pragma acc enter data copyin(dev_test[0:1])
    #pragma acc parallel present(dev_test[0:1])
    {
        dev_test[0] = 0;
    }
    if (dev_test[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            c[x] = 1;
        }

        #pragma acc enter data copyin(c[0:n])
        for (int x = 0; x < n; ++x){
            c[x] = 0;
        }
        acc_create(c, n * sizeof(real_t));
        #pragma acc data copyin(a[0:n], b[0:n])
        {
            #pragma acc parallel present(c[0:n])
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x) {
                    c[x] += a[x] + b[x];
                }
            }
        }

        #pragma acc exit data copyout(c[0:n])
    
        for (int x = 0; x < n; ++x) {
            if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION) {
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
#ifndef T5
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test5();
    }
    if (failed != 0){
        failcode = failcode + (1 << 4);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_create_async.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,async,data,executable-data,construct-independent,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *d = (real_t *)malloc(n * sizeof(real_t));
    real_t *e = (real_t *)malloc(n * sizeof(real_t));
    real_t *f = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = rand() / (real_t)(RAND_MAX / 10);
        f[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n])
    {
        acc_create_async(c, n * sizeof(real_t), 1);
        acc_create_async(f, n * sizeof(real_t), 2);
        #pragma acc data present(c[0:n], f[0:n])
        {
            #pragma acc parallel async(1)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] = a[x] + b[x];
                }
            }
            #pragma acc parallel async(2)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    f[x] = d[x] + e[x];
                }
            }
            #pragma acc wait
        }
    }

    #pragma acc exit data copyout(c[0:n], f[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    acc_create_async(c, n * sizeof(real_t), 1);

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        while (!acc_async_test_all());
        #pragma acc parallel present(c[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
    }

    #pragma acc exit data copyout(c[0:n])

    for (int x = 0; x < n; ++x) {
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    acc_create_async(c, n * sizeof(real_t), 1);

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc wait
        #pragma acc parallel present(c[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
    }

    #pragma acc exit data copyout(c[0:n])

    for (int x = 0; x < n; ++x) {
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T4
//T4:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7
int test4(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    real_t * d = (real_t *)malloc(n * sizeof(real_t));
    real_t * e = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = 0;
    }

    #pragma acc enter data create(c[0:n])
    #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) copyout(e[0:n])
    {
        #pragma acc parallel present(c[0:n]) async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
        acc_create_async(c, n * sizeof(real_t), 1);
        #pragma acc parallel present(c[0:n]) async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                e[x] = c[x] + d[x];
            }
        }
    }
    #pragma acc wait
    #pragma acc exit data copyout(c[0:n])

    for (int x = 0; x < n; ++x) {
        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T5
//T5:runtime,data,executable-data,devonly,async,construct-independent,reference-counting,V:2.5-2.7
int test5(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    int * devtest = (int *)malloc(sizeof(int));
    
    devtest[0] = 0;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 1;
    }

    if (devtest[0] == 0){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            c[x] = 0;
        }

        #pragma acc enter data create(c[0:n])
        #pragma acc data copyin(a[0:n], b[0:n])
        {
            #pragma acc parallel present(c[0:n]) async(1)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x) {
                    c[x] = a[x] + b[x];
                }
            }
            acc_create_async(c, n * sizeof(real_t), 1);
            #pragma acc parallel present(c[0:n]) async(1)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x) {
                    c[x] += a[x] + b[x];
                }
            }
            #pragma acc exit data copyout(c[0:n]) async(1)
            #pragma acc wait
        }

        for (int x = 0; x < n; ++x) {
            if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION) {
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
#ifndef T5
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test5();
    }
    if (failed != 0){
        failcode = failcode + (1 << 4);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_create_async.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,async,data,executable-data,construct-independent,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *d = new real_t[n];
    real_t *e = new real_t[n];
    real_t *f = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = rand() / (real_t)(RAND_MAX / 10);
        f[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n])
    {
        acc_create_async(c, n * sizeof(real_t), 1);
        acc_create_async(f, n * sizeof(real_t), 2);
        #pragma acc data present(c[0:n], f[0:n])
        {
            #pragma acc parallel async(1)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] = a[x] + b[x];
                }
            }
            #pragma acc parallel async(2)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    f[x] = d[x] + e[x];
                }
            }
            #pragma acc wait
        }
    }

    #pragma acc exit data copyout(c[0:n], f[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    acc_create_async(c, n * sizeof(real_t), 1);

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        while (!acc_async_test_all());
        #pragma acc parallel present(c[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
    }

    #pragma acc exit data copyout(c[0:n])

    for (int x = 0; x < n; ++x) {
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    acc_create_async(c, n * sizeof(real_t), 1);

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc wait
        #pragma acc parallel present(c[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
    }

    #pragma acc exit data copyout(c[0:n])

    for (int x = 0; x < n; ++x) {
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T4
//T4:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7
int test4(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];
    real_t * d = new real_t[n];
    real_t * e = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = 0;
    }

    #pragma acc enter data create(c[0:n])
    #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) copyout(e[0:n])
    {
        #pragma acc parallel present(c[0:n]) async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                c[x] = a[x] + b[x];
            }
        }
        acc_create_async(c, n * sizeof(real_t), 1);
        #pragma acc parallel present(c[0:n]) async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x) {
                e[x] = c[x] + d[x];
            }
        }
    }
    #pragma acc wait
    #pragma acc exit data copyout(c[0:n])

    for (int x = 0; x < n; ++x) {
        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T5
//T5:runtime,data,executable-data,devonly,async,construct-independent,reference-counting,V:2.5-2.7
int test5(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];
    int * devtest = (int *)malloc(sizeof(int));
    
    devtest[0] = 0;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 1;
    }

    if (devtest[0] == 0){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            c[x] = 0;
        }

        #pragma acc enter data create(c[0:n])
        #pragma acc data copyin(a[0:n], b[0:n])
        {
            #pragma acc parallel present(c[0:n]) async(1)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x) {
                    c[x] = a[x] + b[x];
                }
            }
            acc_create_async(c, n * sizeof(real_t), 1);
            #pragma acc parallel present(c[0:n]) async(1)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x) {
                    c[x] += a[x] + b[x];
                }
            }
            #pragma acc exit data copyout(c[0:n]) async(1)
            #pragma acc wait
        }

        for (int x = 0; x < n; ++x) {
            if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION) {
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
#ifndef T5
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test5();
    }
    if (failed != 0){
        failcode = failcode + (1 << 4);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_delete.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n])

    #pragma acc data copyout(c[0:n])
    {
        #pragma acc parallel present(a[0:n], b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    acc_delete(a, n * sizeof(real_t));
    acc_delete(b, n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    acc_copyin(a, n * sizeof(real_t));
    acc_copyin(b, n * sizeof(real_t));

    #pragma acc data copyout(c[0:n])
    {
        #pragma acc parallel present(a[0:n], b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    acc_delete(a, n * sizeof(real_t));
    acc_delete(b, n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_delete.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n])

    #pragma acc data copyout(c[0:n])
    {
        #pragma acc parallel present(a[0:n], b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    acc_delete(a, n * sizeof(real_t));
    acc_delete(b, n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    acc_copyin(a, n * sizeof(real_t));
    acc_copyin(b, n * sizeof(real_t));

    #pragma acc data copyout(c[0:n])
    {
        #pragma acc parallel present(a[0:n], b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    acc_delete(a, n * sizeof(real_t));
    acc_delete(b, n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_delete_async.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,async,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *d = (real_t *)malloc(n * sizeof(real_t));
    real_t *e = (real_t *)malloc(n * sizeof(real_t));
    real_t *f = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = rand() / (real_t)(RAND_MAX / 10);
        f[x] = 0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n], d[0:n], e[0:n])

    #pragma acc data present(a[0:n], b[0:n], d[0:n], e[0:n]) copyout(c[0:n], f[0:n])
    {
        #pragma acc parallel async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc parallel async(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                f[x] = d[x] + e[x];
            }
        }
        acc_delete_async(a, n * sizeof(real_t), 1);
        acc_delete_async(b, n * sizeof(real_t), 1);
        acc_delete_async(d, n * sizeof(real_t), 2);
        acc_delete_async(e, n * sizeof(real_t), 2);
        #pragma acc wait
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,devonly,async,construct-independent,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *d = (real_t *)malloc(n * sizeof(real_t));
    real_t *e = (real_t *)malloc(n * sizeof(real_t));
    real_t *f = (real_t *)malloc(n * sizeof(real_t));
    int* devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            c[x] = 0;
        }

        #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])
        #pragma acc data present(a[0:n], b[0:n], c[0:n])
        {
            #pragma acc parallel async(1)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] = a[x] * b[x];
                }
            }
        }
        acc_delete_async(c, n * sizeof(real_t), 1);
        #pragma acc enter data copyin(c[0:n]) async(1)
        #pragma acc data present(a[0:n], b[0:n], c[0:n])
        {
            #pragma acc parallel async(1)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] += a[x] + b[x];
                }
            }
        }
        #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])

        for (int x = 0; x < n; ++x){
            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_delete_async.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,async,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *d = new real_t[n];
    real_t *e = new real_t[n];
    real_t *f = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = rand() / (real_t)(RAND_MAX / 10);
        f[x] = 0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n], d[0:n], e[0:n])

    #pragma acc data present(a[0:n], b[0:n], d[0:n], e[0:n]) copyout(c[0:n], f[0:n])
    {
        #pragma acc parallel async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc parallel async(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                f[x] = d[x] + e[x];
            }
        }
        acc_delete_async(a, n * sizeof(real_t), 1);
        acc_delete_async(b, n * sizeof(real_t), 1);
        acc_delete_async(d, n * sizeof(real_t), 2);
        acc_delete_async(e, n * sizeof(real_t), 2);
        #pragma acc wait
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,devonly,async,construct-independent,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *d = new real_t[n];
    real_t *e = new real_t[n];
    real_t *f = new real_t[n];
    int* devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            c[x] = 0;
        }

        #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])
        #pragma acc data present(a[0:n], b[0:n], c[0:n])
        {
            #pragma acc parallel async(1)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] = a[x] * b[x];
                }
            }
        }
        acc_delete_async(c, n * sizeof(real_t), 1);
        #pragma acc enter data copyin(c[0:n]) async(1)
        #pragma acc data present(a[0:n], b[0:n], c[0:n])
        {
            #pragma acc parallel async(1)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] += a[x] + b[x];
                }
            }
        }
        #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])

        for (int x = 0; x < n; ++x){
            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_delete_finalize.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,reference-counting,construct-independent,syntactic,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n])
    #pragma acc enter data copyin(a[0:n], b[0:n])

    #pragma acc data copyout(c[0:n])
    {
        #pragma acc parallel present(a[0:n], b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    acc_delete_finalize(a, n * sizeof(real_t));
    acc_delete_finalize(b, n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,reference-counting,syntactic,construct-independent,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    acc_copyin(a, n * sizeof(real_t));
    acc_copyin(a, n * sizeof(real_t));
    acc_copyin(b, n * sizeof(real_t));
    acc_copyin(b, n * sizeof(real_t));

    #pragma acc data copyout(c[0:n])
    {
        #pragma acc parallel present(a[0:n], b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    acc_delete_finalize(a, n * sizeof(real_t));
    acc_delete_finalize(b, n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_delete_finalize.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,reference-counting,construct-independent,syntactic,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n])
    #pragma acc enter data copyin(a[0:n], b[0:n])

    #pragma acc data copyout(c[0:n])
    {
        #pragma acc parallel present(a[0:n], b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    acc_delete_finalize(a, n * sizeof(real_t));
    acc_delete_finalize(b, n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,reference-counting,syntactic,construct-independent,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    acc_copyin(a, n * sizeof(real_t));
    acc_copyin(a, n * sizeof(real_t));
    acc_copyin(b, n * sizeof(real_t));
    acc_copyin(b, n * sizeof(real_t));

    #pragma acc data copyout(c[0:n])
    {
        #pragma acc parallel present(a[0:n], b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    acc_delete_finalize(a, n * sizeof(real_t));
    acc_delete_finalize(b, n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_delete_finalize_async.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,reference-counting,syntactic,construct-independent,async,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *d = (real_t *)malloc(n * sizeof(real_t));
    real_t *e = (real_t *)malloc(n * sizeof(real_t));
    real_t *f = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = rand() / (real_t)(RAND_MAX / 10);
        f[x] = 0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n], d[0:n], e[0:n])
    #pragma acc data present(a[0:n], b[0:n], d[0:n], e[0:n]) copyout(c[0:n], f[0:n])
    {
        #pragma acc parallel async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc parallel async(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                f[x] = d[x] + e[x];
            }
        }
        acc_delete_finalize_async(a, n * sizeof(real_t), 1);
        acc_delete_finalize_async(b, n * sizeof(real_t), 1);
        acc_delete_finalize_async(d, n * sizeof(real_t), 2);
        acc_delete_finalize_async(e, n * sizeof(real_t), 2);
        #pragma acc wait
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,reference-counting,devonly,async,construct-independent,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *d = (real_t *)malloc(n * sizeof(real_t));
    real_t *e = (real_t *)malloc(n * sizeof(real_t));
    real_t *f = (real_t *)malloc(n * sizeof(real_t));
    int* devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            c[x] = 0;
        }

        #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])
        #pragma acc data present(a[0:n], b[0:n], c[0:n])
        {
            #pragma acc parallel async(1)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] = a[x] * b[x];
                }
            }
        }
        acc_delete_finalize_async(c, n * sizeof(real_t), 1);
        #pragma acc enter data copyin(c[0:n]) async(1)
        #pragma acc data present(a[0:n], b[0:n], c[0:n]) 
        {
            #pragma acc parallel async(1)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] += a[x] + b[x];
                }
            }
        }
        #pragma acc wait
        #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])

        for (int x = 0; x < n; ++x){
            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
                err += 1;
            }
        }
    }
    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_delete_finalize_async.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,reference-counting,syntactic,construct-independent,async,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *d = new real_t[n];
    real_t *e = new real_t[n];
    real_t *f = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = rand() / (real_t)(RAND_MAX / 10);
        f[x] = 0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n], d[0:n], e[0:n])
    #pragma acc enter data copyin(a[0:n], b[0:n], d[0:n], e[0:n])

    #pragma acc data present(a[0:n], b[0:n], d[0:n], e[0:n]) copyout(c[0:n], f[0:n])
    {
        #pragma acc parallel async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc parallel async(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                f[x] = d[x] + e[x];
            }
        }
        acc_delete_finalize_async(a, n * sizeof(real_t), 1);
        acc_delete_finalize_async(b, n * sizeof(real_t), 1);
        acc_delete_finalize_async(d, n * sizeof(real_t), 2);
        acc_delete_finalize_async(e, n * sizeof(real_t), 2);
        #pragma acc wait
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,reference-counting,devonly,async,construct-independent,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *d = new real_t[n];
    real_t *e = new real_t[n];
    real_t *f = new real_t[n];
    int* devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            c[x] = 0;
        }

        #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])
        #pragma acc enter data copyin(c[0:n])
        #pragma acc data present(a[0:n], b[0:n], c[0:n])
        {
            #pragma acc parallel async(1)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] = a[x] * b[x];
                }
            }
        }
        acc_delete_finalize_async(c, n * sizeof(real_t), 1);
        #pragma acc enter data copyin(c[0:n]) async(1)
        #pragma acc data present(a[0:n], b[0:n], c[0:n])
        {
            #pragma acc parallel async(1)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] += a[x] + b[x];
                }
            }
        }
        #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])

        for (int x = 0; x < n; ++x){
            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_detach.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:3.3
int test1(){
    int err = 0;
    srand(SEED);
    two_d_array data;
    
    data.a = (real_t *)malloc(n * sizeof(real_t));
    data.b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        data.a[x] = rand() / (real_t)(RAND_MAX / 10);
        data.b[x] = 2 * data.a[x];
    }

    #pragma acc enter data copyin(data.a[0:n], data.b[0:n])
    #pragma acc enter data copyin(data)
    acc_attach(&data.a);
    acc_attach(&data.b);

    #pragma acc parallel loop default(present)
    for(int x = 0; x < n; ++x){
        data.a[x] = data.a[x] * 2;
    }

    acc_detach(&data.a);
    acc_detach(&data.b);
    #pragma acc exit data copyout(data.a[0:n], data.b[0:n])
    #pragma acc exit data copyout(data)

    for (int x = 0; x < n; ++x){
        if (fabs(data.a[x] - data.b[x]) > PRECISION){
            err += 1;
        }
    }

    free(data.a);
    free(data.b);

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,construct-independent,V:3.3
int test2(){
    int err = 0;
    srand(SEED);
    two_d_array data;
    
    data.a = (real_t *)malloc(n * sizeof(real_t));
    data.b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        data.a[x] = rand() / (real_t)(RAND_MAX / 10);
        data.b[x] = 2 * data.a[x];
    }

    #pragma acc enter data copyin(data.a[0:n], data.b[0:n])
    #pragma acc enter data copyin(data)
    acc_attach(&data.a);
    acc_attach(&data.b);

    #pragma acc parallel loop default(present)
    for(int x = 0; x < n; ++x){
        data.a[x] = data.a[x] * 2;
    }

    #pragma acc exit data detach(data.a, data.b)
    #pragma acc exit data copyout(data.a[0:n], data.b[0:n])
    #pragma acc exit data copyout(data)

    for (int x = 0; x < n; ++x){
        if (fabs(data.a[x] - data.b[x]) > PRECISION){
            err += 1;
        }
    }

    free(data.a);
    free(data.b);

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_deviceptr.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *a_ptr;
    real_t *b_ptr;
    real_t *c_ptr;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n])

    a_ptr = acc_deviceptr(a);
    b_ptr = acc_deviceptr(b);
    c_ptr = acc_deviceptr(c);

    #pragma acc data deviceptr(a_ptr, b_ptr, c_ptr)
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c_ptr[x] = a_ptr[x] + b_ptr[x];
            }
        }
    }

    #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_deviceptr.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *a_ptr;
    real_t *b_ptr;
    real_t *c_ptr;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n])

    a_ptr = reinterpret_cast<real_t*>(acc_deviceptr(a));
    b_ptr = reinterpret_cast<real_t*>(acc_deviceptr(b));
    c_ptr = reinterpret_cast<real_t*>(acc_deviceptr(c));

    #pragma acc data deviceptr(a_ptr, b_ptr, c_ptr)
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c_ptr[x] = a_ptr[x] + b_ptr[x];
            }
        }
    }

    #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_free.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,V:2.6-2.7
int test1(){
    int err = 0;
    int *a = (int *)acc_malloc(n * sizeof(int));
    size_t initial_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);

    acc_free(a);
    size_t final_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);
    if (final_memory < initial_memory + n * sizeof(int)){
        err += 1;
    }
    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_free.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,V:2.6-2.7
int test1(){
    int err = 0;
    int *a = (int *)acc_malloc(n * sizeof(int));
    size_t initial_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);

    acc_free(a);
    size_t final_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);
    if (final_memory < initial_memory + n * sizeof(int)){
        err += 1;
    }
    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_get_default_async.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,async,construct-independent,internal-control-values,V:2.5-2.7
int test1(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    int holder = acc_get_default_async();

    for(int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])
    {
        #pragma acc parallel async
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc wait(holder)
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }
    if (acc_get_default_async() < 0){
        err += 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_get_default_async.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,async,construct-independent,internal-control-values,V:2.5-2.7
int test1(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    int holder = acc_get_default_async();

    for(int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])
    {
        #pragma acc parallel async
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc wait(holder)
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }
    if (acc_get_default_async() < 0){
        err += 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_get_device_num.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,devonly,internal-control-values,syntactic,V:1.0-2.7
int test1(){
    int err = 0;

    if (acc_get_device_type() != acc_device_none){
        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){
            acc_set_device_num(x, acc_get_device_type());
            if (acc_get_device_num(acc_get_device_type()) != x){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_get_device_num.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,devonly,internal-control-values,syntactic,V:1.0-2.7
int test1(){
    int err = 0;

    if (acc_get_device_type() != acc_device_none){
        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){
            acc_set_device_num(x, acc_get_device_type());
            if (acc_get_device_num(acc_get_device_type()) != x){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_get_device_type.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:,V:1.0-3.2
int test1(){
	int err = 0;

	int device_type = acc_get_device_type();

	if (acc_get_device_type() != device_type){
		err += 1;
	}

	return err;
}
#endif

int main(){
    	int failcode = 0;
    	int failed;
#ifndef T1
    	failed = 0;
    	for (int x = 0; x < NUM_TEST_CALLS; ++x){
        	failed = failed + test1();
    	}
    	if (failed != 0){
        	failcode = failcode + (1 << 0);
    	}
#endif
    	return failcode;
}

########## NEXT FILE ##########
acc_get_device_type.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:,V:1.0-3.2
int test1(){
	int err = 0;

	int device_type = acc_get_device_type();

	if (acc_get_device_type() != device_type){
		err += 1;
	}

	return err;
}
#endif

int main(){
    	int failcode = 0;
    	int failed;
#ifndef T1
    	failed = 0;
    	for (int x = 0; x < NUM_TEST_CALLS; ++x){
        	failed = failed + test1();
    	}
    	if (failed != 0){
        	failcode = failcode + (1 << 0);
    	}
#endif
    	return failcode;
}

########## NEXT FILE ##########
acc_get_num_devices.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,devonly,internal-control-values,syntactic,V:1.0-2.7
int test1(){
    int err = 0;

    if(acc_get_device_type() != acc_device_none && acc_get_num_devices(acc_get_device_type()) == 0){ //Can't have zero of current device type
          err += 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_get_num_devices.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,devonly,internal-control-values,syntactic,V:1.0-2.7
int test1(){
    int err = 0;

    if(acc_get_device_type() != acc_device_none && acc_get_num_devices(acc_get_device_type()) == 0){ //Can't have zero of current device type
          err += 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_get_property.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,devonly,syntactic,V:2.6-2.7
int test1(){
    int err = 0;

    if (acc_get_device_type() != acc_device_none){
        const char* returned_string1;
        const char* returned_string2;
        const char* returned_string3;
        int returned_int;
        returned_int = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_memory);
        returned_int = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);
        returned_string1 = acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_name);
        returned_string2 = acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_vendor);
        returned_string3 = acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_driver);
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_get_property.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,devonly,syntactic,V:2.6-2.7
int test1(){
    int err = 0;

    if (acc_get_device_type() != acc_device_none){
        const char* returned_string1;
        const char* returned_string2;
        const char* returned_string3;
        int returned_int;
        returned_int = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_memory);
        returned_int = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);
        returned_string1 = acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_name);
        returned_string2 = acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_vendor);
        returned_string3 = acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_driver);
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_hostptr.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *a_ptr;

    a_ptr = acc_create(a, n * sizeof(real_t));

    if (a != acc_hostptr(acc_deviceptr(a))){
        err += 1;
    }

    acc_delete(a, n * sizeof(real_t));

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_hostptr.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *a_ptr;

    a_ptr = reinterpret_cast<real_t*>(acc_create(a, n * sizeof(real_t)));

    if (a != acc_hostptr(acc_deviceptr(a))){
        err += 1;
    }

    acc_delete(a, n * sizeof(real_t));

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_init.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,init,syntactic,V:2.5-2.7
int test1(){
    int err = 0;

    if (acc_get_device_type() != acc_device_none){
        acc_init(acc_get_device_type());
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_init.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,init,syntactic,V:2.5-2.7
int test1(){
    int err = 0;

    if (acc_get_device_type() != acc_device_none){
        acc_init(acc_get_device_type());
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_init_device.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:routine,init,runtime,syntactic,V:3.2-3.3
int test1(){
    int err = 0;

    if (acc_get_device_type() != acc_device_none){
        acc_init_device(1, acc_get_device_type());
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}


########## NEXT FILE ##########
acc_is_present.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,devonly,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    int *devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    #pragma acc enter data create(a[0:n])
    if (acc_is_present(a, n * sizeof(real_t)) == 0){
        err += 1;
    }
    #pragma acc exit data delete(a[0:n])

    if (devtest[0] == 1){
        if (acc_is_present(a, n * sizeof(real_t)) != 0){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_is_present.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,devonly,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = new real_t[n];
    int *devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    #pragma acc enter data create(a[0:n])
    if (acc_is_present(a, n * sizeof(real_t)) == 0){
        err += 1;
    }
    #pragma acc exit data delete(a[0:n])

    if (devtest[0] == 1){
        if (acc_is_present(a, n * sizeof(real_t)) != 0){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_malloc.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,V:1.0-2.7
int test1(){
    int err = 0;
    size_t initial_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);
    int *a = (int *)acc_malloc(n * sizeof(int));

    if (initial_memory == 0){
        return err;
    }
    size_t final_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);
    if (final_memory + n * sizeof(int) > initial_memory){
        err += 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_malloc.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,V:1.0-2.7
int test1(){
    int err = 0;
    size_t initial_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);
    int *a = (int *)acc_malloc(n * sizeof(int));

    if (initial_memory == 0){
        return err;
    }
    size_t final_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);
    if (final_memory + n * sizeof(int) > initial_memory){
        err += 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_map_data.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *d;
    real_t *e = (real_t *)malloc(n * sizeof(real_t));

    d = (real_t *)acc_malloc(n * sizeof(real_t));
    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    acc_map_data(c, d, n * sizeof(real_t));

    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    #pragma acc update host(c[0:n])
    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x]))> PRECISION){
            err += 1;
        }
    }

    acc_unmap_data(c);
    acc_free(d);

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test2(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *d;
    real_t *e = (real_t *)malloc(n * sizeof(real_t));

    d = (real_t *)acc_malloc(2 * n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    acc_map_data(c, d, n * sizeof(real_t));
    acc_map_data(e, &(d[n]), n * sizeof(real_t));

    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n], e[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                e[x] = a[x] * b[x];
            }
        }
    }

    #pragma acc update host(c[0:n])
    #pragma acc update host(e[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
        if (fabs(e[x] - (a[x] * b[x])) > PRECISION){
            err += 1;
        }
    }
    acc_unmap_data(c);
    acc_unmap_data(e);
    acc_free(d);

    return err;
}
#endif

#ifndef T3
//T3:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test3(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *d;
    real_t *e = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    d = (real_t *)acc_malloc(n * sizeof(real_t));

    #pragma acc data copyin(a[0:n], b[0:n]) deviceptr(d)
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                d[x] = a[x] + b[x];
            }
        }
    }

    acc_map_data(c, d, n * sizeof(real_t));
    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }
        }
    }

    #pragma acc update host(c[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - 2 * (a[x] + b[x])) > 2 * PRECISION){
            err += 1;
        }
    }

    acc_unmap_data(c);
    acc_free(d);

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_map_data.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *d;
    real_t *e = new real_t[n];

    d = (real_t *)acc_malloc(n * sizeof(real_t));
    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    acc_map_data(c, d, n * sizeof(real_t));

    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    #pragma acc update host(c[0:n])
    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x]))> PRECISION){
            err += 1;
        }
    }

    acc_unmap_data(c);
    acc_free(d);

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test2(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *d;
    real_t *e = new real_t[n];

    d = (real_t *)acc_malloc(2 * n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    acc_map_data(c, d, n * sizeof(real_t));
    acc_map_data(e, &(d[n]), n * sizeof(real_t));

    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n], e[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                e[x] = a[x] * b[x];
            }
        }
    }

    #pragma acc update host(c[0:n])
    #pragma acc update host(e[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
        if (fabs(e[x] - (a[x] * b[x])) > PRECISION){
            err += 1;
        }
    }
    acc_unmap_data(c);
    acc_unmap_data(e);
    acc_delete(d, n * sizeof(real_t));

    return err;
}
#endif

#ifndef T3
//T3:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test3(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *d;
    real_t *e = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    d = (real_t *)acc_malloc(n * sizeof(real_t));

    #pragma acc data copyin(a[0:n], b[0:n]) deviceptr(d)
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                d[x] = a[x] + b[x];
            }
        }
    }

    acc_map_data(c, d, n * sizeof(real_t));
    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }
        }
    }

    #pragma acc update host(c[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - 2 * (a[x] + b[x])) > 2 * PRECISION){
            err += 1;
        }
    }

    acc_unmap_data(c);
    acc_delete(d, n * sizeof(real_t));

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_memcpy_d2d.c:::
#include "acc_testsuite.h"
#include <stdlib.h>
#include <math.h>

#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));

    acc_set_device_num(0, acc_device_nvidia);
    #pragma acc enter data create(a[0:n])
    acc_set_device_num(1, acc_device_nvidia);
    #pragma acc enter data create(b[0:n])
    

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = a[x];
        c[x] = 4 * a[x];
    }
    acc_set_device_num(0, acc_device_nvidia);
    #pragma acc update device(a[0:n])
    acc_set_device_num(1, acc_device_nvidia);
    #pragma acc update device(b[0:n])
    
    acc_set_device_num(0, acc_device_nvidia);
    #pragma acc data present(a)
    {
        // acc_set_device_num(0, acc_device_nvidia);
        #pragma acc parallel loop 
        for(int i = 0; i < n; ++i){
            a[i] *= 2;
        }
        acc_memcpy_d2d(b, a, n * sizeof(real_t), 1, 0);

    }

    acc_set_device_num(1, acc_device_nvidia);
    #pragma acc parallel loop
    for(int i = 0; i < n; ++i){
        b[i] *= 2;
    }

    #pragma acc update host(b[0:n])

    for(int x = 0; x < n; ++x){
        if(fabs(b[x] - c[x]) > PRECISION){
            err++;
            break;
        }
    }

    #pragma acc exit data delete(a[0:n], b[0:n])

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_memcpy_d2d.cpp:::
#include "acc_testsuite.h"
#include <stdlib.h>
#include <math.h>

#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:3.3
int test1(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];

    acc_set_device_num(0, acc_device_nvidia);
    #pragma acc enter data create(a[0:n])
    acc_set_device_num(1, acc_device_nvidia);
    #pragma acc enter data create(b[0:n])
    

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = a[x];
        c[x] = 4 * a[x];
    }
    acc_set_device_num(0, acc_device_nvidia);
    #pragma acc update device(a[0:n])
    acc_set_device_num(1, acc_device_nvidia);
    #pragma acc update device(b[0:n])
    
    acc_set_device_num(0, acc_device_nvidia);
    #pragma acc data present(a)
    {
        #pragma acc parallel loop 
        for(int i = 0; i < n; ++i){
            a[i] *= 2;
        }
        acc_memcpy_d2d(b, a, n * sizeof(real_t), 1, 0);

    }

    acc_set_device_num(1, acc_device_nvidia);
    #pragma acc parallel loop
    for(int i = 0; i < n; ++i){
        b[i] *= 2;
    }

    #pragma acc update host(b[0:n])

    for(int x = 0; x < n; ++x){
        if(fabs(b[x] - c[x]) > PRECISION){
            err++;
            break;
        }
    }

    #pragma acc exit data delete(a[0:n], b[0:n])

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_memcpy_device.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:2.5-2.7
int test1(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *hostdata = (real_t *)malloc(3 * n * sizeof(real_t));
    real_t *devdata;

    for (int x = 0; x < n; ++x){
        hostdata[x] = rand() / (real_t)(RAND_MAX / 10);
        hostdata[n + x] = rand() / (real_t)(RAND_MAX / 10);
        hostdata[2*n + x] = 1;
    }

    devdata = acc_copyin(hostdata, 3 * n * sizeof(real_t));
    #pragma acc enter data create(a[0:n], b[0:n], c[0:n])
    acc_memcpy_device(acc_deviceptr(a), devdata, n * sizeof(real_t));
    acc_memcpy_device(acc_deviceptr(b), devdata+n, n * sizeof(real_t));
    acc_memcpy_device(acc_deviceptr(c), devdata+2*n, n * sizeof(real_t));

    #pragma acc data present(a[0:n], b[0:n], c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }
        }
    }

    #pragma acc exit data copyout(a[0:n], b[0:n], c[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - hostdata[x]) > PRECISION){
            err += 1;
        }
        if (fabs(b[x] - hostdata[n + x]) > PRECISION){
            err += 1;
        }
        if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    #pragma acc exit data delete(hostdata[0:3*n])

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_memcpy_device.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:2.5-2.7
int test1(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *hostdata = new real_t[3 * n];
    real_t *devdata;

    for (int x = 0; x < n; ++x){
        hostdata[x] = rand() / (real_t)(RAND_MAX / 10);
        hostdata[n + x] = rand() / (real_t)(RAND_MAX / 10);
        hostdata[2*n + x] = 1;
    }

    devdata = reinterpret_cast<real_t*>(acc_copyin(hostdata, 3 * n * sizeof(real_t)));
    #pragma acc enter data create(a[0:n], b[0:n], c[0:n])
    acc_memcpy_device(acc_deviceptr(a), devdata, n * sizeof(real_t));
    acc_memcpy_device(acc_deviceptr(b), devdata+n, n * sizeof(real_t));
    acc_memcpy_device(acc_deviceptr(c), devdata+2*n, n * sizeof(real_t));

    #pragma acc data present(a[0:n], b[0:n], c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }
        }
    }

    #pragma acc exit data copyout(a[0:n], b[0:n], c[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - hostdata[x]) > PRECISION){
            err += 1;
        }
        if (fabs(b[x] - hostdata[n + x]) > PRECISION){
            err += 1;
        }
        if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    #pragma acc exit data delete(hostdata[0:3*n])

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_memcpy_from_device.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *hostdata = (real_t *)malloc(3 * n * sizeof(real_t));
    real_t *devdata;

    for (int x = 0; x < n; ++x){
        hostdata[x] = rand() / (real_t)(RAND_MAX / 10);
        hostdata[n + x] = rand() / (real_t)(RAND_MAX / 10);
        hostdata[2*n + x] = 1;
    }

    devdata = acc_copyin(hostdata, 3 * n * sizeof(real_t));

    #pragma acc data deviceptr(devdata)
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                devdata[2*n + x] += devdata[x] + devdata[n + x];
            }
        }
    }

    acc_memcpy_from_device(a, devdata, n * sizeof(real_t));
    acc_memcpy_from_device(b, &(devdata[n]), n * sizeof(real_t));
    acc_memcpy_from_device(c, &(devdata[2*n]), n * sizeof(real_t));


    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - hostdata[x]) > PRECISION){
            err += 1;
        }
        if (fabs(b[x] - hostdata[n + x]) > PRECISION){
            err += 1;
        }
        if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    #pragma acc exit data delete(hostdata[0:3*n])

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_memcpy_from_device.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *hostdata = new real_t[3 * n];
    real_t *devdata;

    for (int x = 0; x < n; ++x){
        hostdata[x] = rand() / (real_t)(RAND_MAX / 10);
        hostdata[n + x] = rand() / (real_t)(RAND_MAX / 10);
        hostdata[2*n + x] = 1;
    }

    devdata = reinterpret_cast<real_t*>(acc_copyin(hostdata, 3 * n * sizeof(real_t)));

    #pragma acc data deviceptr(devdata)
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                devdata[2*n + x] += devdata[x] + devdata[n + x];
            }
        }
    }

    acc_memcpy_from_device(a, devdata, n * sizeof(real_t));
    acc_memcpy_from_device(b, &(devdata[n]), n * sizeof(real_t));
    acc_memcpy_from_device(c, &(devdata[2*n]), n * sizeof(real_t));


    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - hostdata[x]) > PRECISION){
            err += 1;
        }
        if (fabs(b[x] - hostdata[n + x]) > PRECISION){
            err += 1;
        }
        if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    #pragma acc exit data delete(hostdata[0:3*n])

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_memcpy_from_device_async.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
int test1(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *d = (real_t *)malloc(n * sizeof(real_t));
    real_t *e = (real_t *)malloc(n * sizeof(real_t));
    real_t *f = (real_t *)malloc(n * sizeof(real_t));
    real_t *hostdata = (real_t *)malloc(6 * n * sizeof(real_t));
    real_t *hostdata_copy = (real_t *)malloc(6 * n * sizeof(real_t));

    real_t *devdata;

    for (int x = 0; x < n; ++x){
        hostdata[x] = rand() / (real_t)(RAND_MAX / 10);
        hostdata[n + x] = rand() / (real_t)(RAND_MAX / 10);
        hostdata[2*n + x] = 1;
        hostdata[3*n + x] = rand() / (real_t)(RAND_MAX / 10);
        hostdata[4*n + x] = rand() / (real_t)(RAND_MAX / 10);
        hostdata[5*n + x] = 2;
    }

    for (int x = 0; x < 6*n; ++x){
        hostdata_copy[x] = hostdata[x];
    }

    devdata = acc_copyin(hostdata, 6 * n * sizeof(real_t));

    #pragma acc data deviceptr(devdata)
    {
        #pragma acc parallel async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                devdata[x] = devdata[x] * devdata[x];
            }
        }
        acc_memcpy_from_device_async(a, devdata, n * sizeof(real_t), 1);
        #pragma acc parallel async(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                devdata[n + x] = devdata[n + x] * devdata[n + x];
            }
        }
        acc_memcpy_from_device_async(b, &(devdata[n]), n * sizeof(real_t), 2);
        #pragma acc parallel async(4)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                devdata[3*n + x] = devdata[3*n + x] * devdata[3*n + x];
            }
        }
        acc_memcpy_from_device_async(d, &(devdata[3*n]), n * sizeof(real_t), 4);
        #pragma acc parallel async(5)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                devdata[4*n + x] = devdata[4*n + x] * devdata[4*n + x];
            }
        }
        acc_memcpy_from_device_async(e, &(devdata[4*n]), n * sizeof(real_t), 5);
        #pragma acc parallel async(3) wait(1, 2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                devdata[2*n + x] += devdata[x] + devdata[n + x];
            }
        }
        acc_memcpy_from_device_async(c, &(devdata[2*n]), n * sizeof(real_t), 3);
        #pragma acc parallel async(6) wait(4, 5)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                devdata[5*n + x] += devdata[3*n + x] + devdata[4*n + x];
            }
        }
        acc_memcpy_from_device_async(f, &(devdata[5*n]), n * sizeof(real_t), 6);
    }

    #pragma acc wait(1)
    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - hostdata_copy[x] * hostdata_copy[x]) > PRECISION){
            err += 1;
        }
    }
    #pragma acc wait(2)
    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - hostdata_copy[n + x] * hostdata_copy[n + x]) > PRECISION){
            err += 1;
        }
    }
    #pragma acc wait(4)
    for (int x = 0; x < n; ++x){
        if (fabs(d[x] - hostdata_copy[3*n + x] * hostdata_copy[3*n + x]) > PRECISION){
            err += 1;
        }
    }
    #pragma acc wait(5)
    for (int x = 0; x < n; ++x){
        if (fabs(e[x] - hostdata_copy[4*n + x] * hostdata_copy[4*n + x]) > PRECISION){
            err += 1;
        }
    }
    #pragma acc wait(3)
    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }
    #pragma acc wait(6)
    for (int x = 0; x < n; ++x){
        if (fabs(f[x] - (2 + d[x] + e[x])) > PRECISION){
            err += 1;
        }
    }

    #pragma acc exit data delete(hostdata[0:6*n])

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_memcpy_from_device_async.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
int test1(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *d = new real_t[n];
    real_t *e = new real_t[n];
    real_t *f = new real_t[n];
    real_t *hostdata = new real_t[6 * n];
    real_t *hostdata_copy = new real_t[6 * n];

    real_t *devdata;

    for (int x = 0; x < n; ++x){
        hostdata[x] = rand() / (real_t)(RAND_MAX / 10);
        hostdata[n + x] = rand() / (real_t)(RAND_MAX / 10);
        hostdata[2*n + x] = 1;
        hostdata[3*n + x] = rand() / (real_t)(RAND_MAX / 10);
        hostdata[4*n + x] = rand() / (real_t)(RAND_MAX / 10);
        hostdata[5*n + x] = 2;
    }

    for (int x = 0; x < 6*n; ++x){
        hostdata_copy[x] = hostdata[x];
    }

    devdata = reinterpret_cast<real_t*>(acc_copyin(hostdata, 6 * n * sizeof(real_t)));

    #pragma acc data deviceptr(devdata)
    {
        #pragma acc parallel async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                devdata[x] = devdata[x] * devdata[x];
            }
        }
        acc_memcpy_from_device_async(a, devdata, n * sizeof(real_t), 1);
        #pragma acc parallel async(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                devdata[n + x] = devdata[n + x] * devdata[n + x];
            }
        }
        acc_memcpy_from_device_async(b, &(devdata[n]), n * sizeof(real_t), 2);
        #pragma acc parallel async(4)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                devdata[3*n + x] = devdata[3*n + x] * devdata[3*n + x];
            }
        }
        acc_memcpy_from_device_async(d, &(devdata[3*n]), n * sizeof(real_t), 4);
        #pragma acc parallel async(5)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                devdata[4*n + x] = devdata[4*n + x] * devdata[4*n + x];
            }
        }
        acc_memcpy_from_device_async(e, &(devdata[4*n]), n * sizeof(real_t), 5);
        #pragma acc parallel async(3) wait(1, 2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                devdata[2*n + x] += devdata[x] + devdata[n + x];
            }
        }
        acc_memcpy_from_device_async(c, &(devdata[2*n]), n * sizeof(real_t), 3);
        #pragma acc parallel async(6) wait(4, 5)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                devdata[5*n + x] += devdata[3*n + x] + devdata[4*n + x];
            }
        }
        acc_memcpy_from_device_async(f, &(devdata[5*n]), n * sizeof(real_t), 6);
    }

    #pragma acc wait(1)
    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - hostdata_copy[x] * hostdata_copy[x]) > PRECISION){
            err += 1;
        }
    }
    #pragma acc wait(2)
    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - hostdata_copy[n + x] * hostdata_copy[n + x]) > PRECISION){
            err += 1;
        }
    }
    #pragma acc wait(4)
    for (int x = 0; x < n; ++x){
        if (fabs(d[x] - hostdata_copy[3*n + x] * hostdata_copy[3*n + x]) > PRECISION){
            err += 1;
        }
    }
    #pragma acc wait(5)
    for (int x = 0; x < n; ++x){
        if (fabs(e[x] - hostdata_copy[4*n + x] * hostdata_copy[4*n + x]) > PRECISION){
            err += 1;
        }
    }
    #pragma acc wait(3)
    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }
    #pragma acc wait(6)
    for (int x = 0; x < n; ++x){
        if (fabs(f[x] - (2 + d[x] + e[x])) > PRECISION){
            err += 1;
        }
    }

    #pragma acc exit data delete(hostdata[0:6*n])

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_memcpy_to_device.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *hostdata = (real_t *)malloc(3 * n * sizeof(real_t));
    real_t *devdata;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 1;
    }

    devdata = acc_create(hostdata, 3 * n * sizeof(real_t));

    acc_memcpy_to_device(devdata, a, n * sizeof(real_t));
    acc_memcpy_to_device(&(devdata[n]), b, n * sizeof(real_t));
    acc_memcpy_to_device(&(devdata[2*n]), c, n * sizeof(real_t));

    #pragma acc data deviceptr(devdata)
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                devdata[2*n + x] += devdata[x] + devdata[n + x];
            }
        }
    }
    #pragma acc exit data copyout(hostdata[0:3*n])
    for (int x = 0; x < n; ++x){
        if (fabs(hostdata[2 * n + x] - (1 + hostdata[n + x] + hostdata[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_memcpy_to_device.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *hostdata = new real_t[3 * n];
    real_t *devdata;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 1;
    }

    devdata = reinterpret_cast<real_t*>(acc_create(hostdata, 3 * n * sizeof(real_t)));

    acc_memcpy_to_device(devdata, a, n * sizeof(real_t));
    acc_memcpy_to_device(&(devdata[n]), b, n * sizeof(real_t));
    acc_memcpy_to_device(&(devdata[2*n]), c, n * sizeof(real_t));

    #pragma acc data deviceptr(devdata)
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                devdata[2*n + x] += devdata[x] + devdata[n + x];
            }
        }
    }
    #pragma acc exit data copyout(hostdata[0:3*n])
    for (int x = 0; x < n; ++x){
        if (fabs(hostdata[2 * n + x] - (1 + hostdata[n + x] + hostdata[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_memcpy_to_device_async.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
int test1(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *d = (real_t *)malloc(n * sizeof(real_t));
    real_t *e = (real_t *)malloc(n * sizeof(real_t));
    real_t *f = (real_t *)malloc(n * sizeof(real_t));

    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));
    real_t *b_host = (real_t *)malloc(n * sizeof(real_t));
    real_t *d_host = (real_t *)malloc(n * sizeof(real_t));
    real_t *e_host = (real_t *)malloc(n * sizeof(real_t));

    real_t *hostdata = (real_t *)malloc(6 * n * sizeof(real_t));
    real_t *devdata;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 1;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = rand() / (real_t)(RAND_MAX / 10);
        f[x] = 2;

        a_host[x] = a[x];
        b_host[x] = b[x];
        d_host[x] = d[x];
        e_host[x] = e[x];
    }

    devdata = acc_create(hostdata, 6 * n * sizeof(real_t));

    acc_memcpy_to_device_async(devdata, a, n * sizeof(real_t), 1);
    acc_memcpy_to_device_async(&(devdata[n]), b, n * sizeof(real_t), 2);
    acc_memcpy_to_device_async(&(devdata[2*n]), c, n * sizeof(real_t), 3);
    acc_memcpy_to_device_async(&(devdata[3*n]), d, n * sizeof(real_t), 4);
    acc_memcpy_to_device_async(&(devdata[4*n]), e, n * sizeof(real_t), 5);
    acc_memcpy_to_device_async(&(devdata[5*n]), f, n * sizeof(real_t), 6);

    #pragma acc data deviceptr(devdata)
    {
        #pragma acc parallel async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                devdata[x] = devdata[x] * devdata[x];
            }
        }
        #pragma acc parallel async(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                devdata[n + x] = devdata[n + x] * devdata[n + x];
            }
        }
        #pragma acc parallel async(4)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                devdata[3*n + x] = devdata[3*n + x] * devdata[3*n + x];
            }
        }
        #pragma acc parallel async(5)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                devdata[4*n + x] = devdata[4*n + x] * devdata[4*n + x];
            }
        }
        #pragma acc parallel async(3) wait(1, 2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                devdata[2*n + x] += devdata[x] + devdata[n + x];
            }
        }
        #pragma acc parallel async(6) wait(4, 5)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                devdata[5*n + x] += devdata[3*n + x] + devdata[4*n + x];
            }
        }
    }

    #pragma acc update host(hostdata[2*n:n]) async(3)
    #pragma acc update host(hostdata[5*n:n]) async(6)

    #pragma acc wait(3)
    for (int x = 0; x < n; ++x){
        if (fabs(hostdata[2*n + x] - (1 + a_host[x] * a_host[x] + b_host[x] * b_host[x])) > 4 * PRECISION){
            err += 1;
        }
    }

    #pragma acc wait(6)
    for (int x = 0; x < n; ++x){
        if (fabs(hostdata[5*n + x] - (2 + d_host[x] * d_host[x] + e_host[x] * e_host[x])) > PRECISION){
            err += 1;
        }
    }

    #pragma acc exit data delete(hostdata[0:6*n])

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_memcpy_to_device_async.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
int test1(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *d = new real_t[n];
    real_t *e = new real_t[n];
    real_t *f = new real_t[n];

    real_t *a_host = new real_t[n];
    real_t *b_host = new real_t[n];
    real_t *d_host = new real_t[n];
    real_t *e_host = new real_t[n];

    real_t *hostdata = new real_t[6 * n];
    real_t *devdata;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 1;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = rand() / (real_t)(RAND_MAX / 10);
        f[x] = 2;

        a_host[x] = a[x];
        b_host[x] = b[x];
        d_host[x] = d[x];
        e_host[x] = e[x];
    }

    devdata = reinterpret_cast<real_t*>(acc_create(hostdata, 6 * n * sizeof(real_t)));

    acc_memcpy_to_device_async(devdata, a, n * sizeof(real_t), 1);
    acc_memcpy_to_device_async(&(devdata[n]), b, n * sizeof(real_t), 2);
    acc_memcpy_to_device_async(&(devdata[2*n]), c, n * sizeof(real_t), 3);
    acc_memcpy_to_device_async(&(devdata[3*n]), d, n * sizeof(real_t), 4);
    acc_memcpy_to_device_async(&(devdata[4*n]), e, n * sizeof(real_t), 5);
    acc_memcpy_to_device_async(&(devdata[5*n]), f, n * sizeof(real_t), 6);

    #pragma acc data deviceptr(devdata)
    {
        #pragma acc parallel async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                devdata[x] = devdata[x] * devdata[x];
            }
        }
        #pragma acc parallel async(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                devdata[n + x] = devdata[n + x] * devdata[n + x];
            }
        }
        #pragma acc parallel async(4)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                devdata[3*n + x] = devdata[3*n + x] * devdata[3*n + x];
            }
        }
        #pragma acc parallel async(5)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                devdata[4*n + x] = devdata[4*n + x] * devdata[4*n + x];
            }
        }
        #pragma acc parallel async(3) wait(1, 2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                devdata[2*n + x] += devdata[x] + devdata[n + x];
            }
        }
        #pragma acc parallel async(6) wait(4, 5)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                devdata[5*n + x] += devdata[3*n + x] + devdata[4*n + x];
            }
        }
    }

    #pragma acc update host(hostdata[2*n:n]) async(3)
    #pragma acc update host(hostdata[5*n:n]) async(6)

    #pragma acc wait(3)
    for (int x = 0; x < n; ++x){
        if (fabs(hostdata[2*n + x] - (1 + a_host[x] * a_host[x] + b_host[x] * b_host[x])) > 4 * PRECISION){
            err += 1;
        }
    }

    #pragma acc wait(6)
    for (int x = 0; x < n; ++x){
        if (fabs(hostdata[5*n + x] - (2 + d_host[x] * d_host[x] + e_host[x] * e_host[x])) > PRECISION){
            err += 1;
        }
    }

    #pragma acc exit data delete(hostdata[0:6*n])

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_on_device.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    int device_type = acc_get_device_type();

    if (device_type != acc_device_none){
        #pragma acc data copy(err)
        {
            #pragma acc parallel
            {
                if (acc_on_device(device_type) == 0){
                    err += 1;
                }
            }
        }
    }
    else{
        #pragma acc parallel
        {
            if (acc_on_device(acc_device_host) == 0){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_on_device.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    acc_device_t device_type = acc_get_device_type();

    if (device_type != acc_device_none){
        #pragma acc data copy(err)
        {
            #pragma acc parallel
            {
                if (acc_on_device(device_type) == 0){
                    err += 1;
                }
            }
        }
    }
    else{
        #pragma acc parallel
        {
            if (acc_on_device(acc_device_host) == 0){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_set_default_async.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,async,construct-independent,set,V:2.5-2.7
int test1(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));
    real_t *b_host = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        a_host[x] = a[x];
        b_host[x] = b[x];
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])
    {
        acc_set_default_async(1);
        #pragma acc parallel async
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                a[x] = a[x] * a[x];
            }
        }
        acc_set_default_async(2);
        #pragma acc parallel async
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = b[x] * b[x];
            }
        }
        #pragma acc parallel async(1) wait(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc wait(1)
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x])) > 4*PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_set_default_async.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,async,construct-independent,set,V:2.5-2.7
int test1(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *a_host = new real_t[n];
    real_t *b_host = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        a_host[x] = a[x];
        b_host[x] = b[x];
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])
    {
        acc_set_default_async(1);
        #pragma acc parallel async
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                a[x] = a[x] * a[x];
            }
        }
        acc_set_default_async(2);
        #pragma acc parallel async
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = b[x] * b[x];
            }
        }
        #pragma acc parallel async(1) wait(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc wait(1)
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x])) > 4*PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_set_device_num.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,devonly,construct-independent,set,V:2.0-2.7
int test1(){
    int err = 0;

    if (acc_get_device_type() != acc_device_none){
        real_t **host_copy = (real_t **)malloc(acc_get_num_devices(acc_get_device_type()) * sizeof(real_t *));
        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){
            host_copy[x] = (real_t *)malloc(n * sizeof(real_t));
        }
        real_t *a = (real_t *)malloc(n * sizeof(real_t));
        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){
            for (int y = 0; y < n; ++y){
                a[y] = rand() / (real_t)(RAND_MAX / 10);
                host_copy[x][y] = a[y];
            }
            acc_set_device_num(x, acc_get_device_type());
            #pragma acc enter data copyin(a[0:n])
        }
        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){
            acc_set_device_num(x, acc_get_device_type());
            #pragma acc data present(a[0:n])
            {
                #pragma acc parallel
                {
                    #pragma acc loop
                    for (int y = 0; y < n; ++y){
                        a[y] = a[y] + 1;
                    }
                }
            }
        }
        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){
            acc_set_device_num(x, acc_get_device_type());
            #pragma acc exit data copyout(a[0:n])
            for (int y = 0; y < n; ++y){
                if (fabs(a[y] - (host_copy[x][y] + 1)) > PRECISION){
                    err += 1;
                }
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_set_device_num.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,devonly,construct-independent,set,V:2.0-2.7
int test1(){
    int err = 0;

    if (acc_get_device_type() != acc_device_none){
        real_t **host_copy = (real_t **)malloc(acc_get_num_devices(acc_get_device_type()) * sizeof(real_t *));
        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){
            host_copy[x] = new real_t[n];
        }
        real_t *a = new real_t[n];
        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){
            for (int y = 0; y < n; ++y){
                a[y] = rand() / (real_t)(RAND_MAX / 10);
                host_copy[x][y] = a[y];
            }
            acc_set_device_num(x, acc_get_device_type());
            #pragma acc enter data copyin(a[0:n])
        }
        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){
            acc_set_device_num(x, acc_get_device_type());
            #pragma acc data present(a[0:n])
            {
                #pragma acc parallel
                {
                    #pragma acc loop
                    for (int y = 0; y < n; ++y){
                        a[y] = a[y] + 1;
                    }
                }
            }
        }
        for (int x = 0; x < acc_get_num_devices(acc_get_device_type()); ++x){
            acc_set_device_num(x, acc_get_device_type());
            #pragma acc exit data copyout(a[0:n])
            for (int y = 0; y < n; ++y){
                if (fabs(a[y] - (host_copy[x][y] + 1)) > PRECISION){
                    err += 1;
                }
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_set_device_type.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,internal-control-values,syntactic,V:2.0-2.7
int test1(){
    int err = 0;

    int device_type = acc_get_device_type();

    acc_set_device_type(device_type);
    if (acc_get_device_type() != device_type){
        err += 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_set_device_type.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,internal-control-values,syntactic,V:2.0-2.7
int test1(){
    int err = 0;

    acc_device_t device_type = acc_get_device_type();

    acc_set_device_type(device_type);
    if (acc_get_device_type() != device_type){
        err += 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_shutdown.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,devonly,shutdown,V:2.0-2.7
int test1(){
    int err = 0;

    if (acc_get_device_type() != acc_device_none){
        acc_shutdown(acc_get_device_type());
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_shutdown.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,devonly,shutdown,V:2.0-2.7
int test1(){
    int err = 0;

    if (acc_get_device_type() != acc_device_none){
        acc_shutdown(acc_get_device_type());
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_shutdown_device.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:routine,shutdown,runtime,syntactic,V:3.2-3.3
int test1(){
    int err = 0;

    if (acc_get_device_type() != acc_device_none){
        acc_shutdown_device(1, acc_get_device_type());
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}


########## NEXT FILE ##########
acc_unmap_data.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *d;
    real_t *e = (real_t *)malloc(n * sizeof(real_t));

    d = (real_t *)acc_malloc(n * sizeof(real_t));
    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    acc_map_data(c, d, n * sizeof(real_t));

    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    #pragma acc update host(c[0:n])
    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x]))> PRECISION){
            err += 1;
        }
    }

    acc_unmap_data(c);
    acc_free(d);

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test2(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *d;
    real_t *e = (real_t *)malloc(n * sizeof(real_t));

    d = (real_t *)acc_malloc(2 * n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    acc_map_data(c, d, n * sizeof(real_t));
    acc_map_data(e, &(d[n]), n * sizeof(real_t));

    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n], e[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                e[x] = a[x] * b[x];
            }
        }
    }

    #pragma acc update host(c[0:n])
    #pragma acc update host(e[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
        if (fabs(e[x] - (a[x] * b[x])) > PRECISION){
            err += 1;
        }
    }
    acc_unmap_data(c);
    acc_unmap_data(e);
    acc_free(d);

    return err;
}
#endif

#ifndef T3
//T3:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test3(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *d;
    real_t *e = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    d = (real_t *)acc_malloc(n * sizeof(real_t));

    #pragma acc data copyin(a[0:n], b[0:n]) deviceptr(d)
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                d[x] = a[x] + b[x];
            }
        }
    }

    acc_map_data(c, d, n * sizeof(real_t));
    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }
        }
    }

    #pragma acc update host(c[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - 2 * (a[x] + b[x])) > 2 * PRECISION){
            err += 1;
        }
    }

    acc_unmap_data(c);
    acc_free(d);

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_unmap_data.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *d;
    real_t *e = new real_t[n];

    d = (real_t *)acc_malloc(n * sizeof(real_t));
    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    acc_map_data(c, d, n * sizeof(real_t));

    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    #pragma acc update host(c[0:n])
    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x]))> PRECISION){
            err += 1;
        }
    }

    acc_unmap_data(c);
    acc_free(d);

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test2(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *d;
    real_t *e = new real_t[n];

    d = (real_t *)acc_malloc(2 * n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    acc_map_data(c, d, n * sizeof(real_t));
    acc_map_data(e, &(d[n]), n * sizeof(real_t));

    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n], e[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                e[x] = a[x] * b[x];
            }
        }
    }

    #pragma acc update host(c[0:n])
    #pragma acc update host(e[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
        if (fabs(e[x] - (a[x] * b[x])) > PRECISION){
            err += 1;
        }
    }
    acc_unmap_data(c);
    acc_unmap_data(e);
    acc_free(d);

    return err;
}
#endif

#ifndef T3
//T3:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test3(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *d;
    real_t *e = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    d = (real_t *)acc_malloc(n * sizeof(real_t));

    #pragma acc data copyin(a[0:n], b[0:n]) deviceptr(d)
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                d[x] = a[x] + b[x];
            }
        }
    }

    acc_map_data(c, d, n * sizeof(real_t));
    #pragma acc data copyin(a[0:n], b[0:n]) present(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }
        }
    }

    #pragma acc update host(c[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - 2 * (a[x] + b[x])) > 2 * PRECISION){
            err += 1;
        }
    }

    acc_unmap_data(c);
    acc_free(d);

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_update_device.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    int *devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel
    {
        devtest[0] = 0;
    }

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc data copyout(c[0:n]) create(a[0:n], b[0:n])
    {
        acc_update_device(a, n * sizeof(real_t));
        acc_update_device(b, n * sizeof(real_t));
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test2(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    int *devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            c[x] = 0;
        }

        #pragma acc data copyout(c[0:n]) copyin(a[0:n], b[0:n])
        {
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    a[x] = a[x] * a[x];
                }
            }
            acc_update_device(a, n * sizeof(real_t));
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    b[x] = b[x] * b[x];
                }
            }
            acc_update_device(b, n * sizeof(real_t));
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] = a[x] + b[x];
                }
            }
        }


        for (int x = 0; x < n; ++x){
            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_update_device.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    int *devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel
    {
        devtest[0] = 0;
    }

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc data copyout(c[0:n]) create(a[0:n], b[0:n])
    {
        acc_update_device(a, n * sizeof(real_t));
        acc_update_device(b, n * sizeof(real_t));
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test2(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    int *devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            c[x] = 0;
        }

        #pragma acc data copyout(c[0:n]) copyin(a[0:n], b[0:n])
        {
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    a[x] = a[x] * a[x];
                }
            }
            acc_update_device(a, n * sizeof(real_t));
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    b[x] = b[x] * b[x];
                }
            }
            acc_update_device(b, n * sizeof(real_t));
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] = a[x] + b[x];
                }
            }
        }


        for (int x = 0; x < n; ++x){
            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_update_device_async.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
int test1(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));
    real_t *b_host = (real_t *)malloc(n * sizeof(real_t));

    int *devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel
    {
        devtest[0] = 0;
    }

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        a_host[x] = a[x];
        b_host[x] = b[x];
    }



    #pragma acc data copyout(c[0:n]) create(a[0:n], b[0:n])
    {
        acc_update_device_async(a, n * sizeof(real_t), 1);
        #pragma acc parallel async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                a[x] = a[x] * a[x];
            }
        }
        acc_update_device_async(b, n * sizeof(real_t), 2);
        #pragma acc parallel async(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = b[x] * b[x];
            }
        }
        #pragma acc parallel async(1) wait(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc wait(1)
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,async,devonly,construct-independent,V:2.5-2.7
int test2(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));
    real_t *b_host = (real_t *)malloc(n * sizeof(real_t));

    int *devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            c[x] = 0;
        }

        #pragma acc data copyout(c[0:n]) copyin(a[0:n], b[0:n])
        {
            #pragma acc parallel async(1)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    a[x] = a[x] * a[x];
                }
            }
            acc_update_device_async(a, n * sizeof(real_t), 1);
            #pragma acc parallel async(2)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    b[x] = b[x] * b[x];
                }
            }
            acc_update_device_async(b, n * sizeof(real_t), 2);
            #pragma acc parallel async(1) wait(2)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] = a[x] + b[x];
                }
            }
            #pragma acc wait(1)
        }


        for (int x = 0; x < n; ++x){
            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_update_device_async.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
int test1(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *a_host = new real_t[n];
    real_t *b_host = new real_t[n];

    int *devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel
    {
        devtest[0] = 0;
    }

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        a_host[x] = a[x];
        b_host[x] = b[x];
    }



    #pragma acc data copyout(c[0:n]) create(a[0:n], b[0:n])
    {
        acc_update_device_async(a, n * sizeof(real_t), 1);
        #pragma acc parallel async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                a[x] = a[x] * a[x];
            }
        }
        acc_update_device_async(b, n * sizeof(real_t), 2);
        #pragma acc parallel async(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = b[x] * b[x];
            }
        }
        #pragma acc parallel async(1) wait(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc wait(1)
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,async,devonly,construct-independent,V:2.5-2.7
int test2(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *a_host = new real_t[n];
    real_t *b_host = new real_t[n];

    int *devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            c[x] = 0;
        }

        #pragma acc data copyout(c[0:n]) copyin(a[0:n], b[0:n])
        {
            #pragma acc parallel async(1)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    a[x] = a[x] * a[x];
                }
            }
            acc_update_device_async(a, n * sizeof(real_t), 1);
            #pragma acc parallel async(2)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    b[x] = b[x] * b[x];
                }
            }
            acc_update_device_async(b, n * sizeof(real_t), 2);
            #pragma acc parallel async(1) wait(2)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] = a[x] + b[x];
                }
            }
            #pragma acc wait(1)
        }


        for (int x = 0; x < n; ++x){
            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_update_self.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc data create(c[0:n]) copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        acc_update_self(c, n * sizeof(real_t));
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test2(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc data copyout(c[0:n]) copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                a[x] = a[x] * a[x];
            }
        }
        acc_update_self(a, n * sizeof(real_t));
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = b[x] * b[x];
            }
        }
        acc_update_self(b, n * sizeof(real_t));
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }


    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_update_self.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc data create(c[0:n]) copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        acc_update_self(c, n * sizeof(real_t));
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test2(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc data copyout(c[0:n]) copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                a[x] = a[x] * a[x];
            }
        }
        acc_update_self(a, n * sizeof(real_t));
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = b[x] * b[x];
            }
        }
        acc_update_self(b, n * sizeof(real_t));
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }


    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_update_self_async.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
int test1(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *d = (real_t *)malloc(n * sizeof(real_t));

    int *devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel
    {
        devtest[0] = 0;
    }

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = 0;
    }



    #pragma acc data create(c[0:n], d[0:n]) copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc parallel async(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                d[x] = a[x] * b[x];
            }
        }
        acc_update_self_async(c, n * sizeof(real_t), 1);
        acc_update_self_async(d, n * sizeof(real_t), 2);
        #pragma acc wait
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
        if (fabs(d[x] - (a[x] * b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,devonly,async,construct-independent,V:2.5-2.7
int test2(){
	int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *d = (real_t *)malloc(n * sizeof(real_t));

    int *devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            c[x] = 0;
        }

        #pragma acc data copyout(c[0:n]) copyin(a[0:n], b[0:n])
        {
            #pragma acc parallel async(1)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    a[x] = a[x] * a[x];
                }
            }
            acc_update_self_async(a, n * sizeof(real_t), 1);
            #pragma acc parallel async(2)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    b[x] = b[x] * b[x];
                }
            }
            acc_update_self_async(b, n * sizeof(real_t), 2);
            #pragma acc parallel async(1)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    a[x] = a[x] + 1;
                }
            }
            #pragma acc parallel async(2)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    b[x] = b[x] + 1;
                }
            }
            #pragma acc parallel async(1) wait(2)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] = a[x] * b[x];
                }
            }
            #pragma acc wait(1)
        }


        for (int x = 0; x < n; ++x){
            if (fabs(c[x] - ((a[x] + 1) * (b[x] + 1))) > 4 * PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_update_self_async.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
int test1(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *d = new real_t[n];

    int *devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel
    {
        devtest[0] = 0;
    }

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = 0;
    }



    #pragma acc data create(c[0:n], d[0:n]) copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc parallel async(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                d[x] = a[x] * b[x];
            }
        }
        acc_update_self_async(c, n * sizeof(real_t), 1);
        acc_update_self_async(d, n * sizeof(real_t), 2);
        #pragma acc wait
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
        if (fabs(d[x] - (a[x] * b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:runtime,data,executable-data,devonly,async,construct-independent,V:2.5-2.7
int test2(){
	int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *d = new real_t[n];

    int *devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            c[x] = 0;
        }

        #pragma acc data copyout(c[0:n]) copyin(a[0:n], b[0:n])
        {
            #pragma acc parallel async(1)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    a[x] = a[x] * a[x];
                }
            }
            acc_update_self_async(a, n * sizeof(real_t), 1);
            #pragma acc parallel async(2)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    b[x] = b[x] * b[x];
                }
            }
            acc_update_self_async(b, n * sizeof(real_t), 2);
            #pragma acc parallel async(1)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    a[x] = a[x] + 1;
                }
            }
            #pragma acc parallel async(2)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    b[x] = b[x] + 1;
                }
            }
            #pragma acc parallel async(1) wait(2)
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] = a[x] * b[x];
                }
            }
            #pragma acc wait(1)
        }


        for (int x = 0; x < n; ++x){
            if (fabs(c[x] - ((a[x] + 1) * (b[x] + 1))) > 4 * PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_wait.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,async,construct-independent,wait,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *d = (real_t *)malloc(n * sizeof(real_t));
    real_t *e = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = 0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n]) async(1)
    #pragma acc enter data copyin(d[0:n]) create(e[0:n]) async(2)
    #pragma acc parallel present(a[0:n], b[0:n], c[0:n]) async(1)
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = a[x] + b[x];
        }
    }
    #pragma acc parallel present(c[0:n], d[0:n], e[0:n]) async(1) wait(2)
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            e[x] = c[x] + d[x];
        }
    }
    #pragma acc exit data copyout(e[0:n]) async(1)

    acc_wait(1);
    for (int x = 0; x < n; ++x){
        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION){
            err += 1;
        }
    }

    #pragma acc exit data delete(a[0:n], b[0:n], c[0:n], d[0:n])

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_wait.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,async,construct-independent,wait,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *d = new real_t[n];
    real_t *e = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = 0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n]) async(1)
    #pragma acc enter data copyin(d[0:n]) create(e[0:n]) async(2)
    #pragma acc parallel present(a[0:n], b[0:n], c[0:n]) async(1)
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = a[x] + b[x];
        }
    }
    #pragma acc parallel present(c[0:n], d[0:n], e[0:n]) async(1) wait(2)
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            e[x] = c[x] + d[x];
        }
    }
    #pragma acc exit data copyout(e[0:n]) async(1)

    acc_wait(1);
    for (int x = 0; x < n; ++x){
        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION){
            err += 1;
        }
    }

    #pragma acc exit data delete(a[0:n], b[0:n], c[0:n], d[0:n])

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_wait_all.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,async,construct-independent,wait,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *d = (real_t *)malloc(n * sizeof(real_t));
    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));
    real_t *b_host = (real_t *)malloc(n * sizeof(real_t));
    real_t *c_host = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = rand() / (real_t)(RAND_MAX / 10);
        d[x] = 0;
        a_host[x] = a[x];
        b_host[x] = b[x];
        c_host[x] = c[x];
    }

    #pragma acc data copyin(a[0:n], b[0:n], c[0:n]) copyout(d[0:n])
    {
        #pragma acc parallel async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                a[x] = a[x] * a[x];
            }
        }
        #pragma acc parallel async(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = b[x] * b[x];
            }
        }
        #pragma acc parallel async(3)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = c[x] * c[x];
            }
        }
        acc_wait_all();
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                d[x] = a[x] + b[x] + c[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(d[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x] + c_host[x] * c_host[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_wait_all.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,async,construct-independent,wait,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *d = new real_t[n];
    real_t *a_host = new real_t[n];
    real_t *b_host = new real_t[n];
    real_t *c_host = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = rand() / (real_t)(RAND_MAX / 10);
        d[x] = 0;
        a_host[x] = a[x];
        b_host[x] = b[x];
        c_host[x] = c[x];
    }

    #pragma acc data copyin(a[0:n], b[0:n], c[0:n]) copyout(d[0:n])
    {
        #pragma acc parallel async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                a[x] = a[x] * a[x];
            }
        }
        #pragma acc parallel async(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = b[x] * b[x];
            }
        }
        #pragma acc parallel async(3)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = c[x] * c[x];
            }
        }
        acc_wait_all();
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                d[x] = a[x] + b[x] + c[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(d[x] - (a_host[x] * a_host[x] + b_host[x] * b_host[x] + c_host[x] * c_host[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_wait_all_async.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,async,construct-independent,wait,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *d = (real_t *)malloc(n * sizeof(real_t));
    real_t *e = (real_t *)malloc(n * sizeof(real_t));
    real_t *f = (real_t *)malloc(n * sizeof(real_t));
    real_t *g = (real_t *)malloc(n * sizeof(real_t));
    real_t *h = (real_t *)malloc(n * sizeof(real_t));
    real_t *i = (real_t *)malloc(n * sizeof(real_t));
    real_t *j = (real_t *)malloc(n * sizeof(real_t));
    real_t *k = (real_t *)malloc(n * sizeof(real_t));
    real_t *a_host = (real_t *)malloc(n * sizeof(real_t));
    real_t *d_host = (real_t *)malloc(n * sizeof(real_t));
    real_t *g_host = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = rand() / (real_t)(RAND_MAX / 10);
        f[x] = 0;
        g[x] = rand() / (real_t)(RAND_MAX / 10);
        h[x] = rand() / (real_t)(RAND_MAX / 10);
        i[x] = 0;
        j[x] = 0;
        k[x] = 0;
        a_host[x] = a[x];
        d_host[x] = d[x];
        g_host[x] = g[x];
    }

    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n], g[0:n], h[0:n]) create(c[0:n], f[0:n], i[0:n], j[0:n]) copyout(k[0:n])
    {
        #pragma acc parallel async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc parallel async(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                f[x] = d[x] + e[x];
            }
        }
        #pragma acc parallel async(3)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                i[x] = g[x] + h[x];
            }
        }
        acc_wait_all_async(4);
        #pragma acc parallel async(4)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                j[x] = c[x] + f[x] + i[x];
            }
        }
        #pragma acc parallel async(1)
        {
            for (int x = 0; x < n; ++x){
                a[x] = b[x] * c[x];
            }
        }
        #pragma acc parallel async(2)
        {
            for (int x = 0; x < n; ++x){
                d[x] = e[x] * f[x];
            }
        }
        #pragma acc parallel async(3)
        {
            for (int x = 0; x < n; ++x){
                g[x] = h[x] * i[x];
            }
        }
        acc_wait_all_async(4);
        #pragma acc parallel async(4)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                k[x] = j[x] + a[x] + d[x] + g[x];
            }
        }
        #pragma acc wait(4)
    }

    real_t temp;
    for (int x = 0; x < n; ++x){
        temp = a_host[x] + b[x] + d_host[x] + e[x] + g_host[x] + h[x];
        temp += b[x] * (a_host[x] + b[x]) + e[x] * (d_host[x] + e[x]) + h[x] * (g_host[x] + h[x]);
        if (fabs(k[x] - temp) > PRECISION * 10){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_wait_all_async.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,async,construct-independent,wait,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *d = new real_t[n];
    real_t *e = new real_t[n];
    real_t *f = new real_t[n];
    real_t *g = new real_t[n];
    real_t *h = new real_t[n];
    real_t *i = new real_t[n];
    real_t *j = new real_t[n];
    real_t *k = new real_t[n];
    real_t *a_host = new real_t[n];
    real_t *d_host = new real_t[n];
    real_t *g_host = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = rand() / (real_t)(RAND_MAX / 10);
        f[x] = 0;
        g[x] = rand() / (real_t)(RAND_MAX / 10);
        h[x] = rand() / (real_t)(RAND_MAX / 10);
        i[x] = 0;
        j[x] = 0;
        k[x] = 0;
        a_host[x] = a[x];
        d_host[x] = d[x];
        g_host[x] = g[x];
    }

    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n], g[0:n], h[0:n]) create(c[0:n], f[0:n], i[0:n], j[0:n]) copyout(k[0:n])
    {
        #pragma acc parallel async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc parallel async(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                f[x] = d[x] + e[x];
            }
        }
        #pragma acc parallel async(3)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                i[x] = g[x] + h[x];
            }
        }
        acc_wait_all_async(4);
        #pragma acc parallel async(4)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                j[x] = c[x] + f[x] + i[x];
            }
        }
        #pragma acc parallel async(1)
        {
            for (int x = 0; x < n; ++x){
                a[x] = b[x] * c[x];
            }
        }
        #pragma acc parallel async(2)
        {
            for (int x = 0; x < n; ++x){
                d[x] = e[x] * f[x];
            }
        }
        #pragma acc parallel async(3)
        {
            for (int x = 0; x < n; ++x){
                g[x] = h[x] * i[x];
            }
        }
        acc_wait_all_async(4);
        #pragma acc parallel async(4)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                k[x] = j[x] + a[x] + d[x] + g[x];
            }
        }
        #pragma acc wait(4)
    }

    real_t temp;
    for (int x = 0; x < n; ++x){
        temp = a_host[x] + b[x] + d_host[x] + e[x] + g_host[x] + h[x];
        temp += b[x] * (a_host[x] + b[x]) + e[x] * (d_host[x] + e[x]) + h[x] * (g_host[x] + h[x]);
        if (fabs(k[x] - temp) > PRECISION * 10){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_wait_any.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,async,wait,V:3.2-3.3
int test1() {

    int err = 0;
    srand(SEED);

    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));


    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = (a[x] + 1) * 2 + (b[x] + 1) * 2;
    }
    
    real_t *list[3] = {a, b, c};

    #pragma acc data copyin(list[0:3][0:n])
    {
        int queues[10];
        for (int i = 0; i < 2; i++)
        {
            // Do some unbalanced operation on several queues
            #pragma acc enter data copyin(list[i]) async(i)
            
            // Put the queue number in the queues list
            queues[i] = i;

            #pragma acc parallel loop async(i)
            for(int k = 0; k < n; k++) {
                list[i][k]++;
            }
        }
        int next;
        // Look for queue that is ready to process
        while ((next = acc_wait_any(3, queues)) >= 0)
        {
            // Remove this queue from consideration next time around
            queues[next] = acc_async_sync;
            
            // Process work dependent on above
            #pragma acc kernels
            {
                for(int i = 0; i < n; i++)
                {
                    list[next][i] = list[next][i] * 2;
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_wait_any.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,async,wait,V:3.2-3.3
int test1() {

    int err = 0;
    srand(SEED);

    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];


    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = (a[x] + 1) * 2 + (b[x] + 1) * 2;
    }
    
    real_t *list[3] = {a, b, c};

    #pragma acc data copyin(list[0:3][0:n])
    {
        int queues[10];
        for (int i = 0; i < 2; i++)
        {
            // Do some unbalanced operation on several queues
            #pragma acc enter data copyin(list[i]) async(i)
            
            // Put the queue number in the queues list
            queues[i] = i;

            #pragma acc parallel loop async(i)
            for(int k = 0; k < n; k++) {
                list[i][k]++;
            }
        }
        int next;
        // Look for queue that is ready to process
        while ((next = acc_wait_any(3, queues)) >= 0)
        {
            // Remove this queue from consideration next time around
            queues[next] = acc_async_sync;
            
            // Process work dependent on above
            #pragma acc kernels
            {
                for(int i = 0; i < n; i++)
                {
                    list[next][i] = list[next][i] * 2;
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_wait_async.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,async,construct-independent,wait,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *d = (real_t *)malloc(n * sizeof(real_t));
    real_t *e = (real_t *)malloc(n * sizeof(real_t));
    real_t *f = (real_t *)malloc(n * sizeof(real_t));
    real_t *g = (real_t *)malloc(n * sizeof(real_t));
    real_t *h = (real_t *)malloc(n * sizeof(real_t));
    real_t *i = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = rand() / (real_t)(RAND_MAX / 10);
        f[x] = 0;
        g[x] = rand() / (real_t)(RAND_MAX / 10);
        h[x] = 0;
        i[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n], g[0:n]) create(c[0:n], f[0:n], h[0:n]) copyout(i[0:n])
    {
        #pragma acc parallel async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        acc_wait_async(1, 2);
        #pragma acc parallel async(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                h[x] = c[x] + g[x];
            }
        }
        #pragma acc parallel async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                f[x] = d[x] + e[x];
            }
        }
        acc_wait_async(1, 2);
        #pragma acc parallel async(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                i[x] = h[x] + f[x];
            }
        }
        #pragma acc wait(2)
    }

    for (int x = 0; x < n; ++x){
        if (fabs(i[x] - (a[x] + b[x] + g[x] + d[x] + e[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
acc_wait_async.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,async,construct-independent,wait,V:2.0-2.7
int test1(){
    int err = 0;
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *d = new real_t[n];
    real_t *e = new real_t[n];
    real_t *f = new real_t[n];
    real_t *g = new real_t[n];
    real_t *h = new real_t[n];
    real_t *i = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = rand() / (real_t)(RAND_MAX / 10);
        f[x] = 0;
        g[x] = rand() / (real_t)(RAND_MAX / 10);
        h[x] = 0;
        i[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n], g[0:n]) create(c[0:n], f[0:n], h[0:n]) copyout(i[0:n])
    {
        #pragma acc parallel async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        acc_wait_async(1, 2);
        #pragma acc parallel async(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                h[x] = c[x] + g[x];
            }
        }
        #pragma acc parallel async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                f[x] = d[x] + e[x];
            }
        }
        acc_wait_async(1, 2);
        #pragma acc parallel async(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                i[x] = h[x] + f[x];
            }
        }
        #pragma acc wait(2)
    }

    for (int x = 0; x < n; ++x){
        if (fabs(i[x] - (a[x] + b[x] + g[x] + d[x] + e[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_bitand_equals.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] &= a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] &= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_bitand_equals.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] &= a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] &= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_bitor_equals.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] |= a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] |= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_bitor_equals.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] |= a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] |= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_bitxor_equals.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .5){
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] ^= a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] ^= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_bitxor_equals.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .5){
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] ^= a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] ^= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_bitand_equals.c:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = (int *)malloc((length - 1) * sizeof(int));
    int *passed_b = (int *)malloc((length - 1) * sizeof(int));
    for (int x = 0; x < length; x++){
        if (b[x] == (a[x] & prev)){
            for (int y = 0; y < x; y++){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; y++){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = (int *)malloc(n * sizeof(int));
    int *b = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));
    int *temp_a = (int *)malloc(10 * sizeof(int));
    int *temp_b = (int *)malloc(10 * sizeof(int));
    int iterator;
    int iterator2;
    int init = 0;

    for (int x = 0; x < n; x++){
        a[x] = 0;
        for (int y = 0; y < 8; y++){
            
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; x++){
	    totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; y++){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }
    for (int x = 0; x < n; x++){
        b[x] = 0;
        for (int y = 0; y < 8; y++){
            b[x] += 1<<y;
        }
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; x++){
                #pragma acc atomic capture
                    b[x] = totals[x%(n/10 + 1)] &= a[x];
            }
        }
    }
    for (int x = 0; x < n; x++){
        totals_comparison[x%(n/10 + 1)] &= a[x];
    }
    for (int x = 0; x < (n/10 + 1); x++){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < 8; x++){
        init += 1<<x;
    }
    for (int x = 0; x < (n/10 + 1); x++){
        for (iterator = x, iterator2 = 0; iterator < n; iterator += n/10 + 1, iterator2++){
            temp_a[iterator2] = a[iterator];
            temp_b[iterator2] = b[iterator];
        }
        if (!is_possible(temp_a, temp_b, iterator2, init)){
            err += 1;
        }
    }
    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; x++){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_bitand_equals.cpp:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = new int[(length - 1)];
    int *passed_b = new int[(length - 1)];
    for (int x = 0; x < length; x++){
        if (b[x] == (a[x] & prev)){
            for (int y = 0; y < x; y++){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; y++){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = new int[n];
    int *b = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];
    int *temp_a = new int[10];
    int *temp_b = new int[10];
    int iterator;
    int iterator2;
    int init = 0;

    for (int x = 0; x < n; x++){
        a[x] = 0;
        for (int y = 0; y < 8; y++){
            
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; x++){
	    totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; y++){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }
    for (int x = 0; x < n; x++){
        b[x] = 0;
        for (int y = 0; y < 8; y++){
            b[x] += 1<<y;
        }
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; x++){
                #pragma acc atomic capture
                    b[x] = totals[x%(n/10 + 1)] &= a[x];
            }
        }
    }
    for (int x = 0; x < n; x++){
        totals_comparison[x%(n/10 + 1)] &= a[x];
    }
    for (int x = 0; x < (n/10 + 1); x++){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < 8; x++){
        init += 1<<x;
    }
    for (int x = 0; x < (n/10 + 1); x++){
        for (iterator = x, iterator2 = 0; iterator < n; iterator += n/10 + 1, iterator2++){
            temp_a[iterator2] = a[iterator];
            temp_b[iterator2] = b[iterator];
        }
        if (!is_possible(temp_a, temp_b, iterator2, init)){
            err += 1;
        }
    }
    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; x++){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_bitor_equals.c:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = (int *)malloc((length - 1) * sizeof(int));
    int *passed_b = (int *)malloc((length - 1) * sizeof(int));
    for (int x = 0; x < length; ++x){
        if (b[x] == (a[x]|prev)){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = (int *)malloc(n * sizeof(int));
    int *b = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));
    int *temp_a = (int *)malloc(10 * sizeof(int));
    int *temp_b = (int *)malloc(10 * sizeof(int));
    int temp_indexer = 0;
    int absolute_indexer = 0;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    b[x] = totals[x%(n/10 + 1)] |= a[x];
            }
        }
    }
    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] |= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < (n/10 + 1); ++x){
        for (absolute_indexer = x, temp_indexer = 0; absolute_indexer < n; absolute_indexer += n/10 + 1, temp_indexer++){
            temp_a[temp_indexer] = a[absolute_indexer];
            temp_b[temp_indexer] = b[absolute_indexer];
        }
        if (!(is_possible(temp_a, temp_b, temp_indexer, 0))){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_bitor_equals.cpp:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = new int[(length - 1)];
    int *passed_b = new int[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (b[x] == (a[x]|prev)){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = new int[n];
    int *b = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];
    int *temp_a = new int[10];
    int *temp_b = new int[10];
    int temp_indexer = 0;
    int absolute_indexer = 0;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    b[x] = totals[x%(n/10 + 1)] |= a[x];
            }
        }
    }
    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] |= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < (n/10 + 1); ++x){
        for (absolute_indexer = x, temp_indexer = 0; absolute_indexer < n; absolute_indexer += n/10 + 1, temp_indexer++){
            temp_a[temp_indexer] = a[absolute_indexer];
            temp_b[temp_indexer] = b[absolute_indexer];
        }
        if (!(is_possible(temp_a, temp_b, temp_indexer, 0))){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_bitxor_equals.c:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = (int *)malloc((length - 1) * sizeof(int));
    int *passed_b = (int *)malloc((length - 1) * sizeof(int));
    for (int x = 0; x < length; ++x){
        if (b[x] == (a[x] ^ prev)){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = (int *)malloc(n * sizeof(int));
    int *b = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));
    int * temp_a = (int *)malloc(10 * sizeof(int));
    int * temp_b = (int *)malloc(10 * sizeof(int));
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .5){
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    b[x] = totals[x%(n/10 + 1)] ^= a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] ^= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (temp_iterator = 0, ab_iterator = x; ab_iterator < n; temp_iterator++, ab_iterator += n/10 + 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!(is_possible(temp_a, temp_b, temp_iterator, 0))){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_bitxor_equals.cpp:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = new int[(length - 1)];
    int *passed_b = new int[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (b[x] == (a[x] ^ prev)){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = new int[n];
    int *b = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];
    int * temp_a = new int[10];
    int * temp_b = new int[10];
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .5){
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    b[x] = totals[x%(n/10 + 1)] ^= a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] ^= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (temp_iterator = 0, ab_iterator = x; ab_iterator < n; temp_iterator++, ab_iterator += n/10 + 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!(is_possible(temp_a, temp_b, temp_iterator, 0))){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_divided_equals.c:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, real_t* c, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_c = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(c[x] - (prev / (a[x] + b[x]))) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
                passed_c[y] = c[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
                passed_c[y - 1] = c[y];
            }
            if (is_possible(passed_a, passed_b, passed_c, length - 1, c[x])){
                free(passed_a);
                free(passed_b);
                free(passed_c);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    free(passed_c);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));
    real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));
    real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    c[x] = totals[x%(n/10 + 1)] /= (a[x] + b[x]);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < (n/10 + 1); ++x){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n;  ab_iterator+=((n/10) + 1)){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
            temp_c[temp_iterator] = c[ab_iterator];
            temp_iterator++;
        }
        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_divided_equals.cpp:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, real_t* c, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    real_t *passed_c = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(c[x] - (prev / (a[x] + b[x]))) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
                passed_c[y] = c[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
                passed_c[y - 1] = c[y];
            }
            if (is_possible(passed_a, passed_b, passed_c, length - 1, c[x])){
                delete[] passed_a;
                delete[] passed_b;
                delete[] passed_c;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    delete[] passed_c;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];
    real_t *temp_a = new real_t[10];
    real_t *temp_b = new real_t[10];
    real_t *temp_c = new real_t[10];
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    c[x] = totals[x%(n/10 + 1)] /= (a[x] + b[x]);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < (n/10 + 1); ++x){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n;  ab_iterator+=((n/10) + 1)){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
            temp_c[temp_iterator] = c[ab_iterator];
            temp_iterator++;
        }
        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_expr_bitand_x.c:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = (int *)malloc((length - 1) * sizeof(int));
    int *passed_b = (int *)malloc((length - 1) * sizeof(int));
    for (int x = 0; x < length; ++x){
        if (b[x] == (a[x] & prev)){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = (int *)malloc(n * sizeof(int));
    int *b = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));
    int *passed_a = (int *)malloc(10 * sizeof(int));
    int *passed_b = (int *)malloc(10 * sizeof(int));
    int passed_total = 0;
    int absolute_indexer;
    int passed_indexer;

    for (int x = 0; x < n; ++x){
	for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
	for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                     b[x] = totals[x%(n/10 + 1)] = a[x] & totals[x%(n/10 + 1)];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] &= a[x];
    }

    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < 8; ++x){
        passed_total += 1<<x;
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        for (absolute_indexer = x, passed_indexer = 0; absolute_indexer < n; absolute_indexer += (n/10 + 1), passed_indexer++){
            passed_a[passed_indexer] = a[absolute_indexer];
            passed_b[passed_indexer] = b[absolute_indexer];
        }
        if (!is_possible(passed_a, passed_b, passed_indexer, passed_total)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_expr_bitand_x.cpp:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = new int[(length - 1)];
    int *passed_b = new int[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (b[x] == (a[x] & prev)){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = new int[n];
    int *b = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];
    int *passed_a = new int[10];
    int *passed_b = new int[10];
    int passed_total = 0;
    int absolute_indexer;
    int passed_indexer;

    for (int x = 0; x < n; ++x){
	for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
	for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                     b[x] = totals[x%(n/10 + 1)] = a[x] & totals[x%(n/10 + 1)];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] &= a[x];
    }

    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < 8; ++x){
        passed_total += 1<<x;
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        for (absolute_indexer = x, passed_indexer = 0; absolute_indexer < n; absolute_indexer += (n/10 + 1), passed_indexer++){
            passed_a[passed_indexer] = a[absolute_indexer];
            passed_b[passed_indexer] = b[absolute_indexer];
        }
        if (!is_possible(passed_a, passed_b, passed_indexer, passed_total)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_expr_bitor_x.c:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = (int *)malloc((length - 1) * sizeof(int));
    int *passed_b = (int *)malloc((length - 1) * sizeof(int));
    for (int x = 0; x < length; ++x){
        if (b[x] == (a[x]|prev)){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = (int *)malloc(n * sizeof(int));
    int *b = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));
    int *passed_a = (int *)malloc(10 * sizeof(int));
    int *passed_b = (int *)malloc(10 * sizeof(int));
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
	a[x] = 0;
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
	totals_comparison[x] = 0;

    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1], b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    b[x] = totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] |= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){
            passed_a[passed_indexer] = a[absolute_indexer];
            passed_b[passed_indexer] = b[absolute_indexer];
        }
        if (!is_possible(passed_a, passed_b, passed_indexer, 0)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_expr_bitor_x.cpp:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = new int[(length - 1)];
    int *passed_b = new int[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (b[x] == (a[x]|prev)){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = new int[n];
    int *b = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];
    int *passed_a = new int[10];
    int *passed_b = new int[10];
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
	a[x] = 0;
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
	totals_comparison[x] = 0;

    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1], b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    b[x] = totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] |= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){
            passed_a[passed_indexer] = a[absolute_indexer];
            passed_b[passed_indexer] = b[absolute_indexer];
        }
        if (!is_possible(passed_a, passed_b, passed_indexer, 0)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_expr_bitxor_x.c:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = (int *)malloc((length - 1) * sizeof(int));
    int *passed_b = (int *)malloc((length - 1) * sizeof(int));
    for (int x = 0; x < length; ++x){
        if (b[x] == (a[x]^prev)){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = (int *)malloc(n * sizeof(int));
    int *b = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));
    int *passed_a = (int *)malloc(10 * sizeof(int));
    int *passed_b = (int *)malloc(10 * sizeof(int));
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .5){
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    b[x] = totals[x%(n/10 + 1)] = a[x] ^ totals[x%(n/10 + 1)];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] ^= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){
            passed_a[passed_indexer] = a[absolute_indexer];
            passed_b[passed_indexer] = b[absolute_indexer];
        }
        if (!(is_possible(passed_a, passed_b, passed_indexer, 0))){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_expr_bitxor_x.cpp:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = new int[(length - 1)];
    int *passed_b = new int[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (b[x] == (a[x]^prev)){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = new int[n];
    int *b = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];
    int *passed_a = new int[10];
    int *passed_b = new int[10];
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .5){
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    b[x] = totals[x%(n/10 + 1)] = a[x] ^ totals[x%(n/10 + 1)];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] ^= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){
            passed_a[passed_indexer] = a[absolute_indexer];
            passed_b[passed_indexer] = b[absolute_indexer];
        }
        if (!(is_possible(passed_a, passed_b, passed_indexer, 0))){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_expr_divided_x.c:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (a[x]/prev)) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

bool possible_result(real_t * remaining_combinations, int length, real_t current_value, real_t test_value){
    if (length == 0){
        if (fabs(current_value - test_value) > PRECISION){
            return true;
        }
        else {
            return false;
        }
    }
    real_t * passed = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        for (int y = 0; y < x; ++y){
            passed[y] = remaining_combinations[y];
        }
        for (int y = x + 1; y < length; ++y){
            passed[y - 1] = remaining_combinations[y];
        }
        if (possible_result(passed, length - 1, remaining_combinations[x] / current_value, test_value)){
            free(passed);
            return true;
        }
    }
    free(passed);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));
    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));
    int passed_indexer;
    int absolute_indexer;
    real_t * passed = (real_t *)malloc(10 * sizeof(real_t));
    int indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    c[x] = totals[x%(n/10 + 1)] = (a[x] + b[x]) / totals[x%(n/10 + 1)];
            }
        }
    }


    for (int x = 0; x < (n/10 + 1); ++x){
        indexer = x;
        while (indexer < n){
            passed[indexer/(n/10 + 1)] = (a[x] + b[x]);
            indexer += (n/10 + 1);
        }
        if (!(possible_result(passed, 10, 1, totals[x]))){
            err += 1;
        }
    }

    for (int x = 0; x < (n/10 + 1); ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_expr_divided_x.cpp:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (a[x]/prev)) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

bool possible_result(real_t * remaining_combinations, int length, real_t current_value, real_t test_value){
    if (length == 0){
        if (fabs(current_value - test_value) > PRECISION){
            return true;
        }
        else {
            return false;
        }
    }
    real_t * passed = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        for (int y = 0; y < x; ++y){
            passed[y] = remaining_combinations[y];
        }
        for (int y = x + 1; y < length; ++y){
            passed[y - 1] = remaining_combinations[y];
        }
        if (possible_result(passed, length - 1, remaining_combinations[x] / current_value, test_value)){
            delete[] passed;
            return true;
        }
    }
    delete[] passed;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *passed_ab = new real_t[10];
    real_t *passed_c = new real_t[10];
    int passed_indexer;
    int absolute_indexer;
    real_t * passed = new real_t[10];
    int indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    c[x] = totals[x%(n/10 + 1)] = (a[x] + b[x]) / totals[x%(n/10 + 1)];
            }
        }
    }


    for (int x = 0; x < (n/10 + 1); ++x){
        indexer = x;
        while (indexer < n){
            passed[indexer/(n/10 + 1)] = (a[x] + b[x]);
            indexer += (n/10 + 1);
        }
        if (!(possible_result(passed, 10, 1, totals[x]))){
            err += 1;
        }
    }

    for (int x = 0; x < (n/10 + 1); ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_expr_lshift_x.c:::
#include "acc_testsuite.h"
bool is_possible(unsigned int* a, unsigned int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    unsigned int *passed_a = (unsigned int *)malloc((length - 1) * sizeof(int));
    unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(int));
    for (int x = 0; x < length; ++x){
        if (b[x] == (a[x]<<prev)){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *c = (unsigned int *)malloc(3 * n * sizeof(int));
    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};
    int result;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 3; ++y){
            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));
        }
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n]) copyout(c[0:3*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 3; ++y){
                    #pragma acc atomic capture
                        c[x * 3 + y] = b[x] = a[x * 3 + y] << b[x];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 6; ++y){
            result = 0;
            for (int z = 0; z < 3; ++z){
                result = a[x * 3 + orders[y * 3 + z]] << result;
            }
            if (result == b[x]){
                break;
            }
        }
        if (result != b[x]){
            err += 1;
        }
    }

    for (int x = 0; x < n; ++x){
        if (!(is_possible(&(a[x*3]), &(c[x*3]), 3, 0))){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_expr_lshift_x.cpp:::
#include "acc_testsuite.h"
bool is_possible(unsigned int* a, unsigned int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    unsigned int *passed_a = (unsigned int *)malloc((length - 1) * sizeof(int));
    unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(int));
    for (int x = 0; x < length; ++x){
        if (b[x] == (a[x]<<prev)){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *c = (unsigned int *)malloc(3 * n * sizeof(int));
    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};
    int result;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 3; ++y){
            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));
        }
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n]) copyout(c[0:3*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 3; ++y){
                    #pragma acc atomic capture
                        c[x * 3 + y] = b[x] = a[x * 3 + y] << b[x];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 6; ++y){
            result = 0;
            for (int z = 0; z < 3; ++z){
                result = a[x * 3 + orders[y * 3 + z]] << result;
            }
            if (result == b[x]){
                break;
            }
        }
        if (result != b[x]){
            err += 1;
        }
    }

    for (int x = 0; x < n; ++x){
        if (!(is_possible(&(a[x*3]), &(c[x*3]), 3, 0))){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_expr_minus_x.c:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (a[x] - prev)) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}


bool possible_result(real_t * remaining_combinations, int length, real_t current_value, real_t test_value){
    if (length == 0){
        if (fabs(current_value - test_value) > PRECISION){
            return true;
        }
        else {
            return false;
        }
    }
    real_t * passed = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        for (int y = 0; y < x; ++y){
            passed[y] = remaining_combinations[y];
        }
        for (int y = x + 1; y < length; ++y){
            passed[y - 1] = remaining_combinations[y];
        }
        if (possible_result(passed, length - 1, remaining_combinations[x] - current_value, test_value)){
            free(passed);
            return true;
        }
    }
    free(passed);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc(((n/10) + 1) * sizeof(real_t));
    int indexer = 0;
    real_t * passed = (real_t *)malloc(10 * sizeof(real_t));
    real_t *passed_a = (real_t *)malloc(10 * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc(10 * sizeof(real_t));
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < (n/10) + 1; ++x){
        totals[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:(n/10) + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    b[x] = totals[x%((int) (n/10) + 1)] = a[x] - totals[x%((int) (n/10) + 1)];
            }
        }
    }
    for (int x = 0; x < (n/10) + 1; ++x){
        indexer = x;
        while (indexer < n){
            passed[indexer/((int) (n/10) + 1)] = a[indexer];
            indexer += (n/10) + 1;
        }
        if (!(possible_result(passed, 10, 0, totals[x]))){
            err += 1;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){
            passed_a[passed_indexer] = a[absolute_indexer];
            passed_b[passed_indexer] = b[absolute_indexer];
        }
        if (!is_possible(passed_a, passed_b, passed_indexer, 0)){
            err += 1;
        }
        break;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_expr_minus_x.cpp:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (a[x] - prev)) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}


bool possible_result(real_t * remaining_combinations, int length, real_t current_value, real_t test_value){
    if (length == 0){
        if (fabs(current_value - test_value) > PRECISION){
            return true;
        }
        else {
            return false;
        }
    }
    real_t * passed = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        for (int y = 0; y < x; ++y){
            passed[y] = remaining_combinations[y];
        }
        for (int y = x + 1; y < length; ++y){
            passed[y - 1] = remaining_combinations[y];
        }
        if (possible_result(passed, length - 1, remaining_combinations[x] - current_value, test_value)){
            delete[] passed;
            return true;
        }
    }
    delete[] passed;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *totals = new real_t[((n/10) + 1)];
    int indexer = 0;
    real_t * passed = new real_t[10];
    real_t *passed_a = new real_t[10];
    real_t *passed_b = new real_t[10];
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < (n/10) + 1; ++x){
        totals[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:(n/10) + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    b[x] = totals[x%((int) (n/10) + 1)] = a[x] - totals[x%((int) (n/10) + 1)];
            }
        }
    }
    for (int x = 0; x < (n/10) + 1; ++x){
        indexer = x;
        while (indexer < n){
            passed[indexer/((int) (n/10) + 1)] = a[indexer];
            indexer += (n/10) + 1;
        }
        if (!(possible_result(passed, 10, 0, totals[x]))){
            err += 1;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){
            passed_a[passed_indexer] = a[absolute_indexer];
            passed_b[passed_indexer] = b[absolute_indexer];
        }
        if (!is_possible(passed_a, passed_b, passed_indexer, 0)){
            err += 1;
        }
        break;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_expr_multiply_x.c:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (a[x] * prev)) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));
    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    c[x] = totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_expr_multiply_x.cpp:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (a[x] * prev)) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];
    real_t *passed_ab = new real_t[10];
    real_t *passed_c = new real_t[10];
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    c[x] = totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_expr_plus_x.c:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (a[x] + prev)) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((int)(n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((int)(n/10 + 1) * sizeof(real_t));
    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));
    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:11]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    c[x] = totals[x%((int)(n/10 + 1))] = (a[x] + b[x]) + totals[x%((int)(n/10 + 1))];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%((int)(n/10 + 1))] += (a[x] + b[x]);
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_expr_plus_x.cpp:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (a[x] + prev)) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *totals = new real_t[(int)(n/10 + 1)];
    real_t *totals_comparison = new real_t[(int)(n/10 + 1)];
    real_t *passed_ab = new real_t[10];
    real_t *passed_c = new real_t[10];
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:11]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    c[x] = totals[x%((int)(n/10 + 1))] = (a[x] + b[x]) + totals[x%((int)(n/10 + 1))];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%((int)(n/10 + 1))] += (a[x] + b[x]);
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_expr_rshift_x.c:::
#include "acc_testsuite.h"
bool is_possible(unsigned int* a, unsigned int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    unsigned int *passed_a = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));
    unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));
    for (int x = 0; x < length; ++x){
        if (b[x] == (a[x]>>prev)){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *c = (unsigned int *)malloc(3 * n * sizeof(int));
    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};
    int result;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 3; ++y){
            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));
        }
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n]) copyout(c[0:3*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop independent
                for (int y = 0; y < 3; ++y){
                    #pragma acc atomic capture
                        c[x * 3 + y] = b[x] = a[x * 3 + y] >> b[x];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 6; ++y){
            result = 0;
            for (int z = 0; z < 3; ++z){
                result = a[x * 3 + orders[y * 3 + z]] >> result;
            }
            if (result == b[x]){
                break;
            }
        }
        if (result != b[x]){
            err += 1;
        }
    }

    for (int x = 0; x < n; ++x){
        if (!is_possible(&(a[3*x]), &(c[3*x]), 3, 0)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_expr_rshift_x.cpp:::
#include "acc_testsuite.h"
bool is_possible(unsigned int* a, unsigned int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    unsigned int *passed_a = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));
    unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));
    for (int x = 0; x < length; ++x){
        if (b[x] == (a[x]>>prev)){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *c = (unsigned int *)malloc(3 * n * sizeof(int));
    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};
    int result;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 3; ++y){
            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));
        }
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n]) copyout(c[0:3*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop independent
                for (int y = 0; y < 3; ++y){
                    #pragma acc atomic capture
                        c[x * 3 + y] = b[x] = a[x * 3 + y] >> b[x];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 6; ++y){
            result = 0;
            for (int z = 0; z < 3; ++z){
                result = a[x * 3 + orders[y * 3 + z]] >> result;
            }
            if (result == b[x]){
                break;
            }
        }
        if (result != b[x]){
            err += 1;
        }
    }

    for (int x = 0; x < n; ++x){
        if (!is_possible(&(a[3*x]), &(c[3*x]), 3, 0)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_lshift_equals.c:::
#include "acc_testsuite.h"
bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){
    if (length == 0){
        return true;
    }
    unsigned int passed_a = 0;
    unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));
    for (int x = 0; x < length; ++x){
        if ((b[x] == prev<<1 && ((a>>x)%2)==1) || ((a>>x)%2==0 && b[x] == prev)){
            for (int y = 0; y < x; ++y){
                if ((a>>y)%2 == 1){
                    passed_a += 1<<y;
                }
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                if ((a>>y) % 2 == 1){
                    passed_a += 1<<(y - 1);
                }
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));
    unsigned int passed = 1;

    for (int x = 0; x < n; ++x){
        a[x] = 1;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(real_t) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    c[x * 7 + y] = a[x];
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic capture
                            c[x * 7 + y] = a[x] <<= 1;
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] >>= 1;
            }
        }
        if (a[x] != 1){
            err += 1;
        }
    }

    for (int x = 0; x < n; ++x){
        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_lshift_equals.cpp:::
#include "acc_testsuite.h"
bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){
    if (length == 0){
        return true;
    }
    unsigned int passed_a = 0;
    unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));
    for (int x = 0; x < length; ++x){
        if ((b[x] == prev<<1 && ((a>>x)%2)==1) || ((a>>x)%2==0 && b[x] == prev)){
            for (int y = 0; y < x; ++y){
                if ((a>>y)%2 == 1){
                    passed_a += 1<<y;
                }
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                if ((a>>y) % 2 == 1){
                    passed_a += 1<<(y - 1);
                }
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));
    unsigned int passed = 1;

    for (int x = 0; x < n; ++x){
        a[x] = 1;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(real_t) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    c[x * 7 + y] = a[x];
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic capture
                            c[x * 7 + y] = a[x] <<= 1;
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] >>= 1;
            }
        }
        if (a[x] != 1){
            err += 1;
        }
    }

    for (int x = 0; x < n; ++x){
        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_minus_equals.c:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (prev - a[x])) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));
    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));
    real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        totals[x] = 0;
	totals_host[x] = 0;

    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10], c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    c[x] = totals[x%10] -= (a[x] + b[x]);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_host[x] - totals[x]) > PRECISION){
            err += 1;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_minus_equals.cpp:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (prev - a[x])) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *totals = new real_t[10];
    real_t *totals_host = new real_t[10];
    real_t * passed_ab = new real_t[(n/10 + 1)];
    real_t * passed_c = new real_t[(n/10 + 1)];
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        totals[x] = 0;
	totals_host[x] = 0;

    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10], c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    c[x] = totals[x%10] -= (a[x] + b[x]);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_host[x] - totals[x]) > PRECISION){
            err += 1;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_multiply_equals.c:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (a[x] * prev)) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));
    real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    c[x] = totals[x%(n/10 + 1)] *= a[x] + b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_multiply_equals.cpp:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (a[x] * prev)) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];
    real_t * passed_ab = new real_t[10];
    real_t * passed_c = new real_t[10];
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    c[x] = totals[x%(n/10 + 1)] *= a[x] + b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_plus_equals.c:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (a[x] + prev)) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));
    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    c[x] = totals[x%(n/10 + 1)] += a[x] * b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];
    }
    for (int x = 0; x < n/10 + 1; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){
            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_plus_equals.cpp:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (a[x] + prev)) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];
    real_t *passed_ab = new real_t[10];
    real_t *passed_c = new real_t[10];
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    c[x] = totals[x%(n/10 + 1)] += a[x] * b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];
    }
    for (int x = 0; x < n/10 + 1; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){
            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_postdecrement.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    int *c = (int *)malloc(n * sizeof(int));
    int *distribution = (int *)malloc(10 * sizeof(int));
    int *distribution_comparison = (int *)malloc(10 * sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    c[x] = (distribution[(int) (a[x]*b[x]/10)])--;
            }
        }
    }

    for (int x = 0; x < n; ++x){
        distribution_comparison[(int) (a[x]*b[x]/10)]--;
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    bool found = false;
    for (int x = 0; x < 10; ++x){
        for (int y = 0; y > -distribution_comparison[x]; --y){
            for (int z = 0; z < n; ++z){
                if (y == c[z] && x == (int) (a[x] * b[x] / 10)){
                    found = true;
                    break;
                }
            }
            if (!found){
                err++;
            }
            found = false;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_postdecrement.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    int *c = new int[n];
    int *distribution = new int[10];
    int *distribution_comparison = new int[10];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    c[x] = (distribution[(int) (a[x]*b[x]/10)])--;
            }
        }
    }

    for (int x = 0; x < n; ++x){
        distribution_comparison[(int) (a[x]*b[x]/10)]--;
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    bool found = false;
    for (int x = 0; x < 10; ++x){
        for (int y = 0; y > -distribution_comparison[x]; --y){
            for (int z = 0; z < n; ++z){
                if (y == c[z] && x == (int) (a[x] * b[x] / 10)){
                    found = true;
                    break;
                }
            }
            if (!found){
                err++;
            }
            found = false;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_postincrement.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    int *c = (int *)malloc(n * sizeof(int));
    int *distribution = (int *)malloc(10 * sizeof(int));
    int *distribution_comparison = (int *)malloc(10 * sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    c[x] = distribution[(int) (a[x]*b[x]/10)]++;
            }
        }
    }

    for (int x = 0; x < n; ++x){
        distribution_comparison[(int) (a[x]*b[x]/10)]++;
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    bool found = false;
    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < distribution_comparison[x]; ++y){
            for (int z = 0; z < n; ++z){
                if (c[z] == y && (int) (a[z]*b[z]/10) == x){
                    found = true;
                    break;
                }
            }
            if (!found){
                err++;
            }
            found = false;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_postincrement.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    int *c = new int[n];
    int *distribution = new int[10];
    int *distribution_comparison = new int[10];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    c[x] = distribution[(int) (a[x]*b[x]/10)]++;
            }
        }
    }

    for (int x = 0; x < n; ++x){
        distribution_comparison[(int) (a[x]*b[x]/10)]++;
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    bool found = false;
    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < distribution_comparison[x]; ++y){
            for (int z = 0; z < n; ++z){
                if (c[z] == y && (int) (a[z]*b[z]/10) == x){
                    found = true;
                    break;
                }
            }
            if (!found){
                err++;
            }
            found = false;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_predecrement.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    int *c = (int *)malloc(n * sizeof(int));
    int *distribution = (int *)malloc(10 * sizeof(int));
    int *distribution_comparison = (int *)malloc(10 * sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    c[x] = --distribution[(int) (a[x]*b[x]/10)];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        distribution_comparison[(int) (a[x]*b[x]/10)]--;
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    bool found = false;
    for (int x = 0; x < 10; ++x){
        for (int y = 0; y > distribution[x]; --y){
            for (int z = 0; z < n; ++z){
                if (c[z] == y - 1 && x == (int) (a[z] * b[z] / 10)){
                    found = true;
                    break;
                }
            }
            if (!found){
                err++;
            }
            found = false;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_predecrement.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    int *c = new int[n];
    int *distribution = new int[10];
    int *distribution_comparison = new int[10];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    c[x] = --distribution[(int) (a[x]*b[x]/10)];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        distribution_comparison[(int) (a[x]*b[x]/10)]--;
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    bool found = false;
    for (int x = 0; x < 10; ++x){
        for (int y = 0; y > distribution[x]; --y){
            for (int z = 0; z < n; ++z){
                if (c[z] == y - 1 && x == (int) (a[z] * b[z] / 10)){
                    found = true;
                    break;
                }
            }
            if (!found){
                err++;
            }
            found = false;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_preincrement.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    int *c = (int *)malloc(n * sizeof(int));
    int *distribution = (int *)malloc(10 * sizeof(int));
    int *distribution_comparison = (int *)malloc(10 * sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    c[x] = ++distribution[(int) (a[x]*b[x]/10)];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        distribution_comparison[(int) (a[x]*b[x]/10)]++;
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    bool found = false;
    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < distribution[x]; ++y){
            for (int z = 0; z < n; ++z){
                if (c[z] == y + 1 && x == (int) (a[z] * b[z] / 10)){
                    found = true;
                    break;
                }
            }
            if (!found){
                err++;
            }
            found = false;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_preincrement.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    int *c = new int[n];
    int *distribution = new int[10];
    int *distribution_comparison = new int[10];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    c[x] = ++distribution[(int) (a[x]*b[x]/10)];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        distribution_comparison[(int) (a[x]*b[x]/10)]++;
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    bool found = false;
    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < distribution[x]; ++y){
            for (int z = 0; z < n; ++z){
                if (c[z] == y + 1 && x == (int) (a[z] * b[z] / 10)){
                    found = true;
                    break;
                }
            }
            if (!found){
                err++;
            }
            found = false;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_rshift_equals.c:::
#include "acc_testsuite.h"
bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){
    if (length == 0){
        return true;
    }
    unsigned int passed_a = 0;
    unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));
    for (int x = 0; x < length; ++x){
        if ((b[x] == prev>>1 && ((a>>x)%2)==1) || ((a>>x)%2==0 && b[x] == prev)){
            for (int y = 0; y < x; ++y){
                if ((a>>y)%2 == 1){
                    passed_a += 1<<y;
                }
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                if ((a>>y) % 2 == 1){
                    passed_a += 1<<(y - 1);
                }
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));
    unsigned int passed = 1<<8;

    for (int x = 0; x < n; ++x){
        a[x] = 1<<8;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(real_t) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    c[x * 7 + y] = a[x];
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic capture
                            c[x * 7 + y] = a[x] >>= 1;
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] <<= 1;
            }
        }
        if (a[x] != 1<<8){
            err += 1;
        }
    }

    for (int x = 0; x < n; ++x){
        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_capture_rshift_equals.cpp:::
#include "acc_testsuite.h"
bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){
    if (length == 0){
        return true;
    }
    unsigned int passed_a = 0;
    unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));
    for (int x = 0; x < length; ++x){
        if ((b[x] == prev>>1 && ((a>>x)%2)==1) || ((a>>x)%2==0 && b[x] == prev)){
            for (int y = 0; y < x; ++y){
                if ((a>>y)%2 == 1){
                    passed_a += 1<<y;
                }
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                if ((a>>y) % 2 == 1){
                    passed_a += 1<<(y - 1);
                }
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));
    unsigned int passed = 1<<8;

    for (int x = 0; x < n; ++x){
        a[x] = 1<<8;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(real_t) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    c[x * 7 + y] = a[x];
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic capture
                            c[x * 7 + y] = a[x] >>= 1;
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] <<= 1;
            }
        }
        if (a[x] != 1<<8){
            err += 1;
        }
    }

    for (int x = 0; x < n; ++x){
        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_divided_equals.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] /= (a[x] + b[x]);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_divided_equals.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] /= (a[x] + b[x]);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_expr_bitand_x.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] = a[x] & totals[x%(n/10 + 1)];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] &= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_expr_bitand_x.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] = a[x] & totals[x%(n/10 + 1)];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] &= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_expr_bitor_x.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] |= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_expr_bitor_x.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] |= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_expr_bitxor_x.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .5){
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] = a[x] ^ totals[x%(n/10 + 1)];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] ^= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_expr_bitxor_x.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .5){
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] = a[x] ^ totals[x%(n/10 + 1)];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] ^= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_expr_divided_x.c:::
#include "acc_testsuite.h"
bool possible_result(real_t * remaining_combinations, int length, real_t current_value, real_t test_value){
    if (length == 0){
        if (fabs(current_value - test_value) > PRECISION){
            return true;
        }
        else {
            return false;
        }
    }
    real_t * passed = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        for (int y = 0; y < x; ++y){
            passed[y] = remaining_combinations[y];
        }
        for (int y = x + 1; y < length; ++y){
            passed[y - 1] = remaining_combinations[y];
        }
        if (possible_result(passed, length - 1, remaining_combinations[x] / current_value, test_value)){
            free(passed);
            return true;
        }
    }
    free(passed);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t * passed = (real_t *)malloc(10 * sizeof(real_t));
    int indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] = (a[x] + b[x]) / totals[x%(n/10 + 1)];
            }
        }
    }


    for (int x = 0; x < (n/10 + 1); ++x){
        indexer = x;
        while (indexer < n){
            passed[indexer/(n/10 + 1)] = (a[x] + b[x]);
            indexer += (n/10 + 1);
        }
        if (!(possible_result(passed, 10, 1, totals[x]))){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_expr_divided_x.cpp:::
#include "acc_testsuite.h"
bool possible_result(real_t * remaining_combinations, int length, real_t current_value, real_t test_value){
    if (length == 0){
        if (fabs(current_value - test_value) > PRECISION){
            return true;
        }
        else {
            return false;
        }
    }
    real_t * passed = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        for (int y = 0; y < x; ++y){
            passed[y] = remaining_combinations[y];
        }
        for (int y = x + 1; y < length; ++y){
            passed[y - 1] = remaining_combinations[y];
        }
        if (possible_result(passed, length - 1, remaining_combinations[x] / current_value, test_value)){
            delete[] passed;
            return true;
        }
    }
    delete[] passed;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t * passed = new real_t[10];
    int indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] = (a[x] + b[x]) / totals[x%(n/10 + 1)];
            }
        }
    }


    for (int x = 0; x < (n/10 + 1); ++x){
        indexer = x;
        while (indexer < n){
            passed[indexer/(n/10 + 1)] = (a[x] + b[x]);
            indexer += (n/10 + 1);
        }
        if (!(possible_result(passed, 10, 1, totals[x]))){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_expr_lshift_x.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};
    int result;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 3; ++y){
            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));
        }
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 3; ++y){
                    #pragma acc atomic
                        b[x] = a[x * 3 + y] << b[x];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 6; ++y){
            result = 0;
            for (int z = 0; z < 3; ++z){
                result = a[x * 3 + orders[y * 3 + z]] << result;
            }
            if (result == b[x]){
                break;
            }
        }
        if (result != b[x]){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_expr_lshift_x.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};
    int result;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 3; ++y){
            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));
        }
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 3; ++y){
                    #pragma acc atomic
                        b[x] = a[x * 3 + y] << b[x];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 6; ++y){
            result = 0;
            for (int z = 0; z < 3; ++z){
                result = a[x * 3 + orders[y * 3 + z]] << result;
            }
            if (result == b[x]){
                break;
            }
        }
        if (result != b[x]){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_expr_minus_x.c:::
#include "acc_testsuite.h"
bool possible_result(real_t * remaining_combinations, int length, real_t current_value, real_t test_value){
    if (length == 0){
        if (fabs(current_value - test_value) > PRECISION){
            return true;
        }
        else {
            return false;
        }
    }
    real_t * passed = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        for (int y = 0; y < x; ++y){
            passed[y] = remaining_combinations[y];
        }
        for (int y = x + 1; y < length; ++y){
            passed[y - 1] = remaining_combinations[y];
        }
        if (possible_result(passed, length - 1, remaining_combinations[x] - current_value, test_value)){
            free(passed);
            return true;
        }
    }
    free(passed);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc(((n/10) + 1) * sizeof(real_t));
    int indexer = 0;
    real_t * passed = (real_t *)malloc(10 * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < (n/10) + 1; ++x){
        totals[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:(n/10) + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%((int) (n/10) + 1)] = a[x] - totals[x%((int) (n/10) + 1)];
            }
        }
    }
    for (int x = 0; x < (n/10) + 1; ++x){
        indexer = x;
        while (indexer < n){
            passed[indexer/((int) (n/10) + 1)] = a[indexer];
            indexer += (n/10) + 1;
        }
        if (!(possible_result(passed, 10, 0, totals[x]))){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_expr_minus_x.cpp:::
#include "acc_testsuite.h"
bool possible_result(real_t * remaining_combinations, int length, real_t current_value, real_t test_value){
    if (length == 0){
        if (fabs(current_value - test_value) > PRECISION){
            return true;
        }
        else {
            return false;
        }
    }
    real_t * passed = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        for (int y = 0; y < x; ++y){
            passed[y] = remaining_combinations[y];
        }
        for (int y = x + 1; y < length; ++y){
            passed[y - 1] = remaining_combinations[y];
        }
        if (possible_result(passed, length - 1, remaining_combinations[x] - current_value, test_value)){
            delete[] passed;
            return true;
        }
    }
    delete[] passed;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *totals = new real_t[((n/10) + 1)];
    int indexer = 0;
    real_t * passed = new real_t[10];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < (n/10) + 1; ++x){
        totals[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:(n/10) + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%((int) (n/10) + 1)] = a[x] - totals[x%((int) (n/10) + 1)];
            }
        }
    }
    for (int x = 0; x < (n/10) + 1; ++x){
        indexer = x;
        while (indexer < n){
            passed[indexer/((int) (n/10) + 1)] = a[indexer];
            indexer += (n/10) + 1;
        }
        if (!(possible_result(passed, 10, 0, totals[x]))){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_expr_multiply_x.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_expr_multiply_x.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_expr_plus_x.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc(10 * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < n; ++y){
                    #pragma acc atomic
                        totals[(int) ((a[x] + b[x])/2)] = a[x] * b[x] + totals[(int) ((a[x] + b[x])/2)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];
        }
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] -  totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_expr_plus_x.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *totals = new real_t[10];
    real_t *totals_comparison = new real_t[10];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < n; ++y){
                    #pragma acc atomic
                        totals[(int) ((a[x] + b[x])/2)] = a[x] * b[x] + totals[(int) ((a[x] + b[x])/2)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];
        }
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] -  totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_expr_rshift_x.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};
    int result;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 3; ++y){
            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));
        }
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop independent
                for (int y = 0; y < 3; ++y){
                    #pragma acc atomic
                        b[x] = a[x * 3 + y] >> b[x];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 6; ++y){
            result = 0;
            for (int z = 0; z < 3; ++z){
                result = a[x * 3 + orders[y * 3 + z]] >> result;
            }
            if (result == b[x]){
                break;
            }
        }
        if (result != b[x]){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_expr_rshift_x.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};
    int result;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 3; ++y){
            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));
        }
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop independent
                for (int y = 0; y < 3; ++y){
                    #pragma acc atomic
                        b[x] = a[x * 3 + y] >> b[x];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 6; ++y){
            result = 0;
            for (int z = 0; z < 3; ++z){
                result = a[x * 3 + orders[y * 3 + z]] >> result;
            }
            if (result == b[x]){
                break;
            }
        }
        if (result != b[x]){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_lshift_equals.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = 1;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(unsigned int) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic
                            a[x] <<= 1;
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] >>= 1;
            }
        }
        if (a[x] != 1){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_lshift_equals.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = 1;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(unsigned int) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic
                            a[x] <<= 1;
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] >>= 1;
            }
        }
        if (a[x] != 1){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_minus_equals.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));
    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        totals[x] = 0;
        totals_host[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%10] -= (a[x] + b[x]);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_host[x] - totals[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_minus_equals.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *totals = new real_t[10];
    real_t *totals_host = new real_t[10];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        totals[x] = 0;
        totals_host[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%10] -= (a[x] + b[x]);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_host[x] - totals[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_multiply_equals.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] *= a[x] + b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_multiply_equals.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] *= a[x] + b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_plus_equals.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] += a[x] * b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];
    }
    for (int x = 0; x < n/10 + 1; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > (n/10 + 1) * PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_plus_equals.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] += a[x] * b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];
    }
    for (int x = 0; x < n/10 + 1; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > (n/10 + 1) * PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_postdecrement.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    int *distribution = (int *)malloc(10 * sizeof(int));
    int *distribution_comparison = (int *)malloc(10 * sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    distribution[(int) (a[x] * b[x] / 10)]--;
            }
        }
    }

    for (int x = 0; x < n; ++x){
        distribution_comparison[(int) (a[x]*b[x]/10)]--;
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_postdecrement.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    int *distribution = new int[10];
    int *distribution_comparison = new int[10];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    distribution[(int) (a[x] * b[x] / 10)]--;
            }
        }
    }

    for (int x = 0; x < n; ++x){
        distribution_comparison[(int) (a[x]*b[x]/10)]--;
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_postincrement.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    int *distribution = (int *)malloc(10 * sizeof(int));
    int *distribution_comparison = (int *)malloc(10 * sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < n; ++y){
                    #pragma acc atomic
                        distribution[(int) (a[x]*b[y]/10)]++;
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            distribution_comparison[(int) (a[x]*b[y]/10)]++;
        }
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_postincrement.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    int *distribution = new int[10];
    int *distribution_comparison = new int[10];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < n; ++y){
                    #pragma acc atomic
                        distribution[(int) (a[x]*b[y]/10)]++;
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            distribution_comparison[(int) (a[x]*b[y]/10)]++;
        }
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_predecrement.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    int *distribution = (int *)malloc(10 * sizeof(int));
    int *distribution_comparison = (int *)malloc(10 * sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < n; ++y){
                    #pragma acc atomic
                        --distribution[(int) (a[x]*b[y]/10)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            distribution_comparison[(int) (a[x]*b[y]/10)]--;
        }
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_predecrement.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    int *distribution = new int[10];
    int *distribution_comparison = new int[10];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < n; ++y){
                    #pragma acc atomic
                        --distribution[(int) (a[x]*b[y]/10)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            distribution_comparison[(int) (a[x]*b[y]/10)]--;
        }
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_preincrement.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    int *distribution = (int *)malloc(10 * sizeof(int));
    int *distribution_comparison = (int *)malloc(10 * sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < n; ++y){
                    #pragma acc atomic
                        ++distribution[(int) (a[x]*b[y]/10)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            distribution_comparison[(int) (a[x]*b[y]/10)]++;
        }
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_preincrement.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    int *distribution = new int[10];
    int *distribution_comparison = new int[10];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < n; ++y){
                    #pragma acc atomic
                        ++distribution[(int) (a[x]*b[y]/10)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            distribution_comparison[(int) (a[x]*b[y]/10)]++;
        }
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_rshift_equals.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = 1<<7;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(unsigned int) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic
                            a[x] >>= 1;
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] <<= 1;
            }
        }
        if (a[x] != 1<<7){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_rshift_equals.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = 1<<7;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(unsigned int) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic
                            a[x] >>= 1;
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] <<= 1;
            }
        }
        if (a[x] != 1<<7){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_assign.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *b_copy = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        b_copy[x] = b[x];
    }

    #pragma acc data copyin(a[0:n]) copy(b[0:n]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = b[x];
                    b[x] = a[x];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (abs(c[x] - b_copy[x]) > PRECISION){
            err++;
        }
        if (abs(b[x] - a[x]) > PRECISION){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_assign.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *b_copy = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        b_copy[x] = b[x];
    }

    #pragma acc data copyin(a[0:n]) copy(b[0:n]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = b[x];
                    b[x] = a[x];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (abs(c[x] - b_copy[x]) > PRECISION){
            err++;
        }
        if (abs(b[x] - a[x]) > PRECISION){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_bitand_equals.c:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = (int *)malloc((length - 1) * sizeof(int));
    int *passed_b = (int *)malloc((length - 1) * sizeof(int));
    for (int x = 0; x < length; ++x){
        if (b[x] == prev){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, prev & a[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}
 
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = (int *)malloc(n * sizeof(int));
    int *b = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));
    int *temp_a = (int *)malloc(10 * sizeof(int));
    int *temp_b = (int *)malloc(10 * sizeof(int));
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        for (int y = 0; y < 8; ++y){
            totals[x] =  1<<y;
            totals_comparison[x] = 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        b[x] = totals[x/10];
                        totals[x/10] &= a[x];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] &= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_bitand_equals.cpp:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = new int[(length - 1)];
    int *passed_b = new int[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (b[x] == prev){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, prev & a[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}
 
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = new int[n];
    int *b = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];
    int *temp_a = new int[10];
    int *temp_b = new int[10];
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        for (int y = 0; y < 8; ++y){
            totals[x] =  1<<y;
            totals_comparison[x] = 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        b[x] = totals[x/10];
                        totals[x/10] &= a[x];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] &= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_bitor_equals.c:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = (int *)malloc((length - 1) * sizeof(int));
    int *passed_b = (int *)malloc((length - 1) * sizeof(int));
    for (int x = 0; x < length; ++x){
        if (b[x] == prev){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, prev | a[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = (int *)malloc(n * sizeof(int));
    int *b = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));
    int *temp_a = (int *)malloc(10 * sizeof(int));
    int *temp_b = (int *)malloc(10 * sizeof(int));
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        for (int y = 0; y < 8; ++y){
            totals[x] =  1<<y;
            totals_comparison[x] = 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        b[x] = totals[x/10];
                        totals[x/10] |= a[x];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] |= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_bitor_equals.cpp:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = new int[(length - 1)];
    int *passed_b = new int[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (b[x] == prev){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, prev | a[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = new int[n];
    int *b = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];
    int *temp_a = new int[10];
    int *temp_b = new int[10];
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        for (int y = 0; y < 8; ++y){
            totals[x] =  1<<y;
            totals_comparison[x] = 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        b[x] = totals[x/10];
                        totals[x/10] |= a[x];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] |= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_bitxor_equals.c:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = (int *)malloc((length - 1) * sizeof(int));
    int *passed_b = (int *)malloc((length - 1) * sizeof(int));
    for (int x = 0; x < length; ++x){
        if (b[x] == prev){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, prev ^ a[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = (int *)malloc(n * sizeof(int));
    int *b = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));
    int *temp_a = (int *)malloc(10 * sizeof(int));
    int *temp_b = (int *)malloc(10 * sizeof(int));
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        for (int y = 0; y < 8; ++y){
            totals[x] =  1<<y;
            totals_comparison[x] = 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        b[x] = totals[x/10];
                        totals[x/10] ^= a[x];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] ^= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_bitxor_equals.cpp:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = new int[(length - 1)];
    int *passed_b = new int[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (b[x] == prev){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, prev ^ a[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = new int[n];
    int *b = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];
    int *temp_a = new int[10];
    int *temp_b = new int[10];
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        for (int y = 0; y < 8; ++y){
            totals[x] =  1<<y;
            totals_comparison[x] = 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        b[x] = totals[x/10];
                        totals[x/10] ^= a[x];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] ^= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_divided_equals.c:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, real_t* c, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_c = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(c[x] - prev) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
                passed_c[y] = c[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
                passed_c[y - 1] = c[y];
            }
            if (is_possible(passed_a, passed_b, passed_c, length - 1, prev / (a[x] + b[x]))){
                free(passed_a);
                free(passed_b);
                free(passed_c);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    free(passed_c);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));
    real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));
    real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = totals[x/10];
                    totals[x/10] /= (a[x] + b[x]);
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] /= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
            temp_c[temp_iterator] = c[ab_iterator];
            temp_iterator++;
        }
        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_divided_equals.cpp:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, real_t* c, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    real_t *passed_c = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(c[x] - prev) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
                passed_c[y] = c[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
                passed_c[y - 1] = c[y];
            }
            if (is_possible(passed_a, passed_b, passed_c, length - 1, prev / (a[x] + b[x]))){
                delete[] passed_a;
                delete[] passed_b;
                delete[] passed_c;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    delete[] passed_c;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];
    real_t *temp_a = new real_t[10];
    real_t *temp_b = new real_t[10];
    real_t *temp_c = new real_t[10];
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = totals[x/10];
                    totals[x/10] /= (a[x] + b[x]);
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] /= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
            temp_c[temp_iterator] = c[ab_iterator];
            temp_iterator++;
        }
        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_expr_bitand_x.c:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = (int *)malloc((length - 1) * sizeof(int));
    int *passed_b = (int *)malloc((length - 1) * sizeof(int));
    for (int x = 0; x < length; ++x){
        if (b[x] == prev){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, prev & a[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = (int *)malloc(n * sizeof(int));
    int *b = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));
    int *temp_a = (int *)malloc(10 * sizeof(int));
    int *temp_b = (int *)malloc(10 * sizeof(int));
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        for (int y = 0; y < 8; ++y){
            totals[x] =  1<<y;
            totals_comparison[x] = 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        b[x] = totals[x/10];
                        totals[x/10] = a[x] & totals[x/10];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] &= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_expr_bitand_x.cpp:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = new int[(length - 1)];
    int *passed_b = new int[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (b[x] == prev){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, prev & a[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = new int[n];
    int *b = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];
    int *temp_a = new int[10];
    int *temp_b = new int[10];
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        for (int y = 0; y < 8; ++y){
            totals[x] =  1<<y;
            totals_comparison[x] = 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        b[x] = totals[x/10];
                        totals[x/10] = a[x] & totals[x/10];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] &= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_expr_bitor_x.c:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = (int *)malloc((length - 1) * sizeof(int));
    int *passed_b = (int *)malloc((length - 1) * sizeof(int));
    for (int x = 0; x < length; ++x){
        if (b[x] == prev){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, prev | a[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = (int *)malloc(n * sizeof(int));
    int *b = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));
    int *temp_a = (int *)malloc(10 * sizeof(int));
    int *temp_b = (int *)malloc(10 * sizeof(int));
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        for (int y = 0; y < 8; ++y){
            totals[x] =  1<<y;
            totals_comparison[x] = 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        b[x] = totals[x/10];
                        totals[x/10] = a[x] | totals[x/10];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] |= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_expr_bitor_x.cpp:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = new int[(length - 1)];
    int *passed_b = new int[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (b[x] == prev){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, prev | a[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = new int[n];
    int *b = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];
    int *temp_a = new int[10];
    int *temp_b = new int[10];
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        for (int y = 0; y < 8; ++y){
            totals[x] =  1<<y;
            totals_comparison[x] = 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        b[x] = totals[x/10];
                        totals[x/10] = a[x] | totals[x/10];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] |= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_expr_bitxor_x.c:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = (int *)malloc((length - 1) * sizeof(int));
    int *passed_b = (int *)malloc((length - 1) * sizeof(int));
    for (int x = 0; x < length; ++x){
        if (b[x] == prev){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, prev ^ a[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = (int *)malloc(n * sizeof(int));
    int *b = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));
    int *temp_a = (int *)malloc(10 * sizeof(int));
    int *temp_b = (int *)malloc(10 * sizeof(int));
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        for (int y = 0; y < 8; ++y){
            totals[x] =  1<<y;
            totals_comparison[x] = 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        b[x] = totals[x/10];
                        totals[x/10] = a[x] ^ totals[x/10];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] ^= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_expr_bitxor_x.cpp:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = new int[(length - 1)];
    int *passed_b = new int[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (b[x] == prev){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, prev ^ a[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = new int[n];
    int *b = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];
    int *temp_a = new int[10];
    int *temp_b = new int[10];
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        for (int y = 0; y < 8; ++y){
            totals[x] =  1<<y;
            totals_comparison[x] = 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        b[x] = totals[x/10];
                        totals[x/10] = a[x] ^ totals[x/10];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] ^= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_expr_divided_x.c:::
#include "acc_testsuite.h"
bool is_possible_2(real_t* a, real_t* b, int length, real_t prev, real_t destination){
    if (length == 0){
        return abs(prev - destination) < PRECISION;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        for (int y = 0; y < x; ++y){
            passed_a[y] = a[y];
            passed_b[y] = b[y];
        }
        for (int y = x + 1; y < length; ++y){
            passed_a[y - 1] = a[y];
            passed_b[y - 1] = b[y];
        }
        if (is_possible_2(passed_a, passed_b, length - 1, (a[x] + b[x]) / prev, destination)){
            free(passed_a);
            free(passed_b);
            return true;
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

bool is_possible(real_t* a, real_t* b, real_t* c, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_c = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(c[x] - prev) < 100*PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
                passed_c[y] = c[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
                passed_c[y - 1] = c[y];
            }
            if (is_possible(passed_a, passed_b, passed_c, length - 1, (a[x] + b[x]) / prev)){
                free(passed_a);
                free(passed_b);
                free(passed_c);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    free(passed_c);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t* passed_a = (real_t *)malloc(10 * sizeof(real_t));
    real_t* passed_b = (real_t *)malloc(10 * sizeof(real_t));
    real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));
    real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));
    real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = totals[x/10];
                    totals[x/10] = (a[x] + b[x]) / totals[x/10];
                }
            }
        }
    }

    for (int x = 0; x < n; x = x + 10){
        for (int y = 0; y < 10 && (x + y) < n; ++y){
            passed_a[y] = a[x + y];
            passed_b[y] = b[x + y];
        }
        if (!(is_possible_2(passed_a, passed_b, 10, 1, totals[x/10]))){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
            temp_c[temp_iterator] = c[ab_iterator];
            temp_iterator++;
        }
        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_expr_divided_x.cpp:::
#include "acc_testsuite.h"
bool is_possible_2(real_t* a, real_t* b, int length, real_t prev, real_t destination){
    if (length == 0){
        return abs(prev - destination) < PRECISION;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        for (int y = 0; y < x; ++y){
            passed_a[y] = a[y];
            passed_b[y] = b[y];
        }
        for (int y = x + 1; y < length; ++y){
            passed_a[y - 1] = a[y];
            passed_b[y - 1] = b[y];
        }
        if (is_possible_2(passed_a, passed_b, length - 1, (a[x] + b[x]) / prev, destination)){
            delete[] passed_a;
            delete[] passed_b;
            return true;
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

bool is_possible(real_t* a, real_t* b, real_t* c, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    real_t *passed_c = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(c[x] - prev) < 100*PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
                passed_c[y] = c[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
                passed_c[y - 1] = c[y];
            }
            if (is_possible(passed_a, passed_b, passed_c, length - 1, (a[x] + b[x]) / prev)){
                delete[] passed_a;
                delete[] passed_b;
                delete[] passed_c;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    delete[] passed_c;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t* passed_a = new real_t[10];
    real_t* passed_b = new real_t[10];
    real_t *temp_a = new real_t[10];
    real_t *temp_b = new real_t[10];
    real_t *temp_c = new real_t[10];
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = totals[x/10];
                    totals[x/10] = (a[x] + b[x]) / totals[x/10];
                }
            }
        }
    }

    for (int x = 0; x < n; x = x + 10){
        for (int y = 0; y < 10 && (x + y) < n; ++y){
            passed_a[y] = a[x + y];
            passed_b[y] = b[x + y];
        }
        if (!(is_possible_2(passed_a, passed_b, 10, 1, totals[x/10]))){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
            temp_c[temp_iterator] = c[ab_iterator];
            temp_iterator++;
        }
        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_expr_multiply_x.c:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - prev) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, a[x] * prev)){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));
    real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = totals[x%(n/10 + 1)];
                    totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_expr_multiply_x.cpp:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - prev) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, a[x] * prev)){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];
    real_t * passed_ab = new real_t[10];
    real_t * passed_c = new real_t[10];
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = totals[x%(n/10 + 1)];
                    totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_expr_plus_x.c:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - prev) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, a[x] + prev)){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));
    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = totals[x%(n/10 + 1)];
                    totals[x%(n/10 + 1)] = (a[x] * b[x]) + totals[x%(n/10 + 1)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];
    }
    for (int x = 0; x < n/10 + 1; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){
            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_expr_plus_x.cpp:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - prev) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, a[x] + prev)){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];
    real_t *passed_ab = new real_t[10];
    real_t *passed_c = new real_t[10];
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = totals[x%(n/10 + 1)];
                    totals[x%(n/10 + 1)] = (a[x] * b[x]) + totals[x%(n/10 + 1)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];
    }
    for (int x = 0; x < n/10 + 1; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){
            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_lshift_equals.c:::
#include "acc_testsuite.h"
bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){
    if (length == 0){
        return true;
    }
    unsigned int passed_a = 0;
    unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));
    for (int x = 0; x < length; ++x){
        if (b[x] == prev){
            for (int y = 0; y < x; ++y){
                if ((a>>y)%2 == 1){
                    passed_a += 1<<y;
                }
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                if ((a>>y) % 2 == 1){
                    passed_a += 1<<(y - 1);
                }
                passed_b[y - 1] = b[y];
            }
            if ((a>>x)%2 == 1){
                if (is_possible(passed_a, passed_b, length - 1, prev << 1)){
                    return true;
                }
            }
            else {
                if (is_possible(passed_a, passed_b, length - 1, prev)){
                    return true;
                }
            }
        }
    }
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));
    unsigned int passed = 1;

    for (int x = 0; x < n; ++x){
        a[x] = 1;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(real_t) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    c[x * 7 + y] = a[x];
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic capture
                        {
                            c[x * 7 + y] = a[x];
                            a[x] <<= 1;
                        }
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] >>= 1;
            }
        }
        if (a[x] != 1){
            err += 1;
        }
    }

    for (int x = 0; x < n; ++x){
        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_lshift_equals.cpp:::
#include "acc_testsuite.h"
bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){
    if (length == 0){
        return true;
    }
    unsigned int passed_a = 0;
    unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));
    for (int x = 0; x < length; ++x){
        if (b[x] == prev){
            for (int y = 0; y < x; ++y){
                if ((a>>y)%2 == 1){
                    passed_a += 1<<y;
                }
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                if ((a>>y) % 2 == 1){
                    passed_a += 1<<(y - 1);
                }
                passed_b[y - 1] = b[y];
            }
            if ((a>>x)%2 == 1){
                if (is_possible(passed_a, passed_b, length - 1, prev << 1)){
                    return true;
                }
            }
            else {
                if (is_possible(passed_a, passed_b, length - 1, prev)){
                    return true;
                }
            }
        }
    }
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));
    unsigned int passed = 1;

    for (int x = 0; x < n; ++x){
        a[x] = 1;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(real_t) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    c[x * 7 + y] = a[x];
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic capture
                        {
                            c[x * 7 + y] = a[x];
                            a[x] <<= 1;
                        }
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] >>= 1;
            }
        }
        if (a[x] != 1){
            err += 1;
        }
    }

    for (int x = 0; x < n; ++x){
        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_minus_equals.c:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - prev) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, prev - a[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));
    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));
    real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        totals[x] = 0;
	totals_host[x] =0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10], c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = totals[x%10];
                    totals[x%10] -= (a[x] + b[x]);
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_host[x] - totals[x]) > PRECISION){
            err += 1;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_minus_equals.cpp:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - prev) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, prev - a[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *totals = new real_t[10];
    real_t *totals_host = new real_t[10];
    real_t * passed_ab = new real_t[(n/10 + 1)];
    real_t * passed_c = new real_t[(n/10 + 1)];
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        totals[x] = 0;
	totals_host[x] =0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10], c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = totals[x%10];
                    totals[x%10] -= (a[x] + b[x]);
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_host[x] - totals[x]) > PRECISION){
            err += 1;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_multiply_equals.c:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - prev) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, a[x] * prev)){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));
    real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = totals[x%(n/10 + 1)];
                    totals[x%(n/10 + 1)] *= a[x] + b[x];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_multiply_equals.cpp:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - prev) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, a[x] * prev)){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];
    real_t * passed_ab = new real_t[10];
    real_t * passed_c = new real_t[10];
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = totals[x%(n/10 + 1)];
                    totals[x%(n/10 + 1)] *= a[x] + b[x];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_plus_equals.c:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - prev) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, a[x] + prev)){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));
    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = totals[x%(n/10 + 1)];
                    totals[x%(n/10 + 1)] += a[x] * b[x];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];
    }
    for (int x = 0; x < n/10 + 1; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){
            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_plus_equals.cpp:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - prev) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, a[x] + prev)){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];
    real_t *passed_ab = new real_t[10];
    real_t *passed_c = new real_t[10];
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = totals[x%(n/10 + 1)];
                    totals[x%(n/10 + 1)] += a[x] * b[x];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];
    }
    for (int x = 0; x < n/10 + 1; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){
            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_postdecrement.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    int *c = (int *)malloc(n * sizeof(int));
    int *distribution = (int *)malloc(10 * sizeof(int));
    int *distribution_comparison = (int *)malloc(10 * sizeof(int));
    bool found = false;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = distribution[(int) (a[x]*b[x]/10)];
                    (distribution[(int) (a[x]*b[x]/10)])--;
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        distribution_comparison[(int) (a[x]*b[x]/10)]--;
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y > -distribution_comparison[x]; --y){
            for (int z = 0; z < n; ++z){
                if (y == c[z] && x == (int) (a[x] * b[x] / 10)){
                    found = true;
                    break;
                }
            }
            if (!found){
                err++;
            }
            found = false;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_postdecrement.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    int *c = new int[n];
    int *distribution = new int[10];
    int *distribution_comparison = new int[10];
    bool found = false;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = distribution[(int) (a[x]*b[x]/10)];
                    (distribution[(int) (a[x]*b[x]/10)])--;
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        distribution_comparison[(int) (a[x]*b[x]/10)]--;
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y > -distribution_comparison[x]; --y){
            for (int z = 0; z < n; ++z){
                if (y == c[z] && x == (int) (a[x] * b[x] / 10)){
                    found = true;
                    break;
                }
            }
            if (!found){
                err++;
            }
            found = false;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_postincrement.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    int *c = (int *)malloc(n * sizeof(int));
    int *distribution = (int *)malloc(10 * sizeof(int));
    int *distribution_comparison = (int *)malloc(10 * sizeof(int));
    bool found = false;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = distribution[(int) (a[x]*b[x]/10)];
                    distribution[(int) (a[x]*b[x]/10)]++;
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        distribution_comparison[(int) (a[x]*b[x]/10)]++;
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < distribution_comparison[x]; ++y){
            for (int z = 0; z < n; ++z){
                if (c[z] == y && (int) (a[z]*b[z]/10) == x){
                    found = true;
                    break;
                }
            }
            if (!found){
                err++;
            }
            found = false;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_postincrement.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    int *c = new int[n];
    int *distribution = new int[10];
    int *distribution_comparison = new int[10];
    bool found = false;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = distribution[(int) (a[x]*b[x]/10)];
                    distribution[(int) (a[x]*b[x]/10)]++;
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        distribution_comparison[(int) (a[x]*b[x]/10)]++;
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < distribution_comparison[x]; ++y){
            for (int z = 0; z < n; ++z){
                if (c[z] == y && (int) (a[z]*b[z]/10) == x){
                    found = true;
                    break;
                }
            }
            if (!found){
                err++;
            }
            found = false;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_predecrement.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    int *c = (int *)malloc(n * sizeof(int));
    int *distribution = (int *)malloc(10 * sizeof(int));
    int *distribution_comparison = (int *)malloc(10 * sizeof(int));
    bool found = false;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = distribution[(int) (a[x]*b[x]/10)];
                    --distribution[(int) (a[x]*b[x]/10)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        distribution_comparison[(int) (a[x]*b[x]/10)]--;
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y > distribution[x]; --y){
            for (int z = 0; z < n; ++z){
                if (c[z] == y && x == (int) (a[z] * b[z] / 10)){
                    found = true;
                    break;
                }
            }
            if (!found){
                err++;
            }
            found = false;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_predecrement.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    int *c = new int[n];
    int *distribution = new int[10];
    int *distribution_comparison = new int[10];
    bool found = false;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = distribution[(int) (a[x]*b[x]/10)];
                    --distribution[(int) (a[x]*b[x]/10)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        distribution_comparison[(int) (a[x]*b[x]/10)]--;
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y > distribution[x]; --y){
            for (int z = 0; z < n; ++z){
                if (c[z] == y && x == (int) (a[z] * b[z] / 10)){
                    found = true;
                    break;
                }
            }
            if (!found){
                err++;
            }
            found = false;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_preincrement.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    int *c = (int *)malloc(n * sizeof(int));
    int *distribution = (int *)malloc(10 * sizeof(int));
    int *distribution_comparison = (int *)malloc(10 * sizeof(int));
    bool found = false;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = distribution[(int) (a[x]*b[x]/10)];
                    ++distribution[(int) (a[x]*b[x]/10)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        distribution_comparison[(int) (a[x]*b[x]/10)]++;
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < distribution[x]; ++y){
            for (int z = 0; z < n; ++z){
                if (c[z] == y && x == (int) (a[z] * b[z] / 10)){
                    found = true;
                    break;
                }
            }
            if (!found){
                err++;
            }
            found = false;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_preincrement.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    int *c = new int[n];
    int *distribution = new int[10];
    int *distribution_comparison = new int[10];
    bool found = false;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = distribution[(int) (a[x]*b[x]/10)];
                    ++distribution[(int) (a[x]*b[x]/10)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        distribution_comparison[(int) (a[x]*b[x]/10)]++;
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < distribution[x]; ++y){
            for (int z = 0; z < n; ++z){
                if (c[z] == y && x == (int) (a[z] * b[z] / 10)){
                    found = true;
                    break;
                }
            }
            if (!found){
                err++;
            }
            found = false;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_rshift_equals.c:::
#include "acc_testsuite.h"
bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){
    if (length == 0){
        return true;
    }
    unsigned int passed_a = 0;
    unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));
    for (int x = 0; x < length; ++x){
        if (b[x] == prev){
            for (int y = 0; y < x; ++y){
                if ((a>>y)%2 == 1){
                    passed_a += 1<<y;
                }
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                if ((a>>y) % 2 == 1){
                    passed_a += 1<<(y - 1);
                }
                passed_b[y - 1] = b[y];
            }
            if ((a >> x) % 2 == 1){
                if (is_possible(passed_a, passed_b, length - 1,prev >> 1)){
                    free(passed_b);
                    return true;
                }
            }
            else{
                if (is_possible(passed_a, passed_b, length - 1, prev)){
                    free(passed_b);
                    return true;
                }
            }
        }
    }
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));
    unsigned int passed = 1<<8;

    for (int x = 0; x < n; ++x){
        a[x] = 1<<8;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(real_t) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    c[x * 7 + y] = a[x];
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic capture
                        {
                            c[x * 7 + y] = a[x];
                            a[x] >>= 1;
                        }
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] <<= 1;
            }
        }
        if (a[x] != 1<<8){
            err += 1;
        }
    }

    for (int x = 0; x < n; ++x){
        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_rshift_equals.cpp:::
#include "acc_testsuite.h"
bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){
    if (length == 0){
        return true;
    }
    unsigned int passed_a = 0;
    unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));
    for (int x = 0; x < length; ++x){
        if (b[x] == prev){
            for (int y = 0; y < x; ++y){
                if ((a>>y)%2 == 1){
                    passed_a += 1<<y;
                }
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                if ((a>>y) % 2 == 1){
                    passed_a += 1<<(y - 1);
                }
                passed_b[y - 1] = b[y];
            }
            if ((a >> x) % 2 == 1){
                if (is_possible(passed_a, passed_b, length - 1,prev >> 1)){
                    delete[] passed_b;
                    return true;
                }
            }
            else{
                if (is_possible(passed_a, passed_b, length - 1, prev)){
                    delete[] passed_b;
                    return true;
                }
            }
        }
    }
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));
    unsigned int passed = 1<<8;

    for (int x = 0; x < n; ++x){
        a[x] = 1<<8;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(real_t) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    c[x * 7 + y] = a[x];
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic capture
                        {
                            c[x * 7 + y] = a[x];
                            a[x] >>= 1;
                        }
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] <<= 1;
            }
        }
        if (a[x] != 1<<8){
            err += 1;
        }
    }

    for (int x = 0; x < n; ++x){
        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_x_bitand_expr.c:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = (int *)malloc((length - 1) * sizeof(int));
    int *passed_b = (int *)malloc((length - 1) * sizeof(int));
    for (int x = 0; x < length; ++x){
        if (b[x] == prev){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, prev & a[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = (int *)malloc(n * sizeof(int));
    int *b = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));
    int *temp_a = (int *)malloc(10 * sizeof(int));
    int *temp_b = (int *)malloc(10 * sizeof(int));
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        b[x] = totals[x/10];
                        totals[x/10] = totals[x/10] & a[x];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] &= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_x_bitand_expr.cpp:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = new int[(length - 1)];
    int *passed_b = new int[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (b[x] == prev){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, prev & a[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = new int[n];
    int *b = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];
    int *temp_a = new int[10];
    int *temp_b = new int[10];
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        b[x] = totals[x/10];
                        totals[x/10] = totals[x/10] & a[x];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] &= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_x_bitor_expr.c:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = (int *)malloc((length - 1) * sizeof(int));
    int *passed_b = (int *)malloc((length - 1) * sizeof(int));
    for (int x = 0; x < length; ++x){
        if (b[x] == prev){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, prev | a[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = (int *)malloc(n * sizeof(int));
    int *b = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));
    int *temp_a = (int *)malloc(10 * sizeof(int));
    int *temp_b = (int *)malloc(10 * sizeof(int));
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        b[x] = totals[x/10];
                        totals[x/10] = totals[x/10] | a[x];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] |= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_x_bitor_expr.cpp:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = new int[(length - 1)];
    int *passed_b = new int[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (b[x] == prev){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, prev | a[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = new int[n];
    int *b = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];
    int *temp_a = new int[10];
    int *temp_b = new int[10];
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        b[x] = totals[x/10];
                        totals[x/10] = totals[x/10] | a[x];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] |= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_x_bitxor_expr.c:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = (int *)malloc((length - 1) * sizeof(int));
    int *passed_b = (int *)malloc((length - 1) * sizeof(int));
    for (int x = 0; x < length; ++x){
        if (b[x] == prev){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, prev ^ a[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = (int *)malloc(n * sizeof(int));
    int *b = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));
    int *temp_a = (int *)malloc(10 * sizeof(int));
    int *temp_b = (int *)malloc(10 * sizeof(int));
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        b[x] = totals[x/10];
                        totals[x/10] = totals[x/10] ^ a[x];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] ^= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_x_bitxor_expr.cpp:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = new int[(length - 1)];
    int *passed_b = new int[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (b[x] == prev){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, prev ^ a[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = new int[n];
    int *b = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];
    int *temp_a = new int[10];
    int *temp_b = new int[10];
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        b[x] = totals[x/10];
                        totals[x/10] = totals[x/10] ^ a[x];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] ^= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_x_divided_expr.c:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, real_t* c, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_c = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(c[x] - prev) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
                passed_c[y] = c[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
                passed_c[y - 1] = c[y];
            }
            if (is_possible(passed_a, passed_b, passed_c, length - 1, prev / (a[x] + b[x]))){
                free(passed_a);
                free(passed_b);
                free(passed_c);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    free(passed_c);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));
    real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));
    real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = totals[x/10];
                    totals[x/10] = totals[x/10] / (a[x] + b[x]);
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] /= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
            temp_c[temp_iterator] = c[ab_iterator];
            temp_iterator++;
        }
        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_x_divided_expr.cpp:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, real_t* c, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    real_t *passed_c = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(c[x] - prev) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
                passed_c[y] = c[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
                passed_c[y - 1] = c[y];
            }
            if (is_possible(passed_a, passed_b, passed_c, length - 1, prev / (a[x] + b[x]))){
                delete[] passed_a;
                delete[] passed_b;
                delete[] passed_c;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    delete[] passed_c;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];
    real_t *temp_a = new real_t[10];
    real_t *temp_b = new real_t[10];
    real_t *temp_c = new real_t[10];
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = totals[x/10];
                    totals[x/10] = totals[x/10] / (a[x] + b[x]);
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] /= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
            temp_c[temp_iterator] = c[ab_iterator];
            temp_iterator++;
        }
        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_x_lshift_expr.c:::
#include "acc_testsuite.h"
bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){
    if (length == 0){
        return true;
    }
    unsigned int passed_a = 0;
    unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));
    for (int x = 0; x < length; ++x){
        if (b[x] == prev){
            for (int y = 0; y < x; ++y){
                if ((a>>y)%2 == 1){
                    passed_a += 1<<y;
                }
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                if ((a>>y) % 2 == 1){
                    passed_a += 1<<(y - 1);
                }
                passed_b[y - 1] = b[y];
            }
            if ((a>>x)%2 == 1){
                if (is_possible(passed_a, passed_b, length - 1, prev << 1)){
                    return true;
                }
            }
            else {
                if (is_possible(passed_a, passed_b, length - 1, prev)){
                    return true;
                }
            }
        }
    }
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));
    unsigned int passed = 1;

    for (int x = 0; x < n; ++x){
        a[x] = 1;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(real_t) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    c[x * 7 + y] = a[x];
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic capture
                        {
                            c[x * 7 + y] = a[x];
                            a[x] = a[x] << 1;
                        }
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] >>= 1;
            }
        }
        if (a[x] != 1){
            err += 1;
        }
    }

    for (int x = 0; x < n; ++x){
        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_x_lshift_expr.cpp:::
#include "acc_testsuite.h"
bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){
    if (length == 0){
        return true;
    }
    unsigned int passed_a = 0;
    unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));
    for (int x = 0; x < length; ++x){
        if (b[x] == prev){
            for (int y = 0; y < x; ++y){
                if ((a>>y)%2 == 1){
                    passed_a += 1<<y;
                }
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                if ((a>>y) % 2 == 1){
                    passed_a += 1<<(y - 1);
                }
                passed_b[y - 1] = b[y];
            }
            if ((a>>x)%2 == 1){
                if (is_possible(passed_a, passed_b, length - 1, prev << 1)){
                    return true;
                }
            }
            else {
                if (is_possible(passed_a, passed_b, length - 1, prev)){
                    return true;
                }
            }
        }
    }
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));
    unsigned int passed = 1;

    for (int x = 0; x < n; ++x){
        a[x] = 1;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(real_t) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    c[x * 7 + y] = a[x];
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic capture
                        {
                            c[x * 7 + y] = a[x];
                            a[x] = a[x] << 1;
                        }
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] >>= 1;
            }
        }
        if (a[x] != 1){
            err += 1;
        }
    }

    for (int x = 0; x < n; ++x){
        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_x_minus_expr.c:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - prev) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, prev - a[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));
    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));
    real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        totals[x] = 0;
        totals_host[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10], c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = totals[x%10]; totals[x%10] = totals[x%10] - (a[x] + b[x]);
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_host[x] - totals[x]) > PRECISION){
            err += 1;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_x_minus_expr.cpp:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - prev) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, prev - a[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *totals = new real_t[10];
    real_t *totals_host = new real_t[10];
    real_t * passed_ab = new real_t[(n/10 + 1)];
    real_t * passed_c = new real_t[(n/10 + 1)];
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        totals[x] = 0;
        totals_host[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10], c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = totals[x%10]; totals[x%10] = totals[x%10] - (a[x] + b[x]);
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_host[x] - totals[x]) > PRECISION){
            err += 1;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_x_multiply_expr.c:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - prev) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, a[x] * prev)){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));
    real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = totals[x%(n/10 + 1)];
                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_x_multiply_expr.cpp:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - prev) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, a[x] * prev)){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];
    real_t * passed_ab = new real_t[10];
    real_t * passed_c = new real_t[10];
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = totals[x%(n/10 + 1)];
                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_x_plus_expr.c:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - prev) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, a[x] + prev)){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));
    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = totals[x%(n/10 + 1)];
                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] + (a[x] * b[x]);
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];
    }
    for (int x = 0; x < n/10 + 1; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){
            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_x_plus_expr.cpp:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - prev) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, a[x] + prev)){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];
    real_t *passed_ab = new real_t[10];
    real_t *passed_c = new real_t[10];
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    c[x] = totals[x%(n/10 + 1)];
                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] + (a[x] * b[x]);
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];
    }
    for (int x = 0; x < n/10 + 1; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){
            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_x_rshift_expr.c:::
#include "acc_testsuite.h"
bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){
    if (length == 0){
        return true;
    }
    unsigned int passed_a = 0;
    unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));
    for (int x = 0; x < length; ++x){
        if (b[x] == prev){
            for (int y = 0; y < x; ++y){
                if ((a>>y)%2 == 1){
                    passed_a += 1<<y;
                }
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                if ((a>>y) % 2 == 1){
                    passed_a += 1<<(y - 1);
                }
                passed_b[y - 1] = b[y];
            }
            if ((a >> x) % 2 == 1){
                if (is_possible(passed_a, passed_b, length - 1,prev >> 1)){
                    free(passed_b);
                    return true;
                }
            }
            else{
                if (is_possible(passed_a, passed_b, length - 1, prev)){
                    free(passed_b);
                    return true;
                }
            }
        }
    }
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));
    unsigned int passed = 1<<8;

    for (int x = 0; x < n; ++x){
        a[x] = 1<<8;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(real_t) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    c[x * 7 + y] = a[x];
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic capture
                        {
                            c[x * 7 + y] = a[x];
                            a[x] = a[x] >> 1;
                        }
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] <<= 1;
            }
        }
        if (a[x] != 1<<8){
            err += 1;
        }
    }

    for (int x = 0; x < n; ++x){
        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_assign_x_rshift_expr.cpp:::
#include "acc_testsuite.h"
bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){
    if (length == 0){
        return true;
    }
    unsigned int passed_a = 0;
    unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));
    for (int x = 0; x < length; ++x){
        if (b[x] == prev){
            for (int y = 0; y < x; ++y){
                if ((a>>y)%2 == 1){
                    passed_a += 1<<y;
                }
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                if ((a>>y) % 2 == 1){
                    passed_a += 1<<(y - 1);
                }
                passed_b[y - 1] = b[y];
            }
            if ((a >> x) % 2 == 1){
                if (is_possible(passed_a, passed_b, length - 1,prev >> 1)){
                    delete[] passed_b;
                    return true;
                }
            }
            else{
                if (is_possible(passed_a, passed_b, length - 1, prev)){
                    delete[] passed_b;
                    return true;
                }
            }
        }
    }
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));
    unsigned int passed = 1<<8;

    for (int x = 0; x < n; ++x){
        a[x] = 1<<8;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(real_t) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    c[x * 7 + y] = a[x];
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic capture
                        {
                            c[x * 7 + y] = a[x];
                            a[x] = a[x] >> 1;
                        }
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] <<= 1;
            }
        }
        if (a[x] != 1<<8){
            err += 1;
        }
    }

    for (int x = 0; x < n; ++x){
        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_bitand_equals_assign.c:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = (int *)malloc((length - 1) * sizeof(int));
    int *passed_b = (int *)malloc((length - 1) * sizeof(int));
    for (int x = 0; x < length; ++x){
        if (b[x] == (prev & a[x])){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = (int *)malloc(n * sizeof(int));
    int *b = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));
    int *temp_a = (int *)malloc(10 * sizeof(int));
    int *temp_b = (int *)malloc(10 * sizeof(int));
    int temp_iterator;
    int ab_iterator;


    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        totals[x/10] &= a[x];
                        b[x] = totals[x/10];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] &= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_bitand_equals_assign.cpp:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = new int[(length - 1)];
    int *passed_b = new int[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (b[x] == (prev & a[x])){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = new int[n];
    int *b = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];
    int *temp_a = new int[10];
    int *temp_b = new int[10];
    int temp_iterator;
    int ab_iterator;


    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        totals[x/10] &= a[x];
                        b[x] = totals[x/10];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] &= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_bitor_equals_assign.c:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = (int *)malloc((length - 1) * sizeof(int));
    int *passed_b = (int *)malloc((length - 1) * sizeof(int));
    for (int x = 0; x < length; ++x){
        if (b[x] == (prev | a[x])){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = (int *)malloc(n * sizeof(int));
    int *b = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));
    int *temp_a = (int *)malloc(10 * sizeof(int));
    int *temp_b = (int *)malloc(10 * sizeof(int));
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        totals[x/10] |= a[x];
                        b[x] = totals[x/10];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] |= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_bitor_equals_assign.cpp:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = new int[(length - 1)];
    int *passed_b = new int[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (b[x] == (prev | a[x])){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = new int[n];
    int *b = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];
    int *temp_a = new int[10];
    int *temp_b = new int[10];
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        totals[x/10] |= a[x];
                        b[x] = totals[x/10];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] |= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_bitxor_equals_assign.c:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = (int *)malloc((length - 1) * sizeof(int));
    int *passed_b = (int *)malloc((length - 1) * sizeof(int));
    for (int x = 0; x < length; ++x){
        if (b[x] == (prev ^ a[x])){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = (int *)malloc(n * sizeof(int));
    int *b = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));
    int *temp_a = (int *)malloc(10 * sizeof(int));
    int *temp_b = (int *)malloc(10 * sizeof(int));
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        totals[x/10] ^= a[x];
                        b[x] = totals[x/10];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] ^= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_bitxor_equals_assign.cpp:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = new int[(length - 1)];
    int *passed_b = new int[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (b[x] == (prev ^ a[x])){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = new int[n];
    int *b = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];
    int *temp_a = new int[10];
    int *temp_b = new int[10];
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        totals[x/10] ^= a[x];
                        b[x] = totals[x/10];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] ^= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_divided_equals_assign.c:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, real_t* c, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_c = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(c[x] - (prev / (a[x] + b[x]))) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
                passed_c[y] = c[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
                passed_c[y - 1] = c[y];
            }
            if (is_possible(passed_a, passed_b, passed_c, length - 1, c[x])){
                free(passed_a);
                free(passed_b);
                free(passed_c);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    free(passed_c);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));
    real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));
    real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
      #pragma acc parallel
      {
          #pragma acc loop
          for (int x = 0; x < n; ++x){
              #pragma acc atomic capture
              {
                  totals[x/10] /= (a[x] + b[x]);
                  c[x] = totals[x/10];
              }
          }
      }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] /= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
            temp_c[temp_iterator] = c[ab_iterator];
            temp_iterator++;
        }
        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_divided_equals_assign.cpp:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, real_t* c, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    real_t *passed_c = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(c[x] - (prev / (a[x] + b[x]))) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
                passed_c[y] = c[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
                passed_c[y - 1] = c[y];
            }
            if (is_possible(passed_a, passed_b, passed_c, length - 1, c[x])){
                delete[] passed_a;
                delete[] passed_b;
                delete[] passed_c;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    delete[] passed_c;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];
    real_t *temp_a = new real_t[10];
    real_t *temp_b = new real_t[10];
    real_t *temp_c = new real_t[10];
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
      #pragma acc parallel
      {
          #pragma acc loop
          for (int x = 0; x < n; ++x){
              #pragma acc atomic capture
              {
                  totals[x/10] /= (a[x] + b[x]);
                  c[x] = totals[x/10];
              }
          }
      }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] /= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
            temp_c[temp_iterator] = c[ab_iterator];
            temp_iterator++;
        }
        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_expr_bitand_x_assign.c:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = (int *)malloc((length - 1) * sizeof(int));
    int *passed_b = (int *)malloc((length - 1) * sizeof(int));
    for (int x = 0; x < length; ++x){
        if (b[x] == (prev & a[x])){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = (int *)malloc(n * sizeof(int));
    int *b = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));
    int *temp_a = (int *)malloc(10 * sizeof(int));
    int *temp_b = (int *)malloc(10 * sizeof(int));
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        totals[x/10] = a[x] & totals[x/10];
                        b[x] = totals[x/10];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] &= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_expr_bitand_x_assign.cpp:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = new int[(length - 1)];
    int *passed_b = new int[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (b[x] == (prev & a[x])){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = new int[n];
    int *b = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];
    int *temp_a = new int[10];
    int *temp_b = new int[10];
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        totals[x/10] = a[x] & totals[x/10];
                        b[x] = totals[x/10];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] &= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_expr_bitor_x_assign.c:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = (int *)malloc((length - 1) * sizeof(int));
    int *passed_b = (int *)malloc((length - 1) * sizeof(int));
    for (int x = 0; x < length; ++x){
        if (b[x] == (prev | a[x])){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = (int *)malloc(n * sizeof(int));
    int *b = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));
    int *temp_a = (int *)malloc(10 * sizeof(int));
    int *temp_b = (int *)malloc(10 * sizeof(int));
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        totals[x/10] = a[x] | totals[x/10];
                        b[x] = totals[x/10];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] |= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_expr_bitor_x_assign.cpp:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = new int[(length - 1)];
    int *passed_b = new int[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (b[x] == (prev | a[x])){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = new int[n];
    int *b = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];
    int *temp_a = new int[10];
    int *temp_b = new int[10];
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        totals[x/10] = a[x] | totals[x/10];
                        b[x] = totals[x/10];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] |= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_expr_bitxor_x_assign.c:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = (int *)malloc((length - 1) * sizeof(int));
    int *passed_b = (int *)malloc((length - 1) * sizeof(int));
    for (int x = 0; x < length; ++x){
        if (b[x] == (prev ^ a[x])){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = (int *)malloc(n * sizeof(int));
    int *b = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));
    int *temp_a = (int *)malloc(10 * sizeof(int));
    int *temp_b = (int *)malloc(10 * sizeof(int));
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        totals[x/10] = a[x] ^ totals[x/10];
                        b[x] = totals[x/10];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] ^= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_expr_bitxor_x_assign.cpp:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = new int[(length - 1)];
    int *passed_b = new int[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (b[x] == (prev ^ a[x])){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = new int[n];
    int *b = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];
    int *temp_a = new int[10];
    int *temp_b = new int[10];
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        totals[x/10] = a[x] ^ totals[x/10];
                        b[x] = totals[x/10];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] ^= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_expr_multiply_x_assign.c:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (a[x] * prev)) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));
    real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];
                    c[x] = totals[x%(n/10 + 1)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_expr_multiply_x_assign.cpp:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (a[x] * prev)) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];
    real_t * passed_ab = new real_t[10];
    real_t * passed_c = new real_t[10];
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];
                    c[x] = totals[x%(n/10 + 1)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_expr_plus_x_assign.c:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (a[x] + prev)) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));
    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    totals[x%(n/10 + 1)] = (a[x] * b[x]) + totals[x%(n/10 + 1)];
                    c[x] = totals[x%(n/10 + 1)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];
    }
    for (int x = 0; x < n/10 + 1; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){
            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_expr_plus_x_assign.cpp:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (a[x] + prev)) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];
    real_t *passed_ab = new real_t[10];
    real_t *passed_c = new real_t[10];
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    totals[x%(n/10 + 1)] = (a[x] * b[x]) + totals[x%(n/10 + 1)];
                    c[x] = totals[x%(n/10 + 1)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];
    }
    for (int x = 0; x < n/10 + 1; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){
            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_lshift_equals_assign.c:::
#include "acc_testsuite.h"
bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){
    if (length == 0){
        return true;
    }
    unsigned int passed_a = 0;
    unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));
    for (int x = 0; x < length; ++x){
        if ((b[x] == (prev << 1) && (a>>x)%2 == 1) || ((a>>x)%2==0 && b[x] == prev)){
            for (int y = 0; y < x; ++y){
                if ((a>>y)%2 == 1){
                    passed_a += 1<<y;
                }
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                if ((a>>y) % 2 == 1){
                    passed_a += 1<<(y - 1);
                }
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));
    unsigned int passed = 1;

    for (int x = 0; x < n; ++x){
        a[x] = 1;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(real_t) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    c[x * 7 + y] = a[x];
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic capture
                        {
                            a[x] <<= 1;
                            c[x * 7 + y] = a[x];
                        }
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] >>= 1;
            }
        }
        if (a[x] != 1){
            err += 1;
        }
    }

    for (int x = 0; x < n; ++x){
        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_lshift_equals_assign.cpp:::
#include "acc_testsuite.h"
bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){
    if (length == 0){
        return true;
    }
    unsigned int passed_a = 0;
    unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));
    for (int x = 0; x < length; ++x){
        if ((b[x] == (prev << 1) && (a>>x)%2 == 1) || ((a>>x)%2==0 && b[x] == prev)){
            for (int y = 0; y < x; ++y){
                if ((a>>y)%2 == 1){
                    passed_a += 1<<y;
                }
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                if ((a>>y) % 2 == 1){
                    passed_a += 1<<(y - 1);
                }
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));
    unsigned int passed = 1;

    for (int x = 0; x < n; ++x){
        a[x] = 1;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(real_t) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    c[x * 7 + y] = a[x];
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic capture
                        {
                            a[x] <<= 1;
                            c[x * 7 + y] = a[x];
                        }
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] >>= 1;
            }
        }
        if (a[x] != 1){
            err += 1;
        }
    }

    for (int x = 0; x < n; ++x){
        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_minus_equals_assign.c:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (prev - a[x])) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));
    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));
    real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        totals[x] = 0;
	totals_host[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10], c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    totals[x%10] -= (a[x] + b[x]);
                    c[x] = totals[x%10];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_host[x] - totals[x]) > PRECISION){
            err += 1;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_minus_equals_assign.cpp:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (prev - a[x])) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *totals = new real_t[10];
    real_t *totals_host = new real_t[10];
    real_t * passed_ab = new real_t[(n/10 + 1)];
    real_t * passed_c = new real_t[(n/10 + 1)];
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        totals[x] = 0;
	totals_host[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10], c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    totals[x%10] -= (a[x] + b[x]);
                    c[x] = totals[x%10];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_host[x] - totals[x]) > PRECISION){
            err += 1;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_multiply_equals_assign.c:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (a[x] * prev)) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));
    real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    totals[x%(n/10 + 1)] *= a[x] + b[x];
                    c[x] = totals[x%(n/10 + 1)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_multiply_equals_assign.cpp:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (a[x] * prev)) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];
    real_t * passed_ab = new real_t[10];
    real_t * passed_c = new real_t[10];
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    totals[x%(n/10 + 1)] *= a[x] + b[x];
                    c[x] = totals[x%(n/10 + 1)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_plus_equals_assign.c:::
#include "acc_testsuite.h"

bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (a[x] + prev)) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));
    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    totals[x%(n/10 + 1)] += a[x] * b[x];
                    c[x] = totals[x%(n/10 + 1)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];
    }
    for (int x = 0; x < n/10 + 1; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){
            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_plus_equals_assign.cpp:::
#include "acc_testsuite.h"

bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (a[x] + prev)) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];
    real_t *passed_ab = new real_t[10];
    real_t *passed_c = new real_t[10];
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    totals[x%(n/10 + 1)] += a[x] * b[x];
                    c[x] = totals[x%(n/10 + 1)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];
    }
    for (int x = 0; x < n/10 + 1; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){
            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_postdecrement_assign.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    int *c = (int *)malloc(n * sizeof(int));
    int *distribution = (int *)malloc(10 * sizeof(int));
    int *distribution_comparison = (int *)malloc(10 * sizeof(int));
    bool found = false;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    (distribution[(int) (a[x]*b[x]/10)])--;
                    c[x] = distribution[(int) (a[x]*b[x]/10)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        distribution_comparison[(int) (a[x]*b[x]/10)]--;
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y > -distribution_comparison[x]; --y){
            for (int z = 0; z < n; ++z){
                if (y - 1 == c[z] && x == (int) (a[x] * b[x] / 10)){
                    found = true;
                    break;
                }
            }
            if (!found){
                err++;
            }
            found = false;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_postdecrement_assign.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    int *c = new int[n];
    int *distribution = new int[10];
    int *distribution_comparison = new int[10];
    bool found = false;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    (distribution[(int) (a[x]*b[x]/10)])--;
                    c[x] = distribution[(int) (a[x]*b[x]/10)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        distribution_comparison[(int) (a[x]*b[x]/10)]--;
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y > -distribution_comparison[x]; --y){
            for (int z = 0; z < n; ++z){
                if (y - 1 == c[z] && x == (int) (a[x] * b[x] / 10)){
                    found = true;
                    break;
                }
            }
            if (!found){
                err++;
            }
            found = false;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_postincrement_assign.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    int *c = (int *)malloc(n * sizeof(int));
    int *distribution = (int *)malloc(10 * sizeof(int));
    int *distribution_comparison = (int *)malloc(10 * sizeof(int));
    bool found = false;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    distribution[(int) (a[x]*b[x]/10)]++;
                    c[x] = distribution[(int) (a[x]*b[x]/10)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        distribution_comparison[(int) (a[x]*b[x]/10)]++;
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < distribution_comparison[x]; ++y){
            for (int z = 0; z < n; ++z){
                if (c[z] == y + 1 && (int) (a[z]*b[z]/10) == x){
                    found = true;
                    break;
                }
            }
            if (!found){
                err++;
            }
            found = false;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_postincrement_assign.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    int *c = new int[n];
    int *distribution = new int[10];
    int *distribution_comparison = new int[10];
    bool found = false;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    distribution[(int) (a[x]*b[x]/10)]++;
                    c[x] = distribution[(int) (a[x]*b[x]/10)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        distribution_comparison[(int) (a[x]*b[x]/10)]++;
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < distribution_comparison[x]; ++y){
            for (int z = 0; z < n; ++z){
                if (c[z] == y + 1 && (int) (a[z]*b[z]/10) == x){
                    found = true;
                    break;
                }
            }
            if (!found){
                err++;
            }
            found = false;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_predecrement_assign.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    int *c = (int *)malloc(n * sizeof(int));
    int *distribution = (int *)malloc(10 * sizeof(int));
    int *distribution_comparison = (int *)malloc(10 * sizeof(int));
    bool found = false;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    --distribution[(int) (a[x]*b[x]/10)];
                    c[x] = distribution[(int) (a[x]*b[x]/10)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        distribution_comparison[(int) (a[x]*b[x]/10)]--;
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y > distribution[x]; --y){
            for (int z = 0; z < n; ++z){
                if (c[z] == y - 1 && x == (int) (a[z] * b[z] / 10)){
                    found = true;
                    break;
                }
            }
            if (!found){
                err++;
            }
            found = false;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_predecrement_assign.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    int *c = new int[n];
    int *distribution = new int[10];
    int *distribution_comparison = new int[10];
    bool found = false;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    --distribution[(int) (a[x]*b[x]/10)];
                    c[x] = distribution[(int) (a[x]*b[x]/10)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        distribution_comparison[(int) (a[x]*b[x]/10)]--;
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y > distribution[x]; --y){
            for (int z = 0; z < n; ++z){
                if (c[z] == y - 1 && x == (int) (a[z] * b[z] / 10)){
                    found = true;
                    break;
                }
            }
            if (!found){
                err++;
            }
            found = false;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_preincrement_assign.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    int *c = (int *)malloc(n * sizeof(int));
    int *distribution = (int *)malloc(10 * sizeof(int));
    int *distribution_comparison = (int *)malloc(10 * sizeof(int));
    bool found = false;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    ++distribution[(int) (a[x]*b[x]/10)];
                    c[x] = distribution[(int) (a[x]*b[x]/10)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        distribution_comparison[(int) (a[x]*b[x]/10)]++;
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < distribution[x]; ++y){
            for (int z = 0; z < n; ++z){
                if (c[z] == y + 1 && x == (int) (a[z] * b[z] / 10)){
                    found = true;
                    break;
                }
            }
            if (!found){
                err++;
            }
            found = false;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_preincrement_assign.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    int *c = new int[n];
    int *distribution = new int[10];
    int *distribution_comparison = new int[10];
    bool found = false;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    ++distribution[(int) (a[x]*b[x]/10)];
                    c[x] = distribution[(int) (a[x]*b[x]/10)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        distribution_comparison[(int) (a[x]*b[x]/10)]++;
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < distribution[x]; ++y){
            for (int z = 0; z < n; ++z){
                if (c[z] == y + 1 && x == (int) (a[z] * b[z] / 10)){
                    found = true;
                    break;
                }
            }
            if (!found){
                err++;
            }
            found = false;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_rshift_equals_assign.c:::
#include "acc_testsuite.h"
bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){
    if (length == 0){
        return true;
    }
    unsigned int passed_a = 0;
    unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));
    for (int x = 0; x < length; ++x){
        if ((b[x] == (prev >> 1) && (a>>x)%2==1) || b[x] == prev && (a>>x)%2==0){
            for (int y = 0; y < x; ++y){
                if ((a>>y)%2 == 1){
                    passed_a += 1<<y;
                }
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                if ((a>>y) % 2 == 1){
                    passed_a += 1<<(y - 1);
                }
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));
    unsigned int passed = 1<<8;

    for (int x = 0; x < n; ++x){
        a[x] = 1<<8;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(real_t) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    c[x * 7 + y] = a[x];
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic capture
                        {
                            a[x] >>= 1;
                            c[x * 7 + y] = a[x];
                        }
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] <<= 1;
            }
        }
        if (a[x] != 1<<8){
            err += 1;
        }
    }

    for (int x = 0; x < n; ++x){
        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_rshift_equals_assign.cpp:::
#include "acc_testsuite.h"
bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){
    if (length == 0){
        return true;
    }
    unsigned int passed_a = 0;
    unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));
    for (int x = 0; x < length; ++x){
        if ((b[x] == (prev >> 1) && (a>>x)%2==1) || b[x] == prev && (a>>x)%2==0){
            for (int y = 0; y < x; ++y){
                if ((a>>y)%2 == 1){
                    passed_a += 1<<y;
                }
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                if ((a>>y) % 2 == 1){
                    passed_a += 1<<(y - 1);
                }
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));
    unsigned int passed = 1<<8;

    for (int x = 0; x < n; ++x){
        a[x] = 1<<8;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(real_t) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    c[x * 7 + y] = a[x];
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic capture
                        {
                            a[x] >>= 1;
                            c[x * 7 + y] = a[x];
                        }
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] <<= 1;
            }
        }
        if (a[x] != 1<<8){
            err += 1;
        }
    }

    for (int x = 0; x < n; ++x){
        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_x_bitand_expr_assign.c:::
#include "acc_testsuite.h"

bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = (int *)malloc((length - 1) * sizeof(int));
    int *passed_b = (int *)malloc((length - 1) * sizeof(int));
    for (int x = 0; x < length; ++x){
        if (b[x] == (prev & a[x])){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = (int *)malloc(n * sizeof(int));
    int *b = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));
    int *temp_a = (int *)malloc(10 * sizeof(int));
    int *temp_b = (int *)malloc(10 * sizeof(int));
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        totals[x/10] = totals[x/10] & a[x];
                        b[x] = totals[x/10];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] &= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_x_bitand_expr_assign.cpp:::
#include "acc_testsuite.h"

bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = new int[(length - 1)];
    int *passed_b = new int[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (b[x] == (prev & a[x])){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = new int[n];
    int *b = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];
    int *temp_a = new int[10];
    int *temp_b = new int[10];
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        totals[x/10] = totals[x/10] & a[x];
                        b[x] = totals[x/10];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] &= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_x_bitor_expr_assign.c:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = (int *)malloc((length - 1) * sizeof(int));
    int *passed_b = (int *)malloc((length - 1) * sizeof(int));
    for (int x = 0; x < length; ++x){
        if (b[x] == (prev | a[x])){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = (int *)malloc(n * sizeof(int));
    int *b = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));
    int *temp_a = (int *)malloc(10 * sizeof(int));
    int *temp_b = (int *)malloc(10 * sizeof(int));
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        totals[x/10] = totals[x/10] | a[x];
                        b[x] = totals[x/10];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] |= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_x_bitor_expr_assign.cpp:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = new int[(length - 1)];
    int *passed_b = new int[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (b[x] == (prev | a[x])){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = new int[n];
    int *b = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];
    int *temp_a = new int[10];
    int *temp_b = new int[10];
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        totals[x/10] = totals[x/10] | a[x];
                        b[x] = totals[x/10];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] |= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_x_bitxor_expr_assign.c:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = (int *)malloc((length - 1) * sizeof(int));
    int *passed_b = (int *)malloc((length - 1) * sizeof(int));
    for (int x = 0; x < length; ++x){
        if (b[x] == (prev ^ a[x])){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = (int *)malloc(n * sizeof(int));
    int *b = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));
    int *temp_a = (int *)malloc(10 * sizeof(int));
    int *temp_b = (int *)malloc(10 * sizeof(int));
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        totals[x/10] = totals[x/10] ^ a[x];
                        b[x] = totals[x/10];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] ^= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_x_bitxor_expr_assign.cpp:::
#include "acc_testsuite.h"
bool is_possible(int* a, int* b, int length, int prev){
    if (length == 0){
        return true;
    }
    int *passed_a = new int[(length - 1)];
    int *passed_b = new int[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (b[x] == (prev ^ a[x])){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int *a = new int[n];
    int *b = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];
    int *temp_a = new int[10];
    int *temp_b = new int[10];
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }
    for (int x = 0; x < n; ++x){
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    {
                        totals[x/10] = totals[x/10] ^ a[x];
                        b[x] = totals[x/10];
                    }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] ^= a[x];
    }
    for (int x = 0; x < (n/10 + 1); ++x){
        if (totals_comparison[x] != totals[x]){
            err += 1;
            break;
        }
    }
    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10; ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
        }
        if (!is_possible(temp_a, temp_b, temp_iterator, 1)){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_x_divided_expr_assign.c:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, real_t* c, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_c = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(c[x] - (prev / (a[x] + b[x]))) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
                passed_c[y] = c[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
                passed_c[y - 1] = c[y];
            }
            if (is_possible(passed_a, passed_b, passed_c, length - 1, c[x])){
                free(passed_a);
                free(passed_b);
                free(passed_c);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    free(passed_c);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *temp_a = (real_t *)malloc(10 * sizeof(real_t));
    real_t *temp_b = (real_t *)malloc(10 * sizeof(real_t));
    real_t *temp_c = (real_t *)malloc(10 * sizeof(real_t));
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    totals[x/10] = totals[x/10] / (a[x] + b[x]);
                    c[x] = totals[x/10];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] /= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
            temp_c[temp_iterator] = c[ab_iterator];
            temp_iterator++;
        }
        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_x_divided_expr_assign.cpp:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, real_t* c, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    real_t *passed_c = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(c[x] - (prev / (a[x] + b[x]))) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
                passed_c[y] = c[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
                passed_c[y - 1] = c[y];
            }
            if (is_possible(passed_a, passed_b, passed_c, length - 1, c[x])){
                delete[] passed_a;
                delete[] passed_b;
                delete[] passed_c;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    delete[] passed_c;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];
    real_t *temp_a = new real_t[10];
    real_t *temp_b = new real_t[10];
    real_t *temp_c = new real_t[10];
    int temp_iterator;
    int ab_iterator;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    totals[x/10] = totals[x/10] / (a[x] + b[x]);
                    c[x] = totals[x/10];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x/10] /= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n; x = x + 10){
        temp_iterator = 0;
        for (ab_iterator = x; ab_iterator < n && ab_iterator < x + 10;  ab_iterator+= 1){
            temp_a[temp_iterator] = a[ab_iterator];
            temp_b[temp_iterator] = b[ab_iterator];
            temp_c[temp_iterator] = c[ab_iterator];
            temp_iterator++;
        }
        if (!(is_possible(temp_a, temp_b, temp_c, temp_iterator, 1))){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_x_lshift_expr_assign.c:::
#include "acc_testsuite.h"
bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){
    if (length == 0){
        return true;
    }
    unsigned int passed_a = 0;
    unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));
    for (int x = 0; x < length; ++x){
        if ((b[x] == (prev << 1) && (a>>x)%2 == 1) || ((a>>x)%2==0 && b[x] == prev)){
            for (int y = 0; y < x; ++y){
                if ((a>>y)%2 == 1){
                    passed_a += 1<<y;
                }
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                if ((a>>y) % 2 == 1){
                    passed_a += 1<<(y - 1);
                }
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));
    unsigned int passed = 1;

    for (int x = 0; x < n; ++x){
        a[x] = 1;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(real_t) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    c[x * 7 + y] = a[x];
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic capture
                        {
                            a[x] = a[x] << 1;
                            c[x * 7 + y] = a[x];
                        }
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] >>= 1;
            }
        }
        if (a[x] != 1){
            err += 1;
        }
    }

    for (int x = 0; x < n; ++x){
        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_x_lshift_expr_assign.cpp:::
#include "acc_testsuite.h"
bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){
    if (length == 0){
        return true;
    }
    unsigned int passed_a = 0;
    unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));
    for (int x = 0; x < length; ++x){
        if ((b[x] == (prev << 1) && (a>>x)%2 == 1) || ((a>>x)%2==0 && b[x] == prev)){
            for (int y = 0; y < x; ++y){
                if ((a>>y)%2 == 1){
                    passed_a += 1<<y;
                }
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                if ((a>>y) % 2 == 1){
                    passed_a += 1<<(y - 1);
                }
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));
    unsigned int passed = 1;

    for (int x = 0; x < n; ++x){
        a[x] = 1;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(real_t) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    c[x * 7 + y] = a[x];
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic capture
                        {
                            a[x] = a[x] << 1;
                            c[x * 7 + y] = a[x];
                        }
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] >>= 1;
            }
        }
        if (a[x] != 1){
            err += 1;
        }
    }

    for (int x = 0; x < n; ++x){
        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_x_minus_expr_assign.c:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (prev - a[x])) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));
    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));
    real_t * passed_ab = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t * passed_c = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        totals[x] = 0;
	totals_host[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10], c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    totals[x%10] = totals[x%10] - (a[x] + b[x]);
                    c[x] = totals[x%10];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_host[x] - totals[x]) > PRECISION){
            err += 1;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_x_minus_expr_assign.cpp:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (prev - a[x])) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *totals = new real_t[10];
    real_t *totals_host = new real_t[10];
    real_t * passed_ab = new real_t[(n/10 + 1)];
    real_t * passed_c = new real_t[(n/10 + 1)];
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        totals[x] = 0;
	totals_host[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10], c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    totals[x%10] = totals[x%10] - (a[x] + b[x]);
                    c[x] = totals[x%10];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_host[x] - totals[x]) > PRECISION){
            err += 1;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= 10){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_x_multiply_expr_assign.c:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (a[x] * prev)) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t * passed_ab = (real_t *)malloc(10 * sizeof(real_t));
    real_t * passed_c = (real_t *)malloc(10 * sizeof(real_t));
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);
                    c[x] = totals[x%(n/10 + 1)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_x_multiply_expr_assign.cpp:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (a[x] * prev)) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];
    real_t * passed_ab = new real_t[10];
    real_t * passed_c = new real_t[10];
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);
                    c[x] = totals[x%(n/10 + 1)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer += n/10 + 1){
            passed_ab[passed_indexer] = a[absolute_indexer] + b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 1)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_x_plus_expr_assign.c:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = (real_t *)malloc((length - 1) * sizeof(real_t));
    real_t *passed_b = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (a[x] + prev)) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_a);
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_a);
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *c = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *passed_ab = (real_t *)malloc(10 * sizeof(real_t));
    real_t *passed_c = (real_t *)malloc(10 * sizeof(real_t));
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] + (a[x] * b[x]);
                    c[x] = totals[x%(n/10 + 1)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];
    }
    for (int x = 0; x < n/10 + 1; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){
            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_x_plus_expr_assign.cpp:::
#include "acc_testsuite.h"
bool is_possible(real_t* a, real_t* b, int length, real_t prev){
    if (length == 0){
        return true;
    }
    real_t *passed_a = new real_t[(length - 1)];
    real_t *passed_b = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        if (fabs(b[x] - (a[x] + prev)) < PRECISION){
            for (int y = 0; y < x; ++y){
                passed_a[y] = a[y];
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                passed_a[y - 1] = a[y];
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_a;
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_a;
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *c = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];
    real_t *passed_ab = new real_t[10];
    real_t *passed_c = new real_t[10];
    int passed_indexer;
    int absolute_indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                {
                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] + (a[x] * b[x]);
                    c[x] = totals[x%(n/10 + 1)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];
    }
    for (int x = 0; x < n/10 + 1; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    for (int x = 0; x < n/10 + 1; ++x){
        for (passed_indexer = 0, absolute_indexer = x; absolute_indexer < n; passed_indexer++, absolute_indexer+= (n/10 + 1)){
            passed_ab[passed_indexer] = a[absolute_indexer] * b[absolute_indexer];
            passed_c[passed_indexer] = c[absolute_indexer];
        }
        if (!is_possible(passed_ab, passed_c, passed_indexer, 0)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_x_rshift_expr_assign.c:::
#include "acc_testsuite.h"
bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){
    if (length == 0){
        return true;
    }
    unsigned int passed_a = 0;
    unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));
    for (int x = 0; x < length; ++x){
        if ((b[x] == (prev >> 1) && (a>>x)%2==1) || b[x] == prev && (a>>x)%2==0){
            for (int y = 0; y < x; ++y){
                if ((a>>y)%2 == 1){
                    passed_a += 1<<y;
                }
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                if ((a>>y) % 2 == 1){
                    passed_a += 1<<(y - 1);
                }
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                free(passed_b);
                return true;
            }
        }
    }
    free(passed_b);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));
    unsigned int passed = 1<<8;

    for (int x = 0; x < n; ++x){
        a[x] = 1<<8;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(real_t) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    c[x * 7 + y] = a[x];
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic capture
                        {
                            a[x] = a[x] >> 1;
                            c[x * 7 + y] = a[x];
                        }
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] <<= 1;
            }
        }
        if (a[x] != 1<<8){
            err += 1;
        }
    }

    for (int x = 0; x < n; ++x){
        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_structured_x_rshift_expr_assign.cpp:::
#include "acc_testsuite.h"
bool is_possible(unsigned int a, unsigned int* b, int length, unsigned int prev){
    if (length == 0){
        return true;
    }
    unsigned int passed_a = 0;
    unsigned int *passed_b = (unsigned int *)malloc((length - 1) * sizeof(unsigned int));
    for (int x = 0; x < length; ++x){
        if ((b[x] == (prev >> 1) && (a>>x)%2==1) || b[x] == prev && (a>>x)%2==0){
            for (int y = 0; y < x; ++y){
                if ((a>>y)%2 == 1){
                    passed_a += 1<<y;
                }
                passed_b[y] = b[y];
            }
            for (int y = x + 1; y < length; ++y){
                if ((a>>y) % 2 == 1){
                    passed_a += 1<<(y - 1);
                }
                passed_b[y - 1] = b[y];
            }
            if (is_possible(passed_a, passed_b, length - 1, b[x])){
                delete[] passed_b;
                return true;
            }
        }
    }
    delete[] passed_b;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *c = (unsigned int *)malloc(7 * n * sizeof(int));
    unsigned int passed = 1<<8;

    for (int x = 0; x < n; ++x){
        a[x] = 1<<8;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(real_t) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n]) copyout(c[0:7*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    c[x * 7 + y] = a[x];
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic capture
                        {
                            a[x] = a[x] >> 1;
                            c[x * 7 + y] = a[x];
                        }
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] <<= 1;
            }
        }
        if (a[x] != 1<<8){
            err += 1;
        }
    }

    for (int x = 0; x < n; ++x){
        if (!is_possible(b[x], &(c[x * 7]), 7, passed)){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_bitand_equals.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }

    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] &= a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] &= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_bitand_equals.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }

    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] &= a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] &= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_bitor_equals.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] |= a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] |= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_bitor_equals.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] |= a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] |= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_bitxor_equals.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .5){
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] ^= a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] ^= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_bitxor_equals.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .5){
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] ^= a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] ^= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_divided_equals.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] /= (a[x] + b[x]);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_divided_equals.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] /= (a[x] + b[x]);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_expr_bitand_x.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] = a[x] & totals[x%(n/10 + 1)];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] &= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_expr_bitand_x.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] = a[x] & totals[x%(n/10 + 1)];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] &= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_expr_bitor_x.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] |= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_expr_bitor_x.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] |= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_expr_bitxor_x.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .5){
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] = a[x] ^ totals[x%(n/10 + 1)];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] ^= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_expr_bitxor_x.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .5){
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] = a[x] ^ totals[x%(n/10 + 1)];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] ^= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_expr_divided_x.c:::
#include "acc_testsuite.h"
bool possible_result(real_t * remaining_combinations, int length, real_t current_value, real_t test_value){
    if (length == 0){
        if (fabs(current_value - test_value) > PRECISION){
            return true;
        }
        else {
            return false;
        }
    }
    real_t * passed = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        for (int y = 0; y < x; ++y){
            passed[y] = remaining_combinations[y];
        }
        for (int y = x + 1; y < length; ++y){
            passed[y - 1] = remaining_combinations[y];
        }
        if (possible_result(passed, length - 1, remaining_combinations[x] / current_value, test_value)){
            free(passed);
            return true;
        }
    }
    free(passed);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t * passed = (real_t *)malloc(10 * sizeof(real_t));
    int indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] = (a[x] + b[x]) / totals[x%(n/10 + 1)];
            }
        }
    }


    for (int x = 0; x < (n/10 + 1); ++x){
        indexer = x;
        while (indexer < n){
            passed[indexer/(n/10 + 1)] = (a[x] + b[x]);
            indexer += (n/10 + 1);
        }
        if (!(possible_result(passed, 10, 1, totals[x]))){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_expr_divided_x.cpp:::
#include "acc_testsuite.h"
bool possible_result(real_t * remaining_combinations, int length, real_t current_value, real_t test_value){
    if (length == 0){
        if (fabs(current_value - test_value) > PRECISION){
            return true;
        }
        else {
            return false;
        }
    }
    real_t * passed = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        for (int y = 0; y < x; ++y){
            passed[y] = remaining_combinations[y];
        }
        for (int y = x + 1; y < length; ++y){
            passed[y - 1] = remaining_combinations[y];
        }
        if (possible_result(passed, length - 1, remaining_combinations[x] / current_value, test_value)){
            delete[] passed;
            return true;
        }
    }
    delete[] passed;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t * passed = new real_t[10];
    int indexer;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] = (a[x] + b[x]) / totals[x%(n/10 + 1)];
            }
        }
    }


    for (int x = 0; x < (n/10 + 1); ++x){
        indexer = x;
        while (indexer < n){
            passed[indexer/(n/10 + 1)] = (a[x] + b[x]);
            indexer += (n/10 + 1);
        }
        if (!(possible_result(passed, 10, 1, totals[x]))){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_expr_lshift_x.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};
    int result;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 3; ++y){
            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));
        }
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 3; ++y){
                    #pragma acc atomic update
                        b[x] = a[x * 3 + y] << b[x];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 6; ++y){
            result = 0;
            for (int z = 0; z < 3; ++z){
                result = a[x * 3 + orders[y * 3 + z]] << result;
            }
            if (result == b[x]){
                break;
            }
        }
        if (result != b[x]){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_expr_lshift_x.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};
    int result;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 3; ++y){
            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));
        }
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 3; ++y){
                    #pragma acc atomic update
                        b[x] = a[x * 3 + y] << b[x];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 6; ++y){
            result = 0;
            for (int z = 0; z < 3; ++z){
                result = a[x * 3 + orders[y * 3 + z]] << result;
            }
            if (result == b[x]){
                break;
            }
        }
        if (result != b[x]){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_expr_minus_x.c:::
#include "acc_testsuite.h"
bool possible_result(real_t * remaining_combinations, int length, real_t current_value, real_t test_value){
    if (length == 0){
        if (fabs(current_value - test_value) > PRECISION){
            return true;
        }
        else {
            return false;
        }
    }
    real_t * passed = (real_t *)malloc((length - 1) * sizeof(real_t));
    for (int x = 0; x < length; ++x){
        for (int y = 0; y < x; ++y){
            passed[y] = remaining_combinations[y];
        }
        for (int y = x + 1; y < length; ++y){
            passed[y - 1] = remaining_combinations[y];
        }
        if (possible_result(passed, length - 1, remaining_combinations[x] - current_value, test_value)){
            free(passed);
            return true;
        }
    }
    free(passed);
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc(((n/10) + 1) * sizeof(real_t));
    int indexer = 0;
    real_t * passed = (real_t *)malloc(10 * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < (n/10) + 1; ++x){
        totals[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:(n/10) + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%((int) (n/10) + 1)] = a[x] - totals[x%((int) (n/10) + 1)];
            }
        }
    }
    for (int x = 0; x < (n/10) + 1; ++x){
        indexer = x;
        while (indexer < n){
            passed[indexer/((int) (n/10) + 1)] = a[indexer];
            indexer += (n/10) + 1;
        }
        if (!(possible_result(passed, 10, 0, totals[x]))){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_expr_minus_x.cpp:::
#include "acc_testsuite.h"
bool possible_result(real_t * remaining_combinations, int length, real_t current_value, real_t test_value){
    if (length == 0){
        if (fabs(current_value - test_value) > PRECISION){
            return true;
        }
        else {
            return false;
        }
    }
    real_t * passed = new real_t[(length - 1)];
    for (int x = 0; x < length; ++x){
        for (int y = 0; y < x; ++y){
            passed[y] = remaining_combinations[y];
        }
        for (int y = x + 1; y < length; ++y){
            passed[y - 1] = remaining_combinations[y];
        }
        if (possible_result(passed, length - 1, remaining_combinations[x] - current_value, test_value)){
            delete[] passed;
            return true;
        }
    }
    delete[] passed;
    return false;
}

#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *totals = new real_t[((n/10) + 1)];
    int indexer = 0;
    real_t * passed = new real_t[10];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < (n/10) + 1; ++x){
        totals[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:(n/10) + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%((int) (n/10) + 1)] = a[x] - totals[x%((int) (n/10) + 1)];
            }
        }
    }
    for (int x = 0; x < (n/10) + 1; ++x){
        indexer = x;
        while (indexer < n){
            passed[indexer/((int) (n/10) + 1)] = a[indexer];
            indexer += (n/10) + 1;
        }
        if (!(possible_result(passed, 10, 0, totals[x]))){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_expr_multiply_x.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_expr_multiply_x.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] = (a[x] + b[x]) * totals[x%(n/10 + 1)];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_expr_plus_x.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc(10 * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < n; ++y){
                    #pragma acc atomic update
                        totals[(int) ((a[x] + b[x])/2)] = a[x] * b[x] + totals[(int) ((a[x] + b[x])/2)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];
        }
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > 10 * PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_expr_plus_x.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *totals = new real_t[10];
    real_t *totals_comparison = new real_t[10];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < n; ++y){
                    #pragma acc atomic update
                        totals[(int) ((a[x] + b[x])/2)] = a[x] * b[x] + totals[(int) ((a[x] + b[x])/2)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];
        }
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > 10 * PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_expr_rshift_x.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};
    int result;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 3; ++y){
            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));
        }
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop independent
                for (int y = 0; y < 3; ++y){
                    #pragma acc atomic update
                        b[x] = a[x * 3 + y] >> b[x];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 6; ++y){
            result = 0;
            for (int z = 0; z < 3; ++z){
                result = a[x * 3 + orders[y * 3 + z]] >> result;
            }
            if (result == b[x]){
                break;
            }
        }
        if (result != b[x]){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_expr_rshift_x.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(3 * n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));
    int orders[18] = {1, 2, 0, 1, 0, 2, 2, 1, 0, 2, 0, 1, 0, 1, 2, 0, 2, 1};
    int result;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 3; ++y){
            a[x * 3 + y] = (int) (rand() / (unsigned int) (RAND_MAX / 4));
        }
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:3 * n]) copy(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop independent
                for (int y = 0; y < 3; ++y){
                    #pragma acc atomic update
                        b[x] = a[x * 3 + y] >> b[x];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 6; ++y){
            result = 0;
            for (int z = 0; z < 3; ++z){
                result = a[x * 3 + orders[y * 3 + z]] >> result;
            }
            if (result == b[x]){
                break;
            }
        }
        if (result != b[x]){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_lshift_equals.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = 1;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(unsigned int) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic update
                            a[x] <<= 1;
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] >>= 1;
            }
        }
        if (a[x] != 1){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_lshift_equals.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = 1;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(unsigned int) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic update
                            a[x] <<= 1;
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] >>= 1;
            }
        }
        if (a[x] != 1){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_minus_equals.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));
    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        totals[x] = 0;
        totals_host[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%10] -= (a[x] + b[x]);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_host[x] - totals[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_minus_equals.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *totals = new real_t[10];
    real_t *totals_host = new real_t[10];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        totals[x] = 0;
        totals_host[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%10] -= (a[x] + b[x]);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_host[x] - totals[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_multiply_equals.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] *= a[x] + b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_multiply_equals.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] *= a[x] + b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_plus_equals.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] += a[x] * b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];
    }
    for (int x = 0; x < n/10 + 1; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > (n/10 + 1) * PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_plus_equals.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] += a[x] * b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] += a[x] * b[x];
    }
    for (int x = 0; x < n/10 + 1; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > (n/10 + 1) * PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_postdecrement.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    int *distribution = (int *)malloc(10 * sizeof(int));
    int *distribution_comparison = (int *)malloc(10 * sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    distribution[(int) (a[x] * b[x] / 10)]--;
            }
        }
    }

    for (int x = 0; x < n; ++x){
        distribution_comparison[(int) (a[x]*b[x]/10)]--;
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_postdecrement.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    int *distribution = new int[10];
    int *distribution_comparison = new int[10];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    distribution[(int) (a[x] * b[x] / 10)]--;
            }
        }
    }

    for (int x = 0; x < n; ++x){
        distribution_comparison[(int) (a[x]*b[x]/10)]--;
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_postincrement.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    int *distribution = (int *)malloc(10 * sizeof(int));
    int *distribution_comparison = (int *)malloc(10 * sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < n; ++y){
                    #pragma acc atomic update
                        distribution[(int) (a[x]*b[y]/10)]++;
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            distribution_comparison[(int) (a[x]*b[y]/10)]++;
        }
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_postincrement.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    int *distribution = new int[10];
    int *distribution_comparison = new int[10];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < n; ++y){
                    #pragma acc atomic update
                        distribution[(int) (a[x]*b[y]/10)]++;
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            distribution_comparison[(int) (a[x]*b[y]/10)]++;
        }
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_predecrement.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    int *distribution = (int *)malloc(10 * sizeof(int));
    int *distribution_comparison = (int *)malloc(10 * sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < n; ++y){
                    #pragma acc atomic update
                        --distribution[(int) (a[x]*b[y]/10)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            distribution_comparison[(int) (a[x]*b[y]/10)]--;
        }
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_predecrement.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    int *distribution = new int[10];
    int *distribution_comparison = new int[10];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < n; ++y){
                    #pragma acc atomic update
                        --distribution[(int) (a[x]*b[y]/10)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            distribution_comparison[(int) (a[x]*b[y]/10)]--;
        }
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_preincrement.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    int *distribution = (int *)malloc(10 * sizeof(int));
    int *distribution_comparison = (int *)malloc(10 * sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < n; ++y){
                    #pragma acc atomic update
                        ++distribution[(int) (a[x]*b[y]/10)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            distribution_comparison[(int) (a[x]*b[y]/10)]++;
        }
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_preincrement.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    int *distribution = new int[10];
    int *distribution_comparison = new int[10];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        distribution[x] = 0;
        distribution_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(distribution[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < n; ++y){
                    #pragma acc atomic update
                        ++distribution[(int) (a[x]*b[y]/10)];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            distribution_comparison[(int) (a[x]*b[y]/10)]++;
        }
    }
    for (int x = 0; x < 10; ++x){
        if (distribution_comparison[x] != distribution[x]){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_rshift_equals.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = 1<<7;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(unsigned int) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic update
                            a[x] >>= 1;
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] <<= 1;
            }
        }
        if (a[x] != 1<<7){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_rshift_equals.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = 1<<7;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(unsigned int) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic update
                            a[x] >>= 1;
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] <<= 1;
            }
        }
        if (a[x] != 1<<7){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_x_bitand_expr.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
	for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] & a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] &= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_x_bitand_expr.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
	for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] & a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] &= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_x_bitor_expr.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] |= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_x_bitor_expr.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] |= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_x_bitxor_expr.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .5){
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] =  totals[x%(n/10 + 1)] ^ a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] ^= a[x];
    }
    for (int x = 0; x < n/10 + 1; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_x_bitxor_expr.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .5){
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] =  totals[x%(n/10 + 1)] ^ a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] ^= a[x];
    }
    for (int x = 0; x < n/10 + 1; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_x_divided_expr.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] / (a[x] + b[x]);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_x_divided_expr.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] / (a[x] + b[x]);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_x_lshift_expr.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = 1;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(unsigned int) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic update
                            a[x] = a[x] << 1;
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] >>= 1;
            }
        }
        if (a[x] != 1){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_x_lshift_expr.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = 1;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(unsigned int) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic update
                            a[x] = a[x] << 1;
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] >>= 1;
            }
        }
        if (a[x] != 1){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_x_minus_expr.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));
    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        totals[x] = 0;
        totals_host[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%10] = totals[x%10] - (a[x] + b[x]);
            }
        }
    }


    for (int x = 0; x < n; ++x){
        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_host[x] - totals[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_x_minus_expr.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *totals = new real_t[10];
    real_t *totals_host = new real_t[10];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        totals[x] = 0;
        totals_host[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%10] = totals[x%10] - (a[x] + b[x]);
            }
        }
    }


    for (int x = 0; x < n; ++x){
        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_host[x] - totals[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_x_multiply_expr.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_x_multiply_expr.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_x_plus_expr.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc(10 * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < n; ++y){
                    #pragma acc atomic update
                        totals[(int) ((a[x] + b[x])/2)] = totals[(int) ((a[x] + b[x])/2)] + a[x] * b[x];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];
        }
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_x_plus_expr.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *totals = new real_t[10];
    real_t *totals_comparison = new real_t[10];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < n; ++y){
                    #pragma acc atomic update
                        totals[(int) ((a[x] + b[x])/2)] = totals[(int) ((a[x] + b[x])/2)] + a[x] * b[x];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];
        }
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_x_rshift_expr.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = 1<<7;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(unsigned int) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic update
                            a[x] = a[x] >> 1;
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] <<= 1;
            }
        }
        if (a[x] != 1<<7){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_update_x_rshift_expr.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = 1<<7;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(unsigned int) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic update
                            a[x] = a[x] >> 1;
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] <<= 1;
            }
        }
        if (a[x] != 1<<7){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_x_bitand_expr.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] & a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] &= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_x_bitand_expr.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) < .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
        for (int y = 0; y < 8; ++y){
            totals[x] +=  1<<y;
            totals_comparison[x] += 1<<y;
        }
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] & a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] &= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_x_bitor_expr.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] |= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_x_bitor_expr.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .933){ //.933 gets close to a 50/50 distribution for a collescence of 10 values
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] | a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] |= a[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_x_bitxor_expr.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = (int *)malloc(n * sizeof(int));
    int *totals = (int *)malloc((n/10 + 1) * sizeof(int));
    int *totals_comparison = (int *)malloc((n/10 + 1) * sizeof(int));

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .5){
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] =  totals[x%(n/10 + 1)] ^ a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] ^= a[x];
    }
    for (int x = 0; x < n/10 + 1; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_x_bitxor_expr.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int  *a = new int[n];
    int *totals = new int[(n/10 + 1)];
    int *totals_comparison = new int[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 8; ++y){
            if (rand()/(real_t)(RAND_MAX) > .5){
                a[x] += 1<<y;
            }
        }
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] =  totals[x%(n/10 + 1)] ^ a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] ^= a[x];
    }
    for (int x = 0; x < n/10 + 1; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_x_divided_expr.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] / (a[x] + b[x]);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_x_divided_expr.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] / (a[x] + b[x]);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] /= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_x_lshift_expr.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = 1;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(unsigned int) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic
                            a[x] = a[x] << 1;
                    }
                }
            }
        }
    }
    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] >>= 1;
            }
        }
        if (a[x] != 1){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_x_lshift_expr.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = 1;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(unsigned int) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic
                            a[x] = a[x] << 1;
                    }
                }
            }
        }
    }
    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] >>= 1;
            }
        }
        if (a[x] != 1){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_x_minus_expr.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));
    real_t *totals_host = (real_t *)malloc(10 * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        totals[x] = 0;
        totals_host[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%10] = totals[x%10] - (a[x] + b[x]);
            }
        }
    }


    for (int x = 0; x < n; ++x){
        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_host[x] - totals[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_x_minus_expr.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *totals = new real_t[10];
    real_t *totals_host = new real_t[10];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        totals[x] = 0;
        totals_host[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%10] = totals[x%10] - (a[x] + b[x]);
            }
        }
    }


    for (int x = 0; x < n; ++x){
        totals_host[x%10] = totals_host[x%10] - (a[x] + b[x]);
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_host[x] - totals[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_x_multiply_expr.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc((n/10 + 1) * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc((n/10 + 1) * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_x_multiply_expr.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *totals = new real_t[(n/10 + 1)];
    real_t *totals_comparison = new real_t[(n/10 + 1)];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < n/10 + 1; ++x){
        totals[x] = 1;
        totals_comparison[x] = 1;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:n/10 + 1])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    totals[x%(n/10 + 1)] = totals[x%(n/10 + 1)] * (a[x] + b[x]);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        totals_comparison[x%(n/10 + 1)] *= a[x] + b[x];
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION * totals_comparison[x]){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_x_plus_expr.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));
    real_t *totals = (real_t *)malloc(10 * sizeof(real_t));
    real_t *totals_comparison = (real_t *)malloc(10 * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < n; ++y){
                    #pragma acc atomic
                        totals[(int) ((a[x] + b[x])/2)] = totals[(int) ((a[x] + b[x])/2)] + a[x] * b[x];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];
        }
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_x_plus_expr.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];
    real_t *totals = new real_t[10];
    real_t *totals_comparison = new real_t[10];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        totals[x] = 0;
        totals_comparison[x] = 0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(totals[0:10])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < n; ++y){
                    #pragma acc atomic
                        totals[(int) ((a[x] + b[x])/2)] = totals[(int) ((a[x] + b[x])/2)] + a[x] * b[x];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            totals_comparison[(int) ((a[x] + b[x])/2)] += a[x] * b[x];
        }
    }
    for (int x = 0; x < 10; ++x){
        if (fabs(totals_comparison[x] - totals[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_x_rshift_expr.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = 1<<7;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(unsigned int) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic
                            a[x] = a[x] >> 1;
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] <<= 1;
            }
        }
        if (a[x] != 1<<7){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
atomic_x_rshift_expr.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int *a = (unsigned int *)malloc(n * sizeof(int));
    unsigned int *b = (unsigned int *)malloc(n * sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = 1<<7;
        for (int y = 0; y < 7; ++y){
            if ((rand()/(unsigned int) (RAND_MAX)) > .5){
                b[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(b[0:n]) copy(a[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                #pragma acc loop
                for (int y = 0; y < 7; ++y){
                    if ((b[x]>>y)%2 == 1){
                        #pragma acc atomic
                            a[x] = a[x] >> 1;
                    }
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 7; ++y){
            if ((b[x]>>y)%2 == 1){
                a[x] <<= 1;
            }
        }
        if (a[x] != 1<<7){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
copy_copyout.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1: , V:1.0-2.7
int test1(){
    int err = 0;
    real_t test = 0;
    #pragma acc parallel loop copy(test) copyout(test) reduction(+:test)
    for( int x = 0; x <n; ++x){
        test += 1;
    }

    if(fabs(test - n) > PRECISION){
        err++;
    }

    return err;
}
#endif

#ifndef T2
//T2: , V:1.0-2.7
int test2(){
    int err = 0;
    real_t *test = (real_t *)malloc(n * sizeof(real_t));

    for(int x = 0; x < n; ++x){
        test[x] = 1.0;
    }

   #pragma acc parallel loop copy(test[0:n]) copyout(test[0:n])
   for(int x = 0; x < n; ++x){
        test[x] += 1.0;
   }

   for(int x = 0; x < n; ++x){
        if(fabs(test[x] - 2.0) > PRECISION){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for( int x = 0; x < NUM_TEST_CALLS; ++x){
	failed += test1();
    }
    if(failed){
	failcode += (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for( int x = 0; x < NUM_TEST_CALLS; ++x){
        failed += test2();
    }
    if(failed){
        failcode += (1 << 1);
    }
#endif
    return failcode;
}


########## NEXT FILE ##########
copy_copyout.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1: , V:1.0-2.7
int test1(){
    int err = 0;
    real_t test = 0;
    #pragma acc parallel loop copy(test) copyout(test) reduction(+:test)
    for( int x = 0; x <n; ++x){
        test += 1;
    }

    if(fabs(test - n) > PRECISION){
        err++;
    }

    return err;
}
#endif

#ifndef T2
//T2: , V:1.0-2.7
int test2(){
    int err = 0;
    real_t *test = new real_t[n];

    for(int x = 0; x < n; ++x){
        test[x] = 1.0;
    }

   #pragma acc parallel loop copy(test[0:n]) copyout(test[0:n])
   for(int x = 0; x < n; ++x){
        test[x] += 1.0;
   }

   for(int x = 0; x < n; ++x){
        if(fabs(test[x] - 2.0) > PRECISION){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for( int x = 0; x < NUM_TEST_CALLS; ++x){
	failed += test1();
    }
    if(failed){
	failcode += (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for( int x = 0; x < NUM_TEST_CALLS; ++x){
        failed += test2();
    }
    if(failed){
        failcode += (1 << 1);
    }
#endif
    return failcode;
}


########## NEXT FILE ##########
copyin_copyout.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:, V:1.0-2.7
int test1(){
    int err = 0;
    real_t test = 0;
    #pragma acc parallel loop copyin(test) copyout(test) reduction(+:test)
    for( int x = 0; x <n; ++x){
        test += 1;
    }

    if(fabs(test - n) > PRECISION){
        err++;
    }

    return err;
}
#endif

#ifndef T2
//T2: , V:1.0-2.7
int test2(){
    int err = 0;
    real_t *test = (real_t *)malloc(n * sizeof(real_t));

    for(int x = 0; x < n; ++x){
        test[x] = 1.0;
    }

   #pragma acc parallel loop copyin(test[0:n]) copyout(test[0:n])
   for(int x = 0; x < n; ++x){
        test[x] += 1.0;
   }

   for(int x = 0; x < n; ++x){
        if(fabs(test[x] - 2.0) > PRECISION){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for( int x = 0; x < NUM_TEST_CALLS; ++x){
	failed += test1();
    }
    if(failed){
	failcode += (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for( int x = 0; x < NUM_TEST_CALLS; ++x){
        failed += test2();
    }
    if(failed){
        failcode += (1 << 1);
    }
#endif
    return failcode;
}


########## NEXT FILE ##########
copyin_copyout.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:, V:1.0-2.7
int test1(){
    int err = 0;
    real_t test = 0;
    #pragma acc parallel loop copyin(test) copyout(test) reduction(+:test)
    for( int x = 0; x <n; ++x){
        test += 1;
    }

    if(fabs(test - n) > PRECISION){
        err++;
    }

    return err;
}
#endif

#ifndef T2
//T2: , V:1.0-2.7
int test2(){
    int err = 0;
    real_t *test = new real_t[n];

    for(int x = 0; x < n; ++x){
        test[x] = 1.0;
    }

   #pragma acc parallel loop copyin(test[0:n]) copyout(test[0:n])
   for(int x = 0; x < n; ++x){
        test[x] += 1.0;
   }

   for(int x = 0; x < n; ++x){
        if(fabs(test[x] - 2.0) > PRECISION){
            err++;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for( int x = 0; x < NUM_TEST_CALLS; ++x){
	failed += test1();
    }
    if(failed){
	failcode += (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for( int x = 0; x < NUM_TEST_CALLS; ++x){
        failed += test2();
    }
    if(failed){
        failcode += (1 << 1);
    }
#endif
    return failcode;
}


########## NEXT FILE ##########
data_async.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:async,data,V:3.2-3.3
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc data copy(a[0:n], b[0:n], c[0:n]) async(1)
    {
        #pragma acc parallel 
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }
        }
    }

    #pragma acc data copy(a[0:n], b[0:n], c[0:n]) async(1)
    {
        #pragma acc parallel 
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }
        }
    }

    #pragma acc wait(1)
    

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif
#ifndef T2
//T2:async,data,V:3.2-3.3
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc data copy(a[0:n], b[0:n], c[0:n]) async(0)
    {
        #pragma acc parallel loop async(1) wait(0)
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }

    #pragma acc wait(1) async(0)
    }

    #pragma acc wait(0)

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
data_async.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:async,data,V:3.2-3.3
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc data copy(a[0:n], b[0:n], c[0:n]) async(1)
    {
        #pragma acc parallel 
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }
        }
    }

    #pragma acc data copy(a[0:n], b[0:n], c[0:n]) async(1)
    {
        #pragma acc parallel 
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }
        }
    }

    #pragma acc wait(1)
    

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif
#ifndef T2
//T2:async,data,V:3.2-3.3
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc data copy(a[0:n], b[0:n], c[0:n]) async(0)
    {
        #pragma acc parallel loop async(1) wait(0)
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }

    #pragma acc wait(1) async(0)
    }

    #pragma acc wait(0)

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
data_copy_no_lower_bound.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,data-region,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(c[:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
data_copy_no_lower_bound.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,data-region,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(c[:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
data_copyin_no_lower_bound.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,data-region,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc data copyin(a[:n], b[:n]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
data_copyin_no_lower_bound.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,data-region,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc data copyin(a[:n], b[:n]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
data_copyout_no_lower_bound.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,data-region,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
data_copyout_no_lower_bound.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,data-region,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
data_copyout_reference_counts.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,data-region,reference-counting,devonly,construct-independent,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    int * devtest = (int *)malloc(sizeof(int));
    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
      devtest[0] = 0;
    }

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }


    if (devtest[0] == 1) {
        #pragma acc data copyin(c[0:n])
        {
            #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])
            {
                #pragma acc parallel
                {
                    #pragma acc loop
                    for (int x = 0; x < n; ++x){
                        c[x] += a[x] + b[x];
                    }
                }
            }
            for (int x = 0; x < n; ++x){
                if (fabs(c[x]) > PRECISION){
                    err += 1;
                    break;
                }
            }
        }
        for (int x = 0; x < n; ++x){
            if (fabs(c[x]) > PRECISION){
                err += 1;
                break;
            }
        }

    }

    return err;
}
#endif

#ifndef T2
//T2:data,data-region,reference-counting,construct-independent,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    int * devtest = (int *)malloc(sizeof(int));
    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
      devtest[0] = 0;
    }

    for (int x = 0; x < n; ++x){
      a[x] = rand() / (real_t)(RAND_MAX / 10);
      b[x] = rand() / (real_t)(RAND_MAX / 10);
      c[x] = 0.0;
    }

    #pragma acc enter data copyin(c[0:n])
    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }
        }
    }
    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            if (fabs(c[x]) > PRECISION){
                err += 1;
                break;
            }
        }
    }
    #pragma acc exit data copyout(c[0:n])
    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:data,data-region,construct-independent,V:2.5-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    int * devtest = (int *)malloc(sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc enter data copyin(c[0:n])
    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }
        }
        #pragma acc exit data delete(c[0:n])
    }
    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
data_copyout_reference_counts.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,data-region,reference-counting,devonly,construct-independent,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];
    int * devtest = (int *)malloc(sizeof(int));
    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
      devtest[0] = 0;
    }

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }


    if (devtest[0] == 1) {
        #pragma acc data copyin(c[0:n])
        {
            #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])
            {
                #pragma acc parallel
                {
                    #pragma acc loop
                    for (int x = 0; x < n; ++x){
                        c[x] += a[x] + b[x];
                    }
                }
            }
            for (int x = 0; x < n; ++x){
                if (fabs(c[x]) > PRECISION){
                    err += 1;
                    break;
                }
            }
        }
        for (int x = 0; x < n; ++x){
            if (fabs(c[x]) > PRECISION){
                err += 1;
                break;
            }
        }

    }

    return err;
}
#endif

#ifndef T2
//T2:data,data-region,reference-counting,construct-independent,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];
    int * devtest = (int *)malloc(sizeof(int));
    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
      devtest[0] = 0;
    }

    for (int x = 0; x < n; ++x){
      a[x] = rand() / (real_t)(RAND_MAX / 10);
      b[x] = rand() / (real_t)(RAND_MAX / 10);
      c[x] = 0.0;
    }

    #pragma acc enter data copyin(c[0:n])
    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }
        }
    }
    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            if (fabs(c[x]) > PRECISION){
                err += 1;
                break;
            }
        }
    }
    #pragma acc exit data copyout(c[0:n])
    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:data,data-region,construct-independent,V:2.5-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];
    int * devtest = (int *)malloc(sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc enter data copyin(c[0:n])
    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }
        }
        #pragma acc exit data delete(c[0:n])
    }
    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
data_copyout_zero.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,executable-data,data-region,V:3.0-3.2
int test1(){

    int err = 0;
    srand(SEED);

    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copyout(zero: b[0:n])
    {
      #pragma acc parallel
      {
        #pragma acc loop
        {
          for (int x = 0; x < n; ++x){
            b[x] += a[x];
          }
        }
      }
    }

    for (int x = 0; x < n; ++x){
        if(fabs(a[x] - b[x]) > PRECISION){
                err += 1;
                break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
data_copyout_zero.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,executable-data,data-region,V:3.0-3.2
int test1(){

    int err = 0;
    srand(SEED);

    real_t * a = new real_t[n];
    real_t * b = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copyout(zero: b[0:n])
    {
      #pragma acc parallel
      {
        #pragma acc loop
        {
          for (int x = 0; x < n; ++x){
            b[x] += a[x];
          }
        }
      }
    }

    for (int x = 0; x < n; ++x){
        if(fabs(a[x] - b[x]) > PRECISION){
                err += 1;
                break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
data_create.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,data-region,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0.0;
        c[x] = 0.0;
    }

    #pragma acc data create(b[0:n])
    {
        #pragma acc data copyin(a[0:n])
        {
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    b[x] = a[x];
                }
            }
        }
        #pragma acc data copyout(c[0:n])
        {
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] = b[x];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - a[x]) > PRECISION) {
            err += 1;
            break;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:data,data-region,construct-independent,compatibility-features,V:1.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0.0;
        c[x] = 0.0;
    }

    #pragma acc data present_or_create(b[0:n])
    {
        #pragma acc data copyin(a[0:n])
        {
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    b[x] = a[x];
                }
            }
        }
        #pragma acc data copyout(c[0:n])
        {
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] = b[x];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - a[x]) > PRECISION) {
            err += 2;
            break;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:data,data-region,construct-independent,compatibility-features,V:1.0-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0.0;
        c[x] = 0.0;
    }

    #pragma acc data pcreate(b[0:n])
    {
        #pragma acc data copyin(a[0:n])
        {
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    b[x] = a[x];
                }
            }
        }
        #pragma acc data copyout(c[0:n])
        {
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] = b[x];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - a[x]) > PRECISION){
            err += 4;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
data_create.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,data-region,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0.0;
        c[x] = 0.0;
    }

    #pragma acc data create(b[0:n])
    {
        #pragma acc data copyin(a[0:n])
        {
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    b[x] = a[x];
                }
            }
        }
        #pragma acc data copyout(c[0:n])
        {
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] = b[x];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - a[x]) > PRECISION) {
            err += 1;
            break;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:data,data-region,construct-independent,compatibility-features,V:1.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0.0;
        c[x] = 0.0;
    }

    #pragma acc data present_or_create(b[0:n])
    {
        #pragma acc data copyin(a[0:n])
        {
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    b[x] = a[x];
                }
            }
        }
        #pragma acc data copyout(c[0:n])
        {
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] = b[x];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - a[x]) > PRECISION) {
            err += 2;
            break;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:data,data-region,construct-independent,compatibility-features,V:1.0-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0.0;
        c[x] = 0.0;
    }

    #pragma acc data pcreate(b[0:n])
    {
        #pragma acc data copyin(a[0:n])
        {
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    b[x] = a[x];
                }
            }
        }
        #pragma acc data copyout(c[0:n])
        {
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] = b[x];
                }
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - a[x]) > PRECISION){
            err += 4;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
data_create_no_lower_bound.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,data-region,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    real_t * d = (real_t *)malloc(n * sizeof(real_t));
    real_t * e = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = 0.0;
    }

    #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) create(c[:n]) copyout(e[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                e[x] = c[x] + d[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
data_create_no_lower_bound.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,data-region,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];
    real_t * d = new real_t[n];
    real_t * e = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = 0.0;
    }

    #pragma acc data copyin(a[0:n], b[0:n], d[0:n]) create(c[:n]) copyout(e[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                e[x] = c[x] + d[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(e[x] - (a[x] + b[x] + d[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
data_create_zero.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,executable-data,data-region,V:3.0-3.2
int test1(){
    int err = 0;
    srand(SEED);

    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 1;
    }

    #pragma acc data copyin(a[0:n]) create(zero: b[0:n]) copyout(b[0:n])
    {
      #pragma acc parallel
      {
        #pragma acc loop
        {
          for (int x = 0; x < n; ++x){
            b[x] += a[x];
          }
        }
      }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int testrun;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
  return failcode;
}
########## NEXT FILE ##########
data_create_zero.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,executable-data,data-region,V:3.0-3.2
int test1(){
    int err = 0;
    srand(SEED);

    real_t * a = new real_t[n];
    real_t * b = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 1;
    }

    #pragma acc data copyin(a[0:n]) create(zero: b[0:n]) copyout(b[0:n])
    {
      #pragma acc parallel
      {
        #pragma acc loop
        {
          for (int x = 0; x < n; ++x){
            b[x] += a[x];
          }
        }
      }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int testrun;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
  return failcode;
}
########## NEXT FILE ##########
data_present_no_lower_bound.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,data-region,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc enter data copyin(c[0:n])
    #pragma acc data copyin(a[0:n], b[0:n]) present(c[:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }
        }
    }
    #pragma acc exit data copyout(c[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
data_present_no_lower_bound.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,data-region,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc enter data copyin(c[0:n])
    #pragma acc data copyin(a[0:n], b[0:n]) present(c[:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }
        }
    }
    #pragma acc exit data copyout(c[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
data_wait.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:async,data,wait,V:3.2-3.3
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc data copy(a[0:n], b[0:n], c[0:n]) async(0)
    {
        #pragma acc parallel loop async(1) wait(0)
        for (int x = 0; x < n; ++x){
            c[x] = a[x] + b[x];
        }

    #pragma acc wait(1) async(0)
    }

    #pragma acc data copy(a[0:n], b[0:n], c[0:n]) wait(0)
    {
        #pragma acc parallel loop
        for (int x = 0; x < n; ++x){
            c[x] += c[x];
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1 
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}


########## NEXT FILE ##########
data_wait.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:async,data,wait,V:3.2-3.3
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc data copy(a[0:n], b[0:n], c[0:n]) async(0)
    {
        #pragma acc parallel loop async(1) wait(0)
        for (int x = 0; x < n; ++x){
            c[x] = a[x] + b[x];
        }

    #pragma acc wait(1) async(0)
    }

    #pragma acc data copy(a[0:n], b[0:n], c[0:n]) wait(0)
    {
        #pragma acc parallel loop
        for (int x = 0; x < n; ++x){
            c[x] += c[x];
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (2 * (a[x] + b[x]))) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1 
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}


########## NEXT FILE ##########
data_with_changing_subscript.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,data-region,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int length = n;
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc data copyin(a[0:length], b[0:length]) copyout(c[0:length])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < length; ++x){
                c[x] = a[x] + b[x];
            }
        }
        length = 1;
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
data_with_changing_subscript.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,data-region,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int length = n;
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc data copyin(a[0:length], b[0:length]) copyout(c[0:length])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < length; ++x){
                c[x] = a[x] + b[x];
            }
        }
        length = 1;
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
data_with_structs.c:::
#include "acc_testsuite.h"
typedef struct multi_item {
    real_t a;
    real_t b;
    real_t c;
} multi_item;

#ifndef T1
//T1:data,data-region,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    multi_item * a = (multi_item *)malloc(n * sizeof(multi_item));

    for (int x = 0; x < n; ++x){
        a[x].a = rand() / (real_t)(RAND_MAX / 10);
        a[x].b = rand() / (real_t)(RAND_MAX / 10);
        a[x].c = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copy(a[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                a[x].c = a[x].a + a[x].b;
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x].c - (a[x].a + a[x].b)) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
data_with_structs.cpp:::
#include "acc_testsuite.h"
typedef struct multi_item {
    real_t a;
    real_t b;
    real_t c;
} multi_item;

#ifndef T1
//T1:data,data-region,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    multi_item * a = new multi_item[n];

    for (int x = 0; x < n; ++x){
        a[x].a = rand() / (real_t)(RAND_MAX / 10);
        a[x].b = rand() / (real_t)(RAND_MAX / 10);
        a[x].c = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copy(a[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                a[x].c = a[x].a + a[x].b;
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x].c - (a[x].a + a[x].b)) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
declare_copyin.c:::
#define DECLARE_TEST
#define DECLARE_COPYIN
int mult_copyin = 2;
#include "acc_testsuite_declare.h"
#include "acc_testsuite.h"

#pragma acc declare copyin(fixed_size_array)
#pragma acc declare copyin(scalar)
#pragma acc declare copyin(datapointer)
#pragma acc declare copyin(n)
#pragma acc routine vector
void multiplyData(real_t *a){
    #pragma acc loop vector
    for (int x = 0; x < n; ++x){
        a[x] = a[x] * 2;
    }
}

#ifndef T1
//T1:declare,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    int mult = 2;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(fixed_size_array)
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x] + fixed_size_array[x%10];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - (a[x] + fixed_size_array[x%10])) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:declare,construct-independent,V:1.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    int mult = 2;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(scalar)
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x] + scalar;
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - (a[x] + scalar)) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:declare,construct-independent,V:2.0-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    int mult = 2;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = a[x];
    }

    #pragma acc data copy(a[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < 1; ++x){
                extern_multiplyData_copyin(a, n);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - (b[x] * 2)) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

#ifndef T4
//T4:declare,construct-independent,V:2.0-2.7
int test4(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    int mult = 2;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = a[x];
    }

    #pragma acc data copy(a[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < 1; ++x){
                multiplyData(a);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - (b[x] * 2)) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

#ifndef T5
//T5:declare,construct-independent,attach,V:2.6-2.7
int test5(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    int mult = 2;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = a[x];
    }

    datapointer = a;
    #pragma acc enter data copyin(a[0:n]) attach(datapointer)
    #pragma acc data present(datapointer[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                datapointer[x] = datapointer[x] * 2;
            }
        }
    }
    #pragma acc exit data copyout(a[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - (b[x] * 2)) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
#ifndef T5
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test5();
    }
    if (failed != 0){
        failcode = failcode + (1 << 4);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
declare_copyin.cpp:::
#define DECLARE_TEST
#define DECLARE_COPYIN
int mult_copyin = 2;
#include "acc_testsuite_declare.h"
#include "acc_testsuite.h"

#pragma acc declare copyin(fixed_size_array)
#pragma acc declare copyin(scalar)
#pragma acc declare copyin(datapointer)
#pragma acc declare copyin(n)
#pragma acc routine vector
void multiplyData(real_t *a){
    #pragma acc loop vector
    for (int x = 0; x < n; ++x){
        a[x] = a[x] * 2;
    }
}

#ifndef T1
//T1:declare,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    int mult = 2;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0;
    }
    #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(fixed_size_array)
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x] + fixed_size_array[x%10];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - (a[x] + fixed_size_array[x%10])) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:declare,construct-independent,V:1.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    int mult = 2;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(scalar)
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x] + scalar;
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - (a[x] + scalar)) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:declare,construct-independent,V:2.0-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    int mult = 2;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = a[x];
    }

    #pragma acc data copy(a[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < 1; ++x){
                extern_multiplyData_copyin(a, n);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - (b[x] * 2)) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

#ifndef T4
//T4:declare,construct-independent,V:2.0-2.7
int test4(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    int mult = 2;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = a[x];
    }

    #pragma acc data copy(a[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < 1; ++x){
                multiplyData(a);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - (b[x] * 2)) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

#ifndef T5
//T5:declare,construct-independent,attach,V:2.6-2.7
int test5(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    int mult = 2;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = a[x];
    }

    datapointer = a;
    #pragma acc enter data copyin(a[0:n]) attach(datapointer)
    #pragma acc data present(datapointer[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                datapointer[x] = datapointer[x] * 2;
            }
        }
    }
    #pragma acc exit data copyout(a[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - (b[x] * 2)) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
#ifndef T5
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test5();
    }
    if (failed != 0){
        failcode = failcode + (1 << 4);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
declare_create.c:::
#define DECLARE_CREATE 1
#include "acc_testsuite_declare.h"
real_t scalar = 2;
real_t* a;

#pragma acc declare create(scalar, a[0:n], n)
#pragma acc update device(n)

void multiply_scalar(real_t* a){
    #pragma acc parallel loop present(a[0:n])
    for(int x = 0; x < n; ++x){
        a[x] += 1;
    }
}

#pragma acc routine vector
void multiply_scalar_routine(real_t* a){
    #pragma acc loop vector
    for(int x = 0; x < n; ++x){
        a[x] += 1;
    }
    #pragma acc update host(a[0:n])
}


#ifndef T1
//T1:declare,construct-independent,V:1.0-3.3
int test1(){
    int err = 0;
    srand(SEED);
    a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    #pragma acc enter data create(a[0:n])

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = a[x] * 2;
    }
    #pragma acc update device(a[0:n])

    #pragma acc data copy(c[0:n]) present(a[0:n]) 
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] * 2;
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - c[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    free(b);
    free(c);

    return err;
}
#endif

#ifndef T2
//T2:declare,construct-independent,V:1.0-3.3
int test2(){
    int err = 0;
    srand(SEED);
    real_t* local_a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        local_a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = local_a[x] * scalar;
    }

    #pragma acc update device(scalar)

    #pragma acc data copy(local_a[0:n], c[0:n]) present(scalar) 
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = local_a[x] * scalar;
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - c[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    free(local_a);
    free(b);
    free(c);

    return err;
}
#endif

#ifndef T3
//T3:declare,construct-independent,V:1.0-3.3
int test3(){
    int err = 0;
    srand(SEED);
    a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));

    #pragma acc enter data create(a[0:n])

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = a[x] + 1;
    }

    #pragma acc update device(a[0:n])

    multiply_scalar(a);

    #pragma acc update host(a[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - a[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    free(b);

    return err;
}
#endif


#ifndef T4
//T4:declare,construct-independent,V:1.0-3.3
int test4(){
    int err = 0;
    srand(SEED);
    a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    #pragma acc enter data create(a[0:n])

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = a[x] * 2;
    }
    #pragma acc update device(a[0:n])

    extern_multiplyData(a);

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - a[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    free(b);
    free(c);

    return err;
}
#endif

#ifndef T5
//T5:declare,construct-independent,V:1.0-3.3
int test5(){
    int err = 0;
    srand(SEED);
    a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    #pragma acc enter data create(a[0:n])

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = a[x] * mult_create;
    }
    #pragma acc update device(a[0:n], mult_create)

    #pragma acc data copy(c[0:n]) present(a[0:n], mult_create)
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] * mult_create;
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - c[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    free(b);
    free(c);

    return err;
}
#endif

#ifndef T6
//T6:declare,construct-independent,V:1.0-3.3
int test6(){
    int err = 0;
    srand(SEED);
    a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));

    #pragma acc enter data create(a[0:n])

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = a[x] + 1;
    }

    #pragma acc update device(a[0:n])

    multiply_scalar_routine(a);

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - a[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    free(b);

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
#ifndef T5
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test5();
    }
    if (failed != 0){
        failcode = failcode + (1 << 4);
    }
#endif
#ifndef T6
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test6();
    }
    if (failed != 0){
        failcode = failcode + (1 << 5);
    }
#endif
    free(a);
    return failcode;
}
########## NEXT FILE ##########
declare_create.cpp:::
#define DECLARE_CREATE 1
#include "acc_testsuite_declare.h"
real_t scalar = 2;
real_t* a;

#pragma acc declare create(scalar, a[0:n], n)
#pragma acc update device(n)

void multiply_scalar(real_t* a){
    #pragma acc parallel loop present(a[0:n])
    for(int x = 0; x < n; ++x){
        a[x] += 1;
    }
}

#pragma acc routine vector
void multiply_scalar_routine(real_t* a){
    #pragma acc loop vector
    for(int x = 0; x < n; ++x){
        a[x] += 1;
    }
    #pragma acc update host(a[0:n])
}


#ifndef T1
//T1:declare,construct-independent,V:1.0-3.3
int test1(){
    int err = 0;
    srand(SEED);
    a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];


    #pragma acc enter data create(a[0:n])

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = a[x] * 2;
    }
    #pragma acc update device(a[0:n])

    #pragma acc data copy(c[0:n]) present(a[0:n]) 
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] * 2;
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - c[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    delete[] b;
    delete[] c;

    return err;
}
#endif

#ifndef T2
//T2:declare,construct-independent,V:1.0-3.3
int test2(){
    int err = 0;
    srand(SEED);
    real_t* local_a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        local_a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = local_a[x] * scalar;
    }

    #pragma acc update device(scalar)

    #pragma acc data copy(local_a[0:n], c[0:n]) present(scalar) 
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = local_a[x] * scalar;
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - c[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    delete[] local_a;
    delete[] b;
    delete[] c;

    return err;
}
#endif

#ifndef T3
//T3:declare,construct-independent,V:1.0-3.3
int test3(){
    int err = 0;
    srand(SEED);
    a = new real_t[n];
    real_t * b = new real_t[n];
    
    #pragma acc enter data create(a[0:n])

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = a[x] + 1;
    }

    #pragma acc update device(a[0:n])

    multiply_scalar(a);
    
    #pragma acc update host(a[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - a[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    delete[] b;

    return err;
}
#endif


#ifndef T4
//T4:declare,construct-independent,V:1.0-3.3
int test4(){
    int err = 0;
    srand(SEED);
    a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    #pragma acc enter data create(a[0:n])

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = a[x] * 2;
    }
    #pragma acc update device(a[0:n])

    extern_multiplyData(a);

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - a[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    delete[] b;
    delete[] c;

    return err;
}
#endif

#ifndef T5
//T5:declare,construct-independent,V:1.0-3.3
int test5(){
    int err = 0;
    srand(SEED);
    a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    #pragma acc enter data create(a[0:n])

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = a[x] * mult_create;
    }
    #pragma acc update device(a[0:n], mult_create)

    #pragma acc data copy(c[0:n]) present(a[0:n], mult_create) 
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] * mult_create;
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - c[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    delete[] b;
    delete[] c;

    return err;
}
#endif

#ifndef T6
//T6:declare,construct-independent,V:1.0-3.3
int test6(){
    int err = 0;
    srand(SEED);
   a = new real_t[n];
    real_t * b = new real_t[n];
    
    #pragma acc enter data create(a[0:n])

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = a[x] + 1;
    }

    #pragma acc update device(a[0:n])

    multiply_scalar_routine(a);
    
    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - a[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    delete[] b;

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
#ifndef T5
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test5();
    }
    if (failed != 0){
        failcode = failcode + (1 << 4);
    }
#endif
#ifndef T6
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test6();
    }
    if (failed != 0){
        failcode = failcode + (1 << 5);
    }
#endif
    delete[] a;
    return failcode;
}

########## NEXT FILE ##########
declare_device_resident.c:::
#include "acc_testsuite.h"
#define DECLARE_TEST
#define DECLARE_DEVICE_RESIDENT
#include "acc_testsuite_declare.h"
#pragma acc declare device_resident(fixed_size_array)
#pragma acc declare device_resident(scalar)
#pragma acc declare device_resident(datapointer)

int mult_device_resident = 5;

#ifndef T1
//T1:declare,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    int mult = 2;

    #pragma acc parallel
    {
      mult_device_resident = 2;
      scalar = 10;
      for (int x = 0; x < 10; ++x){
        fixed_size_array[x] = x*x;
      }
    }

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(fixed_size_array)
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < 10; ++x){
                fixed_size_array[x] = x*x;
            }
        }
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x] + fixed_size_array[x%10];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - (a[x] + (x%10) * (x%10))) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:declare,construct-independent,V:1.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    int mult = 2;

    #pragma acc parallel
    {
      mult_device_resident = 2;
      scalar = 10;
      for (int x = 0; x < 10; ++x){
        fixed_size_array[x] = x*x;
      }
    }

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x] + scalar;
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - (a[x] + 10)) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:declare,construct-independent,V:2.0-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    int mult = 2;

    #pragma acc parallel
    {
      mult_device_resident = 2;
      scalar = 10;
      for (int x = 0; x < 10; ++x){
        fixed_size_array[x] = x*x;
      }
    }

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = a[x];
    }

    #pragma acc data copy(a[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < 1; ++x){
                extern_multiplyData_device_resident(a, n);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - (b[x] * 2)) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
declare_device_resident.cpp:::
#include "acc_testsuite.h"
#define DECLARE_TEST
#define DECLARE_DEVICE_RESIDENT
#include "acc_testsuite_declare.h"
#pragma acc declare device_resident(fixed_size_array)
#pragma acc declare device_resident(scalar)
#pragma acc declare device_resident(datapointer)

int mult_device_resident = 5;

#ifndef T1
//T1:declare,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    int mult = 2;

    #pragma acc parallel
    {
      mult_device_resident = 2;
      scalar = 10;
      for (int x = 0; x < 10; ++x){
        fixed_size_array[x] = x*x;
      }
    }

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copyout(b[0:n]) present(fixed_size_array)
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < 10; ++x){
                fixed_size_array[x] = x*x;
            }
        }
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x] + fixed_size_array[x%10];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - (a[x] + (x%10) * (x%10))) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:declare,construct-independent,V:1.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    int mult = 2;

    #pragma acc parallel
    {
      mult_device_resident = 2;
      scalar = 10;
      for (int x = 0; x < 10; ++x){
        fixed_size_array[x] = x*x;
      }
    }

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copyout(b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x] + scalar;
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - (a[x] + 10)) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:declare,construct-independent,V:2.0-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    int mult = 2;

    #pragma acc parallel
    {
      mult_device_resident = 2;
      scalar = 10;
      for (int x = 0; x < 10; ++x){
        fixed_size_array[x] = x*x;
      }
    }

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = a[x];
    }

    #pragma acc data copy(a[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < 1; ++x){
                extern_multiplyData_device_resident(a, n);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - (b[x] * 2)) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
declare_function_scope_copy.c:::
#include "acc_testsuite.h"
void copyin_copyout_test(real_t *a, real_t *b, real_t *c){
    #pragma acc declare copy(c[0:n])
    #pragma acc parallel present(a[0:n], b[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = c[x] + a[x] + b[x];
        }
    }
}

#ifndef T1
//T1:declare,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = (real_t *)malloc(n * sizeof(real_t));
        b[x] = (real_t *)malloc(n * sizeof(real_t));
        c[x] = (real_t *)malloc(n * sizeof(real_t));
        for (int y = 0; y < n; ++y){
            a[x][y] = rand() / (real_t)(RAND_MAX / 10);
            b[x][y] = rand() / (real_t)(RAND_MAX / 10);
            c[x][y] = 1;
        }
    }
    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])
    {
        for (int x = 0; x < n; ++x){
            copyin_copyout_test(a[x], b[x], c[x]);
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:declare,construct-independent,reference-counting,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            a[x][y] = rand() / (real_t)(RAND_MAX / 10);
            b[x][y] = rand() / (real_t)(RAND_MAX / 10);
            c[x][y] = 2;
        }
    }

    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])
    {
        for (int x = 0; x < n; ++x){
            #pragma acc data copy(c[x:1][0:n])
            {
                copyin_copyout_test(a[x], b[x], c[x]);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            if (fabs(c[x][y] - (2 + a[x][y] + b[x][y])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:declare,construct-independent,devonly,reference-counting,V:2.5-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));
    int *devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            for (int y = 0; y < n; ++y){
                a[x][y] = rand() / (real_t)(RAND_MAX / 10);
                b[x][y] = rand() / (real_t)(RAND_MAX / 10);
                c[x][y] = 3;
            }
        }

        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])
        {
            for (int x = 0; x < n; ++x){
                #pragma acc data copyin(c[x:1][0:n])
                {
                    copyin_copyout_test(a[x], b[x], c[x]);
                    for (int y = 0; y < n; ++y){
                        if (fabs(c[x][y] - 3) > PRECISION){
                            err += 1;
                        }
                    }
                }
                for (int y = 0; y < n; ++y){
                    if (fabs(c[x][y] - 3) > PRECISION){
                        err += 1;
                    }
                }
            }
        }
    }

    return err;
}
#endif

#ifndef T4
//T4:declare,construct-independent,devonly,reference-counting,V:2.5-2.7
int test4(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));
    int *devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[1] == 1){
        for (int x = 0; x < n; ++x){
            for (int y = 0; y < n; ++y){
                a[x][y] = rand() / (real_t)(RAND_MAX / 10);
                b[x][y] = rand() / (real_t)(RAND_MAX / 10);
                c[x][y] = 4;
            }
        }

        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])
        {
            for (int x = 0; x < n; ++x){
                #pragma acc data copy(c[x:1][0:n])
                {
                    copyin_copyout_test(a[x], b[x], c[x]);
                    for (int y = 0; y < n; ++y){
                        if (fabs(c[x][y] - 4) > PRECISION){
                            err += 1;
                        }
                    }
                }
                for (int y = 0; y < n; ++y){
                    if (fabs(c[x][y] - (4 + a[x][y] + b[x][y])) > PRECISION){
                        err += 1;
                    }
                }
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
declare_function_scope_copy.cpp:::
#include "acc_testsuite.h"
void copyin_copyout_test(real_t *a, real_t *b, real_t *c){
    #pragma acc declare copy(c[0:n])
    #pragma acc parallel present(a[0:n], b[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = c[x] + a[x] + b[x];
        }
    }
}

#ifndef T1
//T1:declare,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = new real_t[n];
        b[x] = new real_t[n];
        c[x] = new real_t[n];
        for (int y = 0; y < n; ++y){
            a[x][y] = rand() / (real_t)(RAND_MAX / 10);
            b[x][y] = rand() / (real_t)(RAND_MAX / 10);
            c[x][y] = 1;
        }
    }
    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])
    {
        for (int x = 0; x < n; ++x){
            copyin_copyout_test(a[x], b[x], c[x]);
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:declare,construct-independent,reference-counting,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            a[x][y] = rand() / (real_t)(RAND_MAX / 10);
            b[x][y] = rand() / (real_t)(RAND_MAX / 10);
            c[x][y] = 2;
        }
    }

    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])
    {
        for (int x = 0; x < n; ++x){
            #pragma acc data copy(c[x:1][0:n])
            {
                copyin_copyout_test(a[x], b[x], c[x]);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            if (fabs(c[x][y] - (2 + a[x][y] + b[x][y])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:declare,construct-independent,devonly,reference-counting,V:2.5-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));
    int *devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            for (int y = 0; y < n; ++y){
                a[x][y] = rand() / (real_t)(RAND_MAX / 10);
                b[x][y] = rand() / (real_t)(RAND_MAX / 10);
                c[x][y] = 3;
            }
        }

        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])
        {
            for (int x = 0; x < n; ++x){
                #pragma acc data copyin(c[x:1][0:n])
                {
                    copyin_copyout_test(a[x], b[x], c[x]);
                    for (int y = 0; y < n; ++y){
                        if (fabs(c[x][y] - 3) > PRECISION){
                            err += 1;
                        }
                    }
                }
                for (int y = 0; y < n; ++y){
                    if (fabs(c[x][y] - 3) > PRECISION){
                        err += 1;
                    }
                }
            }
        }
    }

    return err;
}
#endif

#ifndef T4
//T4:declare,construct-independent,devonly,reference-counting,V:2.5-2.7
int test4(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));
    int *devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[1] == 1){
        for (int x = 0; x < n; ++x){
            for (int y = 0; y < n; ++y){
                a[x][y] = rand() / (real_t)(RAND_MAX / 10);
                b[x][y] = rand() / (real_t)(RAND_MAX / 10);
                c[x][y] = 4;
            }
        }

        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])
        {
            for (int x = 0; x < n; ++x){
                #pragma acc data copy(c[x:1][0:n])
                {
                    copyin_copyout_test(a[x], b[x], c[x]);
                    for (int y = 0; y < n; ++y){
                        if (fabs(c[x][y] - 4) > PRECISION){
                            err += 1;
                        }
                    }
                }
                for (int y = 0; y < n; ++y){
                    if (fabs(c[x][y] - (4 + a[x][y] + b[x][y])) > PRECISION){
                        err += 1;
                    }
                }
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
declare_function_scope_copyin.c:::
#include "acc_testsuite.h"
void function_test(real_t *a, real_t *b, real_t *c){
    #pragma acc declare copyin(a[0:n], b[0:n])
    #pragma acc parallel present(c[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = c[x] + a[x] + b[x];
        }
    }
}

void function_test_dev_only(real_t * a, real_t * b, real_t *c){
    #pragma acc declare copyin(a[0:n], b[0:n])
    #pragma acc parallel present(c[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = c[x] + a[x] + b[x];
            a[x] = -1;
            b[x] = -1;
        }
    }
}

#ifndef T1
//T1:declare,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = (real_t *)malloc(n * sizeof(real_t));
        b[x] = (real_t *)malloc(n * sizeof(real_t));
        c[x] = (real_t *)malloc(n * sizeof(real_t));
        for (int y = 0; y < n; ++y){
            a[x][y] = rand() / (real_t)(RAND_MAX / 10);
            b[x][y] = rand() / (real_t)(RAND_MAX / 10);
            c[x][y] = 1;
        }
    }

    #pragma acc data copy(c[0:n][0:n])
    {
        for (int x = 0; x < n; ++x){
            function_test(a[x], b[x], c[x]);
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:declare,construct-independent,devonly,reference-counting,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));
    int * devtest = (int *)malloc(sizeof(int));
    real_t ** a_host = (real_t **)malloc(n * sizeof(real_t *));
    real_t ** b_host = (real_t **)malloc(n * sizeof(real_t *));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a_host[x] = (real_t *)malloc(n * sizeof(real_t));
            b_host[x] = (real_t *)malloc(n * sizeof(real_t));
            for (int y = 0; y < n; ++y){
                a[x][y] = rand() / (real_t)(RAND_MAX / 10);
                a_host[x][y] = a[x][y];
                b[x][y] = rand() / (real_t)(RAND_MAX / 10);
                b_host[x][y] = b[x][y];
                c[x][y] = 0;
            }
        }

        #pragma acc data copy(a[0:n][0:n], b[0:n][0:n], c[0:n][0:n])
        {
            for (int x = 0; x < n; ++x){
                function_test_dev_only(a[x], b[x], c[x]);
            }
        }

        for (int x = 0; x < n; ++x){
            for (int y = 0; y < n; ++y){
                if (fabs(a[x][y] + 1) > PRECISION){
                    err += 1;
                }
                if (fabs(b[x][y] + 1) > PRECISION){
                    err += 1;
                }
                if (fabs(c[x][y] - (a_host[x][y] + b_host[x][y])) > PRECISION){
                    err += 1;
                }
            }
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:declare,construct-independent,devonly,V:2.0-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));
    int * devtest = (int *)malloc(sizeof(int));
    real_t ** a_host = (real_t **)malloc(n * sizeof(real_t *));
    real_t ** b_host = (real_t **)malloc(n * sizeof(real_t *));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            for (int y = 0; y < n; ++y){
                a[x][y] = rand() / (real_t)(RAND_MAX / 10);
                a_host[x][y] = a[x][y];
                b[x][y] = rand() / (real_t)(RAND_MAX / 10);
                b_host[x][y] = b[x][y];
                c[x][y] = 1;
            }
        }

        #pragma acc data copy(c[0:n][0:n])
        {
            for (int x = 0; x < n; ++x){
                function_test_dev_only(a[x], b[x], c[x]);
            }
        }

        for (int x = 0; x < n; ++x){
            for (int y = 0; y < n; ++y){
                if (fabs(a[x][y] - a_host[x][y]) > PRECISION){
                    err += 1;
                }
                if (fabs(b[x][y] - b_host[x][y]) > PRECISION){
                    err += 1;
                }
                if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){
                    err += 1;
                }
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
declare_function_scope_copyin.cpp:::
#include "acc_testsuite.h"
void function_test(real_t *a, real_t *b, real_t *c){
    #pragma acc declare copyin(a[0:n], b[0:n])
    #pragma acc parallel present(c[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = c[x] + a[x] + b[x];
        }
    }
}

void function_test_dev_only(real_t * a, real_t * b, real_t *c){
    #pragma acc declare copyin(a[0:n], b[0:n])
    #pragma acc parallel present(c[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = c[x] + a[x] + b[x];
            a[x] = -1;
            b[x] = -1;
        }
    }
}

#ifndef T1
//T1:declare,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = new real_t[n];
        b[x] = new real_t[n];
        c[x] = new real_t[n];
        for (int y = 0; y < n; ++y){
            a[x][y] = rand() / (real_t)(RAND_MAX / 10);
            b[x][y] = rand() / (real_t)(RAND_MAX / 10);
            c[x][y] = 1;
        }
    }

    #pragma acc data copy(c[0:n][0:n])
    {
        for (int x = 0; x < n; ++x){
            function_test(a[x], b[x], c[x]);
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:declare,construct-independent,devonly,reference-counting,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));
    int * devtest = (int *)malloc(sizeof(int));
    real_t ** a_host = (real_t **)malloc(n * sizeof(real_t *));
    real_t ** b_host = (real_t **)malloc(n * sizeof(real_t *));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a_host[x] = new real_t[n];
            b_host[x] = new real_t[n];
            for (int y = 0; y < n; ++y){
                a[x][y] = rand() / (real_t)(RAND_MAX / 10);
                a_host[x][y] = a[x][y];
                b[x][y] = rand() / (real_t)(RAND_MAX / 10);
                b_host[x][y] = b[x][y];
                c[x][y] = 0;
            }
        }

        #pragma acc data copy(a[0:n][0:n], b[0:n][0:n], c[0:n][0:n])
        {
            for (int x = 0; x < n; ++x){
                function_test_dev_only(a[x], b[x], c[x]);
            }
        }

        for (int x = 0; x < n; ++x){
            for (int y = 0; y < n; ++y){
                if (fabs(a[x][y] + 1) > PRECISION){
                    err += 1;
                }
                if (fabs(b[x][y] + 1) > PRECISION){
                    err += 1;
                }
                if (fabs(c[x][y] - (a_host[x][y] + b_host[x][y])) > PRECISION){
                    err += 1;
                }
            }
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:declare,construct-independent,devonly,V:2.0-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));
    int * devtest = (int *)malloc(sizeof(int));
    real_t ** a_host = (real_t **)malloc(n * sizeof(real_t *));
    real_t ** b_host = (real_t **)malloc(n * sizeof(real_t *));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            for (int y = 0; y < n; ++y){
                a[x][y] = rand() / (real_t)(RAND_MAX / 10);
                a_host[x][y] = a[x][y];
                b[x][y] = rand() / (real_t)(RAND_MAX / 10);
                b_host[x][y] = b[x][y];
                c[x][y] = 1;
            }
        }

        #pragma acc data copy(c[0:n][0:n])
        {
            for (int x = 0; x < n; ++x){
                function_test_dev_only(a[x], b[x], c[x]);
            }
        }

        for (int x = 0; x < n; ++x){
            for (int y = 0; y < n; ++y){
                if (fabs(a[x][y] - a_host[x][y]) > PRECISION){
                    err += 1;
                }
                if (fabs(b[x][y] - b_host[x][y]) > PRECISION){
                    err += 1;
                }
                if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){
                    err += 1;
                }
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
declare_function_scope_copyout.c:::
#include "acc_testsuite.h"
void copyout_test(real_t *a, real_t *b, real_t *c){
    #pragma acc declare copyout(c[0:n])
    #pragma acc parallel present(a[0:n], b[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = a[x] + b[x];
        }
    }
}

#ifndef T1
//T1:declare,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = (real_t *)malloc(n * sizeof(real_t));
        b[x] = (real_t *)malloc(n * sizeof(real_t));
        c[x] = (real_t *)malloc(n * sizeof(real_t));
        for (int y = 0; y < n; ++y){
            a[x][y] = rand() / (real_t)(RAND_MAX / 10);
            b[x][y] = rand() / (real_t)(RAND_MAX / 10);
            c[x][y] = 1;
        }
    }
    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])
    {
        for (int x = 0; x < n; ++x){
            copyout_test(a[x], b[x], c[x]);
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            if (fabs(c[x][y] - (a[x][y] + b[x][y])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:declare,construct-independent,reference-counting,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            a[x][y] = rand() / (real_t)(RAND_MAX / 10);
            b[x][y] = rand() / (real_t)(RAND_MAX / 10);
            c[x][y] = 2;
        }
    }

    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])
    {
        for (int x = 0; x < n; ++x){
            #pragma acc data copy(c[x:1][0:n])
            {
                copyout_test(a[x], b[x], c[x]);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            if (fabs(c[x][y] - (a[x][y] + b[x][y])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:declare,construct-independent,devonly,reference-counting,V:2.5-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));
    int *devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            for (int y = 0; y < n; ++y){
                a[x][y] = rand() / (real_t)(RAND_MAX / 10);
                b[x][y] = rand() / (real_t)(RAND_MAX / 10);
                c[x][y] = 3;
            }
        }

        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])
        {
            for (int x = 0; x < n; ++x){
                #pragma acc data copyin(c[x:1][0:n])
                {
                    copyout_test(a[x], b[x], c[x]);
                    for (int y = 0; y < n; ++y){
                        if (fabs(c[x][y] - 3) > PRECISION){
                            err += 1;
                        }
                    }
                }
                for (int y = 0; y < n; ++y){
                    if (fabs(c[x][y] - 3) > PRECISION){
                        err += 1;
                    }
                }
            }
        }
    }

    return err;
}
#endif

#ifndef T4
//T4:declare,construct-independent,devonly,reference-counting,V:2.5-2.7
int test4(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));
    int *devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            for (int y = 0; y < n; ++y){
                a[x][y] = rand() / (real_t)(RAND_MAX / 10);
                b[x][y] = rand() / (real_t)(RAND_MAX / 10);
                c[x][y] = 4;
            }
        }

        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])
        {
            for (int x = 0; x < n; ++x){
                #pragma acc data copy(c[x:1][0:n])
                {
                    copyout_test(a[x], b[x], c[x]);
                    for (int y = 0; y < n; ++y){
                        if (fabs(c[x][y] - 4) > PRECISION){
                            err += 1;
                        }
                    }
                }
                for (int y = 0; y < n; ++y){
                    if (fabs(c[x][y] - (a[x][y] + b[x][y])) > PRECISION){
                        err += 1;
                    }
                }
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
declare_function_scope_copyout.cpp:::
#include "acc_testsuite.h"
void copyout_test(real_t *a, real_t *b, real_t *c){
    #pragma acc declare copyout(c[0:n])
    #pragma acc parallel present(a[0:n], b[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = a[x] + b[x];
        }
    }
}

#ifndef T1
//T1:declare,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = new real_t[n];
        b[x] = new real_t[n];
        c[x] = new real_t[n];
        for (int y = 0; y < n; ++y){
            a[x][y] = rand() / (real_t)(RAND_MAX / 10);
            b[x][y] = rand() / (real_t)(RAND_MAX / 10);
            c[x][y] = 1;
        }
    }
    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])
    {
        for (int x = 0; x < n; ++x){
            copyout_test(a[x], b[x], c[x]);
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            if (fabs(c[x][y] - (a[x][y] + b[x][y])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:declare,construct-independent,reference-counting,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            a[x][y] = rand() / (real_t)(RAND_MAX / 10);
            b[x][y] = rand() / (real_t)(RAND_MAX / 10);
            c[x][y] = 2;
        }
    }

    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])
    {
        for (int x = 0; x < n; ++x){
            #pragma acc data copy(c[x:1][0:n])
            {
                copyout_test(a[x], b[x], c[x]);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            if (fabs(c[x][y] - (a[x][y] + b[x][y])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:declare,construct-independent,devonly,reference-counting,V:2.5-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));
    int *devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            for (int y = 0; y < n; ++y){
                a[x][y] = rand() / (real_t)(RAND_MAX / 10);
                b[x][y] = rand() / (real_t)(RAND_MAX / 10);
                c[x][y] = 3;
            }
        }

        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])
        {
            for (int x = 0; x < n; ++x){
                #pragma acc data copyin(c[x:1][0:n])
                {
                    copyout_test(a[x], b[x], c[x]);
                    for (int y = 0; y < n; ++y){
                        if (fabs(c[x][y] - 3) > PRECISION){
                            err += 1;
                        }
                    }
                }
                for (int y = 0; y < n; ++y){
                    if (fabs(c[x][y] - 3) > PRECISION){
                        err += 1;
                    }
                }
            }
        }
    }

    return err;
}
#endif

#ifndef T4
//T4:declare,construct-independent,devonly,reference-counting,V:2.5-2.7
int test4(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));
    int *devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            for (int y = 0; y < n; ++y){
                a[x][y] = rand() / (real_t)(RAND_MAX / 10);
                b[x][y] = rand() / (real_t)(RAND_MAX / 10);
                c[x][y] = 4;
            }
        }

        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])
        {
            for (int x = 0; x < n; ++x){
                #pragma acc data copy(c[x:1][0:n])
                {
                    copyout_test(a[x], b[x], c[x]);
                    for (int y = 0; y < n; ++y){
                        if (fabs(c[x][y] - 4) > PRECISION){
                            err += 1;
                        }
                    }
                }
                for (int y = 0; y < n; ++y){
                    if (fabs(c[x][y] - (a[x][y] + b[x][y])) > PRECISION){
                        err += 1;
                    }
                }
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
declare_function_scope_create.c:::
#include "acc_testsuite.h"
void create_test(real_t *a, real_t *b, real_t *c, real_t *d){
    #pragma acc declare create(c[0:n])
    #pragma acc parallel present(a[0:n], b[0:n], d[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = a[x] + b[x];
        }
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            d[x] = c[x] * a[x];
        }
    }
}

void create_as_present(real_t *a, real_t *b, real_t *c, real_t *d){
    #pragma acc declare create(c[0:n])
    #pragma acc parallel present(a[0:n], b[0:n], d[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = c[x] + a[x] + b[x];
        }
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            d[x] = c[x] * a[x];
        }
    }
}

#ifndef T1
//T1:declare,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));
    real_t ** d = (real_t **)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = (real_t *)malloc(n * sizeof(real_t));
        b[x] = (real_t *)malloc(n * sizeof(real_t));
        c[x] = (real_t *)malloc(n * sizeof(real_t));
        d[x] = (real_t *)malloc(n * sizeof(real_t));
        for (int y = 0; y < n; ++y){
            a[x][y] = rand() / (real_t)(RAND_MAX / 10);
            b[x][y] = rand() / (real_t)(RAND_MAX / 10);
            c[x][y] = 1;
            d[x][y] = 0;
        }
    }
    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n]) copyout(d[0:n][0:n])
    {
        for (int x = 0; x < n; ++x){
            create_test(a[x], b[x], c[x], d[x]);
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            if (fabs(d[x][y] - (a[x][y] * (a[x][y] + b[x][y]))) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:declare,construct-independent,V:2.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));
    real_t ** d = (real_t **)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            a[x][y] = rand() / (real_t)(RAND_MAX / 10);
            b[x][y] = rand() / (real_t)(RAND_MAX / 10);
            c[x][y] = 2;
            d[x][y] = 0;
        }
    }

    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n]) copy(c[0:n][0:n]) copyout(d[0:n][0:n])
    {
        for (int x = 0; x < n; ++x){
            create_as_present(a[x], b[x], c[x], d[x]);
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            if (fabs(c[x][y] - (2 + a[x][y] + b[x][y])) > PRECISION){
                err += 1;
            }
            if (fabs(d[x][y] - (a[x][y] * c[x][y])) > PRECISION * 2){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:declare,construct-independent,devonly,V:2.0-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));
    real_t ** d = (real_t **)malloc(n * sizeof(real_t));
    int *devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            for (int y = 0; y < n; ++y){
                a[x][y] = rand() / (real_t)(RAND_MAX / 10);
                b[x][y] = rand() / (real_t)(RAND_MAX / 10);
                c[x][y] = 3;
            }
        }

        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])
        {
            for (int x = 0; x < n; ++x){
                #pragma acc data copyin(c[x:1][0:n]) copyout(d[x:1][0:n])
                {
                    create_as_present(a[x], b[x], c[x], d[x]);
                }
                for (int y = 0; y < n; ++y){
                    if (fabs(c[x][y] - 3) > PRECISION){
                        err += 1;
                    }
                }
                for (int y = 0; y < n; ++y){
                    if (fabs(d[x][y] - (a[x][y] * (3 + a[x][y] + b[x][y]))) > PRECISION * 2){
                        err += 1;
                    }
                }
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
declare_function_scope_create.cpp:::
#include "acc_testsuite.h"
void create_test(real_t *a, real_t *b, real_t *c, real_t *d){
    #pragma acc declare create(c[0:n])
    #pragma acc parallel present(a[0:n], b[0:n], d[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = a[x] + b[x];
        }
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            d[x] = c[x] * a[x];
        }
    }
}

void create_as_present(real_t *a, real_t *b, real_t *c, real_t *d){
    #pragma acc declare create(c[0:n])
    #pragma acc parallel present(a[0:n], b[0:n], d[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = c[x] + a[x] + b[x];
        }
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            d[x] = c[x] * a[x];
        }
    }
}

#ifndef T1
//T1:declare,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));
    real_t ** d = (real_t **)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = new real_t[n];
        b[x] = new real_t[n];
        c[x] = new real_t[n];
        d[x] = new real_t[n];
        for (int y = 0; y < n; ++y){
            a[x][y] = rand() / (real_t)(RAND_MAX / 10);
            b[x][y] = rand() / (real_t)(RAND_MAX / 10);
            c[x][y] = 1;
            d[x][y] = 0;
        }
    }
    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n]) copyout(d[0:n][0:n])
    {
        for (int x = 0; x < n; ++x){
            create_test(a[x], b[x], c[x], d[x]);
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            if (fabs(d[x][y] - (a[x][y] * (a[x][y] + b[x][y]))) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:declare,construct-independent,V:2.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));
    real_t ** d = (real_t **)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            a[x][y] = rand() / (real_t)(RAND_MAX / 10);
            b[x][y] = rand() / (real_t)(RAND_MAX / 10);
            c[x][y] = 2;
            d[x][y] = 0;
        }
    }

    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n]) copy(c[0:n][0:n]) copyout(d[0:n][0:n])
    {
        for (int x = 0; x < n; ++x){
            create_as_present(a[x], b[x], c[x], d[x]);
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            if (fabs(c[x][y] - (2 + a[x][y] + b[x][y])) > PRECISION){
                err += 1;
            }
            if (fabs(d[x][y] - (a[x][y] * c[x][y])) > PRECISION * 2){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:declare,construct-independent,devonly,V:2.0-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));
    real_t ** d = (real_t **)malloc(n * sizeof(real_t));
    int *devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            for (int y = 0; y < n; ++y){
                a[x][y] = rand() / (real_t)(RAND_MAX / 10);
                b[x][y] = rand() / (real_t)(RAND_MAX / 10);
                c[x][y] = 3;
            }
        }

        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])
        {
            for (int x = 0; x < n; ++x){
                #pragma acc data copyin(c[x:1][0:n]) copyout(d[x:1][0:n])
                {
                    create_as_present(a[x], b[x], c[x], d[x]);
                }
                for (int y = 0; y < n; ++y){
                    if (fabs(c[x][y] - 3) > PRECISION){
                        err += 1;
                    }
                }
                for (int y = 0; y < n; ++y){
                    if (fabs(d[x][y] - (a[x][y] * (3 + a[x][y] + b[x][y]))) > PRECISION * 2){
                        err += 1;
                    }
                }
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
declare_function_scope_deviceptr.c:::
#include "acc_testsuite.h"
void declare_deviceptr(real_t *a, real_t *b, real_t *c, real_t *d){
    #pragma acc declare deviceptr(c)
    #pragma acc parallel present(a[0:n], b[0:n], d[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = c[x] + a[x] + b[x];
        }
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            d[x] = c[x] * a[x];
        }
    }
}

#ifndef T1
//T1:declare,runtime,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t *));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t *));
    real_t ** d = (real_t **)malloc(n * sizeof(real_t *));
    real_t ** devpointer_c = (real_t **)malloc(n * sizeof(real_t *));
    int *devtest = (int *)malloc(sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = (real_t *)malloc(n * sizeof(real_t));
        b[x] = (real_t *)malloc(n * sizeof(real_t));
        c[x] = (real_t *)malloc(n * sizeof(real_t));
        d[x] = (real_t *)malloc(n * sizeof(real_t));
        for (int y = 0; y < n; ++y){
            a[x][y] = rand() / (real_t)(RAND_MAX / 10);
            b[x][y] = rand() / (real_t)(RAND_MAX / 10);
            c[x][y] = 1;
            d[x][y] = 0;
        }
    }

    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n]) copy(c[0:n][0:n]) copyout(d[0:n][0:n])
    {
        for (int x = 0; x < n; ++x){
            devpointer_c[x] = acc_deviceptr(c[x]);
            declare_deviceptr(a[x], b[x], devpointer_c[x], d[x]);
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){
                err += 1;
            }
            if (fabs(d[x][y] - (a[x][y] * c[x][y])) > PRECISION * 2){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:declare,runtime,construct-independent,devonly,V:2.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t *));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t *));
    real_t ** d = (real_t **)malloc(n * sizeof(real_t *));
    real_t ** devpointer_c = (real_t **)malloc(n * sizeof(real_t *));
    int *devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            for (int y = 0; y < n; ++y){
                a[x][y] = rand() / (real_t)(RAND_MAX / 10);
                b[x][y] = rand() / (real_t)(RAND_MAX / 10);
                c[x][y] = 3;
            }
        }

        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])
        {
            for (int x = 0; x < n; ++x){
                #pragma acc data copyout(d[x:1][0:n])
                {
                    devpointer_c[x] = acc_copyin(c[x], n * sizeof(real_t));
                    declare_deviceptr(a[x], b[x], devpointer_c[x], d[x]);
                }
                for (int y = 0; y < n; ++y){
                    if (fabs(c[x][y] - 3) > PRECISION){
                        err += 1;
                    }
                }
                for (int y = 0; y < n; ++y){
                    if (fabs(d[x][y] - (a[x][y] * (3 + a[x][y] + b[x][y]))) > PRECISION * 10){
                        err += 1;
                    }
                }
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
declare_function_scope_deviceptr.cpp:::
#include "acc_testsuite.h"
void declare_deviceptr(real_t *a, real_t *b, real_t *c, real_t *d){
    #pragma acc declare deviceptr(c)
    #pragma acc parallel present(a[0:n], b[0:n], d[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = c[x] + a[x] + b[x];
        }
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            d[x] = c[x] * a[x];
        }
    }
}

#ifndef T1
//T1:declare,runtime,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t *));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t *));
    real_t ** d = (real_t **)malloc(n * sizeof(real_t *));
    real_t ** devpointer_c = (real_t **)malloc(n * sizeof(real_t *));
    int *devtest = (int *)malloc(sizeof(int));

    for (int x = 0; x < n; ++x){
        a[x] = new real_t[n];
        b[x] = new real_t[n];
        c[x] = new real_t[n];
        d[x] = new real_t[n];
        for (int y = 0; y < n; ++y){
            a[x][y] = rand() / (real_t)(RAND_MAX / 10);
            b[x][y] = rand() / (real_t)(RAND_MAX / 10);
            c[x][y] = 1;
            d[x][y] = 0;
        }
    }

    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n]) copy(c[0:n][0:n]) copyout(d[0:n][0:n])
    {
        for (int x = 0; x < n; ++x){
            devpointer_c[x] = reinterpret_cast<real_t *>(acc_copyin(c[x], n * sizeof(real_t)));
            declare_deviceptr(a[x], b[x], devpointer_c[x], d[x]);
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){
                err += 1;
            }
            if (fabs(d[x][y] - (a[x][y] * c[x][y])) > PRECISION * 2){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:declare,runtime,construct-independent,devonly,V:2.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t *));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t *));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t *));
    real_t ** d = (real_t **)malloc(n * sizeof(real_t *));
    real_t ** devpointer_c = (real_t **)malloc(n * sizeof(real_t *));
    int *devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            for (int y = 0; y < n; ++y){
                a[x][y] = rand() / (real_t)(RAND_MAX / 10);
                b[x][y] = rand() / (real_t)(RAND_MAX / 10);
                c[x][y] = 3;
            }
        }

        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])
        {
            for (int x = 0; x < n; ++x){
                #pragma acc data copyout(d[x:1][0:n])
                {
                    devpointer_c[x] = reinterpret_cast<real_t *>(acc_copyin(c[x], n * sizeof(real_t)));
                    declare_deviceptr(a[x], b[x], devpointer_c[x], d[x]);
                }
                for (int y = 0; y < n; ++y){
                    if (fabs(c[x][y] - 3) > PRECISION){
                        err += 1;
                    }
                }
                for (int y = 0; y < n; ++y){
                    if (fabs(d[x][y] - (a[x][y] * (3 + a[x][y] + b[x][y]))) > PRECISION * 10){
                        err += 1;
                    }
                }
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
declare_function_scope_present.c:::
#include "acc_testsuite.h"
void present(real_t *a, real_t *b, real_t *c, real_t *d){
    #pragma acc declare present(c[0:n])
    #pragma acc parallel present(a[0:n], b[0:n], d[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = c[x] + a[x] + b[x];
        }
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            d[x] = c[x] * a[x];
        }
    }
}

#ifndef T1
//T1:declare,present,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));
    real_t ** d = (real_t **)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = (real_t *)malloc(n * sizeof(real_t));
        b[x] = (real_t *)malloc(n * sizeof(real_t));
        c[x] = (real_t *)malloc(n * sizeof(real_t));
        d[x] = (real_t *)malloc(n * sizeof(real_t));
        for (int y = 0; y < n; ++y){
            a[x][y] = rand() / (real_t)(RAND_MAX / 10);
            b[x][y] = rand() / (real_t)(RAND_MAX / 10);
            c[x][y] = 1;
            d[x][y] = 0;
        }
    }

    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n]) copyout(d[0:n][0:n])
    {
        for (int x = 0; x < n; ++x){
            #pragma acc data copy(c[x:1][0:n])
            {
                present(a[x], b[x], c[x], d[x]);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){
                err += 1;
            }
            if (fabs(d[x][y] - (a[x][y] * c[x][y])) > PRECISION * 2){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:declare,present,devonly,construct-independent,V:2.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));
    real_t ** d = (real_t **)malloc(n * sizeof(real_t));
    int *devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            for (int y = 0; y < n; ++y){
                a[x][y] = rand() / (real_t)(RAND_MAX / 10);
                b[x][y] = rand() / (real_t)(RAND_MAX / 10);
                c[x][y] = 3;
            }
        }

        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])
        {
            for (int x = 0; x < n; ++x){
                #pragma acc data copyin(c[x:1][0:n]) copyout(d[x:1][0:n])
                {
                    present(a[x], b[x], c[x], d[x]);
                }
                for (int y = 0; y < n; ++y){
                    if (fabs(c[x][y] - 3) > PRECISION){
                        err += 1;
                    }
                }
                for (int y = 0; y < n; ++y){
                    if (fabs(d[x][y] - (a[x][y] * (3 + a[x][y] + b[x][y]))) > PRECISION * 2){
                        err += 1;
                    }
                }
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
declare_function_scope_present.cpp:::
#include "acc_testsuite.h"
void present(real_t *a, real_t *b, real_t *c, real_t *d){
    #pragma acc declare present(c[0:n])
    #pragma acc parallel present(a[0:n], b[0:n], d[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = c[x] + a[x] + b[x];
        }
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            d[x] = c[x] * a[x];
        }
    }
}

#ifndef T1
//T1:declare,present,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));
    real_t ** d = (real_t **)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = new real_t[n];
        b[x] = new real_t[n];
        c[x] = new real_t[n];
        d[x] = new real_t[n];
        for (int y = 0; y < n; ++y){
            a[x][y] = rand() / (real_t)(RAND_MAX / 10);
            b[x][y] = rand() / (real_t)(RAND_MAX / 10);
            c[x][y] = 1;
            d[x][y] = 0;
        }
    }

    #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n]) copyout(d[0:n][0:n])
    {
        for (int x = 0; x < n; ++x){
            #pragma acc data copy(c[x:1][0:n])
            {
                present(a[x], b[x], c[x], d[x]);
            }
        }
    }

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < n; ++y){
            if (fabs(c[x][y] - (1 + a[x][y] + b[x][y])) > PRECISION){
                err += 1;
            }
            if (fabs(d[x][y] - (a[x][y] * c[x][y])) > PRECISION * 2){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:declare,present,devonly,construct-independent,V:2.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t ** a = (real_t **)malloc(n * sizeof(real_t));
    real_t ** b = (real_t **)malloc(n * sizeof(real_t));
    real_t ** c = (real_t **)malloc(n * sizeof(real_t));
    real_t ** d = (real_t **)malloc(n * sizeof(real_t));
    int *devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            for (int y = 0; y < n; ++y){
                a[x][y] = rand() / (real_t)(RAND_MAX / 10);
                b[x][y] = rand() / (real_t)(RAND_MAX / 10);
                c[x][y] = 3;
            }
        }

        #pragma acc data copyin(a[0:n][0:n], b[0:n][0:n])
        {
            for (int x = 0; x < n; ++x){
                #pragma acc data copyin(c[x:1][0:n]) copyout(d[x:1][0:n])
                {
                    present(a[x], b[x], c[x], d[x]);
                }
                for (int y = 0; y < n; ++y){
                    if (fabs(c[x][y] - 3) > PRECISION){
                        err += 1;
                    }
                }
                for (int y = 0; y < n; ++y){
                    if (fabs(d[x][y] - (a[x][y] * (3 + a[x][y] + b[x][y]))) > PRECISION * 2){
                        err += 1;
                    }
                }
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
enter_data_attach.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    two_d_array data;
    
    data.a = (real_t *)malloc(n * sizeof(real_t));
    data.b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        data.a[x] = rand() / (real_t)(RAND_MAX / 10);
        data.b[x] = 2 * data.a[x];
    }

    #pragma acc enter data copyin(data.a[0:n], data.b[0:n])
    #pragma acc enter data copyin(data) attach(data.a, data.b)

    #pragma acc parallel loop default(present)
    for(int x = 0; x < n; ++x){
        data.a[x] = data.a[x] * 2;
    }

    acc_detach(&data.a);
    acc_detach(&data.b);
    #pragma acc exit data copyout(data.a[0:n], data.b[0:n])
    #pragma acc exit data copyout(data)

    for (int x = 0; x < n; ++x){
        if (fabs(data.a[x] - data.b[x]) > PRECISION){
            err += 1;
        }
    }

    free(data.a);
    free(data.b);

    return err;
}
#endif


int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
enter_data_copyin_no_lower_bound.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,executable-data,syntactic,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc enter data copyin(a[:n], b[:n]) create(c[0:n])
    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = a[x] + b[x];
        }
    }
    #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
enter_data_copyin_no_lower_bound.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,executable-data,syntactic,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc enter data copyin(a[:n], b[:n]) create(c[0:n])
    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = a[x] + b[x];
        }
    }
    #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
enter_data_create.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,executable-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0.0;
        c[x] = 0.0;
    }

    #pragma acc enter data create(b[0:n])
    #pragma acc data copyin(a[0:n])
    {
        #pragma acc parallel present(b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x];
            }
        }
    }
    #pragma acc data copyout(c[0:n])
    {
        #pragma acc parallel present(b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = b[x];
            }
        }
    }
    #pragma acc exit data delete(b[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - a[x]) > PRECISION) {
            err += 1;
            break;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:data,executable-data,construct-independent,compatibility-features,V:2.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0.0;
        c[x] = 0.0;
    }

    #pragma acc enter data present_or_create(b[0:n])
    #pragma acc data copyin(a[0:n])
    {
        #pragma acc parallel present(b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x];
            }
        }
    }
    #pragma acc data copyout(c[0:n])
    {
        #pragma acc parallel present(b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = b[x];
            }
        }
    }
    #pragma acc exit data delete(b[0:n])
    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - a[x]) > PRECISION) {
            err += 2;
            break;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:data,executable-data,construct-independent,compatibility-features,V:2.0-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0.0;
        c[x] = 0.0;
    }

    #pragma acc enter data pcreate(b[0:n])
    #pragma acc data copyin(a[0:n])
    {
        #pragma acc parallel present(b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x];
            }
        }
    }
    #pragma acc data copyout(c[0:n])
    {
        #pragma acc parallel present(b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = b[x];
            }
        }
    }
    #pragma acc exit data delete(b[0:n])
    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - a[x]) > PRECISION){
            err += 4;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
enter_data_create.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,executable-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0.0;
        c[x] = 0.0;
    }

    #pragma acc enter data create(b[0:n])
    #pragma acc data copyin(a[0:n])
    {
        #pragma acc parallel present(b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x];
            }
        }
    }
    #pragma acc data copyout(c[0:n])
    {
        #pragma acc parallel present(b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = b[x];
            }
        }
    }
    #pragma acc exit data delete(b[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - a[x]) > PRECISION) {
            err += 1;
            break;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:data,executable-data,construct-independent,compatibility-features,V:2.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0.0;
        c[x] = 0.0;
    }

    #pragma acc enter data present_or_create(b[0:n])
    #pragma acc data copyin(a[0:n])
    {
        #pragma acc parallel present(b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x];
            }
        }
    }
    #pragma acc data copyout(c[0:n])
    {
        #pragma acc parallel present(b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = b[x];
            }
        }
    }
    #pragma acc exit data delete(b[0:n])
    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - a[x]) > PRECISION) {
            err += 2;
            break;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:data,executable-data,construct-independent,compatibility-features,V:2.0-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0.0;
        c[x] = 0.0;
    }

    #pragma acc enter data pcreate(b[0:n])
    #pragma acc data copyin(a[0:n])
    {
        #pragma acc parallel present(b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x];
            }
        }
    }
    #pragma acc data copyout(c[0:n])
    {
        #pragma acc parallel present(b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = b[x];
            }
        }
    }
    #pragma acc exit data delete(b[0:n])
    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - a[x]) > PRECISION){
            err += 4;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
enter_data_create_no_lower_bound.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,executable-data,syntactic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[:n])
    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = a[x] + b[x];
        }
    }
    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
enter_data_create_no_lower_bound.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,executable-data,syntactic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[:n])
    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = a[x] + b[x];
        }
    }
    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
enter_exit_data_if.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,executable-data,construct-independent,if,reference-counting,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    int dev = 1;
    int host = 0;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n]) if(dev)
    #pragma acc data create(a[0:n], b[0:n]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }
    #pragma acc exit data delete(a[0:n], b[0:n]) if(dev)

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:data,executable-data,construct-independent,if,V:2.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    int dev = 1;
    int host = 0;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc enter data create(a[0:n], b[0:n]) if(host)
    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }
    #pragma acc exit data delete(a[0:n], b[0:n]) if(host)

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:data,executable-data,construct-independent,devonly,if,reference-counting,V:2.5-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    int dev = 1;
    int host = 0;
    int * devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            a_copy[x] = a[x];
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            b_copy[x] = b[x];
            c[x] = 0.0;
        }

        #pragma acc enter data copyin(a[0:n], b[0:n]) if(dev)
        for (int x = 0; x < n; ++x){
            a[x] = 0;
            b[x] = 0;
        }
        #pragma acc data create(a[0:n], b[0:n]) copyout(c[0:n])
        {
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] = a[x] + b[x];
                }
            }
        }
        #pragma acc exit data copyout(a[0:n], b[0:n]) if(dev)

        for (int x = 0; x < n; ++x){
            if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T4
//T4:data,executable-data,if,construct-independent,devonly,V:2.0-2.7
int test4(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    int dev = 1;
    int host = 0;
    int * devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            c[x] = 0.0;
        }

        #pragma acc enter data copyin(a[0:n], b[0:n]) if(host)
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            a_copy[x] = a[x];
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            b_copy[x] = b[x];
        }
        #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])
        {
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] = a[x] + b[x];
                }
            }
        }
        #pragma acc exit data copyout(a[0:n], b[0:n]) if(host)

        for (int x = 0; x < n; ++x){
            if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T5
//T5:data,executable-data,if,construct-independent,devonly,V:2.0-2.7
int test5(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * b_copy = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    int dev = 1;
    int host = 0;
    int * devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            c[x] = 0.0;
        }

        #pragma acc enter data create(a[0:n], b[0:n]) if(host)
        #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])
        {
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] = a[x] + b[x];
                }
            }
        }
        #pragma acc exit data copyout(a[0:n], b[0:n]) if(host)

        for (int x = 0; x < n; ++x){
            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
#ifndef T5
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test5();
    }
    if (failed != 0){
        failcode = failcode + (1 << 4);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
enter_exit_data_if.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,executable-data,construct-independent,if,reference-counting,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];
    int dev = 1;
    int host = 0;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n]) if(dev)
    #pragma acc data create(a[0:n], b[0:n]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }
    #pragma acc exit data delete(a[0:n], b[0:n]) if(dev)

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:data,executable-data,construct-independent,if,V:2.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];
    int dev = 1;
    int host = 0;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc enter data create(a[0:n], b[0:n]) if(host)
    #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
    }
    #pragma acc exit data delete(a[0:n], b[0:n]) if(host)

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:data,executable-data,construct-independent,devonly,if,reference-counting,V:2.5-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * a_copy = new real_t[n];
    real_t * b = new real_t[n];
    real_t * b_copy = new real_t[n];
    real_t * c = new real_t[n];
    int dev = 1;
    int host = 0;
    int * devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            a_copy[x] = a[x];
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            b_copy[x] = b[x];
            c[x] = 0.0;
        }

        #pragma acc enter data copyin(a[0:n], b[0:n]) if(dev)
        for (int x = 0; x < n; ++x){
            a[x] = 0;
            b[x] = 0;
        }
        #pragma acc data create(a[0:n], b[0:n]) copyout(c[0:n])
        {
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] = a[x] + b[x];
                }
            }
        }
        #pragma acc exit data copyout(a[0:n], b[0:n]) if(dev)

        for (int x = 0; x < n; ++x){
            if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T4
//T4:data,executable-data,if,construct-independent,devonly,V:2.0-2.7
int test4(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * a_copy = new real_t[n];
    real_t * b = new real_t[n];
    real_t * b_copy = new real_t[n];
    real_t * c = new real_t[n];
    int dev = 1;
    int host = 0;
    int * devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            c[x] = 0.0;
        }

        #pragma acc enter data copyin(a[0:n], b[0:n]) if(host)
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            a_copy[x] = a[x];
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            b_copy[x] = b[x];
        }
        #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])
        {
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] = a[x] + b[x];
                }
            }
        }
        #pragma acc exit data copyout(a[0:n], b[0:n]) if(host)

        for (int x = 0; x < n; ++x){
            if (fabs(c[x] - (a_copy[x] + b_copy[x])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T5
//T5:data,executable-data,if,construct-independent,devonly,V:2.0-2.7
int test5(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * a_copy = new real_t[n];
    real_t * b = new real_t[n];
    real_t * b_copy = new real_t[n];
    real_t * c = new real_t[n];
    int dev = 1;
    int host = 0;
    int * devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            c[x] = 0.0;
        }

        #pragma acc enter data create(a[0:n], b[0:n]) if(host)
        #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])
        {
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] = a[x] + b[x];
                }
            }
        }
        #pragma acc exit data copyout(a[0:n], b[0:n]) if(host)

        for (int x = 0; x < n; ++x){
            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
#ifndef T5
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test5();
    }
    if (failed != 0){
        failcode = failcode + (1 << 4);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
exit_data.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,executable-data,devonly,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));
    int * devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            a_copy[x] = a[x];
        }

        #pragma acc enter data copyin(a[0:n])
        #pragma acc parallel present(a[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                a[x] = a[x] + 1;
            }
        }
        #pragma acc exit data delete(a[0:n])

        for (int x = 0; x < n; ++x){
            if (fabs(a[x] - a_copy[x]) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:data,executable-data,V:2.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        a_copy[x] = a[x];
    }

    #pragma acc enter data copyin(a[0:n])
    #pragma acc parallel present(a[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            a[x] = a[x] + 1;
        }
    }
    #pragma acc exit data copyout(a[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - (a_copy[x] + 1)) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
exit_data.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,executable-data,devonly,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * a_copy = new real_t[n];
    int * devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            a_copy[x] = a[x];
        }

        #pragma acc enter data copyin(a[0:n])
        #pragma acc parallel present(a[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                a[x] = a[x] + 1;
            }
        }
        #pragma acc exit data delete(a[0:n])

        for (int x = 0; x < n; ++x){
            if (fabs(a[x] - a_copy[x]) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:data,executable-data,V:2.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * a_copy = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        a_copy[x] = a[x];
    }

    #pragma acc enter data copyin(a[0:n])
    #pragma acc parallel present(a[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            a[x] = a[x] + 1;
        }
    }
    #pragma acc exit data copyout(a[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - (a_copy[x] + 1)) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
exit_data_copyout_no_lower_bound.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,executable-data,syntactic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n])
    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = a[x] + b[x];
        }
    }
    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
exit_data_copyout_no_lower_bound.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,executable-data,syntactic,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n])
    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = a[x] + b[x];
        }
    }
    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
exit_data_copyout_reference_counts.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,executable-data,devonly,construct-independent,reference-counting,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    int * devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
          a[x] = rand() / (real_t)(RAND_MAX / 10);
          b[x] = rand() / (real_t)(RAND_MAX / 10);
          c[x] = 0.0;
        }

        #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])
        #pragma acc data copyin(c[0:n])
        {
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] += a[x] + b[x];
                }
            }
            #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])
        }
        for (int x = 0; x < n; ++x){
            if (fabs(c[x]) > PRECISION){
                err += 1;
            }
        }

    }

    return err;
}
#endif

#ifndef T2
//T2:data,executable-data,reference-counting,construct-independent,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
      a[x] = rand() / (real_t)(RAND_MAX / 10);
      b[x] = rand() / (real_t)(RAND_MAX / 10);
      c[x] = 0.0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])
    #pragma acc data copyin(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }
        }
    }
    #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 2;
            break;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:data,executable-data,reference-counting,construct-independent,V:2.5-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])
    #pragma acc enter data create(c[0:n])
    #pragma acc parallel
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] += a[x] + b[x];
        }
    }
    #pragma acc exit data delete(c[0:n])
    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 4;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
exit_data_copyout_reference_counts.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,executable-data,devonly,construct-independent,reference-counting,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];
    int * devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
          a[x] = rand() / (real_t)(RAND_MAX / 10);
          b[x] = rand() / (real_t)(RAND_MAX / 10);
          c[x] = 0.0;
        }

        #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])
        #pragma acc data copyin(c[0:n])
        {
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] += a[x] + b[x];
                }
            }
            #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])
        }
        for (int x = 0; x < n; ++x){
            if (fabs(c[x]) > PRECISION){
                err += 1;
            }
        }

    }

    return err;
}
#endif

#ifndef T2
//T2:data,executable-data,reference-counting,construct-independent,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
      a[x] = rand() / (real_t)(RAND_MAX / 10);
      b[x] = rand() / (real_t)(RAND_MAX / 10);
      c[x] = 0.0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])
    #pragma acc data copyin(c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }
        }
    }
    #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 2;
            break;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:data,executable-data,reference-counting,construct-independent,V:2.5-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])
    #pragma acc enter data create(c[0:n])
    #pragma acc parallel
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] += a[x] + b[x];
        }
    }
    #pragma acc exit data delete(c[0:n])
    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 4;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
exit_data_delete_no_lower_bound.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,executable-data,construct-independent,syntactic,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n])
    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = a[x] + b[x];
        }
    }
    #pragma acc exit data delete(a[:n], b[:n]) copyout(c[0:n])

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
exit_data_delete_no_lower_bound.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,executable-data,construct-independent,syntactic,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n]) create(c[0:n])
    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = a[x] + b[x];
        }
    }
    #pragma acc exit data delete(a[:n], b[:n]) copyout(c[0:n])

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
exit_data_detach.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:runtime,data,executable-data,construct-independent,V:3.3
int test1(){
    int err = 0;
    srand(SEED);
    two_d_array data;
    
    data.a = (real_t *)malloc(n * sizeof(real_t));
    data.b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        data.a[x] = rand() / (real_t)(RAND_MAX / 10);
        data.b[x] = 2 * data.a[x];
    }

    #pragma acc enter data copyin(data.a[0:n], data.b[0:n])
    #pragma acc enter data copyin(data)
    acc_attach(&data.a);
    acc_attach(&data.b);

    #pragma acc parallel loop default(present)
    for(int x = 0; x < n; ++x){
        data.a[x] = data.a[x] * 2;
    }

    #pragma acc exit data detach(data.a, data.b)
    #pragma acc exit data copyout(data.a[0:n], data.b[0:n])
    #pragma acc exit data copyout(data)

    for (int x = 0; x < n; ++x){
        if (fabs(data.a[x] - data.b[x]) > PRECISION){
            err += 1;
        }
    }

    free(data.a);
    free(data.b);

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
exit_data_finalize.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,executable-data,reference-counting,construct-independent,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    int * devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel
    {
        devtest[0] = 0;
    }

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])
    #pragma acc enter data create(a[0:n], b[0:n], c[0:n])
    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = a[x] + b[x];
        }
    }
    #pragma acc exit data copyout(a[0:n], b[0:n], c[0:n])
    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            if (fabs(c[x]) > PRECISION) {
                err += 1;
            }
        }
    }
    #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])
    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:data,executable-data,reference-counting,construct-independent,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])
    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])
    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = a[x] + b[x];
        }
    }
    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n]) finalize
    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
exit_data_finalize.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,executable-data,reference-counting,construct-independent,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];
    int * devtest = (int *)malloc(sizeof(int));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel
    {
        devtest[0] = 0;
    }

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])
    #pragma acc enter data create(a[0:n], b[0:n], c[0:n])
    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = a[x] + b[x];
        }
    }
    #pragma acc exit data copyout(a[0:n], b[0:n], c[0:n])
    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            if (fabs(c[x]) > PRECISION) {
                err += 1;
            }
        }
    }
    #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])
    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:data,executable-data,reference-counting,construct-independent,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])
    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])
    #pragma acc parallel present(a[0:n], b[0:n], c[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = a[x] + b[x];
        }
    }
    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n]) finalize
    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
gang_dimensions.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,gang,dim,V:3.3
int test1(){
    int err = 0;
    srand(SEED); 

    real_t arr1[n][n];
    real_t arr2[n][n];

    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            arr1[i][j] = rand() / (real_t)(RAND_MAX / 10);
            arr2[i][j] = arr1[i][j] + 1;
        }
    }

    #pragma acc parallel num_gangs(n,n) 
    #pragma acc loop gang(dim:2)
    for (int i = 0; i < n; i++)
    {    
        #pragma acc loop gang(dim:1)
        for (int j = 0; j < n; j++)
        {
            arr1[i][j] = arr1[i][j] + 1;
        }
    }

    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            if (fabs(arr1[i][j] - arr2[i][j]) > PRECISION)  {
                err = 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,gang,dim,V:3.3
int test2(){
    int err = 0;
    srand(SEED); 

    real_t arr1[n][n][n];
    real_t arr2[n][n][n];

    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            for(int k = 0; k < n; k++) {
                arr1[i][j][k] = rand() / (real_t)(RAND_MAX / 10);
                arr2[i][j][k] = arr1[i][j][k] + 1;
            }
        }
    }

    #pragma acc parallel num_gangs(n,n,n) 
    #pragma acc loop gang(dim:3)
    for (int i = 0; i < n; i++)
    {
        #pragma acc loop gang(dim:2)
        for (int j = 0; j < n; j++)
        {
            #pragma acc loop gang(dim:1)
            for (int k = 0; k < n; k++)
            {
                arr1[i][j][k] = arr1[i][j][k] + 1;
            }
        }
    }

    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            for(int k = 0; k < n; k++) {
                if (fabs(arr1[i][j][k] - arr2[i][j][k]) > PRECISION)  {
                    err = 1;
                }
            }
        }
    }

    return err;
}
#endif

#pragma acc routine vector
void inner(real_t arr1, int n)
{
    #pragma acc loop vector
    for(int i = 0; i < n; i++)
    {
        arr1 = arr1 + 1;
    }
}

#pragma acc routine gang(dim:1)
void outer(real_t arr1[n], int n)
{
    #pragma acc loop gang(dim:1)
    for(int i = 0; i < n; i++)
    {
        inner(arr1[i], n);
    }
}

#ifndef T3
//T3:parallel,gang,dim,routine,V:3.3
int test3() {
    int err = 0;
    srand(SEED); 

    real_t arr1[n][n];
    real_t arr2[n][n];

    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            arr1[i][j] = rand() / (real_t)(RAND_MAX / 10);
            arr2[i][j] = arr1[i][j] + 1;
        }
    }
    
    #pragma acc parallel loop num_gangs(n,n) gang(dim:2)
    for(int i = 0; i < n; i++)
    {
        outer(arr1[i], n);
    }

    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            if (fabs(arr1[i][j] - arr2[i][j]) > PRECISION)  {
                err = 1;
            }
        }
    }

    return err;
}
#endif

#pragma acc routine vector
void inner_3D(real_t arr1, int n)
{
    #pragma acc loop vector
    for(int i = 0; i < n; i++)
    {
        arr1 = arr1 + 1;
    }
}

#pragma acc_routine gang(dim:1)
void middle(real_t arr1[n], int n)
{
    #pragma acc loop gang(dim:1)
    for(int i = 0; i < n; i++)
    {
        inner_3D(arr1[i], n);
    }
}

#pragma acc routine gang(dim:2)
void outer_3D(real_t arr1[n][n], int n)
{
    #pragma acc loop gang(dim:1)
    for(int i = 0; i < n; i++)
    {
        middle(arr1[i], n);
    }
}

#ifndef T4
//T4:parallel,gang,dim,routine,V:3.3
int test4() {
    int err = 0;
    srand(SEED); 

    real_t arr1[n][n][n];
    real_t arr2[n][n][n];

    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            for(int k = 0; k < n; k++) {
                arr1[i][j][k] = rand() / (real_t)(RAND_MAX / 10);
                arr2[i][j][k] = arr1[i][j][k] + 1;
            }
        }
    }

    #pragma acc parallel loop num_gangs(n,n,n) gang(dim:3)
    for(int i = 0; i < n; i++)
    {
        outer_3D(arr1[i], n);
    }

    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            for(int k = 0; k < n; k++) {
                if (fabs(arr1[i][j][k] - arr2[i][j][k]) > PRECISION)  {
                    err = 1;
                }
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
host_data.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,data-region,host-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    int * high = (int *)malloc(n * sizeof(int));
    int high_current_index = 0;
    size_t * a_points = (size_t *)malloc(n * sizeof(void *));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        if (a[x] > 5) {
            high[high_current_index] = x;
            high_current_index += 1;
        }
    }

    #pragma acc enter data copyin(a[0:n])

    #pragma acc host_data use_device(a)
    {
        int x = 0;
        for (x = 0; x < high_current_index; ++x){
            a_points[x] = (size_t) a + (high[x]*sizeof(real_t*));
        }
        for (; x < n; ++x){
            a_points[x] = 0;
        }
    }
    #pragma acc enter data copyin(a_points[0:n])
    #pragma acc parallel present(a[0:n], a_points[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            if (a_points[x] != 0){
                *((real_t *) a_points[x]) -= 5;
            }
        }
    }
    #pragma acc exit data delete(a_points[0:n]) copyout(a[0:n])
    for (int x = 0; x < n; ++x){
        if (a[x] < 0 || a[x] > 5) {
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
host_data.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:data,data-region,host-data,construct-independent,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    int * high = new int[n];
    int high_current_index = 0;
    size_t * a_points = (size_t *)malloc(n * sizeof(void *));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        if (a[x] > 5) {
            high[high_current_index] = x;
            high_current_index += 1;
        }
    }

    #pragma acc enter data copyin(a[0:n])

    #pragma acc host_data use_device(a)
    {
        int x = 0;
        for (x = 0; x < high_current_index; ++x){
            a_points[x] = (size_t) a + (high[x]*sizeof(real_t*));
        }
        for (; x < n; ++x){
            a_points[x] = 0;
        }
    }
    #pragma acc enter data copyin(a_points[0:n])
    #pragma acc parallel present(a[0:n], a_points[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            if (a_points[x] != 0){
                *((real_t *) a_points[x]) -= 5;
            }
        }
    }
    #pragma acc exit data delete(a_points[0:n]) copyout(a[0:n])
    for (int x = 0; x < n; ++x){
        if (a[x] < 0 || a[x] > 5) {
            err += 1;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
init.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:init,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);

    #pragma acc init

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
init.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:init,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);

    #pragma acc init

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
init_device_num.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:init,runtime,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int device_num = acc_get_device_num(acc_get_device_type());

    #pragma acc init device_num(device_num)

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
init_device_num.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:init,runtime,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int device_num = acc_get_device_num(acc_get_device_type());

    #pragma acc init device_num(device_num)

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
init_device_type.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:init,runtime,V:2.5-3.2
int test1(){
    int err = 0;
    srand(SEED);

    #pragma acc init device_type(host)

    return err;
}
#endif
#ifndef T2
//T2:init,runtime,V:2.5-3.2
int test2(){
    int err = 0;
    srand(SEED);

    #pragma acc init device_type(multicore)

    return err;
}
#endif
#ifndef T3
//T3:init,runtime,V:2.5-3.2
int test3(){
    int err = 0;
    srand(SEED);

    #pragma acc init device_type(default)

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed += test1();
    }
    if (failed){
        failcode += (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed += test2();
    }
    if (failed){
        failcode += (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed += test3();
    }
    if (failed){
        failcode += (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
init_device_type.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:init,runtime,V:2.5-3.2
int test1(){
    int err = 0;
    srand(SEED);

    #pragma acc init device_type(host)

    return err;
}
#endif
#ifndef T2
//T2:init,runtime,V:2.5-3.2
int test2(){
    int err = 0;
    srand(SEED);

    #pragma acc init device_type(multicore)

    return err;
}
#endif
#ifndef T3
//T3:init,runtime,V:2.5-3.2
int test3(){
    int err = 0;
    srand(SEED);

    #pragma acc init device_type(default)

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed += test1();
    }
    if (failed){
        failcode += (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed += test2();
    }
    if (failed){
        failcode += (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed += test3();
    }
    if (failed){
        failcode += (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
init_device_type_num.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:init,runtime,V:2.5-3.2
int test1(){
    int err = 0;
    srand(SEED);
    int device_num = acc_get_device_num(acc_get_device_type());

    #pragma acc init device_type(host) device_num(device_num)

    return err;
}
#endif
#ifndef T2
//T1:init,runtime,V:2.5-3.2
int test2(){
    int err = 0;
    srand(SEED);
    int device_num = acc_get_device_num(acc_get_device_type());

    #pragma acc init device_type(multicore) device_num(device_num)

    return err;
}
#endif
#ifndef T3
//T1:init,runtime,V:2.5-3.2
int test3(){
    int err = 0;
    srand(SEED);
    int device_num = acc_get_device_num(acc_get_device_type());

    #pragma acc init device_type(default) device_num(device_num)

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed += test1();
    }
    if (failed){
        failcode += (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed += test2();
    }
    if (failed){
        failcode += (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed += test3();
    }
    if (failed){
        failcode += (1 << 2);
    }
#endif

    return failcode;
}

########## NEXT FILE ##########
init_device_type_num.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:init,runtime,V:2.5-3.2
int test1(){
    int err = 0;
    srand(SEED);
    int device_num = acc_get_device_num(acc_get_device_type());

    #pragma acc init device_type(host) device_num(device_num)

    return err;
}
#endif
#ifndef T2
//T1:init,runtime,V:2.5-3.2
int test2(){
    int err = 0;
    srand(SEED);
    int device_num = acc_get_device_num(acc_get_device_type());

    #pragma acc init device_type(multicore) device_num(device_num)

    return err;
}
#endif
#ifndef T3
//T1:init,runtime,V:2.5-3.2
int test3(){
    int err = 0;
    srand(SEED);
    int device_num = acc_get_device_num(acc_get_device_type());

    #pragma acc init device_type(default) device_num(device_num)

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed += test1();
    }
    if (failed){
        failcode += (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed += test2();
    }
    if (failed){
        failcode += (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed += test3();
    }
    if (failed){
        failcode += (1 << 2);
    }
#endif

    return failcode;
}

########## NEXT FILE ##########
init_device_type_num_nvidia.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:init,runtime,V:2.5-3.2
int test1(){
    int err = 0;
    srand(SEED);
    int device_num = acc_get_device_num(acc_get_device_type());

    #pragma acc init device_type(nvidia) device_num(device_num)

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed += test1();
    }
    if (failed){
        failcode += (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
init_device_type_num_nvidia.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:init,runtime,V:2.5-3.2
int test1(){
    int err = 0;
    srand(SEED);
    int device_num = acc_get_device_num(acc_get_device_type());

    #pragma acc init device_type(nvidia) device_num(device_num)

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed += test1();
    }
    if (failed){
        failcode += (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
init_device_type_nvidia.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:init,runtime,V:2.5-3.2
int test1(){
    int err = 0;
    srand(SEED);

    #pragma acc init device_type(nvidia)

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed += test1();
    }
    if (failed){
        failcode += (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
init_device_type_nvidia.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:init,runtime,V:2.5-3.2
int test1(){
    int err = 0;
    srand(SEED);

    #pragma acc init device_type(nvidia)

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed += test1();
    }
    if (failed){
        failcode += (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
init_if.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:init,if,V:2.7-3.0
int test1(){
	int err = 0;
	srand(SEED);
	
	int device_num = acc_get_device_num(acc_get_device_type());

	#pragma acc init if(device_num == device_num)

	return err;
}
#endif

#ifndef T2
//T2:,V:2.7-3.0
int test2(){
	int err = 0;
	srand(SEED);

	int device_num = acc_get_device_num(acc_get_device_type());

	#pragma acc init if(device_num != device_num)

	return err;
}
#endif

int main(){
	int failcode = 0;
	int failed;
#ifndef T1
	failed = 0;
	for (int x = 0; x < NUM_TEST_CALLS; ++x){
		failed = failed + test1();
	}
	if (failed != 0){
		failcode = failcode + (1 << 0);
	}
#endif
#ifndef T2
	failed = 0;
	for (int x = 0; x < NUM_TEST_CALLS; ++x){
		failed = failed + test2();
	}
	if (failed != 0){
		failcode = failcode + (1 << 1);
	}
#endif
	return failcode;
}

########## NEXT FILE ##########
init_if.cpp:::
#include "acc_testsuite.h"

#ifndef T1
//T1:init,if,V:2.7-3.0
int test1(){
	int err = 0;
	srand(SEED);
	
	int device_num = acc_get_device_num(acc_get_device_type());

	#pragma acc init if(device_num == device_num)

	return err;
}
#endif

#ifndef T2
//T2:init,if,V:2.7-3.0
int test2(){
	int err = 0;
	srand(SEED);

	int device_num = acc_get_device_num(acc_get_device_type());

	#pragma acc init if(device_num != device_num)

	return err;
}
#endif

int main(){
	int failcode = 0;
	int failed;
#ifndef T1
	failed = 0;
	for (int x = 0; x < NUM_TEST_CALLS; ++x){
		failed = failed + test1();
	}
	if (failed != 0){
		failcode = failcode + (1 << 0);
	}
#endif
#ifndef T2
	failed = 0;
	for (int x = 0; x < NUM_TEST_CALLS; ++x){
		failed = failed + test2();
	}
	if (failed != 0){
		failcode = failcode + (1 << 1);
	}
#endif
	return failcode;
}

########## NEXT FILE ##########
kernel_implicit_data_attributes.c:::
#include "acc_testsuite.h"

#ifndef T1
//T1:kernels,data,data-region,V:2.0-3.3
int test1(){
	int err = 0;
	srand(SEED);
	int temp = rand()/ (real_t)(RAND_MAX / 10);

	#pragma acc kernels
	for ( int x = 0; x < n; ++x){
		temp += temp;
	}

	if(temp > PRECISION){
		err = 1;
	}
	return err;
}
#endif
#ifndef T2
//T2:kernels,data,data-region,V:2.0-3.3
int test2(){
	int err = 0;
	srand(SEED);

	real_t *test_array = (real_t *)malloc(n *sizeof(real_t));
	real_t *host_array = (real_t *)malloc(n *sizeof(real_t));

	for( int x = 0; x < n; ++x){
		test_array[x] = rand()/(real_t)(RAND_MAX/ 10);
		host_array[x] = test_array[x];
	}

	#pragma acc kernels
	for(int x = 0; x < n; ++x){
		test_array[x] += test_array[x];
	}

	for(int x = 0; x < n; ++x){
                if(fabs(host_array[x]*2 - test_array[x]) > PRECISION){
			err = 1;
                }
        }

	return err;
}
#endif

int main(){
	int failcode = 0;
	int failed;
#ifndef T1
	failed = 0;
	for(int x = 0; x < NUM_TEST_CALLS; ++x){
		failed += test1();
	}
	if(failed){
		failcode += ( 1 << 0);
	}
#endif
#ifndef T2
        failed = 0;
        for(int x = 0; x < NUM_TEST_CALLS; ++x){
                failed += test2();
        }
        if(failed != 0){
                failcode += ( 1 << 1);
        }
#endif
	return failcode;
}

########## NEXT FILE ##########
kernel_implicit_data_attributes.cpp:::
#include "acc_testsuite.h"

#ifndef T1
//T1:kernels,data,data-region,V:2.0-3.3
int test1(){
	int err = 0;
	srand(SEED);
	int temp = rand()/ (real_t)(RAND_MAX / 10);

	#pragma acc kernels
	for ( int x = 0; x < n; ++x){
		temp += temp;
	}

	if(temp > PRECISION){
		err = 1;
	}
	return err;
}
#endif
#ifndef T2
//T1:kernels,data,data-region,V:2.0-3.3
int test2(){
	int err = 0;
	srand(SEED);

	real_t *test_array = new real_t[n];
	real_t *host_array = new real_t[n];

	for( int x = 0; x < n; ++x){
		test_array[x] = rand()/(real_t)(RAND_MAX/ 10);
		host_array[x] = test_array[x];
	}

	#pragma acc kernels
	for(int x = 0; x < n; ++x){
		test_array[x] += test_array[x];
	}

	for(int x = 0; x < n; ++x){
                if(fabs(host_array[x]*2 - test_array[x]) > PRECISION){
			err = 1;
                }
        }

	return err;
}
#endif

int main(){
	int failcode = 0;
	int failed;
#ifndef T1
	failed = 0;
	for(int x = 0; x < NUM_TEST_CALLS; ++x){
		failed += test1();
	}
	if(failed){
		failcode += ( 1 << 0);
	}
#endif
#ifndef T2
        failed = 0;
        for(int x = 0; x < NUM_TEST_CALLS; ++x){
                failed += test2();
        }
        if(failed != 0){
                failcode += ( 1 << 1);
        }
#endif
	return failcode;
}

########## NEXT FILE ##########
kernels_async.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,async,wait,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * restrict a = (real_t *)malloc(n * sizeof(real_t));
    real_t * restrict b = (real_t *)malloc(n * sizeof(real_t));
    real_t * restrict c = (real_t *)malloc(n * sizeof(real_t));
    real_t * restrict d = (real_t *)malloc(n * sizeof(real_t));
    real_t * restrict e = (real_t *)malloc(n * sizeof(real_t));
    real_t * restrict f = (real_t *)malloc(n * sizeof(real_t));
    real_t * restrict g = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
      	b[x] = rand() / (real_t)(RAND_MAX / 10);
      	c[x] = 0.0;
      	d[x] = rand() / (real_t)(RAND_MAX / 10);
      	e[x] = rand() / (real_t)(RAND_MAX / 10);
      	f[x] = 0.0;
      	g[x] = 0.0;
    }
    #pragma acc enter data create(g[0:n], c[0:n], f[0:n])
    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n])
    {
        #pragma acc kernels async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc kernels async(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                f[x] = d[x] + e[x];
            }
        }
        #pragma acc kernels wait(1, 2) async(3)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                g[x] = c[x] + f[x];
            }
        }
    }
    #pragma acc wait(1, 2)
    #pragma acc update host(c[0:n], f[0:n])
    #pragma acc exit data copyout(g[0:n]) async(3)
    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
      	}
        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){
            err += 1;
        }
    }
    #pragma acc wait(3)
    for (int x = 0; x < n; ++x){
        if (fabs(g[x] - (c[x] + f[x])) > PRECISION){
            err += 1;
        }
    }
    #pragma acc exit data delete(c[0:n], f[0:n])

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_async.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,async,wait,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];
    real_t * d = new real_t[n];
    real_t * e = new real_t[n];
    real_t * f = new real_t[n];
    real_t * g = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
      	b[x] = rand() / (real_t)(RAND_MAX / 10);
      	c[x] = 0.0;
      	d[x] = rand() / (real_t)(RAND_MAX / 10);
      	e[x] = rand() / (real_t)(RAND_MAX / 10);
      	f[x] = 0.0;
      	g[x] = 0.0;
    }
    #pragma acc enter data create(g[0:n], c[0:n], f[0:n])
    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n])
    {
        #pragma acc kernels async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc kernels async(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                f[x] = d[x] + e[x];
            }
        }
        #pragma acc kernels wait(1, 2) async(3)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                g[x] = c[x] + f[x];
            }
        }
    }
    #pragma acc wait(1, 2)
    #pragma acc update host(c[0:n], f[0:n])
    #pragma acc exit data copyout(g[0:n]) async(3)
    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
      	}
        if (fabs(f[x] - (d[x] + e[x])) > PRECISION){
            err += 1;
        }
    }
    #pragma acc wait(3)
    for (int x = 0; x < n; ++x){
        if (fabs(g[x] - (c[x] + f[x])) > PRECISION){
            err += 1;
        }
    }
    #pragma acc exit data delete(c[0:n], f[0:n])

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_copy.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,data,data-region,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 1;
    }
    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc kernels copy(c[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:kernels,data,data-region,devonly,reference-counting,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    int * devtest = (int *)malloc(sizeof(int));
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc kernels present(devtest[0:1])
    {
      devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
          a[x] = rand() / (real_t)(RAND_MAX / 10);
          b[x] = rand() / (real_t)(RAND_MAX / 10);
          c[x] = 1;
        }
        #pragma acc data copyin(a[0:n], b[0:n], c[0:n])
        {
            #pragma acc kernels copy(c[0:n])
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] += a[x] + b[x];
                }
            }
        }

        for (int x = 0; x < n; ++x){
            if (fabs(c[x] - 1) > PRECISION && (a[x] + b[x]) > PRECISION) {
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:kernels,data,data-region,devonly,reference-counting,V:2.5-2.7
int test3(){
    int err = 0;
    srand(SEED);
    int * devtest = (int *)malloc(sizeof(int));
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc kernels present(devtest[0:1])
    {
      devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++ x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            c[x] = 1;
        }

        #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])
        {
            for (int x = 0; x < n; ++x){
                c[x] = 0;
            }
            #pragma acc kernels copy(c[0:n])
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] += a[x] + b[x];
                }
            }
            for (int x = 0; x < n; ++x){
                if (fabs(c[x]) > PRECISION) {
                    err += 1;
                }
            }
        }

        for (int x = 0; x < n; ++x){
            if (fabs(c[x] - (a[x] + b[x] + 1)) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_copy.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,data,data-region,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 1;
    }
    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc kernels copy(c[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (1 + a[x] + b[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:kernels,data,data-region,devonly,reference-counting,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    int * devtest = (int *)malloc(sizeof(int));
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];
    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc kernels present(devtest[0:1])
    {
      devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
          a[x] = rand() / (real_t)(RAND_MAX / 10);
          b[x] = rand() / (real_t)(RAND_MAX / 10);
          c[x] = 1;
        }
        #pragma acc data copyin(a[0:n], b[0:n], c[0:n])
        {
            #pragma acc kernels copy(c[0:n])
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] += a[x] + b[x];
                }
            }
        }

        for (int x = 0; x < n; ++x){
            if (fabs(c[x] - 1) > PRECISION && (a[x] + b[x]) > PRECISION) {
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:kernels,data,data-region,devonly,reference-counting,V:2.5-2.7
int test3(){
    int err = 0;
    srand(SEED);
    int * devtest = (int *)malloc(sizeof(int));
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];
    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc kernels present(devtest[0:1])
    {
      devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++ x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            c[x] = 1;
        }

        #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])
        {
            for (int x = 0; x < n; ++x){
                c[x] = 0;
            }
            #pragma acc kernels copy(c[0:n])
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] += a[x] + b[x];
                }
            }
            for (int x = 0; x < n; ++x){
                if (fabs(c[x]) > PRECISION) {
                    err += 1;
                }
            }
        }

        for (int x = 0; x < n; ++x){
            if (fabs(c[x] - (a[x] + b[x] + 1)) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_copyin.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,data,data-region,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0.0;
    }


    #pragma acc data copy(b[0:n])
    {
        #pragma acc kernels copyin(a[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] += a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - a[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:kernels,data,data-region,devonly,reference-counting,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    int * devtest = (int *)malloc(sizeof(int));
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc kernels present(devtest[0:1])
    {
      devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = 0.0;
        }

        #pragma acc data copy(a[0:n], b[0:n])
        {
            for (int x = 0; x < n; ++x){
                a[x] = -1;
            }
            #pragma acc kernels copyin(a[0:n])
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    b[x] = a[x];
                }
            }
        }

        for (int x = 0; x < n; ++x){
            if (fabs(b[x] - a[x]) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:kernels,data,data-region,devonly,V:1.0-2.7
int test3(){
    int err = 0;
    srand(SEED);
    int * devtest = (int *)malloc(sizeof(int));
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc kernels present(devtest[0:1])
    {
      devtest[0] = 0;
    }
    
    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = 0;
        }
        #pragma acc kernels copyin(a[0:n], b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x];
            }
        }

        for (int x = 0; x < n; ++x){
            if (fabs(b[x]) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_copyin.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,data,data-region,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0.0;
    }


    #pragma acc data copy(b[0:n])
    {
        #pragma acc kernels copyin(a[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] += a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - a[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:kernels,data,data-region,devonly,reference-counting,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    int * devtest = (int *)malloc(sizeof(int));
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc kernels present(devtest[0:1])
    {
      devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = 0.0;
        }

        #pragma acc data copy(a[0:n], b[0:n])
        {
            for (int x = 0; x < n; ++x){
                a[x] = -1;
            }
            #pragma acc kernels copyin(a[0:n])
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    b[x] = a[x];
                }
            }
        }

        for (int x = 0; x < n; ++x){
            if (fabs(b[x] - a[x]) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:kernels,data,data-region,devonly,V:1.0-2.7
int test3(){
    int err = 0;
    srand(SEED);
    int * devtest = (int *)malloc(sizeof(int));
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc kernels present(devtest[0:1])
    {
      devtest[0] = 0;
    }
    
    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = 0;
        }
        #pragma acc kernels copyin(a[0:n], b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x];
            }
        }

        for (int x = 0; x < n; ++x){
            if (fabs(b[x]) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_copyout.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,data,data-region,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:n])
    {
        #pragma acc kernels copyout(b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - a[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:kernels,data,data-region,devonly,reference-counting,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    int * devtest = (int *)malloc(sizeof(int));
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc kernels present(devtest[0:1])
    {
      devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = 0;
        }

        #pragma acc data copyin(a[0:n], b[0:n])
        {
            #pragma acc kernels copyout(b[0:n])
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    b[x] = a[x];
                }
            }
        }

        for (int x = 0; x < n; ++x){
            if (fabs(b[x]) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_copyout.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,data,data-region,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:n])
    {
        #pragma acc kernels copyout(b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - a[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:kernels,data,data-region,devonly,reference-counting,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    int * devtest = (int *)malloc(sizeof(int));
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc kernels present(devtest[0:1])
    {
      devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = 0;
        }

        #pragma acc data copyin(a[0:n], b[0:n])
        {
            #pragma acc kernels copyout(b[0:n])
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    b[x] = a[x];
                }
            }
        }

        for (int x = 0; x < n; ++x){
            if (fabs(b[x]) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_copyout_zero.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,data,data-region,V:3.0-3.2
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:n])
    {
        #pragma acc kernels copyout(zero: b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] += a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:kernels,data,data-region,devonly,V:3.0-3.1
int test2(){
    int err = 0;
    srand(SEED);
    int * devtest = (int *)malloc(sizeof(int));
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc kernels present(devtest[0:1])
    {
      devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = 0;
        }

        #pragma acc data copyin(a[0:n])
        {
            #pragma acc kernels copyout(zero: b[0:n])
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    b[x] += a[x];
                }
            }
        }

        for (int x = 0; x < n; ++x){
            if (fabs(a[x] - b[x]) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_copyout_zero.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,data,data-region,V:3.0-3.2
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:n])
    {
        #pragma acc kernels copyout(zero: b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] += a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:kernels,data,data-region,devonly,V:3.0-3.1
int test2(){
    int err = 0;
    srand(SEED);
    int * devtest = (int *)malloc(sizeof(int));
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc kernels present(devtest[0:1])
    {
      devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = 0;
        }

        #pragma acc data copyin(a[0:n])
        {
            #pragma acc kernels copyout(zero: b[0:n])
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    b[x] += a[x];
                }
            }
        }

        for (int x = 0; x < n; ++x){
            if (fabs(a[x] - b[x]) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_create.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,data,data-region,devonly,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int * devtest = (int *)malloc(sizeof(int));
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
      devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
          a[x] = rand() / (real_t)(RAND_MAX / 10);
          b[x] = 0.0;
        }

        #pragma acc data copyin(a[0:n])
        {
            #pragma acc kernels create(b[0:n])
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    b[x] = a[x];
                }
            }
        }

        for (int x = 0; x < n; ++x){
            if (fabs(b[x]) > PRECISION){
                err += 1;
            }
        }

    }

    return err;
}
#endif

#ifndef T2
//T2:kernels,data,data-region,reference-counting,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
      a[x] = rand() / (real_t)(RAND_MAX / 10);
      b[x] = 0.0;
    }

    #pragma acc data copyin(a[0:n]) copyout(b[0:n])
    {
        #pragma acc kernels create(b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:kernels,data,data-region,V:1.0-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0.0;
    }

    #pragma acc data copyin(a[0:n]) copyout(c[0:n])
    {
        #pragma acc kernels create(b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x];
            }
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - a[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_create.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,data,data-region,devonly,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    int * devtest = (int *)malloc(sizeof(int));
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
      devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
          a[x] = rand() / (real_t)(RAND_MAX / 10);
          b[x] = 0.0;
        }

        #pragma acc data copyin(a[0:n])
        {
            #pragma acc kernels create(b[0:n])
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    b[x] = a[x];
                }
            }
        }

        for (int x = 0; x < n; ++x){
            if (fabs(b[x]) > PRECISION){
                err += 1;
            }
        }

    }

    return err;
}
#endif

#ifndef T2
//T2:kernels,data,data-region,reference-counting,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];

    for (int x = 0; x < n; ++x){
      a[x] = rand() / (real_t)(RAND_MAX / 10);
      b[x] = 0.0;
    }

    #pragma acc data copyin(a[0:n]) copyout(b[0:n])
    {
        #pragma acc kernels create(b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:kernels,data,data-region,V:1.0-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0.0;
    }

    #pragma acc data copyin(a[0:n]) copyout(c[0:n])
    {
        #pragma acc kernels create(b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x];
            }
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - a[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_create_zero.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,data,data-region,V:3.0-3.2
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
      a[x] = rand() / (real_t)(RAND_MAX / 10);
      b[x] = 0.0;
    }

    #pragma acc data copyin(a[0:n]) copyout(b[0:n])
    {
        #pragma acc kernels create(zero: b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] += a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_create_zero.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,data,data-region,V:3.0-3.2
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];

    for (int x = 0; x < n; ++x){
      a[x] = rand() / (real_t)(RAND_MAX / 10);
      b[x] = 0.0;
    }

    #pragma acc data copyin(a[0:n]) copyout(b[0:n])
    {
        #pragma acc kernels create(zero: b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] += a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_default_copy.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,data-region,default-mapping,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t c[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc kernels
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:kernels,data-region,default-mapping,reference-counting,devonly,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t c[n];
    int * devtest = (int *)malloc(sizeof(real_t));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc kernels present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            c[x] = 1;
        }

        #pragma acc enter data copyin(c[0:n])
        for (int x = 0; x < n; ++x){
            c[x] = 0.0;
        }
        #pragma acc data copyin(a[0:n], b[0:n])
        {
            #pragma acc kernels
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] += a[x] + b[x];
                }
            }
        }

        for (int x = 0; x < n; ++x){
            if (fabs(c[x]) > PRECISION){
                err += 1;
            }
        }

        #pragma acc exit data copyout(c[0:n])

        for (int x = 0; x < n; ++x){
            if (fabs(c[x] - (a[x] + b[x] + 1)) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_default_copy.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,data-region,default-mapping,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t c[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc kernels
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:kernels,data-region,default-mapping,reference-counting,devonly,V:2.5-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t c[n];
    int * devtest = (int *)malloc(sizeof(real_t));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc kernels present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            c[x] = 1;
        }

        #pragma acc enter data copyin(c[0:n])
        for (int x = 0; x < n; ++x){
            c[x] = 0.0;
        }
        #pragma acc data copyin(a[0:n], b[0:n])
        {
            #pragma acc kernels
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] += a[x] + b[x];
                }
            }
        }

        for (int x = 0; x < n; ++x){
            if (fabs(c[x]) > PRECISION){
                err += 1;
            }
        }

        #pragma acc exit data copyout(c[0:n])

        for (int x = 0; x < n; ++x){
            if (fabs(c[x] - (a[x] + b[x] + 1)) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_default_present.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,data,data-region,default,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0;
    }

    #pragma acc enter data copyin(a[0:n]), create(b[0:n])
    #pragma acc kernels default(present)
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            b[x] = a[x];
        }
    }
    #pragma acc exit data delete(a[0:n]), copyout(b[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_default_present.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,data,data-region,default,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0;
    }

    #pragma acc enter data copyin(a[0:n]), create(b[0:n])
    #pragma acc kernels default(present)
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            b[x] = a[x];
        }
    }
    #pragma acc exit data delete(a[0:n]), copyout(b[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_if.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,if,V:1.0-3.2
int test1(){
    int err = 0;
    srand(SEED);
    int data_on_device = 0;
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0;
    }

    #pragma acc kernels if(data_on_device) present(a[0:n], b[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            b[x] = a[x];
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - a[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:kernels,if,V:2.0-3.2
int test2(){
    int err = 0;
    srand(SEED);
    int data_on_device = 0;
    int * devtest = (int *)malloc(sizeof(int));
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0;
    }

    #pragma acc enter data copyin(a[0:n]) create(b[0:n])
    data_on_device = 1;

    #pragma acc kernels if(data_on_device) present(a[0:n], b[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            b[x] = a[x];
        }
    }
    #pragma acc exit data copyout(b[0:n]) delete(a[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - a[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:kernels,if,devonly,V:2.0-3.2
int test3(){
    int err = 0;
    srand(SEED);
    int data_on_device = 0;
    int * devtest = (int *)malloc(sizeof(int));
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    devtest[0] = 1;

    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
	devtest[0] = 0;

    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = 0;
        }

        #pragma acc enter data copyin(a[0:n]) create(b[0:n])
        for (int x = 0; x < n; ++x){
            a[x] = -1;
        }

        #pragma acc kernels if(data_on_device) present(a[0:n], b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x];
            }
        }
        for (int x = 0; x < n; ++x){
            if (fabs(a[x] + 1) > PRECISION){
                err += 1;
            }
            if (fabs(b[x] + 1) > PRECISION){
                err += 1;
            }
        }
        #pragma acc exit data copyout(a[0:n], b[0:n])
        data_on_device = 0;
        for (int x = 0; x < n; ++x){
            if (fabs(a[x] - b[x]) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T4
//T4:kernels,if,devonly,V:2.0-3.2
int test4(){
    int err = 0;
    srand(SEED);
    int data_on_device = 0;
    int * devtest = (int *)malloc(sizeof(int));
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
      devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = 0;
        }

        #pragma acc enter data copyin(a[0:n], b[0:n])
        #pragma acc kernels if(data_on_device) present(a[0:n], b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x];
            }
        }
        for (int x = 0; x < n; ++x){
            if (fabs(a[x] - b[x]) > PRECISION) {
                err += 1;
            }
        }
        #pragma acc exit data copyout(a[0:n], b[0:n])
        for (int x = 0; x < n; ++x){
            if (fabs(b[x]) > PRECISION && b[x] != a[x]){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_if.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,if,V:1.0-3.2
int test1(){
    int err = 0;
    srand(SEED);
    int data_on_device = 0;
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0;
    }

    #pragma acc kernels if(data_on_device) present(a[0:n], b[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            b[x] = a[x];
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - a[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:kernels,if,V:2.0-3.2
int test2(){
    int err = 0;
    srand(SEED);
    int data_on_device = 0;
    int * devtest = (int *)malloc(sizeof(int));
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0;
    }

    #pragma acc enter data copyin(a[0:n]) create(b[0:n])
    data_on_device = 1;

    #pragma acc kernels if(data_on_device) present(a[0:n], b[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            b[x] = a[x];
        }
    }
    #pragma acc exit data copyout(b[0:n]) delete(a[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - a[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:kernels,if,devonly,V:2.0-3.2
int test3(){
    int err = 0;
    srand(SEED);
    int data_on_device = 0;
    int * devtest = (int *)malloc(sizeof(int));
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    devtest[0] = 1;

    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
	devtest[0] = 0;

    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = 0;
        }

        #pragma acc enter data copyin(a[0:n]) create(b[0:n])
        for (int x = 0; x < n; ++x){
            a[x] = -1;
        }

        #pragma acc kernels if(data_on_device) present(a[0:n], b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x];
            }
        }
        for (int x = 0; x < n; ++x){
            if (fabs(a[x] + 1) > PRECISION){
                err += 1;
            }
            if (fabs(b[x] + 1) > PRECISION){
                err += 1;
            }
        }
        #pragma acc exit data copyout(a[0:n], b[0:n])
        data_on_device = 0;
        for (int x = 0; x < n; ++x){
            if (fabs(a[x] - b[x]) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T4
//T4:kernels,if,devonly,V:2.0-3.2
int test4(){
    int err = 0;
    srand(SEED);
    int data_on_device = 0;
    int * devtest = (int *)malloc(sizeof(int));
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
      devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = 0;
        }

        #pragma acc enter data copyin(a[0:n], b[0:n])
        #pragma acc kernels if(data_on_device) present(a[0:n], b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x];
            }
        }
        for (int x = 0; x < n; ++x){
            if (fabs(a[x] - b[x]) > PRECISION) {
                err += 1;
            }
        }
        #pragma acc exit data copyout(a[0:n], b[0:n])
        for (int x = 0; x < n; ++x){
            if (fabs(b[x]) > PRECISION && b[x] != a[x]){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);

    real_t * a = (real_t *)malloc(1024 * sizeof(real_t));
    real_t * b = (real_t *)malloc(1024 * sizeof(real_t));

    for (int x = 0; x < 1024; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0.0;
    }

    #pragma acc kernels loop copy(a[0:1024]) copyout(b[0:1024])
    for (int _0 = 0; _0 < 2; ++_0){
        #pragma acc loop
        for (int _1 = 0; _1 < 2; ++_1){
            #pragma acc loop
            for (int _2 = 0; _2 < 2; ++_2){
                #pragma acc loop
                for (int _3 = 0; _3 < 2; ++_3){
                    #pragma acc loop
                    for (int _4 = 0; _4 < 2; ++_4){
                        #pragma acc loop
                        for (int _5 = 0; _5 < 2; ++_5){
                            #pragma acc loop
                            for (int _6 = 0; _6 < 2; ++_6){
                                #pragma acc loop
                                for (int _7 = 0; _7 < 2; ++_7){
                                    #pragma acc loop
                                    for (int _8 = 0; _8 < 2; ++_8){
                                        #pragma acc loop
                                        for (int _9 = 0; _9 < 2; ++_9){
                                            b[_0 * 512 + _1 * 256 + _2 * 128 + _3 * 64 + _4 * 32 + _5 * 16 + _6 * 8 + _7 * 4 + _8 * 2 + _9] = a[_0 * 512 + _1 * 256 + _2 * 128 + _3 * 64 + _4 * 32 + _5 * 16 + _6 * 8 + _7 * 4 + _8 * 2 + _9];
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    for (int x = 0; x < 1024; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);

    real_t * a = new real_t[1024];
    real_t * b = new real_t[1024];

    for (int x = 0; x < 1024; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0.0;
    }

    #pragma acc kernels loop copy(a[0:1024]) copyout(b[0:1024])
    for (int _0 = 0; _0 < 2; ++_0){
        #pragma acc loop
        for (int _1 = 0; _1 < 2; ++_1){
            #pragma acc loop
            for (int _2 = 0; _2 < 2; ++_2){
                #pragma acc loop
                for (int _3 = 0; _3 < 2; ++_3){
                    #pragma acc loop
                    for (int _4 = 0; _4 < 2; ++_4){
                        #pragma acc loop
                        for (int _5 = 0; _5 < 2; ++_5){
                            #pragma acc loop
                            for (int _6 = 0; _6 < 2; ++_6){
                                #pragma acc loop
                                for (int _7 = 0; _7 < 2; ++_7){
                                    #pragma acc loop
                                    for (int _8 = 0; _8 < 2; ++_8){
                                        #pragma acc loop
                                        for (int _9 = 0; _9 < 2; ++_9){
                                            b[_0 * 512 + _1 * 256 + _2 * 128 + _3 * 64 + _4 * 32 + _5 * 16 + _6 * 8 + _7 * 4 + _8 * 2 + _9] = a[_0 * 512 + _1 * 256 + _2 * 128 + _3 * 64 + _4 * 32 + _5 * 16 + _6 * 8 + _7 * 4 + _8 * 2 + _9];
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    for (int x = 0; x < 1024; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_independent.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:n]) copyout(b[0:n])
    {
        #pragma acc kernels loop independent
        for (int x = 0; x < n; ++x){
            b[x] = a[x];
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_independent.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:n]) copyout(b[0:n])
    {
        #pragma acc kernels loop independent
        for (int x = 0; x < n; ++x){
            b[x] = a[x];
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_add_general.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    real_t total = 10; //Should be innitialized to 0 anyway.
    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc kernels loop reduction(+:total)
        for (int x = 0; x < n; ++x){
            total += a[x] + b[x];
        }
    }
    for (int x = 0; x < n; ++x){
        total -= a[x] + b[x];
    }
    if (fabs(total - 10) > PRECISION * (2 * n - 1)){
        err = 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_add_general.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    real_t total = 10; //Should be innitialized to 0 anyway.
    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc kernels loop reduction(+:total)
        for (int x = 0; x < n; ++x){
            total += a[x] + b[x];
        }
    }
    for (int x = 0; x < n; ++x){
        total -= a[x] + b[x];
    }
    if (fabs(total - 10) > PRECISION * (2 * n - 1)){
        err = 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_add_loop.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,combined-constructs,reduction,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t avg = 0.0;

    for (int x = 0; x < 10 * n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:10*n], b[0:10*n]) create(c[0:10*n]) copyout(d[0:10*n])
    {
        #pragma acc kernels loop gang private(avg)
        for (int x = 0; x < 10; ++x){
            avg = 0;
            #pragma acc loop worker reduction(+:avg)
            for (int y = 0; y < n; ++y){
                avg += c[x * n + y] = a[x * n + y] + b[x * n + y];
            }
            avg = avg / n;
            #pragma acc loop worker
            for (int y = 0; y < n; ++y){
                d[x * n + y] = c[x * n + y] - avg;
            }
        }
    }

    real_t rolling_total = 0;

    for (int x = 0; x < 10; ++x){
        rolling_total = 0;
        for (int y = 0; y < n; ++y){
            rolling_total += a[x * n + y] + b[x * n + y];
        }
        rolling_total = rolling_total / n;
        for (int y = 0; y < n; ++y){
            if (fabs(d[x * n + y] - ((a[x * n + y] + b[x * n + y]) - rolling_total)) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_add_loop.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,combined-constructs,reduction,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[10 * n];
    real_t * b = new real_t[10 * n];
    real_t * c = new real_t[10 * n];
    real_t * d = new real_t[10 * n];
    real_t avg = 0.0;

    for (int x = 0; x < 10 * n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:10*n], b[0:10*n]) create(c[0:10*n]) copyout(d[0:10*n])
    {
        #pragma acc kernels loop gang private(avg)
        for (int x = 0; x < 10; ++x){
            avg = 0;
            #pragma acc loop worker reduction(+:avg)
            for (int y = 0; y < n; ++y){
                avg += c[x * n + y] = a[x * n + y] + b[x * n + y];
            }
            avg = avg / n;
            #pragma acc loop worker
            for (int y = 0; y < n; ++y){
                d[x * n + y] = c[x * n + y] - avg;
            }
        }
    }

    real_t rolling_total = 0;

    for (int x = 0; x < 10; ++x){
        rolling_total = 0;
        for (int y = 0; y < n; ++y){
            rolling_total += a[x * n + y] + b[x * n + y];
        }
        rolling_total = rolling_total / n;
        for (int y = 0; y < n; ++y){
            if (fabs(d[x * n + y] - ((a[x * n + y] + b[x * n + y]) - rolling_total)) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_add_vector_loop.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * c = (real_t *)malloc(10 * sizeof(real_t));
    real_t temp = 0.0;

    for(int x = 0; x < 10 * n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10])
    {
        #pragma acc kernels loop private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 0.0;
            #pragma acc loop vector reduction(+:temp)
            for (int y = 0; y < n; ++y){
                temp += a[(x * n) + y] + b[(x * n) + y];
            }
            c[x] = temp;
        }
    }
    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < n; ++y){
            c[x] -= a[(x * n) + y] + b[(x * n) + y];
        }
        if (fabs(c[x]) > PRECISION * (2 * n - 1)){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_add_vector_loop.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[10 * n];
    real_t * b = new real_t[10 * n];
    real_t * c = new real_t[10];
    real_t temp = 0.0;

    for(int x = 0; x < 10 * n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10])
    {
        #pragma acc kernels loop private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 0.0;
            #pragma acc loop vector reduction(+:temp)
            for (int y = 0; y < n; ++y){
                temp += a[(x * n) + y] + b[(x * n) + y];
            }
            c[x] = temp;
        }
    }
    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < n; ++y){
            c[x] -= a[(x * n) + y] + b[(x * n) + y];
        }
        if (fabs(c[x]) > PRECISION * (2 * n - 1)){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_and_general.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);

    char * a = (char *)malloc(n * sizeof(char));
    real_t false_margin = pow(exp(1), log(.5)/n);
    char result = 1;

    for (int x = 0; x < n; ++x){
        if(rand() / (real_t)(RAND_MAX) < false_margin){
            a[x] = 1;
        }
        else{
            a[x] = 0;
        }
    }


    #pragma acc data copyin(a[0:n])
    {
        #pragma acc kernels loop reduction(&&:result)
        for (int x = 0; x < n; ++x){
            result = result && a[x];
        }
    }

    char found = 0;
    for (int x = 0; x < n; ++x){
        if (a[x] == 0){
            found = 1;
            break;
        }
    }
    if (found == result){
        err = 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_and_general.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);

    char * a = new char[n];
    real_t false_margin = pow(exp(1), log(.5)/n);
    char result = 1;

    for (int x = 0; x < n; ++x){
        if(rand() / (real_t)(RAND_MAX) < false_margin){
            a[x] = 1;
        }
        else{
            a[x] = 0;
        }
    }


    #pragma acc data copyin(a[0:n])
    {
        #pragma acc kernels loop reduction(&&:result)
        for (int x = 0; x < n; ++x){
            result = result && a[x];
        }
    }

    char found = 0;
    for (int x = 0; x < n; ++x){
        if (a[x] == 0){
            found = 1;
            break;
        }
    }
    if (found == result){
        err = 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_and_loop.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    char * a = (char *)malloc(10 * n * sizeof(char));
    char * a_copy = (char *)malloc(10 * n * sizeof(char));
    char * has_false = (char *)malloc(10 * sizeof(char));
    real_t false_margin = pow(exp(1), log(.5)/n);

    for (int x = 0; x < 10; ++x){
        has_false[x] = 0;
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < n; ++y){
            if (rand() / (real_t)(RAND_MAX) < false_margin){
                a[x * n + y] = 1;
                a_copy[x * n + y] = 1;
            }
            else {
                a[x * n + y] = 0;
                a_copy[x * n + y] = 0;
                has_false[x] = 1;
            }
        }
    }

    char temp = 1;
    #pragma acc data copy(a[0:10*n])
    {
        #pragma acc kernels loop gang private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 1;
            #pragma acc loop worker reduction(&&:temp)
            for (int y = 0; y < n; ++y){
                temp = temp && a[x * n + y];
            }
            #pragma acc loop worker
            for (int y = 0; y < n; ++y){
                if(temp == 1){
                    if  (a[x * n + y] == 1){
                        a[x * n + y] = 0;
                    }
                    else {
                        a[x * n + y] = 1;
                    }
                }
            }
        }
    }


    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < n; ++y){
            if (has_false[x] == 1 && a[x * n + y] != a_copy[x * n + y]){
                err = 1;
            }
            else if (has_false[x] == 0 && a[x * n + y] == a_copy[x * n + y]){
                err = 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_and_loop.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    char * a = new char[10 * n];
    char * a_copy = new char[10 * n];
    char * has_false = new char[10];
    real_t false_margin = pow(exp(1), log(.5)/n);

    for (int x = 0; x < 10; ++x){
        has_false[x] = 0;
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < n; ++y){
            if (rand() / (real_t)(RAND_MAX) < false_margin){
                a[x * n + y] = 1;
                a_copy[x * n + y] = 1;
            }
            else {
                a[x * n + y] = 0;
                a_copy[x * n + y] = 0;
                has_false[x] = 1;
            }
        }
    }

    char temp = 1;
    #pragma acc data copy(a[0:10*n])
    {
        #pragma acc kernels loop gang private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 1;
            #pragma acc loop worker reduction(&&:temp)
            for (int y = 0; y < n; ++y){
                temp = temp && a[x * n + y];
            }
            #pragma acc loop worker
            for (int y = 0; y < n; ++y){
                if(temp == 1){
                    if  (a[x * n + y] == 1){
                        a[x * n + y] = 0;
                    }
                    else {
                        a[x * n + y] = 1;
                    }
                }
            }
        }
    }


    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < n; ++y){
            if (has_false[x] == 1 && a[x * n + y] != a_copy[x * n + y]){
                err = 1;
            }
            else if (has_false[x] == 0 && a[x * n + y] == a_copy[x * n + y]){
                err = 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_and_vector_loop.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    char * a = (char *)malloc(10 * n * sizeof(char));
    char * b = (char *)malloc(10 * sizeof(char));
    char * has_false = (char *)malloc(10 * sizeof(char));
    real_t false_margin = pow(exp(1), log(.5)/n);

    for (int x = 0; x < 10; ++x){
        has_false[x] = 0;
    }
    for (int x = 0; x < 10 * n; ++x){
        if(rand() / (real_t)(RAND_MAX) < false_margin){
            a[x] = 1;
        }
        else{
            a[x] = 0;
            has_false[x/n] = 1;
        }
    }
    char temp = 1;
    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])
    {
        #pragma acc kernels loop private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 1;
            #pragma acc loop vector reduction(&&:temp)
            for (int y = 0; y < n; ++y){
                temp = temp && a[x * n + y];
            }
            b[x] = temp;
        }
    }
    for (int x = 0; x < 10; ++x){
        if (has_false[x] == b[x]){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_and_vector_loop.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    char * a = new char[10 * n];
    char * b = new char[10];
    char * has_false = new char[10];
    real_t false_margin = pow(exp(1), log(.5)/n);

    for (int x = 0; x < 10; ++x){
        has_false[x] = 0;
    }
    for (int x = 0; x < 10 * n; ++x){
        if(rand() / (real_t)(RAND_MAX) < false_margin){
            a[x] = 1;
        }
        else{
            a[x] = 0;
            has_false[x/n] = 1;
        }
    }
    char temp = 1;
    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])
    {
        #pragma acc kernels loop private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 1;
            #pragma acc loop vector reduction(&&:temp)
            for (int y = 0; y < n; ++y){
                temp = temp && a[x * n + y];
            }
            b[x] = temp;
        }
    }
    for (int x = 0; x < 10; ++x){
        if (has_false[x] == b[x]){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_bitand_general.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    n = 10;
    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));
    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int temp = 1;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 16; ++y){
            if (rand() / (real_t) RAND_MAX < false_margin){
                for (int z = 0; z < y; ++z){
                    temp *= 2;
                }
                a[x] += temp;
                temp = 1;
            }
        }
    }
    unsigned int b = 0;
    for (int x = 0; x < 16; ++x){
        temp = 1;
        for (int y = 0; y < x; ++y){
            temp *= 2;
        }
        b += temp;
    }
    #pragma acc data copyin(a[0:n])
    {
        #pragma acc kernels loop reduction(&:b)
        for (int x = 0; x < n; ++x){
            b = b & a[x];
        }
    }
    unsigned int host_b = a[0];

    for (int x = 1; x < n; ++x){
        host_b = host_b & a[x];
    }
    if (b != host_b){
        err = 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_bitand_general.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    n = 10;
    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));
    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int temp = 1;

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 16; ++y){
            if (rand() / (real_t) RAND_MAX < false_margin){
                for (int z = 0; z < y; ++z){
                    temp *= 2;
                }
                a[x] += temp;
                temp = 1;
            }
        }
    }
    unsigned int b = 0;
    for (int x = 0; x < 16; ++x){
        temp = 1;
        for (int y = 0; y < x; ++y){
            temp *= 2;
        }
        b += temp;
    }
    #pragma acc data copyin(a[0:n])
    {
        #pragma acc kernels loop reduction(&:b)
        for (int x = 0; x < n; ++x){
            b = b & a[x];
        }
    }
    unsigned int host_b = a[0];

    for (int x = 1; x < n; ++x){
        host_b = host_b & a[x];
    }
    if (b != host_b){
        err = 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_bitand_loop.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));

    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int temp = 1;

    for (int x = 0; x < 10 * n; ++x){
        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);
        b_copy[x] = b[x];
        for (int y = 0; y < 16; ++y){
            if (rand() / (real_t) RAND_MAX < false_margin){
                for (int z = 0; z < y; ++z){
                    temp *= 2;
                }
                a[x] += temp;
                temp = 1;
            }
        }
    }
    #pragma acc data copyin(a[0:10 * n]) copy(b[0:10 * n], c[0:10])
    {
        #pragma acc kernels loop gang private(temp)
        for (int y = 0; y < 10; ++y){
            temp = a[y * n];
            #pragma acc loop worker reduction(&:temp)
            for (int x = 1; x < n; ++x){
                temp = temp & a[y * n + x];
            }
            c[y] = temp;
            #pragma acc loop worker
            for (int x = 0; x < n; ++x){
                b[y * n + x] = b[y * n + x] + c[y];
            }
        }
    }
    unsigned int* host_c = (unsigned int *)malloc(10 * sizeof(unsigned int));
    for (int x = 0; x < 10; ++x){
        host_c[x] = a[x * n];
        for (int y = 1; y < n; ++y){
            host_c[x] = host_c[x] & a[x * n + y];
        }
        if (host_c[x] != c[x]){
          err += 1;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < n; ++y){
            if (b[x * n + y] != b_copy[x * n + y] + c[x]){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_bitand_loop.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));

    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int temp = 1;

    for (int x = 0; x < 10 * n; ++x){
        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);
        b_copy[x] = b[x];
        for (int y = 0; y < 16; ++y){
            if (rand() / (real_t) RAND_MAX < false_margin){
                for (int z = 0; z < y; ++z){
                    temp *= 2;
                }
                a[x] += temp;
                temp = 1;
            }
        }
    }
    #pragma acc data copyin(a[0:10 * n]) copy(b[0:10 * n], c[0:10])
    {
        #pragma acc kernels loop gang private(temp)
        for (int y = 0; y < 10; ++y){
            temp = a[y * n];
            #pragma acc loop worker reduction(&:temp)
            for (int x = 1; x < n; ++x){
                temp = temp & a[y * n + x];
            }
            c[y] = temp;
            #pragma acc loop worker
            for (int x = 0; x < n; ++x){
                b[y * n + x] = b[y * n + x] + c[y];
            }
        }
    }
    unsigned int* host_c = (unsigned int *)malloc(10 * sizeof(unsigned int));
    for (int x = 0; x < 10; ++x){
        host_c[x] = a[x * n];
        for (int y = 1; y < n; ++y){
            host_c[x] = host_c[x] & a[x * n + y];
        }
        if (host_c[x] != c[x]){
          err += 1;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < n; ++y){
            if (b[x * n + y] != b_copy[x * n + y] + c[x]){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_bitand_vector_loop.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));

    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int temp = 1;
    unsigned int c = 0;
    unsigned int b_host;

    for (int x = 0; x < 10 * n; ++x){
        for (int y = 0; y < 16; ++y){
            if (rand() / (real_t) RAND_MAX < false_margin){
                for (int z = 0; z < y; ++z){
                    temp *= 2;
                }
                a[x] += temp;
                temp = 1;
            }
        }
    }

    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])
    {
        #pragma acc kernels loop private(c)
        for (int x = 0; x < 10; ++x){
            c = a[x * n];
            #pragma acc loop vector reduction(&:c)
            for (int y = 1; y < n; ++y){
                c = c & a[x * n + y];
            }
            b[x] = c;
        }
    }
    for (int x = 0; x < 10; ++x){
        b_host = a[x * n];
        for (int y = 1; y < n; ++y){
            b_host = b_host & a[x * n + y];
        }
        if (b_host != b[x]){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_bitand_vector_loop.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));

    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int temp = 1;
    unsigned int c = 0;
    unsigned int b_host;

    for (int x = 0; x < 10 * n; ++x){
        for (int y = 0; y < 16; ++y){
            if (rand() / (real_t) RAND_MAX < false_margin){
                for (int z = 0; z < y; ++z){
                    temp *= 2;
                }
                a[x] += temp;
                temp = 1;
            }
        }
    }

    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])
    {
        #pragma acc kernels loop private(c)
        for (int x = 0; x < 10; ++x){
            c = a[x * n];
            #pragma acc loop vector reduction(&:c)
            for (int y = 1; y < n; ++y){
                c = c & a[x * n + y];
            }
            b[x] = c;
        }
    }
    for (int x = 0; x < 10; ++x){
        b_host = a[x * n];
        for (int y = 1; y < n; ++y){
            b_host = b_host & a[x * n + y];
        }
        if (b_host != b[x]){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_bitor_general.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));
    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int temp = 1;
    unsigned int b = 0;
    unsigned int host_b = a[0];

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 16; ++y){
            if (rand() / (real_t) RAND_MAX > false_margin){
                for (int z = 0; z < y; ++z){
                    temp *= 2;
                }
                a[x] += temp;
                temp = 1;
            }
        }
    }

    #pragma acc data copyin(a[0:n])
    {
        #pragma acc kernels loop reduction(|:b)
        for (int x = 0; x < n; ++x){
            b = b | a[x];
        }
    }


    for (int x = 1; x < n; ++x){
        host_b = host_b | a[x];
    }
    if (b != host_b){
        err = 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_bitor_general.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));
    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int temp = 1;
    unsigned int b = 0;
    unsigned int host_b = a[0];

    for (int x = 0; x < n; ++x){
        for (int y = 0; y < 16; ++y){
            if (rand() / (real_t) RAND_MAX > false_margin){
                for (int z = 0; z < y; ++z){
                    temp *= 2;
                }
                a[x] += temp;
                temp = 1;
            }
        }
    }

    #pragma acc data copyin(a[0:n])
    {
        #pragma acc kernels loop reduction(|:b)
        for (int x = 0; x < n; ++x){
            b = b | a[x];
        }
    }


    for (int x = 1; x < n; ++x){
        host_b = host_b | a[x];
    }
    if (b != host_b){
        err = 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_bitor_loop.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));

    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int temp = 1;
    unsigned int host_c;

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < n; ++y){
            b[x * n + y] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);
            b_copy[x * n + y] = b[x * n + y];
            for (int z = 0; z < 16; ++z){
                if (rand() / (real_t) RAND_MAX > false_margin){
                    temp = 1;
                    for (int i = 0; i < z; ++i){
                        temp = temp * 2;
                    }
                    a[x * n + y] += temp;
                }
            }
        }
    }

    #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])
    {
        #pragma acc kernels loop gang private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 0;
            #pragma acc loop worker reduction(|:temp)
            for (int y = 0; y < n; ++y){
                temp = temp | a[x * n + y];
            }
            c[x] = temp;
            #pragma acc loop worker
            for (int y = 0; y < n; ++y){
                b[x * n + y] = b[x * n + y] + c[x];
            }
        }
    }
    for (int x = 0; x < 10; ++x){
        host_c = a[x * n];
        for (int y = 1; y < n; ++y){
            host_c = host_c | a[x * n + y];
        }
        if (host_c != c[x]){
            err += 1;
        }
        for (int y = 0; y < n; ++y){
            if (b[x * n + y] != b_copy[x * n + y] + host_c){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_bitor_loop.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));

    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int temp = 1;
    unsigned int host_c;

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < n; ++y){
            b[x * n + y] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);
            b_copy[x * n + y] = b[x * n + y];
            for (int z = 0; z < 16; ++z){
                if (rand() / (real_t) RAND_MAX > false_margin){
                    temp = 1;
                    for (int i = 0; i < z; ++i){
                        temp = temp * 2;
                    }
                    a[x * n + y] += temp;
                }
            }
        }
    }

    #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])
    {
        #pragma acc kernels loop gang private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 0;
            #pragma acc loop worker reduction(|:temp)
            for (int y = 0; y < n; ++y){
                temp = temp | a[x * n + y];
            }
            c[x] = temp;
            #pragma acc loop worker
            for (int y = 0; y < n; ++y){
                b[x * n + y] = b[x * n + y] + c[x];
            }
        }
    }
    for (int x = 0; x < 10; ++x){
        host_c = a[x * n];
        for (int y = 1; y < n; ++y){
            host_c = host_c | a[x * n + y];
        }
        if (host_c != c[x]){
            err += 1;
        }
        for (int y = 0; y < n; ++y){
            if (b[x * n + y] != b_copy[x * n + y] + host_c){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_bitor_vector_loop.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));

    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int temp = 1;
    unsigned int b_host;

    for (int x = 0; x < 10 * n; ++x){
        for (int y = 0; y < 16; ++y){
            if (rand() / (real_t) RAND_MAX > false_margin){
                for (int z = 0; z < y; ++z){
                    temp *= 2;
                }
                a[x] += temp;
                temp = 1;
            }
        }
    }
    temp = 0;
    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])
    {
        #pragma acc kernels loop private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 0;
            #pragma acc loop vector reduction(|:temp)
            for (int y = 0; y < n; ++y){
                temp = temp | a[x * n + y];
            }
            b[x] = temp;
        }
    }

    for (int x = 0; x < 10; ++x){
        b_host = a[x * n];
        for (int y = 1; y < n; ++y){
            b_host = b_host | a[x * n + y];
        }
        if (b_host != b[x]){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_bitor_vector_loop.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));

    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int temp = 1;
    unsigned int b_host;

    for (int x = 0; x < 10 * n; ++x){
        for (int y = 0; y < 16; ++y){
            if (rand() / (real_t) RAND_MAX > false_margin){
                for (int z = 0; z < y; ++z){
                    temp *= 2;
                }
                a[x] += temp;
                temp = 1;
            }
        }
    }
    temp = 0;
    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])
    {
        #pragma acc kernels loop private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 0;
            #pragma acc loop vector reduction(|:temp)
            for (int y = 0; y < n; ++y){
                temp = temp | a[x * n + y];
            }
            b[x] = temp;
        }
    }

    for (int x = 0; x < 10; ++x){
        b_host = a[x * n];
        for (int y = 1; y < n; ++y){
            b_host = b_host | a[x * n + y];
        }
        if (b_host != b[x]){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_bitxor_general.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));
    unsigned int b = 0;

    for (int x = 0; x < n; ++x){
        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);
    }
    unsigned int host_b = a[0];

    #pragma acc data copyin(a[0:n])
    {
        #pragma acc kernels loop reduction(^:b)
        for (int x = 0; x < n; ++x){
            b = b ^ a[x];
        }
    }


    for (int x = 1; x < n; ++x){
        host_b = host_b ^ a[x];
    }
    if (b != host_b){
        err = 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_bitxor_general.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));
    unsigned int b = 0;

    for (int x = 0; x < n; ++x){
        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);
    }
    unsigned int host_b = a[0];

    #pragma acc data copyin(a[0:n])
    {
        #pragma acc kernels loop reduction(^:b)
        for (int x = 0; x < n; ++x){
            b = b ^ a[x];
        }
    }


    for (int x = 1; x < n; ++x){
        host_b = host_b ^ a[x];
    }
    if (b != host_b){
        err = 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_bitxor_loop.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));
    unsigned int temp = 0;

    for (int x = 0; x < 10*n; ++x){
        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);
        b_copy[x] = b[x];
        a[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);
    }
    for (int x = 0; x < 10; ++x){
        c[x] = 0;
    }

    #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])
    {
        #pragma acc kernels loop gang private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 0;
            #pragma acc loop worker reduction(^:temp)
            for (int y = 0; y < n; ++y){
                temp = temp ^ a[x * n + y];
            }
            c[x] = temp;
            #pragma acc loop worker
            for (int y = 0; y < n; ++y){
                b[x * n + y] = b[x * n + y] + c[x];
            }
        }
    }

    for (int x = 0; x < 10; ++x){
        temp = 0;
        for (int y = 0; y < n; ++y){
            temp = temp ^ a[x * n + y];
        }
        if (temp != c[x]){
            err += 1;
        }
        for (int y = 0; y < n; ++y){
            if (b[x * n + y] != b_copy[x * n + y] + c[x]){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_bitxor_loop.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));
    unsigned int temp = 0;

    for (int x = 0; x < 10*n; ++x){
        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);
        b_copy[x] = b[x];
        a[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);
    }
    for (int x = 0; x < 10; ++x){
        c[x] = 0;
    }

    #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])
    {
        #pragma acc kernels loop gang private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 0;
            #pragma acc loop worker reduction(^:temp)
            for (int y = 0; y < n; ++y){
                temp = temp ^ a[x * n + y];
            }
            c[x] = temp;
            #pragma acc loop worker
            for (int y = 0; y < n; ++y){
                b[x * n + y] = b[x * n + y] + c[x];
            }
        }
    }

    for (int x = 0; x < 10; ++x){
        temp = 0;
        for (int y = 0; y < n; ++y){
            temp = temp ^ a[x * n + y];
        }
        if (temp != c[x]){
            err += 1;
        }
        for (int y = 0; y < n; ++y){
            if (b[x * n + y] != b_copy[x * n + y] + c[x]){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_bitxor_vector_loop.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));

    unsigned int temp = 0;
    unsigned int b_host;

    for (int x = 0; x < 10 * n; ++x){
        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);
    }

    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])
    {
        #pragma acc kernels loop private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 0;
            #pragma acc loop vector reduction(^:temp)
            for (int y = 0; y < n; ++y){
                temp = temp ^ a[x * n + y];
            }
            b[x] = temp;
        }
    }

    for (int x = 0; x < 10; ++x){
        b_host = a[x * n];
        for (int y = 1; y < n; ++y){
            b_host = b_host ^ a[x * n + y];
        }
        if (b_host != b[x]){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_bitxor_vector_loop.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));

    unsigned int temp = 0;
    unsigned int b_host;

    for (int x = 0; x < 10 * n; ++x){
        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);
    }

    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])
    {
        #pragma acc kernels loop private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 0;
            #pragma acc loop vector reduction(^:temp)
            for (int y = 0; y < n; ++y){
                temp = temp ^ a[x * n + y];
            }
            b[x] = temp;
        }
    }

    for (int x = 0; x < 10; ++x){
        b_host = a[x * n];
        for (int y = 1; y < n; ++y){
            b_host = b_host ^ a[x * n + y];
        }
        if (b_host != b[x]){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_max_general.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t max = 0.0;
    int found = 0;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX/10);
        b[x] = rand() / (real_t)(RAND_MAX/10);
    }
    #pragma acc data copyin(a[0:n], b[0:n]) copy(max)
    {
        #pragma acc kernels loop reduction(max:max)
        for (int x = 0; x < n; ++x){
            max = fmax(a[x] * b[x], max);
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(max - (a[x] * b[x] + PRECISION)) < 0){
            err = 1;
        }
        if (fabs(max - (a[x] * b[x] - PRECISION)) > 0){
            found = 1;
        }
    }
    if (found == 0){
        err = 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_max_general.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t max = 0.0;
    int found = 0;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX/10);
        b[x] = rand() / (real_t)(RAND_MAX/10);
    }
    #pragma acc data copyin(a[0:n], b[0:n]) copy(max)
    {
        #pragma acc kernels loop reduction(max:max)
        for (int x = 0; x < n; ++x){
            max = fmax(a[x] * b[x], max);
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(max - (a[x] * b[x] + PRECISION)) < 0){
            err = 1;
        }
        if (fabs(max - (a[x] * b[x] - PRECISION)) > 0){
            found = 1;
        }
    }
    if (found == 0){
        err = 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_max_loop.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * maximum = (real_t *)malloc(10 * sizeof(real_t));
    real_t temp = 0;
    real_t max = 0.0;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX/10);
        b[x] = rand() / (real_t)(RAND_MAX/10);
        c[x] = 0.0;
    }
    for (int x = 0; x < 10; ++x){
        maximum[x] = 0;
    }

    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], maximum[0:10])
    {
        #pragma acc kernels loop gang private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 0;
            #pragma acc loop worker reduction(max:temp)
            for (int y = 0; y < n; ++y){
                temp = fmax(a[x * n + y] * b[x * n + y], temp);
            }
            maximum[x] = temp;
            #pragma acc loop worker
            for (int y = 0; y < n; ++y){
                c[x * n + y] = (a[x * n + y] * b[x * n + y]) / maximum[x];
            }
        }
    }
    for (int x = 0; x < 10; ++x){
        temp = 0;
        for (int y = 0; y < n; ++y){
            temp = fmax(temp, a[x * n + y] * b[x * n + y]);
        }
        if (fabs(temp - maximum[x]) > PRECISION){
            err += 1;
        }
        for (int y = 0; y < n; ++y){
            if (c[x * n + y] > 1){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_max_loop.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[10 * n];
    real_t * b = new real_t[10 * n];
    real_t * c = new real_t[10 * n];
    real_t * maximum = new real_t[10];
    real_t temp = 0;
    real_t max = 0.0;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX/10);
        b[x] = rand() / (real_t)(RAND_MAX/10);
        c[x] = 0.0;
    }
    for (int x = 0; x < 10; ++x){
        maximum[x] = 0;
    }

    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], maximum[0:10])
    {
        #pragma acc kernels loop gang private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 0;
            #pragma acc loop worker reduction(max:temp)
            for (int y = 0; y < n; ++y){
                temp = fmax(a[x * n + y] * b[x * n + y], temp);
            }
            maximum[x] = temp;
            #pragma acc loop worker
            for (int y = 0; y < n; ++y){
                c[x * n + y] = (a[x * n + y] * b[x * n + y]) / maximum[x];
            }
        }
    }
    for (int x = 0; x < 10; ++x){
        temp = 0;
        for (int y = 0; y < n; ++y){
            temp = fmax(temp, a[x * n + y] * b[x * n + y]);
        }
        if (fabs(temp - maximum[x]) > PRECISION){
            err += 1;
        }
        for (int y = 0; y < n; ++y){
            if (c[x * n + y] > 1){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_max_vector_loop.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * max = (real_t *)malloc(10 * sizeof(real_t));
    real_t temp = 0;
    real_t temp_max;

    for (int x = 0; x < 10 * n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX/10);
        b[x] = rand() / (real_t)(RAND_MAX/10);
    }
    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(max[0:10])
    {
        #pragma acc kernels loop private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 0;
            #pragma acc loop vector reduction(max:temp)
            for (int y = 0; y < n; ++y){
                temp = fmax(a[x * n + y] * b[x * n + y], temp);
            }
            max[x] = temp;
        }
    }
    for (int x = 0; x < 10; ++x){
        temp_max = 0;
        for (int y = 0; y < n; ++y){
            if (temp_max < a[x * n + y] * b[x * n + y]){
                temp_max = a[x * n + y] * b[x * n + y];
            }
        }
        if (fabs(temp_max - max[x]) > PRECISION){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_max_vector_loop.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[10 * n];
    real_t * b = new real_t[10 * n];
    real_t * max = new real_t[10];
    real_t temp = 0;
    real_t temp_max;

    for (int x = 0; x < 10 * n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX/10);
        b[x] = rand() / (real_t)(RAND_MAX/10);
    }
    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(max[0:10])
    {
        #pragma acc kernels loop private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 0;
            #pragma acc loop vector reduction(max:temp)
            for (int y = 0; y < n; ++y){
                temp = fmax(a[x * n + y] * b[x * n + y], temp);
            }
            max[x] = temp;
        }
    }
    for (int x = 0; x < 10; ++x){
        temp_max = 0;
        for (int y = 0; y < n; ++y){
            if (temp_max < a[x * n + y] * b[x * n + y]){
                temp_max = a[x * n + y] * b[x * n + y];
            }
        }
        if (fabs(temp_max - max[x]) > PRECISION){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_min_general.c:::
#include "acc_testsuite.h"
#pragma acc routine (fmin) seq

#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t min = 1000.0;
    int found = 0;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX/10);
        b[x] = rand() / (real_t)(RAND_MAX/10);
    }
    #pragma acc data copyin(a[0:n], b[0:n]) copy(min)
    {
        #pragma acc kernels loop reduction(min:min)
        for (int x = 0; x < n; ++x){
            min = fmin(a[x] * b[x], min);
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs((a[x] * b[x]) - (min + PRECISION)) < 0){
            err = 1;
        }
        if (fabs(min - (a[x] * b[x])) < PRECISION){
            found = 1;
        }
    }
    if (found == 0){
        err = 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_min_general.cpp:::
#include "acc_testsuite.h"
#pragma acc routine (fmin) seq

#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t min = 1000.0;
    int found = 0;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX/10);
        b[x] = rand() / (real_t)(RAND_MAX/10);
    }
    #pragma acc data copyin(a[0:n], b[0:n]) copy(min)
    {
        #pragma acc kernels loop reduction(min:min)
        for (int x = 0; x < n; ++x){
            min = fmin(a[x] * b[x], min);
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs((a[x] * b[x]) - (min + PRECISION)) < 0){
            err = 1;
        }
        if (fabs(min - (a[x] * b[x])) < PRECISION){
            found = 1;
        }
    }
    if (found == 0){
        err = 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_min_loop.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * minimum = (real_t *)malloc(10 * sizeof(real_t));
    real_t temp = 0;

    for (int x = 0; x < 10 * n; ++x){
        a[x] = 1 + rand() / (real_t)(RAND_MAX/10);
        b[x] = 1 + rand() / (real_t)(RAND_MAX/10);
        c[x] = 0.0;
    }

    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], minimum[0:10])
    {
        #pragma acc kernels loop gang private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 1000;
            #pragma acc loop reduction(min:temp)
            for (int y = 0; y < n; ++y){
                temp = fmin(a[x * n + y] * b[x * n + y], temp);
            }
            minimum[x] = temp;
            #pragma acc loop
            for (int y = 0; y < n; ++y){
                c[x * n + y] = (a[x * n + y] * b[x * n + y]) / minimum[x];
            }
        }
    }

    for (int x = 0; x < 10; ++x){
        temp = 1000;
        for (int y = 0; y < n; ++y){
            temp = fmin(temp, a[x * n + y] * b[x * n + y]);
        }
        if (fabs(temp - minimum[x]) > PRECISION){
            err += 1;
        }
        for (int y = 0; y < n; ++y){
            if (fabs(c[x * n + y] - (a[x * n + y] * b[x * n + y] / minimum[x])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_min_loop.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[10 * n];
    real_t * b = new real_t[10 * n];
    real_t * c = new real_t[10 * n];
    real_t * minimum = new real_t[10];
    real_t temp = 0;

    for (int x = 0; x < 10 * n; ++x){
        a[x] = 1 + rand() / (real_t)(RAND_MAX/10);
        b[x] = 1 + rand() / (real_t)(RAND_MAX/10);
        c[x] = 0.0;
    }

    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n], minimum[0:10])
    {
        #pragma acc kernels loop gang private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 1000;
            #pragma acc loop reduction(min:temp)
            for (int y = 0; y < n; ++y){
                temp = fmin(a[x * n + y] * b[x * n + y], temp);
            }
            minimum[x] = temp;
            #pragma acc loop
            for (int y = 0; y < n; ++y){
                c[x * n + y] = (a[x * n + y] * b[x * n + y]) / minimum[x];
            }
        }
    }

    for (int x = 0; x < 10; ++x){
        temp = 1000;
        for (int y = 0; y < n; ++y){
            temp = fmin(temp, a[x * n + y] * b[x * n + y]);
        }
        if (fabs(temp - minimum[x]) > PRECISION){
            err += 1;
        }
        for (int y = 0; y < n; ++y){
            if (fabs(c[x * n + y] - (a[x * n + y] * b[x * n + y] / minimum[x])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_min_vector_loop.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * min = (real_t *)malloc(10 * sizeof(real_t));
    real_t temp = 100;
    real_t temp_min;

    for (int x = 0; x < 10 * n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX/10);
        b[x] = rand() / (real_t)(RAND_MAX/10);
    }

    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(min[0:10])
    {
        #pragma acc kernels loop gang private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 100;
            #pragma acc loop vector reduction(min:temp)
            for (int y = 0; y < n; ++y){
                temp = fmin(a[x * n + y] * b[x * n + y], temp);
            }
            min[x] = temp;
        }
    }
    for (int x = 0; x < 10; ++x){
        temp_min = 100;
        for (int y = 0; y < n; ++y){
            if (temp_min > a[x * n + y] * b[x * n + y]){
                temp_min = a[x * n + y] * b[x * n + y];
            }
        }
        if (fabs(temp_min - min[x]) > PRECISION){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_min_vector_loop.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[10 * n];
    real_t * b = new real_t[10 * n];
    real_t * min = new real_t[10];
    real_t temp = 100;
    real_t temp_min;

    for (int x = 0; x < 10 * n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX/10);
        b[x] = rand() / (real_t)(RAND_MAX/10);
    }

    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(min[0:10])
    {
        #pragma acc kernels loop gang private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 100;
            #pragma acc loop vector reduction(min:temp)
            for (int y = 0; y < n; ++y){
                temp = fmin(a[x * n + y] * b[x * n + y], temp);
            }
            min[x] = temp;
        }
    }
    for (int x = 0; x < 10; ++x){
        temp_min = 100;
        for (int y = 0; y < n; ++y){
            if (temp_min > a[x * n + y] * b[x * n + y]){
                temp_min = a[x * n + y] * b[x * n + y];
            }
        }
        if (fabs(temp_min - min[x]) > PRECISION){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_multiply_general.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    int multiplicitive_n = 128;
    srand(SEED);
    real_t * a = (real_t *)malloc(multiplicitive_n * sizeof(real_t));
    real_t * b = (real_t *)malloc(multiplicitive_n * sizeof(real_t));

    real_t multiplied_total = 1.0;

    for (int x = 0; x < multiplicitive_n; ++x){
        a[x] = rand() / (real_t) RAND_MAX;
        b[x] = rand() / (real_t) RAND_MAX;
    }

    #pragma acc data copyin(a[0:multiplicitive_n], b[0:multiplicitive_n]) copy(multiplied_total)
    {
        #pragma acc kernels loop reduction(*:multiplied_total)
        for (int x = 0; x < multiplicitive_n; ++x){
            multiplied_total *= a[x] + b[x];
        }
    }

    for (int x = 0; x < multiplicitive_n; ++x){
        multiplied_total /= (a[x] + b[x]);
    }
    if (fabs(multiplied_total - 1) > PRECISION * (2 * multiplicitive_n - 1)){
        err = 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_multiply_general.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    int multiplicitive_n = 128;
    srand(SEED);
    real_t * a = new real_t[multiplicitive_n];
    real_t * b = new real_t[multiplicitive_n];

    real_t multiplied_total = 1.0;

    for (int x = 0; x < multiplicitive_n; ++x){
        a[x] = rand() / (real_t) RAND_MAX;
        b[x] = rand() / (real_t) RAND_MAX;
    }

    #pragma acc data copyin(a[0:multiplicitive_n], b[0:multiplicitive_n]) copy(multiplied_total)
    {
        #pragma acc kernels loop reduction(*:multiplied_total)
        for (int x = 0; x < multiplicitive_n; ++x){
            multiplied_total *= a[x] + b[x];
        }
    }

    for (int x = 0; x < multiplicitive_n; ++x){
        multiplied_total /= (a[x] + b[x]);
    }
    if (fabs(multiplied_total - 1) > PRECISION * (2 * multiplicitive_n - 1)){
        err = 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_multiply_loop.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * totals = (real_t *)malloc(10 * sizeof(real_t));
    real_t temp;

    for (int x = 0; x < n; ++x){
        a[x] = (999.4 + rand() / (real_t)(RAND_MAX)) / 1000;
        b[x] = (999.4 + rand() / (real_t)(RAND_MAX)) / 1000;
        c[x] = 0.0;
    }


    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10*n]) copy(totals[0:10])
    {
        #pragma acc kernels loop gang private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 1;
            #pragma acc loop worker reduction(*:temp)
            for (int y = 0; y < n; ++y){
                temp *= a[x * n + y] + b[x * n + y];
            }
            totals[x] = temp;
            #pragma acc loop worker
            for (int y = 0; y < n; ++y){
                c[x * n + y] = (a[x * n + y] + b[x * n + y]) / totals[x];
            }
        }
    }

    for (int x = 0; x < 10; ++x){
        temp = 1;
        for (int y = 0; y < n; ++y){
            temp *= a[x * n + y] + b[x * n + y];
        }
        if (fabs(temp - totals[x]) > (temp / 2 + totals[x] / 2) * PRECISION){
            err += 1;
        }
        for (int y = 0; y < n; ++y){
            if (fabs(c[x * n + y] - ((a[x * n + y] + b[x * n + y]) / totals[x])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_multiply_loop.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[10 * n];
    real_t * b = new real_t[10 * n];
    real_t * c = new real_t[10 * n];
    real_t * totals = new real_t[10];
    real_t temp;

    for (int x = 0; x < n; ++x){
        a[x] = (999.4 + rand() / (real_t)(RAND_MAX)) / 1000;
        b[x] = (999.4 + rand() / (real_t)(RAND_MAX)) / 1000;
        c[x] = 0.0;
    }


    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10*n]) copy(totals[0:10])
    {
        #pragma acc kernels loop gang private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 1;
            #pragma acc loop worker reduction(*:temp)
            for (int y = 0; y < n; ++y){
                temp *= a[x * n + y] + b[x * n + y];
            }
            totals[x] = temp;
            #pragma acc loop worker
            for (int y = 0; y < n; ++y){
                c[x * n + y] = (a[x * n + y] + b[x * n + y]) / totals[x];
            }
        }
    }

    for (int x = 0; x < 10; ++x){
        temp = 1;
        for (int y = 0; y < n; ++y){
            temp *= a[x * n + y] + b[x * n + y];
        }
        if (fabs(temp - totals[x]) > (temp / 2 + totals[x] / 2) * PRECISION){
            err += 1;
        }
        for (int y = 0; y < n; ++y){
            if (fabs(c[x * n + y] - ((a[x * n + y] + b[x * n + y]) / totals[x])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_multiply_vector_loop.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    int multiplicitive_n = 128;
    srand(SEED);
    real_t * a = (real_t *)malloc(10 * multiplicitive_n * sizeof(real_t));
    real_t * b = (real_t *)malloc(10 * multiplicitive_n * sizeof(real_t));
    real_t * c = (real_t *)malloc(10 * sizeof(real_t));
    real_t temp;

    for (int x = 0; x < 10 * multiplicitive_n; ++x){
        a[x] = rand() / (real_t) RAND_MAX;
        b[x] = rand() / (real_t) RAND_MAX;
    }

    #pragma acc data copyin(a[0:10*multiplicitive_n], b[0:10*multiplicitive_n]) copyout(c[0:10])
    {
        #pragma acc kernels loop private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 1.0;
            #pragma acc loop vector reduction(*:temp)
            for (int y = 0; y < multiplicitive_n; ++y){
                temp *= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];
            }
            c[x] = temp;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < multiplicitive_n; ++y){
            c[x] /= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];
        }
    }

    for (int x = 0; x < 10; ++x){
        if (fabs(c[x] - 1) > PRECISION * (4 * multiplicitive_n - 1)){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_multiply_vector_loop.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    int multiplicitive_n = 128;
    srand(SEED);
    real_t * a = new real_t[10 * multiplicitive_n];
    real_t * b = new real_t[10 * multiplicitive_n];
    real_t * c = new real_t[10];
    real_t temp;

    for (int x = 0; x < 10 * multiplicitive_n; ++x){
        a[x] = rand() / (real_t) RAND_MAX;
        b[x] = rand() / (real_t) RAND_MAX;
    }

    #pragma acc data copyin(a[0:10*multiplicitive_n], b[0:10*multiplicitive_n]) copyout(c[0:10])
    {
        #pragma acc kernels loop private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 1.0;
            #pragma acc loop vector reduction(*:temp)
            for (int y = 0; y < multiplicitive_n; ++y){
                temp *= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];
            }
            c[x] = temp;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < multiplicitive_n; ++y){
            c[x] /= a[(x * multiplicitive_n) + y] + b[(x * multiplicitive_n) + y];
        }
    }

    for (int x = 0; x < 10; ++x){
        if (fabs(c[x] - 1) > PRECISION * (4 * multiplicitive_n - 1)){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_or_general.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    char * a = (char *)malloc(n * sizeof(char));
    real_t false_margin = pow(exp(1), log(.5)/n);
    char result = 0;
    char found = 0;

    for (int x = 0; x < n; ++x){
        if(a[x] = rand() / (real_t)(RAND_MAX) > false_margin){
            a[x] = 1;
        }
        else{
            a[x] = 0;
        }
    }


    #pragma acc data copyin(a[0:n])
    {
        #pragma acc kernels loop reduction(||:result)
        for (int x = 0; x < n; ++x){
            result = result || a[x];
        }
    }

    for (int x = 0; x < n; ++x){
        if (a[x] == 1){
            found = 1;
        }
    }
    if (found != result){
        err = 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_or_general.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    char * a = new char[n];
    real_t false_margin = pow(exp(1), log(.5)/n);
    char result = 0;
    char found = 0;

    for (int x = 0; x < n; ++x){
        if(a[x] = rand() / (real_t)(RAND_MAX) > false_margin){
            a[x] = 1;
        }
        else{
            a[x] = 0;
        }
    }


    #pragma acc data copyin(a[0:n])
    {
        #pragma acc kernels loop reduction(||:result)
        for (int x = 0; x < n; ++x){
            result = result || a[x];
        }
    }

    for (int x = 0; x < n; ++x){
        if (a[x] == 1){
            found = 1;
        }
    }
    if (found != result){
        err = 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_or_loop.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    char * a = (char *)malloc(10 * n * sizeof(char));
    char * a_copy = (char *)malloc(10 * n * sizeof(char));
    char * results = (char *)malloc(10 * sizeof(char));
    char temp = 0;
    real_t false_margin = pow(exp(1), log(.5)/n);

    for (int x = 0; x < 10 * n; ++x){
        if (rand() / (real_t)(RAND_MAX) > false_margin){
            a[x] = 1;
            a_copy[x] = 1;
        }
        else{
            a[x] = 0;
            a_copy[x] = 0;
        }
    }
    #pragma acc data copy(a[0:10*n])
    {
        #pragma acc kernels loop gang private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 0;
            #pragma acc loop worker reduction(||:temp)
            for (int y = 0; y < n; ++y){
                temp = temp || a[x * n + y];
            }
            results[x] = temp;
            #pragma acc loop worker
            for (int y = 0; y < n; ++y){
                if(results[x] == 1){
                    if (a[x * n + y] == 1){
                        a[x * n + y] = 0;
                    }
                    else{
                        a[x * n + y] = 1;
                    }
                }
            }
        }
    }
    for (int x = 0; x < 10; ++x){
        temp = 0;
        for (int y = 0; y < n; ++y){
            temp = temp || a_copy[x * n + y];
        }
        if (temp != results[x]) {
            err += 1;
        }
        for (int y = 0; y < n; ++y){
            if (temp == 1){
                if (a[x * n + y] == a_copy[x * n + y]){
                    err += 1;
                }
            }
            else {
                if (a[x * n + y] != a_copy[x * n + y]){
                    err += 1;
                }
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_or_loop.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    char * a = new char[10 * n];
    char * a_copy = new char[10 * n];
    char * results = new char[10];
    char temp = 0;
    real_t false_margin = pow(exp(1), log(.5)/n);

    for (int x = 0; x < 10 * n; ++x){
        if (rand() / (real_t)(RAND_MAX) > false_margin){
            a[x] = 1;
            a_copy[x] = 1;
        }
        else{
            a[x] = 0;
            a_copy[x] = 0;
        }
    }
    #pragma acc data copy(a[0:10*n])
    {
        #pragma acc kernels loop gang private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 0;
            #pragma acc loop worker reduction(||:temp)
            for (int y = 0; y < n; ++y){
                temp = temp || a[x * n + y];
            }
            results[x] = temp;
            #pragma acc loop worker
            for (int y = 0; y < n; ++y){
                if(results[x] == 1){
                    if (a[x * n + y] == 1){
                        a[x * n + y] = 0;
                    }
                    else{
                        a[x * n + y] = 1;
                    }
                }
            }
        }
    }
    for (int x = 0; x < 10; ++x){
        temp = 0;
        for (int y = 0; y < n; ++y){
            temp = temp || a_copy[x * n + y];
        }
        if (temp != results[x]) {
            err += 1;
        }
        for (int y = 0; y < n; ++y){
            if (temp == 1){
                if (a[x * n + y] == a_copy[x * n + y]){
                    err += 1;
                }
            }
            else {
                if (a[x * n + y] != a_copy[x * n + y]){
                    err += 1;
                }
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_or_vector_loop.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    char * a = (char *)malloc(10 * n * sizeof(char));
    char * b = (char *)malloc(10 * sizeof(char));
    real_t false_margin = pow(exp(1), log(.5)/n);
    char temp = 0;
    char found;

    for (int x = 0; x < 10 * n; ++x){
        if(rand() / (real_t)(RAND_MAX) > false_margin){
            a[x] = 1;
        }
        else{
            a[x] = 0;
        }
    }
    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])
    {
        #pragma acc kernels loop private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 0;
            #pragma acc loop vector reduction(||:temp)
            for (int y = 0; y < n; ++y){
                temp = temp || a[x * n + y];
            }
            b[x] = temp;
        }
    }
    for (int x = 0; x < 10; ++x){
        found = 0;
        for (int y = 0; y < n; ++y){
            if (a[x * n + y] &! 0){
                found = 1;
            }
        }
        if (found != b[x]){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_reduction_or_vector_loop.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    char * a = new char[10 * n];
    char * b = new char[10];
    real_t false_margin = pow(exp(1), log(.5)/n);
    char temp = 0;
    char found;

    for (int x = 0; x < 10 * n; ++x){
        if(rand() / (real_t)(RAND_MAX) > false_margin){
            a[x] = 1;
        }
        else{
            a[x] = 0;
        }
    }
    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])
    {
        #pragma acc kernels loop private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 0;
            #pragma acc loop vector reduction(||:temp)
            for (int y = 0; y < n; ++y){
                temp = temp || a[x * n + y];
            }
            b[x] = temp;
        }
    }
    for (int x = 0; x < 10; ++x){
        found = 0;
        for (int y = 0; y < n; ++y){
            if (a[x * n + y] &! 0){
                found = 1;
            }
        }
        if (found != b[x]){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_seq.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,combined-constructs,V:1.0-2.7
int test1(){
  int err = 0;
  srand(SEED);
  real_t * a = (real_t *)malloc(n * sizeof(real_t));
  real_t * b = (real_t *)malloc(n * sizeof(real_t));
  real_t temp = 0.0;

  for (int x = 0; x < n; ++x){
      a[x] = rand() / (real_t)(RAND_MAX / 10);
      b[x] = 0.0;
  }

  #pragma acc data copyin(a[0:n]) copy(b[0:n])
  {
      #pragma acc kernels loop seq
      for (int x = 1; x < n; ++x){
          b[x] = b[x-1] + a[x];
      }
  }

  for (int x = 1; x < n; ++x){
      temp += a[x];
      if (fabs(b[x] - temp) > PRECISION){
          err = 1;
      }
  }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_seq.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,combined-constructs,V:1.0-2.7
int test1(){
  int err = 0;
  srand(SEED);
  real_t * a = new real_t[n];
  real_t * b = new real_t[n];
  real_t temp = 0.0;

  for (int x = 0; x < n; ++x){
      a[x] = rand() / (real_t)(RAND_MAX / 10);
      b[x] = 0.0;
  }

  #pragma acc data copyin(a[0:n]) copy(b[0:n])
  {
      #pragma acc kernels loop seq
      for (int x = 1; x < n; ++x){
          b[x] = b[x-1] + a[x];
      }
  }

  for (int x = 1; x < n; ++x){
      temp += a[x];
      if (fabs(b[x] - temp) > PRECISION){
          err = 1;
      }
  }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_tile.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,tile,reduction,combined-constructs,V:2.0-2.7
int test1(){
  int err = 0;
  srand(SEED);
  real_t * a = (real_t *)malloc(n * sizeof(real_t));
  real_t * b = (real_t *)malloc(n * sizeof(real_t));
  real_t * c = (real_t *)malloc(n * sizeof(real_t));
  real_t * d2 = (real_t *)malloc(n * n * sizeof(real_t));
  real_t * d3 = (real_t *)malloc(n * n * n * sizeof(real_t));
  real_t temp = 0.0;

  for (int x = 0; x < n; ++x){
      a[x] = rand() / (real_t)(RAND_MAX / 10);
      b[x] = rand() / (real_t)(RAND_MAX / 10);
      c[x] = rand() / (real_t)(RAND_MAX / 10);
  }
  #pragma acc data copy(a[0:n], b[0:n], c[0:n], d2[0:n*n])
  {
      #pragma acc kernels loop tile(*, *) reduction(+:temp)
      for (int x = 0; x < n; ++x){
          for (int y = 0; y < n; ++y){
              temp = 0;
              for (int z = 0; z < n; ++z){
                  temp += a[x] + b[y] + c[z];
              }
              d2[x * n + y] = temp;
          }
      }
  }
  for (int x = 0; x < n; ++x){
      for (int y = 0; y < n; ++y){
          temp = 0.0;
          for (int z = 0; z < n; ++z){
              temp += a[x] + b[y] + c[z];
          }
          if (fabs(temp - d2[x * n + y]) > PRECISION * n){
              err += 1;
          }
      }
  }

    return err;
}
#endif

#ifndef T2
//T2:kernels,loop,tile,combined-constructs,V:2.0-2.7
int test2(){
  int err = 0;
  srand(SEED);
  real_t * a = (real_t *)malloc(n * sizeof(real_t));
  real_t * b = (real_t *)malloc(n * sizeof(real_t));
  real_t * c = (real_t *)malloc(n * sizeof(real_t));
  real_t * d2 = (real_t *)malloc(n * n * sizeof(real_t));
  real_t * d3 = (real_t *)malloc(n * n * n * sizeof(real_t));
  real_t temp = 0.0;

  for (int x = 0; x < n; ++x){
      a[x] = rand() / (real_t)(RAND_MAX / 10);
      b[x] = rand() / (real_t)(RAND_MAX / 10);
      c[x] = rand() / (real_t)(RAND_MAX / 10);
  }

  #pragma acc data copyin(a[0:n], b[0:n], c[0:n]) copyout(d3[0:n*n*n])
  {
      #pragma acc kernels loop tile(n/10, n, n*2)
      for (int x = 0; x < n; ++x){
          for (int y = 0; y < n; ++y){
              for (int z = 0; z < n; ++z){
                  d3[(n * n * x) + (n * y) + z] = a[x] + b[x] + c[x];
              }
          }
      }
  }

  for (int x = 0; x < n; ++x){
      for (int y = 0; y < n; ++y){
          for (int z = 0; z < n; ++z){
              if (fabs(d3[(n * n * x) + (n * y) + z] - a[x] - b[x] - c[x]) > PRECISION * 2){
                  err = 1;
              }
          }
      }
  }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_tile.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,tile,reduction,combined-constructs,V:2.0-2.7
int test1(){
  int err = 0;
  srand(SEED);
  real_t * a = new real_t[n];
  real_t * b = new real_t[n];
  real_t * c = new real_t[n];
  real_t * d2 = new real_t[n * n];
  real_t * d3 = new real_t[n * n * n];
  real_t temp = 0.0;

  for (int x = 0; x < n; ++x){
      a[x] = rand() / (real_t)(RAND_MAX / 10);
      b[x] = rand() / (real_t)(RAND_MAX / 10);
      c[x] = rand() / (real_t)(RAND_MAX / 10);
  }
  #pragma acc data copy(a[0:n], b[0:n], c[0:n], d2[0:n*n])
  {
      #pragma acc kernels loop tile(*, *) reduction(+:temp)
      for (int x = 0; x < n; ++x){
          for (int y = 0; y < n; ++y){
              temp = 0;
              for (int z = 0; z < n; ++z){
                  temp += a[x] + b[y] + c[z];
              }
              d2[x * n + y] = temp;
          }
      }
  }
  for (int x = 0; x < n; ++x){
      for (int y = 0; y < n; ++y){
          temp = 0.0;
          for (int z = 0; z < n; ++z){
              temp += a[x] + b[y] + c[z];
          }
          if (fabs(temp - d2[x * n + y]) > PRECISION * n){
              err += 1;
          }
      }
  }

    return err;
}
#endif

#ifndef T2
//T2:kernels,loop,tile,combined-constructs,V:2.0-2.7
int test2(){
  int err = 0;
  srand(SEED);
  real_t * a = new real_t[n];
  real_t * b = new real_t[n];
  real_t * c = new real_t[n];
  real_t * d2 = new real_t[n * n];
  real_t * d3 = new real_t[n * n * n];
  real_t temp = 0.0;

  for (int x = 0; x < n; ++x){
      a[x] = rand() / (real_t)(RAND_MAX / 10);
      b[x] = rand() / (real_t)(RAND_MAX / 10);
      c[x] = rand() / (real_t)(RAND_MAX / 10);
  }

  #pragma acc data copyin(a[0:n], b[0:n], c[0:n]) copyout(d3[0:n*n*n])
  {
      #pragma acc kernels loop tile(n/10, n, n*2)
      for (int x = 0; x < n; ++x){
          for (int y = 0; y < n; ++y){
              for (int z = 0; z < n; ++z){
                  d3[(n * n * x) + (n * y) + z] = a[x] + b[x] + c[x];
              }
          }
      }
  }

  for (int x = 0; x < n; ++x){
      for (int y = 0; y < n; ++y){
          for (int z = 0; z < n; ++z){
              if (fabs(d3[(n * n * x) + (n * y) + z] - a[x] - b[x] - c[x]) > PRECISION * 2){
                  err = 1;
              }
          }
      }
  }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_vector_blocking.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,V:1.0-2.7
int test1(){
  int err = 0;
  srand(SEED);
  real_t * a = (real_t *)malloc(n * sizeof(real_t));
  real_t * b = (real_t *)malloc(n * sizeof(real_t));
  real_t * c = (real_t *)malloc(n * sizeof(real_t));
  real_t multiplyer = 1;

  for (int x = 0; x < n; ++x){
      a[x] = rand() / (real_t)(RAND_MAX / 10);
      b[x] = rand() / (real_t)(RAND_MAX / 10);
      c[x] = 0.0;
  }

  #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])
  {
    #pragma acc kernels
    {
      #pragma acc loop vector
      for (int x = 0; x < n; ++x){
        c[x] = (a[x] + b[x]) * multiplyer;
      }
      multiplyer += 1;
      #pragma acc loop vector
      for (int x = 0; x < n; ++x){
        c[x] += (a[x] + b[x]) * multiplyer;
      }
    }
  }

  for (int x = 0; x < n; ++x){
    if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){
      err + 1;
      break;
    }
  }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_vector_blocking.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,V:1.0-2.7
int test1(){
  int err = 0;
  srand(SEED);
  real_t * a = new real_t[n];
  real_t * b = new real_t[n];
  real_t * c = new real_t[n];
  real_t multiplyer = 1;

  for (int x = 0; x < n; ++x){
      a[x] = rand() / (real_t)(RAND_MAX / 10);
      b[x] = rand() / (real_t)(RAND_MAX / 10);
      c[x] = 0.0;
  }

  #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])
  {
    #pragma acc kernels
    {
      #pragma acc loop vector
      for (int x = 0; x < n; ++x){
        c[x] = (a[x] + b[x]) * multiplyer;
      }
      multiplyer += 1;
      #pragma acc loop vector
      for (int x = 0; x < n; ++x){
        c[x] += (a[x] + b[x]) * multiplyer;
      }
    }
  }

  for (int x = 0; x < n; ++x){
    if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){
      err + 1;
      break;
    }
  }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_worker_blocking.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,V:1.0-2.7
int test1(){
  int err = 0;
  srand(SEED);
  real_t * a = (real_t *)malloc(n * sizeof(real_t));
  real_t * b = (real_t *)malloc(n * sizeof(real_t));
  real_t * c = (real_t *)malloc(n * sizeof(real_t));
  real_t multiplyer = 1;

  for (int x = 0; x < n; ++x){
      a[x] = rand() / (real_t)(RAND_MAX / 10);
      b[x] = rand() / (real_t)(RAND_MAX / 10);
      c[x] = 0.0;
  }

  #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])
  {
    #pragma acc kernels
    {
      #pragma acc loop worker
      for (int x = 0; x < n; ++x){
        c[x] = (a[x] + b[x]) * multiplyer;
      }
      multiplyer += 1;
      #pragma acc loop worker
      for (int x = 0; x < n; ++x){
        c[x] += (a[x] + b[x]) * multiplyer;
      }
    }
  }

  for (int x = 0; x < n; ++x){
    if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){
      err + 1;
      break;
    }
  }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_loop_worker_blocking.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,V:1.0-2.7
int test1(){
  int err = 0;
  srand(SEED);
  real_t * a = new real_t[n];
  real_t * b = new real_t[n];
  real_t * c = new real_t[n];
  real_t multiplyer = 1;

  for (int x = 0; x < n; ++x){
      a[x] = rand() / (real_t)(RAND_MAX / 10);
      b[x] = rand() / (real_t)(RAND_MAX / 10);
      c[x] = 0.0;
  }

  #pragma acc data copyin(a[0:n], b[0:n]) copyout(c[0:n])
  {
    #pragma acc kernels
    {
      #pragma acc loop worker
      for (int x = 0; x < n; ++x){
        c[x] = (a[x] + b[x]) * multiplyer;
      }
      multiplyer += 1;
      #pragma acc loop worker
      for (int x = 0; x < n; ++x){
        c[x] += (a[x] + b[x]) * multiplyer;
      }
    }
  }

  for (int x = 0; x < n; ++x){
    if (fabs(c[x] - 3 * (a[x] + b[x])) > PRECISION){
      err + 1;
      break;
    }
  }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_num_gangs.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * restrict a = (real_t *)malloc(n * sizeof(real_t));
    real_t * restrict b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copyout(b[0:n])
    {
        #pragma acc kernels loop num_gangs(16)
        for (int x = 0; x < n; ++x){
            b[x] = a[x];
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_num_gangs.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * restrict a = new real_t[n];
    real_t * restrict b = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copyout(b[0:n])
    {
        #pragma acc kernels loop num_gangs(16)
        for (int x = 0; x < n; ++x){
            b[x] = a[x];
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_num_workers.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * restrict a = (real_t *)malloc(n * sizeof(real_t));
    real_t * restrict b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copyout(b[0:n])
    {
        #pragma acc kernels loop num_workers(16)
        for (int x = 0; x < n; ++x){
            b[x] = a[x];
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_num_workers.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,loop,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * restrict a = new real_t[n];
    real_t * restrict b = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copyout(b[0:n])
    {
        #pragma acc kernels loop num_workers(16)
        for (int x = 0; x < n; ++x){
            b[x] = a[x];
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_present.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,data,structured-data,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0.0;
    }

    #pragma acc enter data copyin(a[0:n]) create(b[0:n])
    #pragma acc kernels present(a[0:n], b[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            b[x] = a[x];
        }
    }
    #pragma acc exit data copyout(b[0:n]) delete(a[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - a[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_present.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,data,structured-data,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0.0;
    }

    #pragma acc enter data copyin(a[0:n]) create(b[0:n])
    #pragma acc kernels present(a[0:n], b[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            b[x] = a[x];
        }
    }
    #pragma acc exit data copyout(b[0:n]) delete(a[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(b[x] - a[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_scalar_default_copy.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,data,data-region,default-mapping,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t sum = 0.0;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    for (int x = 0; x < n; ++x){
        sum = sum + a[x];
    }

    #pragma acc data copyin(b[0:n])
    {
        #pragma acc kernels num_gangs(1) vector_length(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                sum = sum + b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        sum = sum - (a[x] + b[x]);
    }

    if (fabs(sum) > (2 * n - 2) * PRECISION){
        err += 1;
        sum = 0.0;
        for (int x = 0; x < n; ++x){
            sum = sum + a[x];
        }
        sum = 0.0;
        for (int x = 0; x < n; ++x){
            sum = sum + b[x];
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_scalar_default_copy.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,data,data-region,default-mapping,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t sum = 0.0;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    for (int x = 0; x < n; ++x){
        sum = sum + a[x];
    }

    #pragma acc data copyin(b[0:n])
    {
        #pragma acc kernels num_gangs(1) vector_length(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                sum = sum + b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        sum = sum - (a[x] + b[x]);
    }

    if (fabs(sum) > (2 * n - 2) * PRECISION){
        err += 1;
        sum = 0.0;
        for (int x = 0; x < n; ++x){
            sum = sum + a[x];
        }
        sum = 0.0;
        for (int x = 0; x < n; ++x){
            sum = sum + b[x];
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_vector_length.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copyout(b[0:n])
    {
        #pragma acc kernels vector_length(16)
        {
            #pragma acc loop vector
            for (int x = 0; x < n; ++x){
                b[x] = a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_vector_length.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) copyout(b[0:n])
    {
        #pragma acc kernels vector_length(16)
        {
            #pragma acc loop vector
            for (int x = 0; x < n; ++x){
                b[x] = a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_wait.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,wait,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n]) async(1)
    #pragma acc kernels wait(1)
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] += a[x] + b[x];
        }
    }

    #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
kernels_wait.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:kernels,wait,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n]) async(1)
    #pragma acc kernels wait(1)
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] += a[x] + b[x];
        }
    }

    #pragma acc exit data copyout(c[0:n]) delete(a[0:n], b[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
loop_collapse.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:loop,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));

    for (int x = 0; x < 10 * n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }
    for (int x = 0; x < 10; ++x){
        c[x * n] = a[x * n] + b[x * n];
    }

    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop independent collapse(1)
            for (int x = 0; x < 10; ++x){
                for (int y = 1; y < n; ++y){
                    c[x * n + y] = c[x * n + y - 1] + a[x * n + y] + b[x * n + y];
                }
            }
        }
    }

    real_t total;
    for (int x = 0; x < 10; ++x){
        total = 0;
        for (int y = 0; y < n; ++y){
            total += a[x * n + y] + b[x * n + y];
            if (fabs(c[x * n + y] - total) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:loop,syntactic,construct-independent,V:1.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));

    for (int x = 0; x < 10 * n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop independent collapse(2)
            for (int x = 0; x < 10; ++x){
                for (int y = 0; y < n; ++y){
                    c[x * n + y] = a[x * n + y] + b[x * n + y];
                }
            }
        }
    }

    for (int x = 0; x < 10 * n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
loop_collapse.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:loop,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[10 * n];
    real_t * b = new real_t[10 * n];
    real_t * c = new real_t[10 * n];

    for (int x = 0; x < 10 * n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }
    for (int x = 0; x < 10; ++x){
        c[x * n] = a[x * n] + b[x * n];
    }

    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop independent collapse(1)
            for (int x = 0; x < 10; ++x){
                for (int y = 1; y < n; ++y){
                    c[x * n + y] = c[x * n + y - 1] + a[x * n + y] + b[x * n + y];
                }
            }
        }
    }

    real_t total;
    for (int x = 0; x < 10; ++x){
        total = 0;
        for (int y = 0; y < n; ++y){
            total += a[x * n + y] + b[x * n + y];
            if (fabs(c[x * n + y] - total) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:loop,syntactic,construct-independent,V:1.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[10 * n];
    real_t * b = new real_t[10 * n];
    real_t * c = new real_t[10 * n];

    for (int x = 0; x < 10 * n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop independent collapse(2)
            for (int x = 0; x < 10; ++x){
                for (int y = 0; y < n; ++y){
                    c[x * n + y] = a[x * n + y] + b[x * n + y];
                }
            }
        }
    }

    for (int x = 0; x < 10 * n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
loop_no_collapse_default.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:loop,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t total = 0;

    for (int x = 0; x < 10 * n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        c[x * n] = a[x * n] + b[x * n];
    }

    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop independent
            for (int x = 0; x < 10; ++x){
                for (int y = 1; y < n; ++y){
                    c[x * n + y] = c[x * n + y - 1] + a[x * n + y] + b[x * n + y];
                }
            }
        }
    }
    for (int x = 0; x < 10; ++x){
        total = 0;
        for (int y = 0; y < n; ++y){
            total += a[x * n + y] + b[x * n +y];
            if (fabs(total - c[x * n + y]) > PRECISION * y){
                err += 1;
            }
        }
    }

    return err;
}
#endif


int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
loop_no_collapse_default.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:loop,construct-independent,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[10 * n];
    real_t * b = new real_t[10 * n];
    real_t * c = new real_t[10 * n];
    real_t total = 0;

    for (int x = 0; x < 10 * n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    for (int x = 0; x < 10; ++x){
        c[x * n] = a[x * n] + b[x * n];
    }

    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(c[0:10*n])
    {
        #pragma acc parallel
        {
            #pragma acc loop independent
            for (int x = 0; x < 10; ++x){
                for (int y = 1; y < n; ++y){
                    c[x * n + y] = c[x * n + y - 1] + a[x * n + y] + b[x * n + y];
                }
            }
        }
    }
    for (int x = 0; x < 10; ++x){
        total = 0;
        for (int y = 0; y < n; ++y){
            total += a[x * n + y] + b[x * n +y];
            if (fabs(total - c[x * n + y]) > PRECISION * y){
                err += 1;
            }
        }
    }

    return err;
}
#endif


int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t* a = (real_t *) malloc(1024 * sizeof(real_t));
    real_t* b = (real_t *) malloc(1024 * sizeof(real_t));
    real_t* c = (real_t *) malloc(1024 * sizeof(real_t));

    for(int x = 0; x < 1024; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc data copyin(a[0:1024], b[0:1024]) copy(c[0:1024])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int _0 = 0; _0 < 2; ++_0){
                #pragma acc loop
                for (int _1 = 0; _1 < 2; ++_1){
                    #pragma acc loop
                    for (int _2 = 0; _2 < 2; ++_2){
                        #pragma acc loop
                        for (int _3 = 0; _3 < 2; ++_3){
                            #pragma acc loop
                            for (int _4 = 0; _4 < 2; ++_4){
                                #pragma acc loop
                                for (int _5 = 0; _5 < 2; ++_5){
                                    #pragma acc loop
                                    for (int _6 = 0; _6 < 2; ++_6){
                                        #pragma acc loop
                                        for (int _7 = 0; _7 < 2; ++_7){
                                            #pragma acc loop
                                            for (int _8 = 0; _8 < 2; ++_8){
                                                #pragma acc loop
                                                for (int _9 = 0; _9 < 2; ++_9){
                                                    c[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9] =
                                                    a[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9] +
                                                    b[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9];
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    for (int x = 0; x < 1024; ++x){
        if(fabs(c[x] - (a[x] +b[x])) > PRECISION){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t* a = new real_t[1024];
    real_t* b = new real_t[1024];
    real_t* c = new real_t[1024];

    for(int x = 0; x < 1024; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc data copyin(a[0:1024], b[0:1024]) copy(c[0:1024])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int _0 = 0; _0 < 2; ++_0){
                #pragma acc loop
                for (int _1 = 0; _1 < 2; ++_1){
                    #pragma acc loop
                    for (int _2 = 0; _2 < 2; ++_2){
                        #pragma acc loop
                        for (int _3 = 0; _3 < 2; ++_3){
                            #pragma acc loop
                            for (int _4 = 0; _4 < 2; ++_4){
                                #pragma acc loop
                                for (int _5 = 0; _5 < 2; ++_5){
                                    #pragma acc loop
                                    for (int _6 = 0; _6 < 2; ++_6){
                                        #pragma acc loop
                                        for (int _7 = 0; _7 < 2; ++_7){
                                            #pragma acc loop
                                            for (int _8 = 0; _8 < 2; ++_8){
                                                #pragma acc loop
                                                for (int _9 = 0; _9 < 2; ++_9){
                                                    c[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9] =
                                                    a[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9] +
                                                    b[_0*512 + _1*256 + _2*128 + _3*64 + _4*32 + _5*16 + _6*8+ _7*4 + _8*2 + _9];
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    for (int x = 0; x < 1024; ++x){
        if(fabs(c[x] - (a[x] +b[x])) > PRECISION){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_async.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,async,wait,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    real_t * d = (real_t *)malloc(n * sizeof(real_t));
    real_t * e = (real_t *)malloc(n * sizeof(real_t));
    real_t * f = (real_t *)malloc(n * sizeof(real_t));
    real_t * g = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = rand() / (real_t)(RAND_MAX / 10);
        f[x] = 0.0;
        g[x] = 0.0;
    }

    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n], c[0:n], f[0:n], g[0:n])
    {
        #pragma acc parallel async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc parallel async(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                f[x] = d[x] + e[x];
            }
        }
        #pragma acc parallel wait(1, 2) async(3)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                g[x] = c[x] + f[x];
            }
        }
        #pragma acc update host(c[0:n]) async(1)
        #pragma acc update host(f[0:n]) async(2)
        #pragma acc update host(g[0:n]) async(3)

        #pragma acc wait(1)
        for (int x = 0; x < n; ++x){
            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
                err += 1;
            }
        }
        #pragma acc wait(2)
        for (int x = 0; x < n; ++x){
            if (fabs(f[x] - (d[x] + e[x])) > PRECISION){
                err += 1;
            }
        }
        #pragma acc wait(3)
        for (int x = 0; x < n; ++x){
            if (fabs(g[x] - (a[x] + b[x] + d[x] + e[x])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_async.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,async,wait,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];
    real_t * d = new real_t[n];
    real_t * e = new real_t[n];
    real_t * f = new real_t[n];
    real_t * g = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
        d[x] = rand() / (real_t)(RAND_MAX / 10);
        e[x] = rand() / (real_t)(RAND_MAX / 10);
        f[x] = 0.0;
        g[x] = 0.0;
    }

    #pragma acc data copyin(a[0:n], b[0:n], d[0:n], e[0:n], c[0:n], f[0:n], g[0:n])
    {
        #pragma acc parallel async(1)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = a[x] + b[x];
            }
        }
        #pragma acc parallel async(2)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                f[x] = d[x] + e[x];
            }
        }
        #pragma acc parallel wait(1, 2) async(3)
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                g[x] = c[x] + f[x];
            }
        }
        #pragma acc update host(c[0:n]) async(1)
        #pragma acc update host(f[0:n]) async(2)
        #pragma acc update host(g[0:n]) async(3)

        #pragma acc wait(1)
        for (int x = 0; x < n; ++x){
            if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
                err += 1;
            }
        }
        #pragma acc wait(2)
        for (int x = 0; x < n; ++x){
            if (fabs(f[x] - (d[x] + e[x])) > PRECISION){
                err += 1;
            }
        }
        #pragma acc wait(3)
        for (int x = 0; x < n; ++x){
            if (fabs(g[x] - (a[x] + b[x] + d[x] + e[x])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_copy.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,data,data-region,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * a_host = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        a_host[x] = a[x];
    }

    #pragma acc parallel copy(a[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            a[x] = 2 * a[x];
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - (2 * a_host[x])) > PRECISION){
            err = 1;
        }
    }

    return err;
}
#endif
#ifndef T2
//T2:parallel,data,data-region,V:1.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t device = rand() / (real_t)(RAND_MAX / 10);
    real_t host = device;
    #pragma acc parallel loop copy(device) reduction(+:device)
    for(int x = 0; x < n; ++x){
        device += 1.0;
    }

    if(fabs(host - (device - n) ) > PRECISION){
            err++;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed += test1();
    }
    if(failed){
        failcode +=  (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed += test2();
    }
    if(failed){
        failcode +=  (1 << 1);
    }
#endif

    return failcode;
}
########## NEXT FILE ##########
parallel_copy.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,data,data-region,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * a_host = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        a_host[x] = a[x];
    }

    #pragma acc parallel copy(a[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            a[x] = 2 * a[x];
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - (2 * a_host[x])) > PRECISION){
            err = 1;
        }
    }

    return err;
}
#endif
#ifndef T2
//T2:parallel,data,data-region,V:1.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t device = rand() / (real_t)(RAND_MAX / 10);
    real_t host = device;
    #pragma acc parallel loop copy(device) reduction(+:device)
    for(int x = 0; x < n; ++x){
        device += 1.0;
    }

    if(fabs(host - (device - n) ) > PRECISION){
            err++;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed += test1();
    }
    if(failed){
        failcode +=  (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed += test2();
    }
    if(failed){
        failcode +=  (1 << 1);
    }
#endif

    return failcode;
}
########## NEXT FILE ##########
parallel_copyin.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,data,data-region,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    int* hasDevice = (int *) malloc(sizeof(int));
    hasDevice[0] = 1;
    #pragma acc enter data copyin(hasDevice[0:1])
    #pragma acc parallel present(hasDevice[0:1])
    {
      hasDevice[0] = 0;
    }

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        a_copy[x] = a[x];
        b[x] = 0.0;
    }

    #pragma acc parallel copyin(a[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            a[x] = 0.0;
        }
    }

    for (int x = 0; x < n; ++x){
        if (((fabs(a[x] - a_copy[x]) > PRECISION) && (hasDevice[0] == 1)) || ((hasDevice[0] == 0) && (fabs(a[x]) > PRECISION))){
            err = 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,data,data-region,V:1.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * a_copy = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copy(b[0:n])
    {
        #pragma acc parallel copyin(a[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_copyin.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,data,data-region,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * a_copy = new real_t[n];
    real_t * b = new real_t[n];
    int* hasDevice = (int *) malloc(sizeof(int));
    hasDevice[0] = 1;
    #pragma acc enter data copyin(hasDevice[0:1])
    #pragma acc parallel present(hasDevice[0:1])
    {
      hasDevice[0] = 0;
    }

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        a_copy[x] = a[x];
        b[x] = 0.0;
    }

    #pragma acc parallel copyin(a[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            a[x] = 0.0;
        }
    }

    for (int x = 0; x < n; ++x){
        if (((fabs(a[x] - a_copy[x]) > PRECISION) && (hasDevice[0] == 1)) || ((hasDevice[0] == 0) && (fabs(a[x]) > PRECISION))){
            err = 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,data,data-region,V:1.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * a_copy = new real_t[n];
    real_t * b = new real_t[n];
    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copy(b[0:n])
    {
        #pragma acc parallel copyin(a[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_copyout.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,data,data-region,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);

    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0.0;
    }

    #pragma acc data copyin(a[0:n])
    {
        #pragma acc parallel copyout(b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,data,data-region,devonly,V:2.0-2.7
int test2(){
    int err = 0;
    srand(SEED);

    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));

    int* hasDevice = (int *) malloc(sizeof(int));
    hasDevice[0] = 1;
    #pragma acc enter data copyin(hasDevice[0:1])
    #pragma acc parallel present(hasDevice[0:1])
    {
      hasDevice[0] = 0;
    }

    if (hasDevice[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = a[x];
        }

        #pragma acc data copyin(a[0:n], b[0:n])
        {
            #pragma acc parallel copyout(b[0:n])
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    b[x] = b[x] - a[x];
                }
            }
        }
        for (int x = 0; x < n; ++x){
          if (fabs(a[x] - b[x]) > PRECISION){
            err += 2;
            break;
          }
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:parallel,data,data-region,V:1.0-2.7
int test3(){
    int err = 0;
    srand(SEED);

    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = a[x];
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel copyout(b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = b[x] - a[x];
            }
        }
        #pragma acc update host(b[0:n])
    }

    for (int x = 0; x < n; ++x){
        if (fabs(b[x]) > 2 * PRECISION){
            err += 4;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_copyout.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,data,data-region,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);

    real_t * a = new real_t[n];
    real_t * b = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0.0;
    }

    #pragma acc data copyin(a[0:n])
    {
        #pragma acc parallel copyout(b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err += 1;
            break;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,data,data-region,devonly,V:2.0-2.7
int test2(){
    int err = 0;
    srand(SEED);

    real_t * a = new real_t[n];
    real_t * b = new real_t[n];

    int* hasDevice = (int *) malloc(sizeof(int));
    hasDevice[0] = 1;
    #pragma acc enter data copyin(hasDevice[0:1])
    #pragma acc parallel present(hasDevice[0:1])
    {
      hasDevice[0] = 0;
    }

    if (hasDevice[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = a[x];
        }

        #pragma acc data copyin(a[0:n], b[0:n])
        {
            #pragma acc parallel copyout(b[0:n])
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    b[x] = b[x] - a[x];
                }
            }
        }
        for (int x = 0; x < n; ++x){
          if (fabs(a[x] - b[x]) > PRECISION){
            err += 2;
            break;
          }
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:parallel,data,data-region,V:1.0-2.7
int test3(){
    int err = 0;
    srand(SEED);

    real_t * a = new real_t[n];
    real_t * b = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = a[x];
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel copyout(b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = b[x] - a[x];
            }
        }
        #pragma acc update host(b[0:n])
    }

    for (int x = 0; x < n; ++x){
        if (fabs(b[x]) > 2 * PRECISION){
            err += 4;
            break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_copyout_zero.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,data,data-region,V:3.0-3.2
int test1(){
    int err = 0;
    srand(SEED);

    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) 
    {
      #pragma acc parallel copyout(zero: b[0:n])
      {
        #pragma acc loop
        {
          for (int x = 0; x < n; ++x){
            b[x] += a[x];
          }
        }
      }
    }

    for (int x = 0; x < n; ++x){
        if(fabs(a[x] - b[x]) > PRECISION){
                err += 1;
                break;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,data,data-region,devonly,V:3.0-3.1
int test2(){
    //for development; logic test
    int err = 0;
    srand(SEED);

    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));

    int* hasDevice = (int *) malloc(sizeof(int));
    hasDevice[0] = 1;
    #pragma acc enter data copyin(hasDevice[0:1])
    #pragma acc parallel present(hasDevice[0:1])
    {
      hasDevice[0] = 0;
    }

    if (hasDevice[0] == 1){
      for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 1;
      }

      #pragma acc data copyin(a[0:n])
      {
        #pragma acc parallel copyout(zero: b[0:n])
        {
          #pragma acc loop
          {
            for (int x = 0; x < n; ++x){
              b[x] += a[x];
            }
          }
        }
      }

      for (int x = 0; x < n; ++x){
          if(fabs(a[x] - b[x]) > PRECISION){
                  err += 1;
                  break;
          }
      }
    }

    return err;
}
#endif

#ifndef T3
//T3:parallel,data,data-region,V:3.0-3.1
int test3(){
    int err = 0;
    srand(SEED);

    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 1;
    }

    #pragma acc data copyin(a[0:n]) copy(b[0:n])
    {
      #pragma acc parallel copyout(zero: b[0:n])
      {
        #pragma acc loop
        {
          for (int x = 0; x < n; ++x){
            b[x] += a[x];
          }
        }
      }
    }

    for (int x = 0; x < n; ++x){
        if(fabs(a[x] - b[x] + 1) > PRECISION){
                err += 1;
                break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;

    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_copyout_zero.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,data,data-region,V:3.0-3.2
int test1(){
    int err = 0;
    srand(SEED);

    real_t * a = new real_t[n];
    real_t * b = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0;
    }

    #pragma acc data copyin(a[0:n]) 
    {
      #pragma acc parallel copyout(zero: b[0:n])
      {
        #pragma acc loop
        {
          for (int x = 0; x < n; ++x){
            b[x] += a[x];
          }
        }
      }
    }

    for (int x = 0; x < n; ++x){
        if(fabs(a[x] - b[x]) > PRECISION){
                err += 1;
                break;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,data,data-region,devonly,V:3.0-3.1
int test2(){
    //for development; logic test
    int err = 0;
    srand(SEED);

    real_t * a = new real_t[n];
    real_t * b = new real_t[n];

    int* hasDevice = (int *) malloc(sizeof(int));
    hasDevice[0] = 1;
    #pragma acc enter data copyin(hasDevice[0:1])
    #pragma acc parallel present(hasDevice[0:1])
    {
      hasDevice[0] = 0;
    }

    if (hasDevice[0] == 1){
      for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 1;
      }

      #pragma acc data copyin(a[0:n])
      {
        #pragma acc parallel copyout(zero: b[0:n])
        {
          #pragma acc loop
          {
            for (int x = 0; x < n; ++x){
              b[x] += a[x];
            }
          }
        }
      }

      for (int x = 0; x < n; ++x){
          if(fabs(a[x] - b[x]) > PRECISION){
                  err += 1;
                  break;
          }
      }
    }

    return err;
}
#endif

#ifndef T3
//T3:parallel,data,data-region,V:3.0-3.1
int test3(){
    int err = 0;
    srand(SEED);

    real_t * a = new real_t[n];
    real_t * b = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 1;
    }

    #pragma acc data copyin(a[0:n]) copy(b[0:n])
    {
      #pragma acc parallel copyout(zero: b[0:n])
      {
        #pragma acc loop
        {
          for (int x = 0; x < n; ++x){
            b[x] += a[x];
          }
        }
      }
    }

    for (int x = 0; x < n; ++x){
        if(fabs(a[x] - b[x] + 1) > PRECISION){
                err += 1;
                break;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;

    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_create.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,data,data-region,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0.0;
        c[x] = 0.0;
    }

    #pragma acc data copyin(a[0:n]) copy(c[0:n])
    {
        #pragma acc parallel create(b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x];
            }
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - c[x]) > PRECISION){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_create.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,data,data-region,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0.0;
        c[x] = 0.0;
    }

    #pragma acc data copyin(a[0:n]) copy(c[0:n])
    {
        #pragma acc parallel create(b[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                b[x] = a[x];
            }
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] = b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - c[x]) > PRECISION){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_create_zero.c:::
#include "acc_testsuite.h"
#ifndef T1
//#T1:parallel,data,data_region,V:3.0-3.2
int Test1(){
    int err=0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));

    for( int x = 0; x < n; x++){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0.0;
    }

    #pragma acc data copyin(a[0:n]) copyout(b[0:n]
    {
        #pragma acc parallel create(zero: b[0:n])
        {
            #pragma acc loop
            {
                for(int x = 0; x < n; x++){
                    b[x] += a[x];
                }
            }
        }
    }
    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}
########## NEXT FILE ##########
parallel_create_zero.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//#T1:parallel,data,data_region,V:3.0-3.2
int Test1(){
    int err=0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];

    for( int x = 0; x < n; x++){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = 0.0;
    }

    #pragma acc data copyin(a[0:n]) copyout(b[0:n]
    {
        #pragma acc parallel create(zero: b[0:n])
        {
            #pragma acc loop
            {
                for(int x = 0; x < n; x++){
                    b[x] += a[x];
                }
            }
        }
    }
    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}
########## NEXT FILE ##########
parallel_default_copy.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,data,data-region,default-mapping,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t c[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,data,data-region,default-mapping,V:2.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t c[n];
    int * devtest = (int *)malloc(sizeof(real_t));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            c[x] = 1;
        }

        #pragma acc enter data copyin(c[0:n])
        for (int x = 0; x < n; ++x){
            c[x] = 0.0;
        }
        #pragma acc data copyin(a[0:n], b[0:n])
        {
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] += a[x] + b[x];
                }
            }
        }

        for (int x = 0; x < n; ++x){
            if (fabs(c[x]) > PRECISION){
                err += 1;
            }
        }

        #pragma acc exit data copyout(c[0:n])

        for (int x = 0; x < n; ++x){
            if (fabs(c[x] - (a[x] + b[x] + 1)) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_default_copy.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,data,data-region,default-mapping,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t c[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,data,data-region,default-mapping,V:2.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t c[n];
    int * devtest = (int *)malloc(sizeof(real_t));

    devtest[0] = 1;
    #pragma acc enter data copyin(devtest[0:1])
    #pragma acc parallel present(devtest[0:1])
    {
        devtest[0] = 0;
    }

    if (devtest[0] == 1){
        for (int x = 0; x < n; ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            c[x] = 1;
        }

        #pragma acc enter data copyin(c[0:n])
        for (int x = 0; x < n; ++x){
            c[x] = 0.0;
        }
        #pragma acc data copyin(a[0:n], b[0:n])
        {
            #pragma acc parallel
            {
                #pragma acc loop
                for (int x = 0; x < n; ++x){
                    c[x] += a[x] + b[x];
                }
            }
        }

        for (int x = 0; x < n; ++x){
            if (fabs(c[x]) > PRECISION){
                err += 1;
            }
        }

        #pragma acc exit data copyout(c[0:n])

        for (int x = 0; x < n; ++x){
            if (fabs(c[x] - (a[x] + b[x] + 1)) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_default_present.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,default,data,data-region,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = 0.0;
    }
    #pragma acc enter data copyin(a[0:n])
    #pragma acc parallel default(present)
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            a[x] = 1.0;
        }
    }
    #pragma acc exit data copyout(a[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - 1.0) > PRECISION){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_default_present.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,default,data,data-region,V:2.5-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = 0.0;
    }
    #pragma acc enter data copyin(a[0:n])
    #pragma acc parallel default(present)
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            a[x] = 1.0;
        }
    }
    #pragma acc exit data copyout(a[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - 1.0) > PRECISION){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_deviceptr.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,runtime,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b;

    for (int x = 0; x < n; ++x){
        a[x] = 0;
    }

    #pragma acc enter data copyin(a[0:n])
    b = (real_t *) acc_deviceptr(a);
    if (b == NULL){
        err = 1;
    }
    else{
        #pragma acc parallel deviceptr(b)
        {
            #pragma acc loop
            for (int x = 0; x < (int) n/2; ++x){
                b[x] = 1;
            }
        }
        #pragma acc exit data copyout(a[0:n])
    }
    for (int x = 0; x < n; ++x){
        if (x < (int) n/2){
            if (fabs(a[x] - 1) > PRECISION){
                err = 1;
            }
        }
        else {
            if (fabs(a[x]) > PRECISION){
                err = 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_deviceptr.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,runtime,V:2.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b;

    for (int x = 0; x < n; ++x){
        a[x] = 0;
    }

    #pragma acc enter data copyin(a[0:n])
    b = (real_t *) acc_deviceptr(a);
    if (b == NULL){
        err = 1;
    }
    else{
        #pragma acc parallel deviceptr(b)
        {
            #pragma acc loop
            for (int x = 0; x < (int) n/2; ++x){
                b[x] = 1;
            }
        }
        #pragma acc exit data copyout(a[0:n])
    }
    for (int x = 0; x < n; ++x){
        if (x < (int) n/2){
            if (fabs(a[x] - 1) > PRECISION){
                err = 1;
            }
        }
        else {
            if (fabs(a[x]) > PRECISION){
                err = 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_firstprivate.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,firstprivate,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    real_t * c_copy = (real_t *)malloc(n * sizeof(real_t));
    real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));

    for (int x = 0; x < 10*n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        d[x] = 0.0;
    }
    for (int x = 0; x < n; ++x){
        c[x] = rand() / (real_t)(RAND_MAX / 10);
        c_copy[x] = c[x];
    }
    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(d[0:10*n])
    {
        #pragma acc parallel firstprivate(c[0:n])
        {
            #pragma acc loop gang
            for (int x = 0; x < 10; ++x){
                #pragma acc loop worker
                for (int y = 0; y < n; ++y){
                    d[x * n + y] = a[x * n + y] + b[x * n + y] + c[y];
                }
            }
        }
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < n; ++y){
            if (fabs(d[x * n + y] - (a[x * n + y] + b[x * n + y] + c_copy[y])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,firstprivate,V:1.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    real_t * c_copy = (real_t *)malloc(n * sizeof(real_t));
    real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));

    for (int x = 0; x < 10*n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        d[x] = 0.0;
    }
    for (int x = 0; x < n; ++x){
        c[x] = 0.0;
    }

    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(d[0:10*n])
    {
        #pragma acc parallel firstprivate(c[0:n])
        {
            #pragma acc loop gang independent
            for (int x = 0; x < 10; ++x){
                #pragma acc loop worker independent
                for (int y = 0; y < n; ++y){
                    c[y] = a[x * n + y] - b[x * n + y];
                }
                #pragma acc loop worker independent
                for (int y = 0; y < n; ++y){
                    d[x * n + y] = a[x * n + y] + b[x * n + y] + c[y];
                }
            }
        }
    }

    for (int x = 0; x < 10 * n; ++x){
        if (fabs(d[x] - 2 * a[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_firstprivate.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,firstprivate,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[10 * n];
    real_t * b = new real_t[10 * n];
    real_t * c = new real_t[n];
    real_t * c_copy = new real_t[n];
    real_t * d = new real_t[10 * n];

    for (int x = 0; x < 10*n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        d[x] = 0.0;
    }
    for (int x = 0; x < n; ++x){
        c[x] = rand() / (real_t)(RAND_MAX / 10);
        c_copy[x] = c[x];
    }
    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(d[0:10*n])
    {
        #pragma acc parallel firstprivate(c[0:n])
        {
            #pragma acc loop gang
            for (int x = 0; x < 10; ++x){
                #pragma acc loop worker
                for (int y = 0; y < n; ++y){
                    d[x * n + y] = a[x * n + y] + b[x * n + y] + c[y];
                }
            }
        }
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < n; ++y){
            if (fabs(d[x * n + y] - (a[x * n + y] + b[x * n + y] + c_copy[y])) > PRECISION){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,firstprivate,V:1.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[10 * n];
    real_t * b = new real_t[10 * n];
    real_t * c = new real_t[n];
    real_t * c_copy = new real_t[n];
    real_t * d = new real_t[10 * n];

    for (int x = 0; x < 10*n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        d[x] = 0.0;
    }
    for (int x = 0; x < n; ++x){
        c[x] = 0.0;
    }

    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copy(d[0:10*n])
    {
        #pragma acc parallel firstprivate(c[0:n])
        {
            #pragma acc loop gang independent
            for (int x = 0; x < 10; ++x){
                #pragma acc loop worker independent
                for (int y = 0; y < n; ++y){
                    c[y] = a[x * n + y] - b[x * n + y];
                }
                #pragma acc loop worker independent
                for (int y = 0; y < n; ++y){
                    d[x * n + y] = a[x * n + y] + b[x * n + y] + c[y];
                }
            }
        }
    }

    for (int x = 0; x < 10 * n; ++x){
        if (fabs(d[x] - 2 * a[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_if.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,if,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    int host = 0;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }
    #pragma acc parallel if(host)
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err = 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,if,devonly,V:2.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    int * dev_test = (int *)malloc(sizeof(int));
    int host = 0;

    dev_test[0] = 1;
    #pragma acc data copyin(dev_test[0:1])
    #pragma acc parallel
    {
      dev_test[0] = 0;
    }

    if (dev_test[0] != 0){
        for (int x = 0; x < n;  ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            c[x] = 0;
        }

        #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])
        #pragma acc parallel if(host) present(a[0:n], b[0:n], c[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }
        }
        #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])

        for (int x = 0; x < n; ++x){
            if (fabs(c[x]) > PRECISION){
                err = 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:parallel,if,V:2.0-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    int accel = 1;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])

    #pragma acc parallel if(accel) present(a[0:n], b[0:n], c[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] += a[x] + b[x];
        }
    }

    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION * 2){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_if.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,if,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];
    int accel = 1;
    int host = 0;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }
    #pragma acc parallel if(host)
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] = a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err = 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,if,devonly,V:2.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];
    int * dev_test = (int *)malloc(sizeof(int));
    int accel = 1;
    int host = 0;

    dev_test[0] = 1;
    #pragma acc data copyin(dev_test[0:1])
    #pragma acc parallel
    {
      dev_test[0] = 0;
    }

    if (devtest[0] != 0){
        for (int x = 0; x < n;  ++x){
            a[x] = rand() / (real_t)(RAND_MAX / 10);
            b[x] = rand() / (real_t)(RAND_MAX / 10);
            c[x] = 0;
        }

        #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])
        #pragma acc parallel if(host) present(a[0:n], b[0:n], c[0:n])
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                c[x] += a[x] + b[x];
            }
        }
        #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])

        for (int x = 0; x < n; ++x){
            if (fabs(c[x]) > PRECISION){
                err = 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T3
//T3:parallel,if,V:2.0-2.7
int test3(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];
    int accel = 1;
    int host = 0;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
    }

    #pragma acc enter data copyin(a[0:n], b[0:n], c[0:n])

    #pragma acc parallel if(accel) present(a[0:n], b[0:n], c[0:n])
    {
        #pragma acc loop
        for (int x = 0; x < n; ++x){
            c[x] += a[x] + b[x];
        }
    }

    #pragma acc exit data delete(a[0:n], b[0:n]) copyout(c[0:n])

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION * 2){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_implicit_data_attributes.c:::
#include "acc_testsuite.h"

#ifndef T1
//T1:parallel,data,data-region,V:2.0-3.3
int test1(){
    int err = 0;
    srand(SEED);
    int test = rand()/(real_t)(RAND_MAX/10);
    int host = test;

    #pragma acc parallel default(none) reduction(+:test)
    for(int x = 0; x < n; ++x){
	test += 1;
    }

    if(fabs( test - host) >  PRECISION){
	err++;
    }
    
    return err;
} 
#endif
#ifndef T2
//T2:parallel,data,data-region,V:2.0-3.3
int test2(){
	int err = 0;
	srand(SEED);
	real_t a = rand()/(real_t)(RAND_MAX/10);
	real_t host = a;

	#pragma acc parallel loop reduction(+:a)
	for( int x = 0; x < n; ++x){
		a += 1.0;
	}

	if( fabs( a - host) > PRECISION){
		err++;
	}
	return err;
}
#endif
#ifndef T3
//firstprivate test with only parallel and reduction with scalar variable
int test3(){
	int err = 0;
	srand(SEED);
	int host_value = rand()/ (real_t)(RAND_MAX/10);
	int device_value = host_value;

	#pragma acc parallel reduction(+:device_value) 
	for( int x = 0; x > n; ++ x){
		device_value += device_value;
	}
	if( fabs(host_value - device_value) > PRECISION){
		err = 1;
	}
	return err;
}	
#endif
#ifndef T4
//copy clause wtth that calles detach action only parallel loop  with aggregate variables
int test4(){
	int err = 0;
	srand(SEED);

	real_t *host_array = (real_t *)malloc( n * sizeof(real_t));
	real_t *device_array = (real_t *)malloc( n * sizeof(real_t));

	for(int x = 0; x < n; ++ x){
		host_array[x] = rand()/(real_t)(RAND_MAX/10);
		device_array[x] = host_array[x];
	}

	#pragma acc parallel loop
	for( int x = 0; x < n; ++x){
		device_array[x] += device_array[x];
	}

	for(int x = 0; x < n; ++x){
		if(fabs(host_array[x]*2 - device_array[x]) > PRECISION){
			err = 1;
		}
	}
	free(host_array);
	free(device_array);
	return err;

}
#endif

int main(){
	int failcode = 0;
	int failed;
#ifndef T1
	failed = 0;
	for( int x = 0; x < NUM_TEST_CALLS; ++x){
		failed += test1();
	}
	if(failed){
		failcode += ( 1 << 0);
	}
#endif
#ifndef T2
        failed = 0;
        for( int x = 0; x < NUM_TEST_CALLS; ++x){
                failed += test2();
        }
        if(failed){
                failcode += ( 1 << 1);
        }
#endif
#ifndef T3
        failed = 0;
        for( int x = 0; x < NUM_TEST_CALLS; ++x){
                failed += test3();
        }
        if(failed){
                failcode += ( 1 << 2);
        }
#endif
#ifndef T4
        failed = 0;
        for( int x = 0; x < NUM_TEST_CALLS; ++x){
                failed += test4();
        }
        if(failed){
                failcode += ( 1 << 3);
        }
#endif
	return failcode;
}

########## NEXT FILE ##########
parallel_implicit_data_attributes.cpp:::
#include "acc_testsuite.h"

#ifndef T1
//T1:parallel,data,data-region,V:2.0-3.3
int test1(){
    int err = 0;
    srand(SEED);
    int test = rand()/(real_t)(RAND_MAX/10);
    int host = test;

    #pragma acc parallel default(none) reduction(+:test)
    for(int x = 0; x < n; ++x){
	test += 1;
    }

    if(fabs( test - host) >  PRECISION){
	err++;
    }
    
    return err;
} 
#endif
#ifndef T2
//T2:parallel,data,data-region,V:2.0-3.3
int test2(){
	int err = 0;
	srand(SEED);
	real_t a = rand()/(real_t)(RAND_MAX/10);
	real_t host = a;

	#pragma acc parallel loop reduction(+:a)
	for( int x = 0; x < n; ++x){
		a += 1.0;
	}

	if( fabs( a - host) > PRECISION){
		err++;
	}
	return err;
}
#endif
#ifndef T3
//T3:parallel,data,data-region,V:2.0-3.3
int test3(){
	int err = 0;
	srand(SEED);
	int host_value = rand()/ (real_t)(RAND_MAX/10);
	int device_value = host_value;

	#pragma acc parallel reduction(+:device_value) 
	for( int x = 0; x > n; ++ x){
		device_value += device_value;
	}
	if( fabs(host_value - device_value) > PRECISION){
		err = 1;
	}
	return err;
}	
#endif
#ifndef T4
//T4:parallel,data,data-region,V:2.0-3.3
int test4(){
	int err = 0;
	srand(SEED);

	real_t *host_array = new real_t[n];
	real_t *device_array = new real_t[n];

	for(int x = 0; x < n; ++ x){
		host_array[x] = rand()/(real_t)(RAND_MAX/10);
		device_array[x] = host_array[x];
	}

	#pragma acc parallel loop
	for( int x = 0; x < n; ++x){
		device_array[x] += device_array[x];
	}

	for(int x = 0; x < n; ++x){
		if(fabs(host_array[x]*2 - device_array[x]) > PRECISION){
			err = 1;
		}
	}
	delete[] host_array;
	delete[] device_array;
	return err;

}
#endif

int main(){
	int failcode = 0;
	int failed;
#ifndef T1
	failed = 0;
	for( int x = 0; x < NUM_TEST_CALLS; ++x){
		failed += test1();
	}
	if(failed){
		failcode += ( 1 << 0);
	}
#endif
#ifndef T2
        failed = 0;
        for( int x = 0; x < NUM_TEST_CALLS; ++x){
                failed += test2();
        }
        if(failed){
                failcode += ( 1 << 1);
        }
#endif
#ifndef T3
        failed = 0;
        for( int x = 0; x < NUM_TEST_CALLS; ++x){
                failed += test3();
        }
        if(failed){
                failcode += ( 1 << 2);
        }
#endif
#ifndef T4
        failed = 0;
        for( int x = 0; x < NUM_TEST_CALLS; ++x){
                failed += test4();
        }
        if(failed){
                failcode += ( 1 << 3);
        }
#endif
	return failcode;
}

########## NEXT FILE ##########
parallel_independent_atomic.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.7-3.2
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copy(a[0:n], b[0:n])
    {
        #pragma acc parallel
        {
	    #pragma acc loop independent
            for (int x = 0; x < n; ++x){
                #pragma acc atomic 
                    a[x] = a[x] * 2; //dependent
                    b[x] = a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,loop,V:2.7-3.2
int test2(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = a[x];
    }

    #pragma acc data copy(a[0:n])
    {
        #pragma acc parallel
        {
	    #pragma acc loop independent
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    (a[x])++; //independent - without a clause, you're doing atomic update   
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - (b[x] + 1)) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
   failed = 0;
   for (int x = 0; x < NUM_TEST_CALLS; ++x){
       failed = failed + test1();
   }
   if (failed != 0){
       failcode = failcode + (1 << 0);
   }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}


########## NEXT FILE ##########
parallel_independent_atomic.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.7-3.2
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copy(a[0:n], b[0:n])
    {
        #pragma acc parallel
        {
	    #pragma acc loop independent
            for (int x = 0; x < n; ++x){
                #pragma acc atomic 
                    a[x] = a[x] * 2; //dependent
                    b[x] = a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,loop,V:2.7-3.2
int test2(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = a[x];
    }

    #pragma acc data copy(a[0:n])
    {
        #pragma acc parallel
        {
	    #pragma acc loop independent
            for (int x = 0; x < n; ++x){
                #pragma acc atomic
                    (a[x])++; //independent - without a clause, you're doing atomic update   
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - (b[x] + 1)) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
   failed = 0;
   for (int x = 0; x < NUM_TEST_CALLS; ++x){
       failed = failed + test1();
   }
   if (failed != 0){
       failcode = failcode + (1 << 0);
   }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}


########## NEXT FILE ##########
parallel_independent_atomic_capture.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.7-3.2
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copy(a[0:n], b[0:n])
    {
        #pragma acc parallel
        {
	    #pragma acc loop independent
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    b[x] = (a[x])++;
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - (b[x] + 1)) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
   failed = 0;
   for (int x = 0; x < NUM_TEST_CALLS; ++x){
       failed = failed + test1();
   }
   if (failed != 0){
       failcode = failcode + (1 << 0);
   }
#endif
    return failcode;
}


########## NEXT FILE ##########
parallel_independent_atomic_capture.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.7-3.2
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copy(a[0:n], b[0:n])
    {
        #pragma acc parallel
        {
	    #pragma acc loop independent
            for (int x = 0; x < n; ++x){
                #pragma acc atomic capture
                    b[x] = (a[x])++;
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - (b[x] + 1)) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
   failed = 0;
   for (int x = 0; x < NUM_TEST_CALLS; ++x){
       failed = failed + test1();
   }
   if (failed != 0){
       failcode = failcode + (1 << 0);
   }
#endif
    return failcode;
}


########## NEXT FILE ##########
parallel_independent_atomic_read.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.7-3.2
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copy(a[0:n], b[0:n])
    {
        #pragma acc parallel
        {
	    #pragma acc loop independent
            for (int x = 0; x < n; ++x){
                #pragma acc atomic read
                    b[x] = a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
   failed = 0;
   for (int x = 0; x < NUM_TEST_CALLS; ++x){
       failed = failed + test1();
   }
   if (failed != 0){
       failcode = failcode + (1 << 0);
   }
#endif
    return failcode;
}


########## NEXT FILE ##########
parallel_independent_atomic_read.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.7-3.2
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copy(a[0:n], b[0:n])
    {
        #pragma acc parallel
        {
	    #pragma acc loop independent
            for (int x = 0; x < n; ++x){
                #pragma acc atomic read
                    b[x] = a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
   failed = 0;
   for (int x = 0; x < NUM_TEST_CALLS; ++x){
       failed = failed + test1();
   }
   if (failed != 0){
       failcode = failcode + (1 << 0);
   }
#endif
    return failcode;
}


########## NEXT FILE ##########
parallel_independent_atomic_update.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.7-3.2
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = a[x];
    }

    #pragma acc data copy(a[0:n])
    {
        #pragma acc parallel
        {
	    #pragma acc loop independent
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    (a[x])++;
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - (b[x] + 1)) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
   failed = 0;
   for (int x = 0; x < NUM_TEST_CALLS; ++x){
       failed = failed + test1();
   }
   if (failed != 0){
       failcode = failcode + (1 << 0);
   }
#endif
    return failcode;
}


########## NEXT FILE ##########
parallel_independent_atomic_update.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.7-3.2
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = a[x];
    }

    #pragma acc data copy(a[0:n])
    {
        #pragma acc parallel
        {
	    #pragma acc loop independent
            for (int x = 0; x < n; ++x){
                #pragma acc atomic update
                    (a[x])++;
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - (b[x] + 1)) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
   failed = 0;
   for (int x = 0; x < NUM_TEST_CALLS; ++x){
       failed = failed + test1();
   }
   if (failed != 0){
       failcode = failcode + (1 << 0);
   }
#endif
    return failcode;
}


########## NEXT FILE ##########
parallel_independent_atomic_write.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.7-3.2
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = (real_t *)malloc(n * sizeof(real_t));
    real_t *b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copy(a[0:n], b[0:n])
    {
        #pragma acc parallel
        {
	    #pragma acc loop independent
            for (int x = 0; x < n; ++x){
                #pragma acc atomic write
                    b[x] = a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif


int main(){
    int failcode = 0;
    int failed;
#ifndef T1
   failed = 0;
   for (int x = 0; x < NUM_TEST_CALLS; ++x){
       failed = failed + test1();
   }
   if (failed != 0){
       failcode = failcode + (1 << 0);
   }
#endif
    return failcode;
}


########## NEXT FILE ##########
parallel_independent_atomic_write.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:atomic,construct-independent,V:2.7-3.2
int test1(){
    int err = 0;
    srand(SEED);
    real_t *a = new real_t[n];
    real_t *b = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copy(a[0:n], b[0:n])
    {
        #pragma acc parallel
        {
	    #pragma acc loop independent
            for (int x = 0; x < n; ++x){
                #pragma acc atomic write
                    b[x] = a[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err += 1;
        }
    }

    return err;
}
#endif


int main(){
    int failcode = 0;
    int failed;
#ifndef T1
   failed = 0;
   for (int x = 0; x < NUM_TEST_CALLS; ++x){
       failed = failed + test1();
   }
   if (failed != 0){
       failcode = failcode + (1 << 0);
   }
#endif
    return failcode;
}


########## NEXT FILE ##########
parallel_loop.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,loop,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = 0;
    }

    #pragma acc data copy(a[0:n])
    {
        #pragma acc parallel loop
        for (int x = 0; x < n; ++x){
            a[x] = 1.0;
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - 1.0) > PRECISION){
            err = 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,loop,V:1.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
      a[x] = 0.0;
      b[x] = rand() / (real_t)(RAND_MAX / 10);
      c[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    #pragma acc data copy(a[0:n], b[0:n], c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                a[x] = b[x];
            }
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                a[x] += c[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - (b[x] + c[x])) > PRECISION * 2){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,loop,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = 0;
    }

    #pragma acc data copy(a[0:n])
    {
        #pragma acc parallel loop
        for (int x = 0; x < n; ++x){
            a[x] = 1.0;
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - 1.0) > PRECISION){
            err = 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,loop,V:1.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
      a[x] = 0.0;
      b[x] = rand() / (real_t)(RAND_MAX / 10);
      c[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    #pragma acc data copy(a[0:n], b[0:n], c[0:n])
    {
        #pragma acc parallel
        {
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                a[x] = b[x];
            }
            #pragma acc loop
            for (int x = 0; x < n; ++x){
                a[x] += c[x];
            }
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - (b[x] + c[x])) > PRECISION * 2){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_async.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,loop,async,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * c = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * d = (real_t *)malloc(10 * n * sizeof(real_t));
	int * errors = (int *)malloc(10 * sizeof(int));

	for (int x = 0; x < 10; ++x){
		errors[x] = 0;
	}

    for (int x = 0; x < 10 * n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
        d[x] = a[x] + b[x];
    }

    #pragma acc data copyin(a[0:10*n], b[0:10*n], c[0:10*n], d[0:10*n]) copy(errors[0:10])
    {
        for (int x = 0; x < 10; ++x){
            #pragma acc parallel loop async(x)
            for (int y = 0; y < n; ++y){
                c[x * n + y] = a[x * n + y] + b[x * n + y];
            }
            #pragma acc parallel loop async(x) reduction(+:errors[x])
            for (int y = 0; y < n; ++y){
                if(c[x * n + y] - d[x * n + y] > PRECISION || d[x * n + y] - c[x * n + y] > PRECISION){
                    errors[x] += 1;
                }
            }
        }
		#pragma acc wait
    }

    for (int x = 0; x < 10; ++x){
        err += errors[x];
    }

    return err;
}
#endif
#ifndef T2
//T2:parallel,loop,async,combined-constructs,V:1.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));
    real_t * d = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = a[x] * 2;
        c[x] = rand() / (real_t)(RAND_MAX / 10);
        d[x] = c[x] * 2;
    }

    #pragma acc parallel loop copy(a[0:n]) async(0)
    for(int x = 0; x < n; ++x) {
        a[x] = a[x] * 2;
    }

    #pragma acc parallel loop copy(c[0:n]) async(0)
    for(int x = 0; x < n; ++x) {
        c[x] = c[x] * 2;
    }

    #pragma acc wait

    for (int x = 0; x < n; ++x){
        if(a[x] != b[x] || c[x] != d[x]) err = 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_async.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,loop,async,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[10 * n];
    real_t * b = new real_t[10 * n];
    real_t * c = new real_t[10 * n];
    real_t * d = new real_t[10 * n];
	int * errors = new int[10];

	for (int x = 0; x < 10; ++x){
		errors[x] = 0;
	}

    for (int x = 0; x < 10 * n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
        d[x] = a[x] + b[x];
    }

    #pragma acc data copyin(a[0:10*n], b[0:10*n], c[0:10*n], d[0:10*n]) copy(errors[0:10])
    {
        for (int x = 0; x < 10; ++x){
            #pragma acc parallel loop async(x)
            for (int y = 0; y < n; ++y){
                c[x * n + y] = a[x * n + y] + b[x * n + y];
            }
            #pragma acc parallel loop async(x) reduction(+:errors[x])
            for (int y = 0; y < n; ++y){
                if(c[x * n + y] - d[x * n + y] > PRECISION || d[x * n + y] - c[x * n + y] > PRECISION){
                    errors[x] += 1;
                }
            }
        }
	    #pragma acc wait
    }

    for (int x = 0; x < 10; ++x){
        err += errors[x];
    }

    return err;
}
#endif
#ifndef T2
//T2:parallel,loop,async,combined-constructs,V:1.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];
    real_t * d = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = a[x] * 2;
        c[x] = rand() / (real_t)(RAND_MAX / 10);
        d[x] = c[x] * 2;
    }

    #pragma acc parallel loop copy(a[0:n]) async(0)
    for(int x = 0; x < n; ++x) {
        a[x] = a[x] * 2;
    }

    #pragma acc parallel loop copy(c[0:n]) async(0)
    for(int x = 0; x < n; ++x) {
        c[x] = c[x] * 2;
    }

    #pragma acc wait

    for (int x = 0; x < n; ++x){
        if(a[x] != b[x] || c[x] != d[x]) err = 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_auto.c:::
#include "acc_testsuite.h"

#ifndef T1
//T1:parallel,loop,combined-constructs,V:2.0-2.7
//data dependent, treated with as a seq clause. Added the num_gangs clause with 1
int test1(){
    int err = 0;
    srand(SEED);
    real_t * device = (real_t *)malloc(n * sizeof(real_t));
    real_t * host = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        device[x] = rand() / (real_t)(RAND_MAX / 10);
        host[x] = device[x];
    }

    #pragma acc data copy(device[0:n])
    {
      #pragma acc parallel loop num_gangs(1) vector_length(1) num_workers(1) auto
      for (int x = 1; x < n; ++x){
        device[x] = device[x - 1] + device[x];
      }
    }

    real_t rolling_total = 0.0;
    for (int x = 0; x < n; ++x){
      rolling_total += host[x];
      if (fabs(rolling_total - device[x]) > PRECISION){
        err = 1;
      }
    }

    free(device);
    free(host);

    return err;
}


#endif

int main(){
    int failcode = 0;
    int failed;

#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed += test1();
    }
    if (failed){
        failcode += (1 << 2);
    }
#endif
    return failcode;
}
########## NEXT FILE ##########
parallel_loop_auto.cpp:::
#include "acc_testsuite.h"

#ifndef T1
//T1:parallel,loop,combined-constructs,V:2.0-2.7
//data dependent, treated with as a seq clause. Added the num_gangs clause with 1
int test1(){
    int err = 0;
    srand(SEED);
    real_t * device = new real_t[n];
    real_t * host = new real_t[n];

    for (int x = 0; x < n; ++x){
        device[x] = rand() / (real_t)(RAND_MAX / 10);
        host[x] = device[x];
    }

    #pragma acc data copy(device[0:n])
    {
      #pragma acc parallel loop num_gangs(1) vector_length(1) num_workers(1) auto
      for (int x = 1; x < n; ++x){
        device[x] = device[x - 1] + device[x];
      }
    }

    real_t rolling_total = 0.0;
    for (int x = 0; x < n; ++x){
      rolling_total += host[x];
      if (fabs(rolling_total - device[x]) > PRECISION){
        err = 1;
      }
    }

    delete[] device;
    delete[] host;

    return err;
}


#endif

int main(){
    int failcode = 0;
    int failed;

#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed += test1();
    }
    if (failed){
        failcode += (1 << 2);
    }
#endif
    return failcode;
}
########## NEXT FILE ##########
parallel_loop_gang.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,loop,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t * c = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])
    {
        #pragma acc parallel loop gang
        for (int x = 0; x < n; ++x){
            c[x] = a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_gang.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,loop,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t * c = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0.0;
    }

    #pragma acc data copyin(a[0:n], b[0:n]) copy(c[0:n])
    {
        #pragma acc parallel loop gang
        for (int x = 0; x < n; ++x){
            c[x] = a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(c[x] - (a[x] + b[x])) > PRECISION){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_independent.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,loop,combined-constructs,V:2.7-3.2
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copy(a[0:n]) copyout(b[0:n])
    {
        #pragma acc parallel loop independent
        for (int x = 0; x < n; ++x){
            b[x] = a[x];
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_independent.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,loop,combined-constructs,V:2.7-3.2
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copy(a[0:n]) copyout(b[0:n])
    {
        #pragma acc parallel loop independent
        for (int x = 0; x < n; ++x){
            b[x] = a[x];
        }
    }

    for (int x = 0; x < n; ++x){
        if (fabs(a[x] - b[x]) > PRECISION){
            err = 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_independent_reduction.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,reduction,V:2.7-3.2
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t reduction;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc parallel copyin(a[0:n]) reduction(+:reduction)
    {
        #pragma acc loop independent
        for (int x = 0; x < n; ++x){
            reduction = reduction + a[x];
        }
    }

    for (int x = 0; x < n; ++x){
        reduction = reduction - a[x];
    }
    if (fabs(reduction) > PRECISION){
        err += 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}


########## NEXT FILE ##########
parallel_loop_independent_reduction.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,reduction,V:2.7-3.2
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t reduction;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc parallel copyin(a[0:n]) reduction(+:reduction)
    {
        #pragma acc loop independent
        for (int x = 0; x < n; ++x){
            reduction = reduction + a[x];
        }
    }

    for (int x = 0; x < n; ++x){
        reduction = reduction - a[x];
    }
    if (fabs(reduction) > PRECISION){
        err += 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}


########## NEXT FILE ##########
parallel_loop_reduction_add_general.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * sizeof(real_t));
    real_t total;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    total = 10;
    #pragma acc data copyin(a[0:n], b[0:n]) copy(total)
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x){
            total += a[x] + b[x];
        }
    }
    for (int x = 0; x < n; ++x){
        total -= a[x] + b[x];
    }
    if (fabs(total - 10) > PRECISION * (2 * n - 1)){ //199 = # of mathematical operations necessary
        err = 1;
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,loop,reduction,combined-constructs,V:2.7-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(n * 10 * sizeof(real_t));
    real_t * b = (real_t *)malloc(n * 10 * sizeof(real_t));
    real_t c[10];
    real_t c_host[10];

    for (int x = 0; x < 10 * n; ++x) {
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    for (int x = 0; x < 10; ++x) {
        c[x] = 1.0;
        c_host[x] = 1.0;
    }

    #pragma acc data copyin(a[0:10*n], b[0:10*n])
    {
        #pragma acc parallel loop reduction(+:c[0:10])
        for (int x = 0; x < n; ++x) {
            for (int y = 0; y < 10; ++y) {
                c[y] += a[x * 10 + y] + b[x * 10 + y];
            }
        }
    }

    for (int x = 0; x < n; ++x) {
        for (int y = 0; y < 10; ++y) {
            c_host[y] += a[x * 10 + y] + b[x * 10 + y];
        }
    }

    for (int x = 0; x < 10; ++x) {
        if (fabs(c_host[x] - c[x]) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_reduction_add_general.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n];
    real_t * b = new real_t[n];
    real_t total;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    total = 10;
    #pragma acc data copyin(a[0:n], b[0:n]) copy(total)
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x){
            total += a[x] + b[x];
        }
    }
    for (int x = 0; x < n; ++x){
        total -= a[x] + b[x];
    }
    if (fabs(total - 10) > PRECISION * (2 * n - 1)){ //199 = # of mathematical operations necessary
        err = 1;
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,loop,reduction,combined-constructs,V:2.7-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[n * 10];
    real_t * b = new real_t[n * 10];
    real_t c[10];
    real_t c_host[10];

    for (int x = 0; x < 10 * n; ++x) {
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    for (int x = 0; x < 10; ++x) {
        c[x] = 1.0;
        c_host[x] = 1.0;
    }

    #pragma acc data copyin(a[0:10*n], b[0:10*n])
    {
        #pragma acc parallel loop reduction(+:c[0:10])
        for (int x = 0; x < n; ++x) {
            for (int y = 0; y < 10; ++y) {
                c[y] += a[x * 10 + y] + b[x * 10 + y];
            }
        }
    }

    for (int x = 0; x < n; ++x) {
        for (int y = 0; y < 10; ++y) {
            c_host[y] += a[x * 10 + y] + b[x * 10 + y];
        }
    }

    for (int x = 0; x < 10; ++x) {
        if (fabs(c_host[x] - c[x]) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_reduction_add_general_type_check_pt1.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test1() {
    int err = 0;
    srand(SEED);
    _Bool* a = (_Bool*)malloc(n * sizeof(_Bool));
    _Bool* b = (_Bool*)malloc(n * sizeof(_Bool));
    _Bool total = 1;
    _Bool host_total = 1;

    for (int x = 0; x < n; ++x) {
        if ((rand()/((real_t) RAND_MAX)) > .5) {
            a[x] = 1;
        }
        else {
            a[x] = 0;
        }
        if ((rand()/((real_t) RAND_MAX)) > .5) {
            b[x] = 1;
        }
        else {
            b[x] = 0;
        }
    }
    
    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }
    

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (total != host_total) {
        err += 1;
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    char * a = (char *)malloc(n * sizeof(char));
    char * b = (char *)malloc(n * sizeof(char));
    char total = 10;
    char host_total = 10;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(UCHAR_MAX / 10);
        b[x] = rand() / (real_t)(UCHAR_MAX / 10);
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (host_total != total) {
        err += 1;
    }

    return err;
}
#endif

#ifndef T3
//T3:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test3(){
    int err = 0;
    srand(SEED);
    signed char * a = (signed char *)malloc(n * sizeof(signed char));
    signed char * b = (signed char *)malloc(n * sizeof(signed char));
    signed char total = 10;
    signed char host_total = 10;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (host_total != total) {
        err += 1;
    }

    return err;
}
#endif

#ifndef T4
//T4:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test4(){
    int err = 0;
    srand(SEED);
    unsigned char * a = (unsigned char *)malloc(n * sizeof(unsigned char));
    unsigned char * b = (unsigned char *)malloc(n * sizeof(unsigned char));
    unsigned char total = 10;
    unsigned char host_total = 10;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (total != host_total) {
        err += 1;
    }

    return err;
}
#endif

#ifndef T5
//T5:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test5(){
    int err = 0;
    srand(SEED);
    short int * a = (short int *)malloc(n * sizeof(short int));
    short int * b = (short int *)malloc(n * sizeof(short int));
    short int total = 10;
    short int host_total = 10;    

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (total != host_total) {
        err += 1;
    }

    return err;
}
#endif

#ifndef T6
//T6:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test6(){
    int err = 0;
    srand(SEED);
    int * a = (int *)malloc(n * sizeof(int));
    int * b = (int *)malloc(n * sizeof(int));
    int total = 10;
    int host_total = 10;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (total != host_total) {
        err += 1;
    }

    return err;
}
#endif

#ifndef T7
//T7:parallel,reduction,combined-constructs,loop,nonvalidating,V:1.0-2.7
int test7(){
    int err = 0;
    srand(SEED);
    long int * a = (long int *)malloc(n * sizeof(long int));
    long int * b = (long int *)malloc(n * sizeof(long int));
    long int total = 10;
    long int host_total = 10;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    return err;
}
#endif

#ifndef T8
//T8:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test8(){
    int err = 0;
    srand(SEED);
    long long int * a = (long long int *)malloc(n * sizeof(long long int));
    long long int * b = (long long int *)malloc(n * sizeof(long long int));
    long long int total = 10;
    long long int host_total = 10;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (host_total != total) {
        err += 1;
    }

    return err;
}
#endif

int main() {
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x) {
        failed = failed + test1();
    }
    if (failed != 0) {
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
#ifndef T5
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test5();
    }
    if (failed != 0){
        failcode = failcode + (1 << 4);
    }
#endif
#ifndef T6
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test6();
    }
    if (failed != 0){
        failcode = failcode + (1 << 5);
    }
#endif
#ifndef T7
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test7();
    }
    if (failed != 0){
        failcode = failcode + (1 << 6);
    }
#endif
#ifndef T8
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test8();
    }
    if (failed != 0){
        failcode = failcode + (1 << 7);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_reduction_add_general_type_check_pt1.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test1() {
    int err = 0;
    srand(SEED);
    bool* a = new bool[n];
    bool* b = new bool[n];
    bool total = 1;
    bool host_total = 1;

    for (int x = 0; x < n; ++x) {
        if ((rand()/((real_t) RAND_MAX)) > .5) {
            a[x] = 1;
        }
        else {
            a[x] = 0;
        }
        if ((rand()/((real_t) RAND_MAX)) > .5) {
            b[x] = 1;
        }
        else {
            b[x] = 0;
        }
    }
    
    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }
    

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (total != host_total) {
        err += 1;
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    char * a = new char[n];
    char * b = new char[n];
    char total = 10;
    char host_total = 10;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(UCHAR_MAX / 10);
        b[x] = rand() / (real_t)(UCHAR_MAX / 10);
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (host_total != total) {
        err += 1;
    }

    return err;
}
#endif

#ifndef T3
//T3:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test3(){
    int err = 0;
    srand(SEED);
    signed char * a = (signed char *)malloc(n * sizeof(signed char));
    signed char * b = (signed char *)malloc(n * sizeof(signed char));
    signed char total = 10;
    signed char host_total = 10;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (host_total != total) {
        err += 1;
    }

    return err;
}
#endif

#ifndef T4
//T4:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test4(){
    int err = 0;
    srand(SEED);
    unsigned char * a = (unsigned char *)malloc(n * sizeof(unsigned char));
    unsigned char * b = (unsigned char *)malloc(n * sizeof(unsigned char));
    unsigned char total = 10;
    unsigned char host_total = 10;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (total != host_total) {
        err += 1;
    }

    return err;
}
#endif

#ifndef T5
//T5:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test5(){
    int err = 0;
    srand(SEED);
    short int * a = (short int *)malloc(n * sizeof(short int));
    short int * b = (short int *)malloc(n * sizeof(short int));
    short int total = 10;
    short int host_total = 10;    

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (total != host_total) {
        err += 1;
    }

    return err;
}
#endif

#ifndef T6
//T6:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test6(){
    int err = 0;
    srand(SEED);
    int * a = new int[n];
    int * b = new int[n];
    int total = 10;
    int host_total = 10;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (total != host_total) {
        err += 1;
    }

    return err;
}
#endif

#ifndef T7
//T7:parallel,reduction,combined-constructs,loop,nonvalidating,V:1.0-2.7
int test7(){
    int err = 0;
    srand(SEED);
    long int * a = (long int *)malloc(n * sizeof(long int));
    long int * b = (long int *)malloc(n * sizeof(long int));
    long int total = 10;
    long int host_total = 10;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    return err;
}
#endif

#ifndef T8
//T8:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test8(){
    int err = 0;
    srand(SEED);
    long long int * a = (long long int *)malloc(n * sizeof(long long int));
    long long int * b = (long long int *)malloc(n * sizeof(long long int));
    long long int total = 10;
    long long int host_total = 10;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (host_total != total) {
        err += 1;
    }

    return err;
}
#endif

int main() {
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x) {
        failed = failed + test1();
    }
    if (failed != 0) {
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
#ifndef T5
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test5();
    }
    if (failed != 0){
        failcode = failcode + (1 << 4);
    }
#endif
#ifndef T6
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test6();
    }
    if (failed != 0){
        failcode = failcode + (1 << 5);
    }
#endif
#ifndef T7
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test7();
    }
    if (failed != 0){
        failcode = failcode + (1 << 6);
    }
#endif
#ifndef T8
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test8();
    }
    if (failed != 0){
        failcode = failcode + (1 << 7);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_reduction_add_general_type_check_pt2.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned short int * a = (unsigned short int*)malloc(n * sizeof(unsigned short int));
    unsigned short int * b = (unsigned short int *)malloc(n * sizeof(unsigned short int));
    unsigned short int total = 10;
    unsigned short int host_total = 10;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (host_total != total) {
        err += 1;
    }

    return err;
}
#endif


#ifndef T2
//T2:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));
    unsigned int * b = (unsigned int *)malloc(n * sizeof(unsigned int));
    unsigned int total = 10;
    unsigned int host_total = 10;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (host_total != total) {
        err += 1;
    }

    return err;
}
#endif

#ifndef T3
//T3:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test3(){
    int err = 0;
    srand(SEED);
    unsigned long int * a = (unsigned long int *)malloc(n * sizeof(unsigned long int));
    unsigned long int * b = (unsigned long int *)malloc(n * sizeof(unsigned long int));
    unsigned long int total = 10;
    unsigned long int host_total = 10;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (host_total != total) {
        err += 1;
    }

    return err;
}
#endif

#ifndef T4
//T4:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test4(){
    int err = 0;
    srand(SEED);
    unsigned long long int * a = (unsigned long long int *)malloc(n * sizeof(unsigned long long int));
    unsigned long long int * b = (unsigned long long int *)malloc(n * sizeof(unsigned long long int));
    unsigned long long int total = 10;
    unsigned long long int host_total = 10;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }
    
    if (total != host_total) {
        err += 1;
    }

    return err;
}
#endif

#ifndef T5
//T5:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test5(){
    int err = 0;
    srand(SEED);
    float * a = (float *)malloc(n * sizeof(float));
    float * b = (float *)malloc(n * sizeof(float));
    float total = 10;
    float host_total = 10;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (fabsf(total - host_total) > PRECISION) {
        err += 1;
    }

    return err;
}
#endif

#ifndef T6
//T6:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test6(){
    int err = 0;
    srand(SEED);
    double * a = (double *)malloc(n * sizeof(double));
    double * b = (double *)malloc(n * sizeof(double));
    double total = 10;
    double host_total = 10;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (fabs(host_total - total) > PRECISION) {
        err += 1;
    }

    return err;
}
#endif

#ifndef T7
//T7:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test7(){
    int err = 0;
    srand(SEED);
    long double * a = (long double *)malloc(n * sizeof(long double));
    long double * b = (long double *)malloc(n * sizeof(long double));
    long double total = 10;
    long double host_total = 10;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    
    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x){
            total += a[x] + b[x];
        }
    }
    
    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (fabsl(host_total - total) > PRECISION) {
        err += 1;
    }

    return err;
}
#endif

#ifndef T8
//T8:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test8(){
    int err = 0;
    srand(SEED);
    float _Complex * a = (float _Complex *)malloc(n * sizeof(float _Complex));
    float _Complex * b = (float _Complex *)malloc(n * sizeof(float _Complex));
    float _Complex total = 10 + 10 * I;
    float _Complex host_total = 10 + 10 * I;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;
        b[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (fabsf(crealf(total) - crealf(host_total)) > PRECISION) {
        err += 1;
    }
    if (fabsf(cimagf(total) - cimagf(host_total)) > PRECISION) {
        err += 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
#ifndef T5
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test5();
    }
    if (failed != 0){
        failcode = failcode + (1 << 4);
    }
#endif
#ifndef T6
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test6();
    }
    if (failed != 0){
        failcode = failcode + (1 << 5);
    }
#endif
#ifndef T7
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test7();
    }
    if (failed != 0){
        failcode = failcode + (1 << 6);
    }
#endif
#ifndef T8
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test8();
    }
    if (failed != 0){
        failcode = failcode + (1 << 7);
    }
#endif
    return failcode;
}


########## NEXT FILE ##########
parallel_loop_reduction_add_general_type_check_pt2.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned short int * a = (unsigned short int*)malloc(n * sizeof(unsigned short int));
    unsigned short int * b = (unsigned short int *)malloc(n * sizeof(unsigned short int));
    unsigned short int total = 10;
    unsigned short int host_total = 10;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (host_total != total) {
        err += 1;
    }

    return err;
}
#endif


#ifndef T2
//T2:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));
    unsigned int * b = (unsigned int *)malloc(n * sizeof(unsigned int));
    unsigned int total = 10;
    unsigned int host_total = 10;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (host_total != total) {
        err += 1;
    }

    return err;
}
#endif

#ifndef T3
//T3:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test3(){
    int err = 0;
    srand(SEED);
    unsigned long int * a = (unsigned long int *)malloc(n * sizeof(unsigned long int));
    unsigned long int * b = (unsigned long int *)malloc(n * sizeof(unsigned long int));
    unsigned long int total = 10;
    unsigned long int host_total = 10;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (host_total != total) {
        err += 1;
    }

    return err;
}
#endif

#ifndef T4
//T4:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test4(){
    int err = 0;
    srand(SEED);
    unsigned long long int * a = (unsigned long long int *)malloc(n * sizeof(unsigned long long int));
    unsigned long long int * b = (unsigned long long int *)malloc(n * sizeof(unsigned long long int));
    unsigned long long int total = 10;
    unsigned long long int host_total = 10;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }
    
    if (total != host_total) {
        err += 1;
    }

    return err;
}
#endif

#ifndef T5
//T5:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test5(){
    int err = 0;
    srand(SEED);
    float * a = new float[n];
    float * b = new float[n];
    float total = 10;
    float host_total = 10;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (fabsf(total - host_total) > PRECISION) {
        err += 1;
    }

    return err;
}
#endif

#ifndef T6
//T6:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test6(){
    int err = 0;
    srand(SEED);
    double * a = new double[n];
    double * b = new double[n];
    double total = 10;
    double host_total = 10;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (fabs(host_total - total) > PRECISION) {
        err += 1;
    }

    return err;
}
#endif

#ifndef T7
//T7:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test7(){
    int err = 0;
    srand(SEED);
    long double * a = (long double *)malloc(n * sizeof(long double));
    long double * b = (long double *)malloc(n * sizeof(long double));
    long double total = 10;
    long double host_total = 10;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    
    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x){
            total += a[x] + b[x];
        }
    }
    
    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (fabsl(host_total - total) > PRECISION) {
        err += 1;
    }

    return err;
}
#endif

#ifndef T8
//T8:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test8(){
    int err = 0;
    srand(SEED);
    float _Complex * a = (float _Complex *)malloc(n * sizeof(float _Complex));
    float _Complex * b = (float _Complex *)malloc(n * sizeof(float _Complex));
    float _Complex total = 10 + 10 * I;
    float _Complex host_total = 10 + 10 * I;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;
        b[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (fabsf(crealf(total) - crealf(host_total)) > PRECISION) {
        err += 1;
    }
    if (fabsf(cimagf(total) - cimagf(host_total)) > PRECISION) {
        err += 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
#ifndef T3
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test3();
    }
    if (failed != 0){
        failcode = failcode + (1 << 2);
    }
#endif
#ifndef T4
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test4();
    }
    if (failed != 0){
        failcode = failcode + (1 << 3);
    }
#endif
#ifndef T5
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test5();
    }
    if (failed != 0){
        failcode = failcode + (1 << 4);
    }
#endif
#ifndef T6
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test6();
    }
    if (failed != 0){
        failcode = failcode + (1 << 5);
    }
#endif
#ifndef T7
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test7();
    }
    if (failed != 0){
        failcode = failcode + (1 << 6);
    }
#endif
#ifndef T8
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test8();
    }
    if (failed != 0){
        failcode = failcode + (1 << 7);
    }
#endif
    return failcode;
}


########## NEXT FILE ##########
parallel_loop_reduction_add_general_type_check_pt3.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    double _Complex * a = (double _Complex *)malloc(n * sizeof(double _Complex));
    double _Complex * b = (double _Complex *)malloc(n * sizeof(double _Complex));
    double _Complex total = 10 + 10 * I;
    double _Complex host_total = 10 + 10 * I;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;
        b[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (fabs(creal(total) - creal(host_total)) > PRECISION) {
        err += 1;
    }
    if (fabs(cimag(total) - cimag(host_total)) > PRECISION) {
        err += 1;
    }

    return err;
}
#endif


#ifndef T2
//T2:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    long double _Complex * a = (long double _Complex*)malloc(n * sizeof(long double _Complex));
    long double _Complex * b = (long double _Complex*)malloc(n * sizeof(long double _Complex));
    long double _Complex total = 10 + 10 * I;
    long double _Complex host_total = 10 + 10 * I;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;
        b[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (fabsl(creall(total) - creall(host_total)) > PRECISION) {
        err += 1;
    }
    if (fabsl(cimagl(total) - cimagl(host_total)) > PRECISION) {
        err += 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}


########## NEXT FILE ##########
parallel_loop_reduction_add_general_type_check_pt3.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    double _Complex * a = (double _Complex *)malloc(n * sizeof(double _Complex));
    double _Complex * b = (double _Complex *)malloc(n * sizeof(double _Complex));
    double _Complex total = 10 + 10 * I;
    double _Complex host_total = 10 + 10 * I;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;
        b[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (fabs(creal(total) - creal(host_total)) > PRECISION) {
        err += 1;
    }
    if (fabs(cimag(total) - cimag(host_total)) > PRECISION) {
        err += 1;
    }

    return err;
}
#endif


#ifndef T2
//T2:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test2(){
    int err = 0;
    srand(SEED);
    long double _Complex * a = (long double _Complex*)malloc(n * sizeof(long double _Complex));
    long double _Complex * b = (long double _Complex*)malloc(n * sizeof(long double _Complex));
    long double _Complex total = 10 + 10 * I;
    long double _Complex host_total = 10 + 10 * I;

    for (int x = 0; x < n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;
        b[x] = rand() / (real_t)(RAND_MAX / 10) + rand() / (real_t)(RAND_MAX / 10) * I;
    }

    #pragma acc data copyin(a[0:n], b[0:n])
    {
        #pragma acc parallel loop reduction(+:total)
        for (int x = 0; x < n; ++x) {
            total += a[x] + b[x];
        }
    }

    for (int x = 0; x < n; ++x) {
        host_total += a[x] + b[x];
    }

    if (fabsl(creall(total) - creall(host_total)) > PRECISION) {
        err += 1;
    }
    if (fabsl(cimagl(total) - cimagl(host_total)) > PRECISION) {
        err += 1;
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}


########## NEXT FILE ##########
parallel_loop_reduction_add_loop.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t* b = (real_t*)malloc(10 * n * sizeof(real_t));
    real_t* c = (real_t*)malloc(10 * n * sizeof(real_t));
    real_t* d = (real_t*)malloc(10 * n * sizeof(real_t));
    real_t avg = 0.0;
    real_t rolling_total = 0;

    for (int x = 0; x < 10 * n; ++x) {
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:10*n], b[0:10*n]) create(c[0:10*n]) copyout(d[0:10*n])
    {
        #pragma acc parallel loop gang private(avg)
        for (int x = 0; x < 10; ++x) {
            avg = 0;
            #pragma acc loop worker reduction(+:avg)
            for (int y = 0; y < n; ++y) {
                avg += c[x * n + y] = a[x * n + y] + b[x * n + y];
            }
            avg = avg / n;
            #pragma acc loop worker
            for (int y = 0; y < n; ++y) {
                d[x * n + y] = c[x * n + y] - avg;
            }
        }
    }


    for (int x = 0; x < 10; ++x) {
        rolling_total = 0;
        for (int y = 0; y < n; ++y) {
            rolling_total += a[x * n + y] + b[x * n + y];
        }
        rolling_total = rolling_total / n;
        for (int y = 0; y < n; ++y) {
            if (fabs(d[x * n + y] - ((a[x * n + y] + b[x * n + y]) - rolling_total)) > PRECISION) {
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,loop,reduction,combined-constructs,V:2.7-2.7
int test2() {
    int err = 0;
    srand(SEED);
    real_t* a = (real_t*)malloc(25 * n * sizeof(real_t));
    real_t* b = (real_t*)malloc(25 * n * sizeof(real_t));
    real_t* c = (real_t*)malloc(25 * n * sizeof(real_t));
    real_t* d = (real_t*)malloc(25 * n * sizeof(real_t));
    real_t avgs[5];
    real_t host_avgs[5];

    for (int x = 0; x < 25 * n; ++x) {
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = 0;
    }

    #pragma acc data copyin(a[0:25*n], b[0:25*n]) copyout(c[0:25*n], d[0:25*n])
    {
        #pragma acc parallel loop gang private(avgs)
        for (int x = 0; x < 5; ++x) {
            for (int y = 0; y < 5; ++y) {
                avgs[y] = 0;
            }
            #pragma acc loop worker reduction(+:avgs)
            for (int y = 0; y < 5 * n; ++y) {
                avgs[y % 5] += c[x * 5 * n + y] = a[x * 5 * n + y] + b[x * 5 * n + y];
            }
            for (int y = 0; y < 5; ++y) {
                avgs[y] = avgs[y] / n;
            }
            #pragma acc loop worker
            for (int y = 0; y < 5 * n; ++y) {
                d[x * 5 * n + y] = c[x * 5 * n + y] - avgs[y % 5];
            }
        }
    }

    for (int x = 0; x < 5; ++x) {
        for (int y = 0; y < 5; ++y) {
            host_avgs[y] = 0;
        }
        for (int y = 0; y < 5 * n; ++y) {
            host_avgs[y % 5] += a[x * 5 * n + y] + b[x * 5 * n + y];
            if (fabs(c[x * 5 * n + y] - (a[x * n * 5 + y] + b[x * n * 5 + y])) > PRECISION) {
                err += 1;
            }
        }
        for (int y = 0; y < 5; ++y) {
            host_avgs[y] = host_avgs[y] / n;
        }
        for (int y = 0; y < 5 * n; ++y) {
            if (fabs(d[x * 5 * n + y] - (c[x * 5 * n + y] - host_avgs[y % 5])) > PRECISION){
                err += 1;
            
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_reduction_add_loop.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[10 * n];
    real_t* b = new real_t[10 * n];
    real_t* c = new real_t[10 * n];
    real_t* d = new real_t[10 * n];
    real_t avg = 0.0;
    real_t rolling_total = 0;

    for (int x = 0; x < 10 * n; ++x) {
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:10*n], b[0:10*n]) create(c[0:10*n]) copyout(d[0:10*n])
    {
        #pragma acc parallel loop gang private(avg)
        for (int x = 0; x < 10; ++x) {
            avg = 0;
            #pragma acc loop worker reduction(+:avg)
            for (int y = 0; y < n; ++y) {
                avg += c[x * n + y] = a[x * n + y] + b[x * n + y];
            }
            avg = avg / n;
            #pragma acc loop worker
            for (int y = 0; y < n; ++y) {
                d[x * n + y] = c[x * n + y] - avg;
            }
        }
    }


    for (int x = 0; x < 10; ++x) {
        rolling_total = 0;
        for (int y = 0; y < n; ++y) {
            rolling_total += a[x * n + y] + b[x * n + y];
        }
        rolling_total = rolling_total / n;
        for (int y = 0; y < n; ++y) {
            if (fabs(d[x * n + y] - ((a[x * n + y] + b[x * n + y]) - rolling_total)) > PRECISION) {
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,loop,reduction,combined-constructs,V:2.7-2.7
int test2() {
    int err = 0;
    srand(SEED);
    real_t* a = new real_t[25 * n];
    real_t* b = new real_t[25 * n];
    real_t* c = new real_t[25 * n];
    real_t* d = new real_t[25 * n];
    real_t avgs[5];
    real_t host_avgs[5];

    for (int x = 0; x < 25 * n; ++x) {
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = 0;
        d[x] = 0;
    }

    #pragma acc data copyin(a[0:25*n], b[0:25*n]) copyout(c[0:25*n], d[0:25*n])
    {
        #pragma acc parallel loop gang private(avgs)
        for (int x = 0; x < 5; ++x) {
            for (int y = 0; y < 5; ++y) {
                avgs[y] = 0;
            }
            #pragma acc loop worker reduction(+:avgs)
            for (int y = 0; y < 5 * n; ++y) {
                avgs[y % 5] += c[x * 5 * n + y] = a[x * 5 * n + y] + b[x * 5 * n + y];
            }
            for (int y = 0; y < 5; ++y) {
                avgs[y] = avgs[y] / n;
            }
            #pragma acc loop worker
            for (int y = 0; y < 5 * n; ++y) {
                d[x * 5 * n + y] = c[x * 5 * n + y] - avgs[y % 5];
            }
        }
    }

    for (int x = 0; x < 5; ++x) {
        for (int y = 0; y < 5; ++y) {
            host_avgs[y] = 0;
        }
        for (int y = 0; y < 5 * n; ++y) {
            host_avgs[y % 5] += a[x * 5 * n + y] + b[x * 5 * n + y];
            if (fabs(c[x * 5 * n + y] - (a[x * n * 5 + y] + b[x * n * 5 + y])) > PRECISION) {
                err += 1;
            }
        }
        for (int y = 0; y < 5; ++y) {
            host_avgs[y] = host_avgs[y] / n;
        }
        for (int y = 0; y < 5 * n; ++y) {
            if (fabs(d[x * 5 * n + y] - (c[x * 5 * n + y] - host_avgs[y % 5])) > PRECISION){
                err += 1;
            
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_reduction_add_loop_type_check_pt1.c:::
#include "acc_testsuite.h"
#ifndef T1:private,reduction,combined-constructs,loop,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    char * a = (char *)malloc(10 * n * sizeof(char));
    char * b = (char *)malloc(10 * n * sizeof(char));
    char * c = (char *)malloc(10 * n * sizeof(char));
    char * d = (char *)malloc(10 * n * sizeof(char));
    char total = 10;
    char host_total = 10;
    char temp;

    for (int x = 0; x < 10 * n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:10*n],b[0:10*n], c[0:10*n]) copyout(d[0:10*n])
    {
        #pragma acc parallel loop gang private(total)
        for (int x = 0; x < 10; ++x) {
            total = 10;
            #pragma acc loop worker reduction(+:total)
            for (int y = 0; y < n; ++y) {
                total += a[x * n + y] + b[x * n + y];
            }
            #pragma acc loop worker
            for (int y = 0; y < n; ++y) {
                d[x * n + y] = c[x * n + y] + total;
            }
        }
    }
    int error_count = 0;
    int total_count = 0;
    for (int x = 0; x < 10; ++x) {
        host_total = 10;
        for (int y = 0; y < n; ++y) {
            host_total += a[x * n + y] + b[x * n + y];
        }
        for (int y = 0; y < n; ++y) {
            temp = host_total + c[x * n + y];
            if (d[x * n + y] != temp) {
                err += 1;
                error_count += 1;
                printf("Error location x: %d \t y: %d\n", x, y); 
                printf("%d != %d\n", d[x * n + y], temp);
            }
            total_count += 1;
        }
    }

    //printf("%d out of %d failed\n", error_count, total_count);

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}
########## NEXT FILE ##########
parallel_loop_reduction_add_loop_type_check_pt1.cpp:::
#include "acc_testsuite.h"
#ifndef T1:private,reduction,combined-constructs,loop,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    char * a = new char[10 * n];
    char * b = new char[10 * n];
    char * c = new char[10 * n];
    char * d = new char[10 * n];
    char total = 10;
    char host_total = 10;
    char temp;

    for (int x = 0; x < 10 * n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
        c[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    #pragma acc data copyin(a[0:10*n],b[0:10*n], c[0:10*n]) copyout(d[0:10*n])
    {
        #pragma acc parallel loop gang private(total)
        for (int x = 0; x < 10; ++x) {
            total = 10;
            #pragma acc loop worker reduction(+:total)
            for (int y = 0; y < n; ++y) {
                total += a[x * n + y] + b[x * n + y];
            }
            #pragma acc loop worker
            for (int y = 0; y < n; ++y) {
                d[x * n + y] = c[x * n + y] + total;
            }
        }
    }
    int error_count = 0;
    int total_count = 0;
    for (int x = 0; x < 10; ++x) {
        host_total = 10;
        for (int y = 0; y < n; ++y) {
            host_total += a[x * n + y] + b[x * n + y];
        }
        for (int y = 0; y < n; ++y) {
            temp = host_total + c[x * n + y];
            if (d[x * n + y] != temp) {
                err += 1;
                error_count += 1;
                printf("Error location x: %d \t y: %d\n", x, y); 
                printf("%d != %d\n", d[x * n + y], temp);
            }
            total_count += 1;
        }
    }

    //printf("%d out of %d failed\n", error_count, total_count);

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
    return failcode;
}
########## NEXT FILE ##########
parallel_loop_reduction_add_vector_loop.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * b = (real_t *)malloc(10 * n * sizeof(real_t));
    real_t * c = (real_t *)malloc(10 * sizeof(real_t));
    real_t temp = 0.0;

    for(int x = 0; x < 10 * n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10])
    {
        #pragma acc parallel loop private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 0.0;
            #pragma acc loop vector reduction(+:temp)
            for (int y = 0; y < n; ++y){
                temp += a[(x * n) + y] + b[(x * n) + y];
            }
            c[x] = temp;
        }
    }
    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < n; ++y){
            c[x] -= a[(x * n) + y] + b[(x * n) + y];
        }
        if (fabs(c[x]) > PRECISION * (2 * n - 1)){
            err = 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = (real_t *)malloc(25 * n * sizeof(real_t));
    real_t * b = (real_t *)malloc(25 * n * sizeof(real_t));
    real_t * c = (real_t *)malloc(25 * sizeof(real_t));
    real_t * c_host = (real_t *)malloc(25 * sizeof(real_t));
    real_t temp[5];

    for (int x = 0; x < 25 * n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    for (int x = 0; x < 25; ++x) {
        c[x] = 0;
        c_host[x] = 0;
    }

    #pragma acc data copyin(a[0:25*n], b[0:25*n]) copyout(c[0:25])
    {
        #pragma acc parallel loop private(temp)
        for (int x = 0; x < 5; ++x) {
            for (int y = 0; y < 5; ++y) {
                temp[y] = 0;
            }
            #pragma acc loop vector reduction(+:temp)
            for (int y = 0; y < 5 * n; ++y) {
                temp[y % 5] += a[x * 5 * n + y] + b[x * 5 * n + y];
            }
            for (int y = 0; y < 5; ++y) {
                c[x * 5 + y] = temp[y];
            }
        }
    }

    for (int x = 0; x < 5; ++x) {
        for (int y = 0; y < 5 * n; ++y) {
            c_host[x * 5 + (y % 5)] += a[x * 5 * n + y] + b[x * 5 * n + y];
        }
    }

    for (int x = 0; x < 25; ++x) {
        if (fabs(c[x] - c_host[x]) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_reduction_add_vector_loop.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,private,reduction,combined-constructs,loop,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[10 * n];
    real_t * b = new real_t[10 * n];
    real_t * c = new real_t[10];
    real_t temp = 0.0;

    for(int x = 0; x < 10 * n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }
    #pragma acc data copyin(a[0:10*n], b[0:10*n]) copyout(c[0:10])
    {
        #pragma acc parallel loop private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 0.0;
            #pragma acc loop vector reduction(+:temp)
            for (int y = 0; y < n; ++y){
                temp += a[(x * n) + y] + b[(x * n) + y];
            }
            c[x] = temp;
        }
    }
    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < n; ++y){
            c[x] -= a[(x * n) + y] + b[(x * n) + y];
        }
        if (fabs(c[x]) > PRECISION * (2 * n - 1)){
            err = 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7
int test2(){
    int err = 0;
    srand(SEED);
    real_t * a = new real_t[25 * n];
    real_t * b = new real_t[25 * n];
    real_t * c = new real_t[25];
    real_t * c_host = new real_t[25];
    real_t temp[5];

    for (int x = 0; x < 25 * n; ++x){
        a[x] = rand() / (real_t)(RAND_MAX / 10);
        b[x] = rand() / (real_t)(RAND_MAX / 10);
    }

    for (int x = 0; x < 25; ++x) {
        c[x] = 0;
        c_host[x] = 0;
    }

    #pragma acc data copyin(a[0:25*n], b[0:25*n]) copyout(c[0:25])
    {
        #pragma acc parallel loop private(temp)
        for (int x = 0; x < 5; ++x) {
            for (int y = 0; y < 5; ++y) {
                temp[y] = 0;
            }
            #pragma acc loop vector reduction(+:temp)
            for (int y = 0; y < 5 * n; ++y) {
                temp[y % 5] += a[x * 5 * n + y] + b[x * 5 * n + y];
            }
            for (int y = 0; y < 5; ++y) {
                c[x * 5 + y] = temp[y];
            }
        }
    }

    for (int x = 0; x < 5; ++x) {
        for (int y = 0; y < 5 * n; ++y) {
            c_host[x * 5 + (y % 5)] += a[x * 5 * n + y] + b[x * 5 * n + y];
        }
    }

    for (int x = 0; x < 25; ++x) {
        if (fabs(c[x] - c_host[x]) > PRECISION) {
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_reduction_and_general.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);

    char * a = (char *)malloc(n * sizeof(char));
    real_t false_margin = pow(exp(1), log(.5)/n);
    char result = 1;
    char found = 0;

    for (int x = 0; x < n; ++x){
        if(rand() / (real_t)(RAND_MAX) < false_margin){
            a[x] = 1;
        }
        else{
            a[x] = 0;
        }
    }

    #pragma acc data copyin(a[0:n])
    {
        #pragma acc parallel loop reduction(&&:result)
        for (int x = 0; x < n; ++x){
            result = result && a[x];
        }
    }

    for (int x = 0; x < n; ++x){
        if (a[x] == 0){
            found = 1;
            break;
        }
    }
    if (found == result){
        err = 1;
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,combined-constructs,loop,V:2.7-2.7
int test2(){
    int err = 0;
    srand(SEED);
    char * a = (char *)malloc(n * 5 * sizeof(char));
    real_t false_margin = pow(exp(1), log(.5/n));
    char result[5];
    char host_result[5];

    for (int x = 0; x < 5; ++x) {
        result[x] = 1;
        host_result[x] = 1;
    }

    for (int x = 0; x < 5 * n; ++x) {
        if (rand() / (real_t)(RAND_MAX) < false_margin) {
            a[x] = 1;
        }
        else {
            a[x] = 0;
        }
    }

    #pragma acc data copyin(a[0:5*n])
    {
        #pragma acc parallel loop reduction(&&:result)
        for (int x = 0; x < 5 * n; ++x) {
            result[x%5] = result[x%5] && a[x];
        }
    }

    for (int x = 0; x < 5 * n; ++x) {
        host_result[x%5] = host_result[x%5] && a[x];
    }

    for (int x = 0; x < 5; ++x){
        if (host_result[x] != result[x]) {
            err += 1;
        } 
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_reduction_and_general.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);

    char * a = new char[n];
    real_t false_margin = pow(exp(1), log(.5)/n);
    char result = 1;
    char found = 0;

    for (int x = 0; x < n; ++x){
        if(rand() / (real_t)(RAND_MAX) < false_margin){
            a[x] = 1;
        }
        else{
            a[x] = 0;
        }
    }

    #pragma acc data copyin(a[0:n])
    {
        #pragma acc parallel loop reduction(&&:result)
        for (int x = 0; x < n; ++x){
            result = result && a[x];
        }
    }

    for (int x = 0; x < n; ++x){
        if (a[x] == 0){
            found = 1;
            break;
        }
    }
    if (found == result){
        err = 1;
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,combined-constructs,loop,V:2.7-2.7
int test2(){
    int err = 0;
    srand(SEED);
    char * a = new char[n * 5];
    real_t false_margin = pow(exp(1), log(.5/n));
    char result[5];
    char host_result[5];

    for (int x = 0; x < 5; ++x) {
        result[x] = 1;
        host_result[x] = 1;
    }

    for (int x = 0; x < 5 * n; ++x) {
        if (rand() / (real_t)(RAND_MAX) < false_margin) {
            a[x] = 1;
        }
        else {
            a[x] = 0;
        }
    }

    #pragma acc data copyin(a[0:5*n])
    {
        #pragma acc parallel loop reduction(&&:result)
        for (int x = 0; x < 5 * n; ++x) {
            result[x%5] = result[x%5] && a[x];
        }
    }

    for (int x = 0; x < 5 * n; ++x) {
        host_result[x%5] = host_result[x%5] && a[x];
    }

    for (int x = 0; x < 5; ++x){
        if (host_result[x] != result[x]) {
            err += 1;
        } 
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_reduction_and_loop.c:::
#include "acc_testsuite.h"

#ifndef T1
//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    char * a = (char *)malloc(10 * n * sizeof(char));
    char * a_copy = (char *)malloc(10 * n * sizeof(char));
    char * has_false = (char *)malloc(10 * sizeof(char));
    real_t false_margin = pow(exp(1), log(.5)/n);
    char temp = 1;

    for (int x = 0; x < 10; ++x){
        has_false[x] = 0;
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < n; ++y){
            if (rand() / (real_t)(RAND_MAX) < false_margin){
                a[x * n + y] = 1;
                a_copy[x * n + y] = 1;
            }
            else {
                a[x * n + y] = 0;
                a_copy[x * n + y] = 0;
                has_false[x] = 1;
            }
        }
    }

    #pragma acc data copy(a[0:10*n])
    {
        #pragma acc parallel loop gang private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 1;
            #pragma acc loop worker reduction(&&:temp)
            for (int y = 0; y < n; ++y){
                temp = temp && a[x * n + y];
            }
            #pragma acc loop worker
            for (int y = 0; y < n; ++y){
                a[x * n + y] = a[x * n + y] ^ temp;
            }
        }
    }


    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < n; ++y){
            if (has_false[x] == 1 && a[x * n + y] != a_copy[x * n + y]){
                err = 1;
            }
            else if (has_false[x] == 0 && a[x * n + y] == a_copy[x * n + y]){
                err = 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7
int test2(){
    int err = 0;
    srand(SEED);
    char * a = (char *)malloc(n * 25 * sizeof(char));
    char * a_copy = (char *)malloc(n * 25 * sizeof(char));
    char * has_false = (char *)malloc(25 * sizeof(char));
    real_t false_margin = pow(exp(1), log(.5)/n);
    char device[5];
    char host[5];

    for (int x = 0; x < 5; ++x) {
        device[x] = 1;
        host[x] = 1;
        for (int y = 0; y < 5; ++y) {
            has_false[x * 5 + y] = 0;
        }
    }

    for (int x = 0; x < 25 * n; ++x){
        if (rand() / (real_t)(RAND_MAX) < false_margin) {
            a[x] = 1;
            a_copy[x] = 1;
        }
        else {
            a[x] = 0;
            a_copy[x] = 0;
            has_false[x % 25] = 1;
        }
    }

    #pragma acc data copy(a[0:25*n])
    {
        #pragma acc parallel loop gang private(device)
        for (int x = 0; x < 5; ++x) {
            for (int y = 0; y < 5; ++y) {
                device[y] = 1;
            }
            #pragma acc loop worker reduction(&&:device)
            for (int y = 0; y < 5 * n; ++y) {
                device[y%5] = device[y%5] && a[x * 5 * n + y];
            }
            #pragma acc loop worker
            for (int y = 0; y < 5 * n; ++y) {
                a[x * 5 * n + y] = a[x * 5 * n + y] ^ device[y%5];
            }
        }
    }

    for (int x = 0; x < 5; ++x) {
        for (int y = 0; y < 5; ++y) {
            host[y] = 1;
        }
        for (int y = 0; y < 5 * n; ++y) {
            host[y%5] = host[y%5] && a_copy[x * 5 * n + y];
        }
        for (int y = 0; y < 5 * n; ++y) {
            if (a[x * 5 * n + y] != (a_copy[x * 5 * n + y] ^ host[y % 5])) {
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_reduction_and_loop.cpp:::
#include "acc_testsuite.h"

#ifndef T1
//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    char * a = new char[10 * n];
    char * a_copy = new char[10 * n];
    char * has_false = new char[10];
    real_t false_margin = pow(exp(1), log(.5)/n);
    char temp = 1;

    for (int x = 0; x < 10; ++x){
        has_false[x] = 0;
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < n; ++y){
            if (rand() / (real_t)(RAND_MAX) < false_margin){
                a[x * n + y] = 1;
                a_copy[x * n + y] = 1;
            }
            else {
                a[x * n + y] = 0;
                a_copy[x * n + y] = 0;
                has_false[x] = 1;
            }
        }
    }

    #pragma acc data copy(a[0:10*n])
    {
        #pragma acc parallel loop gang private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 1;
            #pragma acc loop worker reduction(&&:temp)
            for (int y = 0; y < n; ++y){
                temp = temp && a[x * n + y];
            }
            #pragma acc loop worker
            for (int y = 0; y < n; ++y){
                a[x * n + y] = a[x * n + y] ^ temp;
            }
        }
    }


    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < n; ++y){
            if (has_false[x] == 1 && a[x * n + y] != a_copy[x * n + y]){
                err = 1;
            }
            else if (has_false[x] == 0 && a[x * n + y] == a_copy[x * n + y]){
                err = 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7
int test2(){
    int err = 0;
    srand(SEED);
    char * a = new char[n * 25];
    char * a_copy = new char[n * 25];
    char * has_false = new char[25];
    real_t false_margin = pow(exp(1), log(.5)/n);
    char device[5];
    char host[5];

    for (int x = 0; x < 5; ++x) {
        device[x] = 1;
        host[x] = 1;
        for (int y = 0; y < 5; ++y) {
            has_false[x * 5 + y] = 0;
        }
    }

    for (int x = 0; x < 25 * n; ++x){
        if (rand() / (real_t)(RAND_MAX) < false_margin) {
            a[x] = 1;
            a_copy[x] = 1;
        }
        else {
            a[x] = 0;
            a_copy[x] = 0;
            has_false[x % 25] = 1;
        }
    }

    #pragma acc data copy(a[0:25*n])
    {
        #pragma acc parallel loop gang private(device)
        for (int x = 0; x < 5; ++x) {
            for (int y = 0; y < 5; ++y) {
                device[y] = 1;
            }
            #pragma acc loop worker reduction(&&:device)
            for (int y = 0; y < 5 * n; ++y) {
                device[y%5] = device[y%5] && a[x * 5 * n + y];
            }
            #pragma acc loop worker
            for (int y = 0; y < 5 * n; ++y) {
                a[x * 5 * n + y] = a[x * 5 * n + y] ^ device[y%5];
            }
        }
    }

    for (int x = 0; x < 5; ++x) {
        for (int y = 0; y < 5; ++y) {
            host[y] = 1;
        }
        for (int y = 0; y < 5 * n; ++y) {
            host[y%5] = host[y%5] && a_copy[x * 5 * n + y];
        }
        for (int y = 0; y < 5 * n; ++y) {
            if (a[x * 5 * n + y] != (a_copy[x * 5 * n + y] ^ host[y % 5])) {
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_reduction_and_vector_loop.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    char * a = (char *)malloc(10 * n * sizeof(char));
    char * b = (char *)malloc(10 * sizeof(char));
    char * has_false = (char *)malloc(10 * sizeof(char));
    real_t false_margin = pow(exp(1), log(.5)/n);
    char temp = 1;

    for (int x = 0; x < 10; ++x){
        has_false[x] = 0;
    }
    for (int x = 0; x < 10 * n; ++x){
        if(rand() / (real_t)(RAND_MAX) < false_margin){
            a[x] = 1;
        }
        else{
            a[x] = 0;
            has_false[x/n] = 1;
        }
    }
    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])
    {
        #pragma acc parallel loop private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 1;
            #pragma acc loop vector reduction(&&:temp)
            for (int y = 0; y < n; ++y){
                temp = temp && a[x * n + y];
            }
            b[x] = temp;
        }
    }
    for (int x = 0; x < 10; ++x){
        if (has_false[x] == b[x]){
            err = 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7
int test2(){
    int err = 0;
    srand(SEED);
    char * a = (char *)malloc(25 * n * sizeof(char));
    char * b = (char *)malloc(25 * sizeof(char));
    char * has_false = (char *)malloc(25 * sizeof(char));
    real_t false_margin = pow(exp(1), log(.5)/n);
    char device[5];
    char host[5];

    for (int x = 0; x < 5; ++x) {
        for (int y = 0; y < 5 * n; ++y){
            if (rand() / (real_t)(RAND_MAX) < false_margin) {
                a[x] = 1;
            }
            else {
                a[x] = 0;
                has_false[x * 5 + y % 5];
            }
        }
    }

    #pragma acc data copyin(a[0:25*n]) copy(b[0:25])
    {
        #pragma acc parallel loop private(device)
        for (int x = 0; x < 5; ++x) {
            for (int y = 0; y < 5; ++y) {
                device[y] = 1;
            }
            #pragma acc loop vector reduction(&&:device)
            for (int y = 0; y < 5 * n; ++y) {
                device[y%5] = device[y%5] && a[x * 5 * n + y];
            }
            for (int y = 0; y < 5; ++y){
                b[x * 5 + y] = device[y];
            }
        }
    }

    for (int x = 0; x < 5; ++x) {
        for (int y = 0; y < 5; ++y) {
            host[y] = 1;
        }
        for (int y = 0; y < 5 * n; ++y) {
            host[y%5] = host[y%5] && a[x * 5 * n + y];
        }
        for (int y = 0; y < 5; ++y) {
            if (b[x * 5 + y] != host[y]) {
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_reduction_and_vector_loop.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    char * a = new char[10 * n];
    char * b = new char[10];
    char * has_false = new char[10];
    real_t false_margin = pow(exp(1), log(.5)/n);
    char temp = 1;

    for (int x = 0; x < 10; ++x){
        has_false[x] = 0;
    }
    for (int x = 0; x < 10 * n; ++x){
        if(rand() / (real_t)(RAND_MAX) < false_margin){
            a[x] = 1;
        }
        else{
            a[x] = 0;
            has_false[x/n] = 1;
        }
    }
    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])
    {
        #pragma acc parallel loop private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 1;
            #pragma acc loop vector reduction(&&:temp)
            for (int y = 0; y < n; ++y){
                temp = temp && a[x * n + y];
            }
            b[x] = temp;
        }
    }
    for (int x = 0; x < 10; ++x){
        if (has_false[x] == b[x]){
            err = 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7
int test2(){
    int err = 0;
    srand(SEED);
    char * a = new char[25 * n];
    char * b = new char[25];
    char * has_false = new char[25];
    real_t false_margin = pow(exp(1), log(.5)/n);
    char device[5];
    char host[5];

    for (int x = 0; x < 5; ++x) {
        for (int y = 0; y < 5 * n; ++y){
            if (rand() / (real_t)(RAND_MAX) < false_margin) {
                a[x] = 1;
            }
            else {
                a[x] = 0;
                has_false[x * 5 + y % 5];
            }
        }
    }

    #pragma acc data copyin(a[0:25*n]) copy(b[0:25])
    {
        #pragma acc parallel loop private(device)
        for (int x = 0; x < 5; ++x) {
            for (int y = 0; y < 5; ++y) {
                device[y] = 1;
            }
            #pragma acc loop vector reduction(&&:device)
            for (int y = 0; y < 5 * n; ++y) {
                device[y%5] = device[y%5] && a[x * 5 * n + y];
            }
            for (int y = 0; y < 5; ++y){
                b[x * 5 + y] = device[y];
            }
        }
    }

    for (int x = 0; x < 5; ++x) {
        for (int y = 0; y < 5; ++y) {
            host[y] = 1;
        }
        for (int y = 0; y < 5 * n; ++y) {
            host[y%5] = host[y%5] && a[x * 5 * n + y];
        }
        for (int y = 0; y < 5; ++y) {
            if (b[x * 5 + y] != host[y]) {
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_reduction_bitand_general.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    n = 10;
    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));
    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int temp = 1;
    unsigned int b;
    unsigned int host_b;

    for (int x = 0; x < n; ++x){
        a[x] = 0;
        for (int y = 0; y < 16; ++y){
            if (rand() / (real_t) RAND_MAX < false_margin){
                for (int z = 0; z < y; ++z){
                    temp *= 2;
                }
                a[x] += temp;
                temp = 1;
            }
        }
    }

    b = a[0];
    host_b = a[0];

    #pragma acc data copyin(a[0:n])
    {
        #pragma acc parallel loop reduction(&:b)
        for (int x = 0; x < n; ++x){
            b = b & a[x];
        }
    }

    for (int x = 1; x < n; ++x){
        host_b = host_b & a[x];
    }
    if (b != host_b){
        err = 1;
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7
int test2(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(int));
    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int device[10];
    unsigned int host[10];

    for (int x = 0; x < 10 * n; ++x) {
        a[x] = 0;
        for (int y = 0; y < 16; ++y){
            if (rand() / (real_t)RAND_MAX < false_margin) {
                a[x] += 1<<y;
            }
        }
    }

    for (int x = 0; x < 10; ++x) {
        device[x] = 0;
        host[x] = 0;
        for (int y = 0; y < 16; ++y) {
            device[x] += 1<<y;
            host[x] += 1<<y;
        }
    }

    #pragma acc data copyin(a[0:10*n])
    {
        #pragma acc parallel loop reduction(&:device)
        for (int x = 0; x < 10 * n; ++x) {
            device[x%10] = device[x%10] & a[x];
        }
    }

    for (int x = 0; x < 10 * n; ++x) {
        host[x%10] = host[x%10] & a[x];
    }

    for (int x = 0; x < 10; ++x) {
        if (host[x] != device[x]) {
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_reduction_bitand_general.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    n = 10;
    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));
    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int temp = 1;
    unsigned int b;
    unsigned int host_b;

    for (int x = 0; x < n; ++x){
        a[x] = 0;
        for (int y = 0; y < 16; ++y){
            if (rand() / (real_t) RAND_MAX < false_margin){
                for (int z = 0; z < y; ++z){
                    temp *= 2;
                }
                a[x] += temp;
                temp = 1;
            }
        }
    }

    b = a[0];
    host_b = a[0];

    #pragma acc data copyin(a[0:n])
    {
        #pragma acc parallel loop reduction(&:b)
        for (int x = 0; x < n; ++x){
            b = b & a[x];
        }
    }

    for (int x = 1; x < n; ++x){
        host_b = host_b & a[x];
    }
    if (b != host_b){
        err = 1;
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7
int test2(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(int));
    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int device[10];
    unsigned int host[10];

    for (int x = 0; x < 10 * n; ++x) {
        a[x] = 0;
        for (int y = 0; y < 16; ++y){
            if (rand() / (real_t)RAND_MAX < false_margin) {
                a[x] += 1<<y;
            }
        }
    }

    for (int x = 0; x < 10; ++x) {
        device[x] = 0;
        host[x] = 0;
        for (int y = 0; y < 16; ++y) {
            device[x] += 1<<y;
            host[x] += 1<<y;
        }
    }

    #pragma acc data copyin(a[0:10*n])
    {
        #pragma acc parallel loop reduction(&:device)
        for (int x = 0; x < 10 * n; ++x) {
            device[x%10] = device[x%10] & a[x];
        }
    }

    for (int x = 0; x < 10 * n; ++x) {
        host[x%10] = host[x%10] & a[x];
    }

    for (int x = 0; x < 10; ++x) {
        if (host[x] != device[x]) {
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_reduction_bitand_loop.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));
    unsigned int * host_c = (unsigned int *)malloc(10 * sizeof(unsigned int));

    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int temp = 1;

    for (int x = 0; x < 10 * n; ++x){
        a[x] = 0;
        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);
        b_copy[x] = b[x];
        for (int y = 0; y < 16; ++y){
            if (rand() / (real_t) RAND_MAX < false_margin){
                a[x] += 1 << y;
            }
        }
    }
    #pragma acc data copyin(a[0:10 * n]) copy(b[0:10 * n], c[0:10])
    {
        #pragma acc parallel loop gang private(temp)
        for (int y = 0; y < 10; ++y){
            temp = a[y * n];
            #pragma acc loop worker reduction(&:temp)
            for (int x = 1; x < n; ++x){
                temp = temp & a[y * n + x];
            }
            c[y] = temp;
            #pragma acc loop worker
            for (int x = 0; x < n; ++x){
                b[y * n + x] = b[y * n + x] + c[y];
            }
        }
    }
    for (int x = 0; x < 10; ++x){
        host_c[x] = a[x * n];
        for (int y = 1; y < n; ++y){
            host_c[x] = host_c[x] & a[x * n + y];
        }
        if (host_c[x] != c[x]){
          err += 1;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < n; ++y){
            if (b[x * n + y] != b_copy[x * n + y] + c[x]){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7
int test2(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));
    unsigned int * b = (unsigned int *)malloc(25 * n * sizeof(unsigned int));
    unsigned int * b_copy = (unsigned int *)malloc(25 * n * sizeof(unsigned int));
    unsigned int * c = (unsigned int *)malloc(25 * sizeof(unsigned int));
    unsigned int device[5];
    unsigned int host[5];

    real_t false_margin = pow(exp(1), log(.5)/n);
    
    for (int x = 0; x < 25 * n; ++x){
        a[x] = 0;
        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);
        b_copy[x] = b[x];
        for (int y = 0; y < 16; ++y) {
            if (rand() / (real_t)RAND_MAX < false_margin) {
                a[x] += 1 << y;
            }
        }
    }

    #pragma acc data copyin(a[0:25*n]) copy(b[0:25*n], c[0:25])
    {
        #pragma acc parallel loop gang private(device)
        for (int x = 0; x < 5; ++x) {
            for (int y = 0; y < 5; ++y) {
                device[y] = a[x * 5 * n + y];
            }
            #pragma acc loop worker reduction(&:device)
            for (int y = 0; y < 5 * n; ++y) {
                device[y%5] = device[y%5] & a[x * 5 * n + y];
            }
            for (int y = 0; y < 5; ++y) {
                c[x * 5 + y] = device[y];
            }
            #pragma acc loop worker
            for (int y = 0; y < 5 * n; ++y) {
                b[x * 5 * n + y] = b[x * 5 * n + y] + c[x * 5 + (y % 5)];
            }
        }
    }

    for (int x = 0; x < 5; ++x) {
        for (int y = 0; y < 5; ++y) {
            host[y] = a[x * 5 * n + y];
        }
        for (int y = 0; y < 5 * n; ++y) {
            host[y%5] = host[y%5] & a[x * 5 * n + y];
        }
        for (int y = 0; y < 5; ++y) {
            if (host[y] != c[x * 5 + y]) {
                err += 1;
            }
        }
        for (int y = 0; y < 5 * n; ++y) {
            if (b[x * 5 * n + y] != (host[y%5] + b_copy[x * 5 * n + y])) {
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_reduction_bitand_loop.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));
    unsigned int * host_c = (unsigned int *)malloc(10 * sizeof(unsigned int));

    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int temp = 1;

    for (int x = 0; x < 10 * n; ++x){
        a[x] = 0;
        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);
        b_copy[x] = b[x];
        for (int y = 0; y < 16; ++y){
            if (rand() / (real_t) RAND_MAX < false_margin){
                a[x] += 1 << y;
            }
        }
    }
    #pragma acc data copyin(a[0:10 * n]) copy(b[0:10 * n], c[0:10])
    {
        #pragma acc parallel loop gang private(temp)
        for (int y = 0; y < 10; ++y){
            temp = a[y * n];
            #pragma acc loop worker reduction(&:temp)
            for (int x = 1; x < n; ++x){
                temp = temp & a[y * n + x];
            }
            c[y] = temp;
            #pragma acc loop worker
            for (int x = 0; x < n; ++x){
                b[y * n + x] = b[y * n + x] + c[y];
            }
        }
    }
    for (int x = 0; x < 10; ++x){
        host_c[x] = a[x * n];
        for (int y = 1; y < n; ++y){
            host_c[x] = host_c[x] & a[x * n + y];
        }
        if (host_c[x] != c[x]){
          err += 1;
        }
    }

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < n; ++y){
            if (b[x * n + y] != b_copy[x * n + y] + c[x]){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7
int test2(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));
    unsigned int * b = (unsigned int *)malloc(25 * n * sizeof(unsigned int));
    unsigned int * b_copy = (unsigned int *)malloc(25 * n * sizeof(unsigned int));
    unsigned int * c = (unsigned int *)malloc(25 * sizeof(unsigned int));
    unsigned int device[5];
    unsigned int host[5];

    real_t false_margin = pow(exp(1), log(.5)/n);
    
    for (int x = 0; x < 25 * n; ++x){
        a[x] = 0;
        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);
        b_copy[x] = b[x];
        for (int y = 0; y < 16; ++y) {
            if (rand() / (real_t)RAND_MAX < false_margin) {
                a[x] += 1 << y;
            }
        }
    }

    #pragma acc data copyin(a[0:25*n]) copy(b[0:25*n], c[0:25])
    {
        #pragma acc parallel loop gang private(device)
        for (int x = 0; x < 5; ++x) {
            for (int y = 0; y < 5; ++y) {
                device[y] = a[x * 5 * n + y];
            }
            #pragma acc loop worker reduction(&:device)
            for (int y = 0; y < 5 * n; ++y) {
                device[y%5] = device[y%5] & a[x * 5 * n + y];
            }
            for (int y = 0; y < 5; ++y) {
                c[x * 5 + y] = device[y];
            }
            #pragma acc loop worker
            for (int y = 0; y < 5 * n; ++y) {
                b[x * 5 * n + y] = b[x * 5 * n + y] + c[x * 5 + (y % 5)];
            }
        }
    }

    for (int x = 0; x < 5; ++x) {
        for (int y = 0; y < 5; ++y) {
            host[y] = a[x * 5 * n + y];
        }
        for (int y = 0; y < 5 * n; ++y) {
            host[y%5] = host[y%5] & a[x * 5 * n + y];
        }
        for (int y = 0; y < 5; ++y) {
            if (host[y] != c[x * 5 + y]) {
                err += 1;
            }
        }
        for (int y = 0; y < 5 * n; ++y) {
            if (b[x * 5 * n + y] != (host[y%5] + b_copy[x * 5 * n + y])) {
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_reduction_bitand_vector_loop.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));

    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int temp = 1;
    unsigned int c = 0;
    unsigned int b_host;

    for (int x = 0; x < 10 * n; ++x){
        a[x] = 0;
        for (int y = 0; y < 16; ++y){
            if (rand() / (real_t) RAND_MAX < false_margin){
                a[x] += 1 << y;
            }
        }
    }

    #pragma acc data copyin(a[0:10*n]) copyout(b[0:10])
    {
        #pragma acc parallel loop private(c)
        for (int x = 0; x < 10; ++x){
            c = a[x * n];
            #pragma acc loop vector reduction(&:c)
            for (int y = 1; y < n; ++y){
                c = c & a[x * n + y];
            }
            b[x] = c;
        }
    }
    for (int x = 0; x < 10; ++x){
        b_host = a[x * n];
        for (int y = 1; y < n; ++y){
            b_host = b_host & a[x * n + y];
        }
        if (b_host != b[x]){
            err = 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7
int test2(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));
    unsigned int * b = (unsigned int *)malloc(25 * sizeof(unsigned int));
    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int c[5];
    unsigned int * b_host = (unsigned int *)malloc(5 * sizeof(unsigned int));
    

    for (int x = 0; x < 25 * n; ++x){
        a[x] = 0;
        for (int y = 0; y < 16; ++y) {
            if (rand() / (real_t)RAND_MAX < false_margin) {
                a[x] += 1 << y;
            }
        }
    }

    #pragma acc data copyin(a[0:25*n]) copyout(b[0:25])
    {
        #pragma acc parallel loop private(c)
        for (int x = 0; x < 5; ++x) {
            for (int y = 0; y < 5; ++y) {
                c[y] = a[x * 5 * n + y];
            }
            #pragma acc loop vector reduction(&:c)
            for (int y = 0; y < 5 * n; ++y) {
                c[y%5] = c[y%5] & a[x * 5 * n + y];
            }
            for (int y = 0; y < 5; ++y) {
                b[x * 5 + y] = c[y];
            }
        }
    }

    for (int x = 0; x < 5; ++x) {
        for (int y = 0; y < 5; ++y) {
            b_host[y] = a[x * 5 * n + y];
        }
        for (int y = 0; y < 5 * n; ++y) {
            b_host[y%5] = b_host[y%5] & a[x * 5 * n + y];
        }
        for (int y = 0; y < 5; ++y) {
            if (b_host[y] != b[x * 5 + y]){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_reduction_bitand_vector_loop.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));

    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int temp = 1;
    unsigned int c = 0;
    unsigned int b_host;

    for (int x = 0; x < 10 * n; ++x){
        a[x] = 0;
        for (int y = 0; y < 16; ++y){
            if (rand() / (real_t) RAND_MAX < false_margin){
                a[x] += 1 << y;
            }
        }
    }

    #pragma acc data copyin(a[0:10*n]) copyout(b[0:10])
    {
        #pragma acc parallel loop private(c)
        for (int x = 0; x < 10; ++x){
            c = a[x * n];
            #pragma acc loop vector reduction(&:c)
            for (int y = 1; y < n; ++y){
                c = c & a[x * n + y];
            }
            b[x] = c;
        }
    }
    for (int x = 0; x < 10; ++x){
        b_host = a[x * n];
        for (int y = 1; y < n; ++y){
            b_host = b_host & a[x * n + y];
        }
        if (b_host != b[x]){
            err = 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7
int test2(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));
    unsigned int * b = (unsigned int *)malloc(25 * sizeof(unsigned int));
    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int c[5];
    unsigned int * b_host = (unsigned int *)malloc(5 * sizeof(unsigned int));
    

    for (int x = 0; x < 25 * n; ++x){
        a[x] = 0;
        for (int y = 0; y < 16; ++y) {
            if (rand() / (real_t)RAND_MAX < false_margin) {
                a[x] += 1 << y;
            }
        }
    }

    #pragma acc data copyin(a[0:25*n]) copyout(b[0:25])
    {
        #pragma acc parallel loop private(c)
        for (int x = 0; x < 5; ++x) {
            for (int y = 0; y < 5; ++y) {
                c[y] = a[x * 5 * n + y];
            }
            #pragma acc loop vector reduction(&:c)
            for (int y = 0; y < 5 * n; ++y) {
                c[y%5] = c[y%5] & a[x * 5 * n + y];
            }
            for (int y = 0; y < 5; ++y) {
                b[x * 5 + y] = c[y];
            }
        }
    }

    for (int x = 0; x < 5; ++x) {
        for (int y = 0; y < 5; ++y) {
            b_host[y] = a[x * 5 * n + y];
        }
        for (int y = 0; y < 5 * n; ++y) {
            b_host[y%5] = b_host[y%5] & a[x * 5 * n + y];
        }
        for (int y = 0; y < 5; ++y) {
            if (b_host[y] != b[x * 5 + y]){
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_reduction_bitor_general.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));
    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int temp = 1;
    unsigned int b = 0;
    unsigned int host_b;

    for (int x = 0; x < n; ++x){
        a[x] = 0;
        for (int y = 0; y < 16; ++y){
            if (rand() / (real_t) RAND_MAX > false_margin){
                a[x] += 1 << y;
            }
        }
    }

    #pragma acc data copyin(a[0:n])
    {
        #pragma acc parallel loop reduction(|:b)
        for (int x = 0; x < n; ++x){
            b = b | a[x];
        }
    }

    host_b = a[0];
    for (int x = 1; x < n; ++x){
        host_b = host_b | a[x];
    }

    if (b != host_b){
        err = 1;
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7
int test2(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(5 * n * sizeof(unsigned int));
    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int b[5];
    unsigned int host_b[5];

    for (int x = 0; x < 5 * n; ++x){
        a[x] = 0;
        for (int y = 0; y < 16; ++y) {
            if (rand() / (real_t) RAND_MAX > false_margin) {
                a[x] += 1 << y;
            }
        }
    }

    for (int x = 0; x < 5; ++x) {
        b[x] = 0;
        host_b[x] = 0;
    }

    #pragma acc data copyin(a[0:5*n])
    {
        #pragma acc parallel loop reduction(|:b)
        for (int x = 0; x < 5 * n; ++x) {
            b[x%5] = b[x%5] | a[x];
        }
    }

    for (int x = 0; x < 5 * n; ++x){
        host_b[x%5] = host_b[x%5] | a[x];
    }

    for (int x = 0; x < 5; ++x) {
        if (host_b[x] != b[x]) {
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_reduction_bitor_general.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));
    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int temp = 1;
    unsigned int b = 0;
    unsigned int host_b;

    for (int x = 0; x < n; ++x){
        a[x] = 0;
        for (int y = 0; y < 16; ++y){
            if (rand() / (real_t) RAND_MAX > false_margin){
                a[x] += 1 << y;
            }
        }
    }

    #pragma acc data copyin(a[0:n])
    {
        #pragma acc parallel loop reduction(|:b)
        for (int x = 0; x < n; ++x){
            b = b | a[x];
        }
    }

    host_b = a[0];
    for (int x = 1; x < n; ++x){
        host_b = host_b | a[x];
    }

    if (b != host_b){
        err = 1;
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7
int test2(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(5 * n * sizeof(unsigned int));
    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int b[5];
    unsigned int host_b[5];

    for (int x = 0; x < 5 * n; ++x){
        a[x] = 0;
        for (int y = 0; y < 16; ++y) {
            if (rand() / (real_t) RAND_MAX > false_margin) {
                a[x] += 1 << y;
            }
        }
    }

    for (int x = 0; x < 5; ++x) {
        b[x] = 0;
        host_b[x] = 0;
    }

    #pragma acc data copyin(a[0:5*n])
    {
        #pragma acc parallel loop reduction(|:b)
        for (int x = 0; x < 5 * n; ++x) {
            b[x%5] = b[x%5] | a[x];
        }
    }

    for (int x = 0; x < 5 * n; ++x){
        host_b[x%5] = host_b[x%5] | a[x];
    }

    for (int x = 0; x < 5; ++x) {
        if (host_b[x] != b[x]) {
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_reduction_bitor_loop.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));

    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int temp = 1;
    unsigned int host_c;

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < n; ++y){
            b[x * n + y] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);
            b_copy[x * n + y] = b[x * n + y];
            for (int z = 0; z < 16; ++z){
                a[x * n + y] += (1<<z);
            }
        }
    }

    #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])
    {
        #pragma acc parallel loop gang private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 0;
            #pragma acc loop worker reduction(|:temp)
            for (int y = 0; y < n; ++y){
                temp = temp | a[x * n + y];
            }
            c[x] = temp;
            #pragma acc loop worker
            for (int y = 0; y < n; ++y){
                b[x * n + y] = b[x * n + y] + c[x];
            }
        }
    }
    for (int x = 0; x < 10; ++x){
        host_c = a[x * n];
        for (int y = 1; y < n; ++y){
            host_c = host_c | a[x * n + y];
        }
        if (host_c != c[x]){
            err += 1;
        }
        for (int y = 0; y < n; ++y){
            if (b[x * n + y] != b_copy[x * n + y] + host_c){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7
int test2(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));
    unsigned int * b = (unsigned int *)malloc(25 * n * sizeof(unsigned int));
    unsigned int * b_copy = (unsigned int *)malloc(25 * n * sizeof(unsigned int));
    unsigned int * c = (unsigned int *)malloc(25 * sizeof(unsigned int));
    unsigned int temp[5];

    real_t false_margin = pow(exp(1), log(.5)/n);

    for (int x = 0; x < 25 * n; ++x){
        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);
        b_copy[x] = b[x];
        for (int y = 0; y < 16; ++y) {
            if (rand() / (real_t)RAND_MAX > false_margin) {
                a[x] += (1<<y);
            }
        }
    }

    #pragma acc data copyin(a[0:25*n]) copy(b[0:25*n], c[0:25])
    {
        #pragma acc parallel loop gang private(temp)
        for (int x = 0; x < 5; ++x) {
            for (int y = 0; y < 5; ++y) {
                temp[y] = 0;
            }
            #pragma acc loop worker reduction(|:temp)
            for (int y = 0; y < 5 * n; ++y) {
                temp[y%5] = temp[y%5] | a[x * 5 * n + y];
            }
            for (int y = 0; y < 5; ++y) {
                c[x * 5 + y] = temp[y];
            }
            #pragma acc loop worker
            for (int y = 0; y < 5 * n; ++y) {
                b[x * 5 * n + y] = b[x * 5 * n + y] + c[x * 5 + (y % 5)];
            }
        }
    }

    for (int x = 0; x < 5; ++x){
        for (int y = 0; y < 5; ++y){
            temp[y] = 0;
        }
        for (int y = 0; y < 5 * n; ++y) {
            temp[y%5] = temp[y%5] | a[x * 5 * n + y];
        }
        for (int y = 0; y < 5; ++y){
            if (c[x * 5 + y] != temp[y]) {
                err += 1;
            }
        }
        for (int y = 0; y < 5 * n; ++y) {
            if ((b_copy[x * 5 * n + y] + c[x * 5 + (y % 5)]) != b[x * 5 * n + y]) {
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_reduction_bitor_loop.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * b = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * b_copy = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int * c = (unsigned int *)malloc(10 * sizeof(unsigned int));

    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int temp = 1;
    unsigned int host_c;

    for (int x = 0; x < 10; ++x){
        for (int y = 0; y < n; ++y){
            b[x * n + y] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);
            b_copy[x * n + y] = b[x * n + y];
            for (int z = 0; z < 16; ++z){
                a[x * n + y] += (1<<z);
            }
        }
    }

    #pragma acc data copyin(a[0:10*n]) copy(b[0:10*n], c[0:10])
    {
        #pragma acc parallel loop gang private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 0;
            #pragma acc loop worker reduction(|:temp)
            for (int y = 0; y < n; ++y){
                temp = temp | a[x * n + y];
            }
            c[x] = temp;
            #pragma acc loop worker
            for (int y = 0; y < n; ++y){
                b[x * n + y] = b[x * n + y] + c[x];
            }
        }
    }
    for (int x = 0; x < 10; ++x){
        host_c = a[x * n];
        for (int y = 1; y < n; ++y){
            host_c = host_c | a[x * n + y];
        }
        if (host_c != c[x]){
            err += 1;
        }
        for (int y = 0; y < n; ++y){
            if (b[x * n + y] != b_copy[x * n + y] + host_c){
                err += 1;
            }
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7
int test2(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));
    unsigned int * b = (unsigned int *)malloc(25 * n * sizeof(unsigned int));
    unsigned int * b_copy = (unsigned int *)malloc(25 * n * sizeof(unsigned int));
    unsigned int * c = (unsigned int *)malloc(25 * sizeof(unsigned int));
    unsigned int temp[5];

    real_t false_margin = pow(exp(1), log(.5)/n);

    for (int x = 0; x < 25 * n; ++x){
        b[x] = (unsigned int) rand() / (real_t)(RAND_MAX / 1000);
        b_copy[x] = b[x];
        for (int y = 0; y < 16; ++y) {
            if (rand() / (real_t)RAND_MAX > false_margin) {
                a[x] += (1<<y);
            }
        }
    }

    #pragma acc data copyin(a[0:25*n]) copy(b[0:25*n], c[0:25])
    {
        #pragma acc parallel loop gang private(temp)
        for (int x = 0; x < 5; ++x) {
            for (int y = 0; y < 5; ++y) {
                temp[y] = 0;
            }
            #pragma acc loop worker reduction(|:temp)
            for (int y = 0; y < 5 * n; ++y) {
                temp[y%5] = temp[y%5] | a[x * 5 * n + y];
            }
            for (int y = 0; y < 5; ++y) {
                c[x * 5 + y] = temp[y];
            }
            #pragma acc loop worker
            for (int y = 0; y < 5 * n; ++y) {
                b[x * 5 * n + y] = b[x * 5 * n + y] + c[x * 5 + (y % 5)];
            }
        }
    }

    for (int x = 0; x < 5; ++x){
        for (int y = 0; y < 5; ++y){
            temp[y] = 0;
        }
        for (int y = 0; y < 5 * n; ++y) {
            temp[y%5] = temp[y%5] | a[x * 5 * n + y];
        }
        for (int y = 0; y < 5; ++y){
            if (c[x * 5 + y] != temp[y]) {
                err += 1;
            }
        }
        for (int y = 0; y < 5 * n; ++y) {
            if ((b_copy[x * 5 * n + y] + c[x * 5 + (y % 5)]) != b[x * 5 * n + y]) {
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_reduction_bitor_vector_loop.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));

    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int temp = 1;
    unsigned int b_host;

    for (int x = 0; x < 10 * n; ++x){
        for (int y = 0; y < 16; ++y){
            if (rand() / (real_t) RAND_MAX > false_margin){
                for (int z = 0; z < y; ++z){
                    temp *= 2;
                }
                a[x] += temp;
                temp = 1;
            }
        }
    }
    temp = 0;
    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])
    {
        #pragma acc parallel loop private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 0;
            #pragma acc loop vector reduction(|:temp)
            for (int y = 0; y < n; ++y){
                temp = temp | a[x * n + y];
            }
            b[x] = temp;
        }
    }

    for (int x = 0; x < 10; ++x){
        b_host = a[x * n];
        for (int y = 1; y < n; ++y){
            b_host = b_host | a[x * n + y];
        }
        if (b_host != b[x]){
            err = 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7
int test2(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));
    unsigned int * b = (unsigned int *)malloc(25 * sizeof(unsigned int));

    unsigned int reduced[5];
    real_t false_margin = pow(exp(1), log(.5)/n);
    
    for (int x = 0; x < 25 * n; ++x) {
        a[x] = 0;
        for (int y = 0; y < 16; ++y) {
            if (rand() / (real_t)RAND_MAX > false_margin) {
                a[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(a[0:25*n]) copy(b[0:25])
    {
        #pragma acc parallel loop private(reduced)
        for (int x = 0; x < 5; ++x) {
            for (int y = 0; y < 5; ++y) {
                reduced[y] = 0;
            }
            #pragma acc loop vector reduction(|:reduced)
            for (int y = 0; y < 5 * n; ++y) {
                reduced[y%5] = reduced[y%5] | a[x * 5 * n + y];
            }
            for (int y = 0; y < 5; ++y) {
                b[x * 5 + y] = reduced[y];
            }
        }
    }

    for (int x = 0; x < 5; ++x) {
        for (int y = 0; y < 5; ++y) {
            reduced[y] = 0;
        }
        for (int y = 0; y < 5 * n; ++y) {
            reduced[y%5] = reduced[y%5] | a[x * 5 * n + y];
        }
        for (int y = 0; y < 5; ++y) {
            if (b[x * 5 + y] != reduced[y]) {
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_reduction_bitor_vector_loop.cpp:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,loop,reduction,combined-constructs,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int* a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int* b = (unsigned int *)malloc(10 * sizeof(unsigned int));

    real_t false_margin = pow(exp(1), log(.5)/n);
    unsigned int temp = 1;
    unsigned int b_host;

    for (int x = 0; x < 10 * n; ++x){
        for (int y = 0; y < 16; ++y){
            if (rand() / (real_t) RAND_MAX > false_margin){
                for (int z = 0; z < y; ++z){
                    temp *= 2;
                }
                a[x] += temp;
                temp = 1;
            }
        }
    }
    temp = 0;
    #pragma acc data copyin(a[0:10*n]) copy(b[0:10])
    {
        #pragma acc parallel loop private(temp)
        for (int x = 0; x < 10; ++x){
            temp = 0;
            #pragma acc loop vector reduction(|:temp)
            for (int y = 0; y < n; ++y){
                temp = temp | a[x * n + y];
            }
            b[x] = temp;
        }
    }

    for (int x = 0; x < 10; ++x){
        b_host = a[x * n];
        for (int y = 1; y < n; ++y){
            b_host = b_host | a[x * n + y];
        }
        if (b_host != b[x]){
            err = 1;
        }
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,private,reduction,combined-constructs,loop,V:2.7-2.7
int test2(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(25 * n * sizeof(unsigned int));
    unsigned int * b = (unsigned int *)malloc(25 * sizeof(unsigned int));

    unsigned int reduced[5];
    real_t false_margin = pow(exp(1), log(.5)/n);
    
    for (int x = 0; x < 25 * n; ++x) {
        a[x] = 0;
        for (int y = 0; y < 16; ++y) {
            if (rand() / (real_t)RAND_MAX > false_margin) {
                a[x] += 1<<y;
            }
        }
    }

    #pragma acc data copyin(a[0:25*n]) copy(b[0:25])
    {
        #pragma acc parallel loop private(reduced)
        for (int x = 0; x < 5; ++x) {
            for (int y = 0; y < 5; ++y) {
                reduced[y] = 0;
            }
            #pragma acc loop vector reduction(|:reduced)
            for (int y = 0; y < 5 * n; ++y) {
                reduced[y%5] = reduced[y%5] | a[x * 5 * n + y];
            }
            for (int y = 0; y < 5; ++y) {
                b[x * 5 + y] = reduced[y];
            }
        }
    }

    for (int x = 0; x < 5; ++x) {
        for (int y = 0; y < 5; ++y) {
            reduced[y] = 0;
        }
        for (int y = 0; y < 5 * n; ++y) {
            reduced[y%5] = reduced[y%5] | a[x * 5 * n + y];
        }
        for (int y = 0; y < 5; ++y) {
            if (b[x * 5 + y] != reduced[y]) {
                err += 1;
            }
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
parallel_loop_reduction_bitxor_general.c:::
#include "acc_testsuite.h"
#ifndef T1
//T1:parallel,reduction,combined-constructs,loop,V:1.0-2.7
int test1(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(n * sizeof(unsigned int));
    unsigned int b = 0;
    unsigned int host_b = 0;

    for (int x = 0; x < n; ++x){
        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);
    }

    #pragma acc data copyin(a[0:n])
    {
        #pragma acc parallel loop reduction(^:b)
        for (int x = 0; x < n; ++x){
            b = b ^ a[x];
        }
    }

    for (int x = 0; x < n; ++x){
        host_b = host_b ^ a[x];
    }
    if (b != host_b){
        err = 1;
    }

    return err;
}
#endif

#ifndef T2
//T2:parallel,reduction,combined-constructs,loop,V:2.7-2.7
int test2(){
    int err = 0;
    srand(SEED);
    unsigned int * a = (unsigned int *)malloc(10 * n * sizeof(unsigned int));
    unsigned int b[10];
    unsigned int host_b[10];

    for (int x = 0; x < 10 * n; ++x){
        a[x] = (unsigned int) rand() / (real_t) (RAND_MAX / 2);
    }

    for (int x = 0; x < 10; ++x) {
        b[x] = 0;
        host_b[x] = 0;
    }

    #pragma acc data copyin(a[0:10*n])
    {
        #pragma acc parallel loop reduction(^:b)
        for (int x = 0; x < 10 * n; ++x) {
            b[x % 10] = b[x % 10] ^ a[x];
        }
    }

    for (int x = 0; x < 10 * n; ++x) {
        host_b[x % 10] = host_b[x % 10] ^ a[x];
    }

    for (int x = 0; x < 10; ++x) {
        if (host_b[x] != b[x]) {
            err += 1;
        }
    }

    return err;
}
#endif

int main(){
    int failcode = 0;
    int failed;
#ifndef T1
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test1();
    }
    if (failed != 0){
        failcode = failcode + (1 << 0);
    }
#endif
#ifndef T2
    failed = 0;
    for (int x = 0; x < NUM_TEST_CALLS; ++x){
        failed = failed + test2();
    }
    if (failed != 0){
        failcode = failcode + (1 << 1);
    }
#endif
    return failcode;
}

########## NEXT FILE ##########
ann.cpp:::
#include <iostream>
#include <cstdlib>
#include <sstream>
#include <fstream>
#include <string>
#include <cstring>
#include <vector>
#include <math.h>
#include <time.h>
#include <sstream>
using namespace std;

#include <config.h>
#include "ann.h"


CAnn::CAnn()
{
	p=NULL;
	srand (time(NULL));
};

CAnn::~CAnn()
{

};


void CAnn::randperm(int n,int *perm)
{
	int i, j, t;

	for(i=0; i<n; i++)
		perm[i] = i;
	for(i=0; i<n; i++) {
		j = rand()%(n-i)+i;
		t = perm[j];
		perm[j] = perm[i];
		perm[i] = t;
	}
}

int CAnn::train(int ntrain, string name1,string name2,int n, double percent)
{
	int i;

	if(loadx(name1)!=0)
	{
		cout<<"Load X fail!"<<endl;
		return 1;
	}
	else if(loady(name2)!=0)
	{
		cout<<"Load Y fail!"<<endl;
		return 2;
	}
	mapminmax();

	
	for(i=0;i<ntrain;i++)
	{
		initp(n);
		train_it(percent);
		push_p();
		if(i==0)  savehead("temp_save.dat",ntrain);
		savep("temp_save.dat",i);
	}
	return 0;
}

int CAnn::train_md(int ntrain, string name1,string name2,int n, double percent)
{
	int i;

	if(loadx_md(name1)!=0)
	{
		cout<<"Load X fail!"<<endl;
		return 1;
	}
	else if(loady(name2)!=0)
	{
		cout<<"Load Y fail!"<<endl;
		return 2;
	}
	mapminmax_md();

	
	for(i=0;i<ntrain;i++)
	{
		initp(n);
		train_it_md(percent);
		push_p();
		if(i==0)  savehead("temp_save.dat",ntrain);
		savep("temp_save.dat",i);
	}
	return 0;
}



void CAnn::close()
{
	n_dim=0;
	n_dat=0;
	n_neuron=0;
	n_par=0;
	n_conf=0;

	delete[] p;
	delete[] x;
	delete[] y;
	delete[] v_min;
	delete[] v_max;

	return;
}


void CAnn::push_p(void)
{
	int i;
	vector<double> t;

	t.clear();
	for(i=0;i<n_par;i++)
	{
		t.push_back(p[i]);
	}

	p_save.push_back(t);
}




void CAnn::initp(int n)
{
	int i;

	n_neuron=n;
	n_par=n_dim*n_neuron+n_neuron+n_neuron+1;

	if(p!=NULL) 
		delete [] p;
	p=new double[n_par];


	for(i=0;i<n_par;i++)
	{
		p[i]=((double)rand())/RAND_MAX*2-1;
	}

	for(i=0;i<n_dim*n_neuron;i++)
		p[i]/=sqrt((double) n_dim);
	for(i=n_dim*n_neuron+n_neuron;i<n_dim*n_neuron+n_neuron*2;i++)
		p[i]/=sqrt((double) n_neuron);

	return;
};

bool CAnn::loadx(vector<vector<double> > xx)
{
	int i,j;
	n_dat=xx.size();
	n_dim=xx.at(0).size();

	x=new double[n_dat*n_dim];
	
	for(i=0;i<n_dat;i++)
	{
		for(j=0;j<n_dim;j++)
		{
			x[i*n_dim+j]=xx.at(i).at(j);
		}
	}
	
	return 1;
}


bool  CAnn::loadx_md(string name)
{
	int i;
	ifstream fin;
	string line,part;
	istringstream iss;	
	vector<double> x_line;
	vector<double> xx;
	bool breturn=0;
	bool bfirst=1;
	
	fin.open(name.c_str());
	n_dat=0;
	while(getline(fin,line))
	{
		iss.clear();
		iss.str(line);
		if(bfirst==1)
		{
			iss>>n_conf;
			bfirst=0;
			continue;
		}
		x_line.clear();
		while(iss>>part)
		{	
			x_line.push_back(atof(part.c_str()));
		}
		if(x_line.size()==0)
			continue;
		if(n_dat==0)
		{
			n_dim=x_line.size();
		}
		if(x_line.size()!=n_dim)
		{
			cerr<<"input data error"<<endl;
			breturn=1;
			break;
		}
		n_dat++;
		xx.insert(xx.end(),x_line.begin(),x_line.end());
	}

	n_dat/=n_conf;

	x=new double[n_dat*n_dim*n_conf];
	

	for(i=0;i<n_dat*n_dim*n_conf;i++)
		x[i]=xx.at(i);
	
	return breturn;
};


bool  CAnn::loadx(string name)
{
	int i;
	ifstream fin;
	string line,part;
	istringstream iss;	
	vector<double> x_line;
	vector<double> xx;
	bool breturn=0;
	
	fin.open(name.c_str());
	n_dat=0;
	while(getline(fin,line))
	{
		iss.clear();
		iss.str(line);
		x_line.clear();
		while(iss>>part)
		{	
			x_line.push_back(atof(part.c_str()));
		}
		if(n_dat==0)
		{
			n_dim=x_line.size();
		}
		if(x_line.size()!=n_dim)
		{
			cerr<<"input data error"<<endl;
			breturn=1;
			break;
		}
		n_dat++;
		xx.insert(xx.end(),x_line.begin(),x_line.end());
	}


	x=new double[n_dat*n_dim];
	

	for(i=0;i<n_dat*n_dim;i++)
		x[i]=xx.at(i);
	

	return breturn;
};


bool CAnn::loady(string name)
{
	int i,n_dat2;
	ifstream fin;
	string line,part;
	istringstream iss;	
	vector<double> x_line;
	vector<double> xx;
	bool breturn=0;
	
	fin.open(name.c_str());
	n_dat2=0;
	while(getline(fin,line))
	{
		iss.clear();
		iss.str(line);
		x_line.clear();
		while(iss>>part)
		{	
			x_line.push_back(atof(part.c_str()));
		}
		if(x_line.size()!=1)
		{
			cerr<<"input data error in Y"<<endl;
			breturn=1;
			break;
		}
		
		n_dat2++;
		xx.insert(xx.end(),x_line.begin(),x_line.end());
	}

	if(n_dat2!=n_dat)
	{
		breturn=1;
	}
	else
	{
		y=new double[n_dat];
		for(i=0;i<n_dat;i++)
			y[i]=xx.at(i);
	}
	

	return breturn;
};


void CAnn::mapminmax()
{
	double tmin,tmax,v;
	int i,j,step;

	
	v_min=new double[n_dim];
	v_max=new double[n_dim];
	
	for(i=0;i<n_dim;i++)
	{	
		tmax=-100000.0;
		tmin=100000.0;
		for(j=0;j<n_dat;j++)
		{
			step=j*n_dim+i;
			v=x[step];
			if(v>tmax)
				tmax=v;
			if(v<tmin)
				tmin=v;
		}

		v_min[i]=tmin;
		v_max[i]=tmax;
	
		for(j=0;j<n_dat;j++)
		{
			step=j*n_dim+i;
			v=x[step];
			x[step]=(v-tmin)/(tmax-tmin)*2-1;
		}

	}

	y_max=-100000.0;
	y_min=100000.0;
	for(j=0;j<n_dat;j++)
	{
		if(y[j]>y_max)
			y_max=y[j];
		if(y[i]<y_min)
			y_min=y[j];
	}
	for(j=0;j<n_dat;j++)
	{
		y[j]=(y[j]-y_min)/(y_max-y_min)*2-1;
	}
	return;
};


void CAnn::mapminmax_md()
{
	double tmin,tmax,v;
	int i,j,step;

	
	v_min=new double[n_dim];
	v_max=new double[n_dim];
	
	for(i=0;i<n_dim;i++)
	{	
		tmax=-100000.0;
		tmin=100000.0;
		for(j=0;j<n_dat*n_conf;j++)
		{
			step=j*n_dim+i;
			v=x[step];
			if(v>tmax)
				tmax=v;
			if(v<tmin)
				tmin=v;
		}

		v_min[i]=tmin;
		v_max[i]=tmax;
	
		for(j=0;j<n_dat*n_conf;j++)
		{
			step=j*n_dim+i;
			v=x[step];
			x[step]=(v-tmin)/(tmax-tmin)*2-1;
		}

	}

	y_max=-100000.0;
	y_min=100000.0;
	for(j=0;j<n_dat;j++)
	{
		if(y[j]>y_max)
			y_max=y[j];
		if(y[i]<y_min)
			y_min=y[j];
	}
	for(j=0;j<n_dat;j++)
	{
		y[j]=(y[j]-y_min)/(y_max-y_min)*2-1;
	}
	return;
};


void CAnn::xapplyminmax_md()
{
	double tmin,tmax;
	int i,j,step;

	
	for(i=0;i<n_dim;i++)
	{	
		tmin=v_min[i];
		tmax=v_max[i];
	
		for(j=0;j<n_dat*n_conf;j++)
		{
			step=j*n_dim+i;
			x[step]=(x[step]-tmin)/(tmax-tmin)*2-1;
		}

	}

	return;
};


void CAnn::xapplyminmax()
{
	double tmin,tmax;
	int i,j,step;

	
	for(i=0;i<n_dim;i++)
	{	
		tmin=v_min[i];
		tmax=v_max[i];
	
		for(j=0;j<n_dat;j++)
		{
			step=j*n_dim+i;
			x[step]=(x[step]-tmin)/(tmax-tmin)*2-1;
		}

	}

	return;
};

void CAnn::train_it_md(double percent)
{
	lm_status_struct status;
	lm_control_struct control;
	int i,j;
	int n_dat_val;
	double *x2,*y2;
	int *n;

	n=new int[n_dat];
	x2=new double[n_dat*n_dim*n_conf];
	y2=new double[n_dat];


	randperm(n_dat,n);
	for(i=0;i<n_dat;i++)
	{
		y2[i]=y[n[i]];
		for(j=0;j<n_dim*n_conf;j++)
		{
			x2[i*n_dim*n_conf+j]=x[n[i]*n_dim*n_conf+j];
		}
	}
	

	n_dat_val=(int)(n_dat*percent);

	control = lm_control_double;
    control.verbosity = 3;

	data_struct_md data;
	data_struct_md data2;

	data.input=x2;
	data.n_dim=n_dim;
	data.n_conf=n_conf;
	data.n_neuron=n_neuron;
	data.y=y2;
	data.f=&(CAnn::myfunc_md);

	data2.input=x2+n_dim*n_conf*(n_dat-n_dat_val);
	data2.n_dim=n_dim;
	data2.n_conf=n_conf;
	data2.n_neuron=n_neuron;
	data2.y=y2+n_dat-n_dat_val;
	data2.f=&(CAnn::myfunc_md);


	lmmin(n_par,p,n_dat-n_dat_val,(const void*) &data,n_dat_val,(const void*) &data2,evaluation_md,&control,&status);

	delete [] x2;
	delete [] y2;

	return;
};


void CAnn::train_it(double percent)
{
	lm_status_struct status;
	lm_control_struct control;
	int i,j;
	int n_dat_val;
	double *x2,*y2;
	int *n;

	n=new int[n_dat];
	x2=new double[n_dat*n_dim];
	y2=new double[n_dat];


	randperm(n_dat,n);
	for(i=0;i<n_dat;i++)
	{
		y2[i]=y[n[i]];
		for(j=0;j<n_dim;j++)
		{
			x2[i*n_dim+j]=x[n[i]*n_dim+j];
		}
	}
	

	n_dat_val=(int)(n_dat*percent);

	control = lm_control_double;
    control.verbosity = 3;

	data_struct_neuron data;
	data_struct_neuron data2;

	data.input=x2;
	data.n_dim=n_dim;
	data.n_neuron=n_neuron;
	data.y=y2;
	data.f=&(CAnn::myfunc_neuron);

	data2.input=x2+n_dim*(n_dat-n_dat_val);
	data2.n_dim=n_dim;
	data2.n_neuron=n_neuron;
	data2.y=y2+n_dat-n_dat_val;
	data2.f=&(CAnn::myfunc_neuron);


	lmmin(n_par,p,n_dat-n_dat_val,(const void*) &data,n_dat_val,(const void*) &data2,evaluation_neuron,&control,&status);

	delete [] x2;
	delete [] y2;

	return;
};


void CAnn::evaluation_neuron(const double *par, int n_dat, const void *pdata, double *fvect, int *user)
{
	data_struct_neuron *d;

	d=(data_struct_neuron *)pdata;

#pragma omp parallel for
	for(int i=0;i<n_dat;i++)
	{
		int begin=i*(d->n_dim);
		fvect[i]=(d->y[i])-(d->f)(d->n_dim,d->n_neuron,&(d->input[begin]),(const double *)par);
	}
	return;
};


double CAnn::myfunc_neuron(int ndim, int nneuron, double *x, const double *p)
{
	int i;
	double r2;
	const double *p2,*p3,*p4;

	p2=p+ndim*nneuron;
	p3=p2+nneuron;
	p4=p3+nneuron;

	r2=0;
	for(int j=0;j<nneuron;j++)
	{
		const double *p1;
		double r;
		p1=p+j*ndim;
		r=0.0;
		for(i=0;i<ndim;i++)
		{
			r+=x[i]*p1[i];
		}
		r+=p2[j];
		if(r<-30 )
			r=0.0;
		else if(r>30)
			r=1.0;
		else
			r=(1-exp(-2*r))/(1+exp(-2*r));
		r=r*p3[j];
		r2+=r;
	}
	r2+=p4[0];

	return r2;
};

void CAnn::evaluation_md(const double *par, int n_dat, const void *pdata, double *fvect, int *user)
{
	data_struct_md *d;

	d=(data_struct_md *)pdata;

#pragma omp parallel for
	for(int i=0;i<n_dat;i++)
	{
		int begin=i*(d->n_dim)*(d->n_conf);
		fvect[i]=(d->y[i])-(d->f)(d->n_dim,d->n_conf,d->n_neuron,&(d->input[begin]),(const double *)par);
	}
	return;
};

double CAnn::myfunc_md(int ndim, int nconf, int nneuron, double *x, const double *p)
{
	int i,j,n;
	double r2,r;
	double sum;
	const double *p2,*p3,*p4;
	const double *p1;

	p2=p+ndim*nneuron;
	p3=p2+nneuron;
	p4=p3+nneuron;

	sum=0.0;
	for(n=0;n<nconf;n++)
	{

		r2=0;
		for(j=0;j<nneuron;j++)
		{
			p1=p+j*ndim;
			r=0.0;
			for(i=0;i<ndim;i++)
			{
				r+=x[i+n*ndim]*p1[i];
			}
			r+=p2[j];
			if(r<-30 )
				r=0.0;
			else if(r>30)
				r=1.0;
			else
				r=(1-exp(-2*r))/(1+exp(-2*r));
			r=r*p3[j];
			r2+=r;
		}
		r2+=p4[0];

		sum+=r2;
	}

	sum/=nconf;
	return sum;
};

void CAnn::savehead(string filename, int n)
{
	int i,j;
	ofstream fout;

	fout.open(filename.c_str());

	fout<<"n_dim "<<n_dim<<endl;
	fout<<"n_neuron "<<n_neuron<<endl;
	fout<<"n_par "<<n_par<<endl;

	for(i=0;i<n_dim;i++)
		fout<<v_min[i]<<" "<<v_max[i]<<endl;

	fout<<y_min<<" "<<y_max<<endl;

	fout<<n<<endl;

	fout.close();
};


void CAnn::savep(string filename,int n)
{
	int i,j;
	ofstream fout;

	fout.open(filename.c_str(),std::ofstream::app);
	for(j=0;j<n_par;j++)
		fout<<p_save.at(n).at(j)<<" ";
	fout<<endl;
	
	fout.close();
}


void CAnn::save(string filename)
{
	int i,j;
	ofstream fout;

	fout.open(filename.c_str());

	fout<<"n_dim "<<n_dim<<endl;
	fout<<"n_neuron "<<n_neuron<<endl;
	fout<<"n_par "<<n_par<<endl;

	for(i=0;i<n_dim;i++)
		fout<<v_min[i]<<" "<<v_max[i]<<endl;

	fout<<y_min<<" "<<y_max<<endl;

	fout<<p_save.size()<<endl;

	for(i=0;i<p_save.size();i++)
	{
		for(j=0;j<n_par;j++)
			fout<<p_save.at(i).at(j)<<" ";
		fout<<endl;
	}

	fout.close();
};


void CAnn::loadp(double *pdata)
{
	int i,j;
	ifstream fin;
	string part;
	int n_set;
	vector<double> t;

	

	n_dim=(int)(*pdata);pdata++;
	n_neuron=(int)(*pdata);pdata++;
	n_par=(int)(*pdata);pdata++;

	n_par=n_dim*n_neuron+n_neuron+n_neuron+1;

	p=new double[n_par];
	v_min=new double[n_dim];
	v_max=new double[n_dim];

	for(i=0;i<n_dim;i++)
	{
		v_min[i]=*pdata;pdata++;
		v_max[i]=*pdata;pdata++;
	}

	y_min=*pdata;pdata++;
	y_max=*pdata;pdata++;
	

	n_set=(int)(*pdata);pdata++;
	
	for(j=0;j<n_set;j++)
	{
		t.clear();
		for(i=0;i<n_par;i++)
		{
			p[i]=*pdata;
			pdata++;
			t.push_back(p[i]);
		}
		p_save.push_back(t);
	}
};



void CAnn::load(string filename)
{
	int i,j;
	ifstream fin;
	string part;
	int n_set;
	vector<double> t;

	fin.open(filename.c_str());

	fin>>part>>n_dim;
	fin>>part>>n_neuron;
	fin>>part>>n_par;

	n_par=n_dim*n_neuron+n_neuron+n_neuron+1;

	p=new double[n_par];
	v_min=new double[n_dim];
	v_max=new double[n_dim];

	for(i=0;i<n_dim;i++)
		fin>>v_min[i]>>v_max[i];

	fin>>y_min>>y_max;

	fin>>n_set;
	
	for(j=0;j<n_set;j++)
	{
		t.clear();
		for(i=0;i<n_par;i++)
		{
			fin>>p[i];
			t.push_back(p[i]);
		}
		p_save.push_back(t);
	}

	fin.close();
};

double CAnn::assess(string ann_name,string x_name,string y_name)
{
	int i;
	vector<double> out;
	double rms,tt;
	vector<vector<double> > xx;


	out=predict(0,ann_name,x_name,xx);

	
	if(loady(y_name)!=0)
	{
		cout<<"Load Y error"<<endl;
		return 1000.0;
	}


	rms=0.0;
	for(i=0;i<n_dat;i++)
	{
		tt=out.at(i)-y[i];
		rms+=tt*tt;
	}
	rms=sqrt(rms/n_dat);

	return rms;
};

double CAnn::assess_md(string ann_name,string x_name,string y_name)
{
	int i;
	vector<double> out;
	double rms,tt;
	vector<vector<double> > xx;


	out=predict_md(0,ann_name,x_name,xx);

	
	if(loady(y_name)!=0)
	{
		cout<<"Load Y error"<<endl;
		return 1000.0;
	}


	rms=0.0;
	for(i=0;i<n_dat;i++)
	{
		tt=out.at(i)-y[i];
		rms+=tt*tt;
	}
	rms=sqrt(rms/n_dat);

	return rms;
};

double CAnn::predict_one( vector<double> xx )
{
	int j;
	double tt,out;

	if(xx.size()!=n_dim)
		return 0;

	n_dat=1;
	x=new double[n_dat*n_dim];
	for(j=0;j<n_dim;j++)
	{
		x[j]=xx.at(j);
	}
	xapplyminmax();

	out=0;
	for(int j=0;j<(int)p_save.size();j++)
	{
		for(int i=0;i<n_par;i++)
			p[i]=p_save.at(j).at(i);
	
		tt=CAnn::myfunc_neuron(n_dim,n_neuron,x,p);
		tt=(tt+1)/2*(y_max-y_min)+y_min;
		out+=tt;
	}
	out/=p_save.size();
	return out;
};
	
double CAnn::predict_one_md(int n, vector<double> xx )
{
	int j;
	double tt,out;

	n_conf=n;

	if(xx.size()!=n_dim*n_conf)
		return 0;

	n_dat=1;
	x=new double[n_conf*n_dim];
	for(j=0;j<n_dim*n_conf;j++)
	{
		x[j]=xx.at(j);
	}
	xapplyminmax_md();

	out=0;
	for(int j=0;j<(int)p_save.size();j++)
	{
		for(int i=0;i<n_par;i++)
			p[i]=p_save.at(j).at(i);
	
		tt=CAnn::myfunc_md(n_dim,n_conf,n_neuron,x,p);
		tt=(tt+1)/2*(y_max-y_min)+y_min;
		out+=tt;
	}
	out/=p_save.size();
	return out;
};	


vector<double> CAnn::predict(int flag, string ann_name,string x_name, vector< vector<double> > xx)
{
	int t;
	vector<double> out;
	double tt;
	double *pre;

	out.clear();


	load(ann_name);
	t=n_dim;

	if(flag==0)
	{
		if(loadx(x_name)!=0)
		{
			cout<<"load X fail"<<endl;
			return out;
		}
	}
	else //flag==1
	{
		loadx(xx);
	}

	if(t!=n_dim)
	{
		cout<<"Inconsistent dimension between trained ANN and input X data"<<endl;
		return out;
	}
	
	xapplyminmax();
	pre=new double[n_dat];
	for(int i=0;i<n_dat;i++)
		pre[i]=0.0;
	for(int j=0;j<(int)p_save.size();j++)
	{
		for(int i=0;i<n_par;i++)
			p[i]=p_save.at(j).at(i);

#pragma omp parallel for
		for(int i=0;i<n_dat;i++)
		{
			int begin=i*n_dim;
			tt=CAnn::myfunc_neuron(n_dim,n_neuron,x+begin,p);
			tt=(tt+1)/2*(y_max-y_min)+y_min;
			pre[i]+=tt;
		}
	}

	for(int i=0;i<n_dat;i++)
	{
		pre[i]/=p_save.size();
		out.push_back(pre[i]);
	}

	return out;
}


vector<double> CAnn::predict_md(int flag, string ann_name,string x_name, vector< vector<double> > xx)
{
	int t;
	vector<double> out;
	double tt;
	double *pre;

	out.clear();


	load(ann_name);
	t=n_dim;

	if(flag==0)
	{
		if(loadx_md(x_name)!=0)
		{
			cout<<"load X fail"<<endl;
			return out;
		}
	}
	else //flag==1
	{
		loadx(xx);
	}

	if(t!=n_dim)
	{
		cout<<"Inconsistent dimension between trained ANN and input X data"<<endl;
		return out;
	}
	
	xapplyminmax_md();
	pre=new double[n_dat];
	for(int i=0;i<n_dat;i++)
		pre[i]=0.0;
	for(int j=0;j<(int)p_save.size();j++)
	{
		for(int i=0;i<n_par;i++)
			p[i]=p_save.at(j).at(i);

#pragma omp parallel for
		for(int i=0;i<n_dat;i++)
		{
			int begin=i*n_dim*n_conf;
			tt=CAnn::myfunc_md(n_dim,n_conf,n_neuron,x+begin,p);
			tt=(tt+1)/2*(y_max-y_min)+y_min;
			pre[i]+=tt;
		}
	}

	for(int i=0;i<n_dat;i++)
	{
		pre[i]/=p_save.size();
		out.push_back(pre[i]);
	}

	return out;
}

				


double CAnn::myfunc_mix(int n_neuron, double *x, const double *p)
{
	int i;
	const double *p1,*p2,*p3,*p4;
	double *x1,*x2,*x3,*x4;
	double r1,r2,r3;

	r1=0;
	p1=p;
	x1=x;
	for(i=0;i<500;i++)
		r1+=x1[i]*p1[i];

	r2=0;
	p2=p1+500;
	x2=x+500;
	for(i=0;i<260;i++)
		r2+=x2[i]*p2[i];

	r3=0;
	p3=p1+500+260;
	x3=x+500+260;
	for(i=0;i<260;i++)
		r3+=x3[i]*p3[i];

	p4=p+500+260+260;
	x4=x+500+260+260;

	x4[0]=r1/11.464-1.7415;     /* rescale and shift r1 to be within [-1,1], as required by next step*/
	x4[1]=r2/1.4956-11.8745;
	x4[2]=r3/1.5156-12.031;

	return myfunc_neuron(10,n_neuron,x4,p4);
};

void CAnn::evaluation_mix(const double *par, int m_dat, const void *pdata, double *fvect, int *user)
{
	data_struct_mix *d;

	d=(data_struct_mix *)pdata;

#pragma omp parallel for
	for(int i=0;i<m_dat;i++)
	{
		int begin=i*(d->n_dim);
		fvect[i]=(d->y[i])-(d->f)(d->n_neuron,&(d->input[begin]),(const double *)par);
	}
	return;
};
########## NEXT FILE ##########
lmcurve.c:::
/*
 * Library:   lmfit (Levenberg-Marquardt least squares fitting)
 *
 * File:      lmcurve.c
 *
 * Contents:  Levenberg-Marquardt curve-fitting
 *
 * Copyright: Joachim Wuttke, Forschungszentrum Juelich GmbH (2004-2013)
 *
 * License:   see ../COPYING (FreeBSD)
 * 
 * Homepage:  apps.jcns.fz-juelich.de/lmfit
 */

#include "lmmin.h"

#ifdef USE_OPENMP
#include "omp.h"
#endif

typedef struct {
    const double *t;
    const double *y;
    double (*f) (double t, const double *par);
} lmcurve_data_struct;


void lmcurve_evaluate( const double *par, int m_dat, const void *data,
                       double *fvec, int *info )
{
    int i;
    for ( i = 0; i < m_dat; i++ )
        fvec[i] =
            ((lmcurve_data_struct*)data)->y[i] -
            ((lmcurve_data_struct*)data)->f(
                ((lmcurve_data_struct*)data)->t[i], par );
}


void lmcurve( int n_par, double *par, int m_dat, 
              const double *t, const double *y,
              double (*f)( double t, const double *par ),
              const lm_control_struct *control,
              lm_status_struct *status )
{
    lmcurve_data_struct data;
    data.t = t;
    data.y = y;
    data.f = f;

    lmmin( n_par, par, m_dat, (const void*) &data,m_dat, (const void*) &data,
           lmcurve_evaluate, control, status );
}

########## NEXT FILE ##########
lmmin.c:::
/*
 * Library:   lmfit (Levenberg-Marquardt least squares fitting)
 *
 * File:      lmmin.c
 *
 * Contents:  Levenberg-Marquardt minimization.
 *
 * Copyright: MINPACK authors, The University of Chikago (1980-1999)
 *            Joachim Wuttke, Forschungszentrum Juelich GmbH (2004-2013)
 *
 * License:   see ../COPYING (FreeBSD)
 * 
 * Homepage:  apps.jcns.fz-juelich.de/lmfit
 */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <float.h>
#include "lmmin.h"

#ifdef USE_OPENMP
#include "omp.h"
#endif


#define MIN(a,b) (((a)<=(b)) ? (a) : (b))
#define MAX(a,b) (((a)>=(b)) ? (a) : (b))
#define SQR(x)   (x)*(x)

/* function declarations (implemented below). */
void lm_lmpar( int n, double *r, int ldr, int *ipvt, double *diag,
               double *qtb, double delta, double *par, double *x,
               double *sdiag, double *aux, double *xdi );
void lm_qrfac( int m, int n, double *a, int *ipvt,
               double *rdiag, double *acnorm, double *wa );
void lm_qrsolv( int n, double *r, int ldr, int *ipvt, double *diag,
                double *qtb, double *x, double *sdiag, double *wa );


/*****************************************************************************/
/*  Numeric constants                                                        */
/*****************************************************************************/

/* machine-dependent constants from float.h */
#define LM_MACHEP     DBL_EPSILON   /* resolution of arithmetic */
#define LM_DWARF      DBL_MIN       /* smallest nonzero number */
#define LM_SQRT_DWARF sqrt(DBL_MIN) /* square should not underflow */
#define LM_SQRT_GIANT sqrt(DBL_MAX) /* square should not overflow */
#define LM_USERTOL    30*LM_MACHEP  /* users are recommended to require this */

/* If the above values do not work, the following seem good for an x86:
 LM_MACHEP     .555e-16
 LM_DWARF      9.9e-324 
 LM_SQRT_DWARF 1.e-160   
 LM_SQRT_GIANT 1.e150 
 LM_USER_TOL   1.e-14
   The following values should work on any machine:
 LM_MACHEP     1.2e-16
 LM_DWARF      1.0e-38
 LM_SQRT_DWARF 3.834e-20
 LM_SQRT_GIANT 1.304e19
 LM_USER_TOL   1.e-14
*/

const lm_control_struct lm_control_double = {
    LM_USERTOL, LM_USERTOL, LM_USERTOL, LM_USERTOL, 1.00 , 100, 1, 
    NULL, 0, -1, -1, 4 };
const lm_control_struct lm_control_float = {
    1.e-7,      1.e-7,      1.e-7,      1.e-7,      1.00 , 100, 1,
    NULL, 0, -1, -1, 4 };


/*****************************************************************************/
/*  Message texts (indexed by status.info)                                   */
/*****************************************************************************/

const char *lm_infmsg[] = {
    "found zero (sum of squares below underflow limit)",
    "converged  (the relative error in the sum of squares is at most tol)",
    "converged  (the relative error of the parameter vector is at most tol)",
    "converged  (both errors are at most tol)",
    "trapped    (by degeneracy; increasing epsilon might help)",
    "exhausted  (number of function calls exceeding preset patience)",
    "failed     (ftol<tol: cannot reduce sum of squares any further)",
    "failed     (xtol<tol: cannot improve approximate solution any further)",
    "failed     (gtol<tol: cannot improve approximate solution any further)",
    "crashed    (not enough memory)",
    "exploded   (fatal coding error: improper input parameters)",
    "stopped    (break requested within function evaluation)",
	"stopped    (break because validation set fail to improve)"
};

const char *lm_shortmsg[] = {
    "found zero",
    "converged (f)",
    "converged (p)",
    "converged (2)",
    "degenerate",
    "call limit",
    "failed (f)",
    "failed (p)",
    "failed (o)",
    "no memory",
    "invalid input",
    "user break"
	"validation check break"
};


/*****************************************************************************/
/*  Monitoring auxiliaries.                                                  */
/*****************************************************************************/

void lm_print_pars( int nout, const double *par, double fval, double fnorm, FILE* fout )
{
    int i;
    for (i = 0; i < nout; ++i)
        fprintf( fout, " %16.9g", par[i] );
    fprintf( fout, " => %18.11g ", fval );
    fprintf( fout, " => %18.11g\n", fnorm );
}


/*****************************************************************************/
/*  lmmin (main minimization routine)                                        */
/*****************************************************************************/

void lmmin( int n, double *x, int m, const void *data, int m2, const void * data2,
            void (*evaluate) (const double *par, int m_dat, const void *data,
                              double *fvec, int *userbreak),
            const lm_control_struct *C, lm_status_struct *S )
{
	int nalert;    /* added by dawei li */
	double *fvec2, validation_sum, temp_validation, *xback; /* added by dawei li */
    double *fvec, *diag, *fjac, *qtf, *wa1, *wa2, *wa3, *wf;
    int *ipvt;
    int j, i;
    double actred, dirder, fnorm, fnorm1, gnorm, pnorm,
        prered, ratio, step, sum, temp, temp1, temp2, temp3;
    static double p0001 = 1.0e-4;

    int maxfev = C->patience * (n+1);

    int    outer, inner;  /* loop counters, for monitoring */
    int    inner_success; /* flag for loop control */
    double lmpar = 0;     /* Levenberg-Marquardt parameter */
    double delta = 0;
    double xnorm = 0;
    double eps = sqrt(MAX(C->epsilon, LM_MACHEP)); /* for forward differences */

    int nout = C->n_maxpri==-1 ? n : MIN( C->n_maxpri, n );

    /* The workaround msgfile=NULL is needed for default initialization */
    FILE* msgfile = C->msgfile ? C->msgfile : stdout;

    /* Default status info; must be set ahead of first return statements */    
    S->outcome = 0;      /* status code */
    S->userbreak = 0;
    S->nfev = 0;      /* function evaluation counter */

/***  Check input parameters for errors.  ***/

    if ( n <= 0 ) {
        fprintf( stderr, "lmmin: invalid number of parameters %i\n", n );
        S->outcome = 10; /* invalid parameter */
        return;
    }
    if (m < n) {
        fprintf( stderr, "lmmin: number of data points (%i) "
                 "smaller than number of parameters (%i)\n", m, n );
        S->outcome = 10;
        return;
    }
    if (C->ftol < 0. || C->xtol < 0. || C->gtol < 0.) {
        fprintf( stderr,
                 "lmmin: negative tolerance (at least one of %g %g %g)\n",
                 C->ftol, C->xtol, C->gtol );
        S->outcome = 10;
        return;
    }
    if (maxfev <= 0) {
        fprintf( stderr, "lmmin: nonpositive function evaluations limit %i\n",
                 maxfev );
        S->outcome = 10;
        return;
    }
    if (C->stepbound <= 0.) {
        fprintf( stderr, "lmmin: nonpositive stepbound %g\n", C->stepbound );
        S->outcome = 10;
        return;
    }
    if (C->scale_diag != 0 && C->scale_diag != 1) {
        fprintf( stderr, "lmmin: logical variable scale_diag=%i, "
                 "should be 0 or 1\n", C->scale_diag );
        S->outcome = 10;
        return;
    }

/***  Allocate work space.  ***/

    if ( (fvec = (double *) malloc(m * sizeof(double))) == NULL ||
		 (fvec2= (double *) malloc(m2* sizeof(double))) == NULL ||  /*added by dawei*/
		 (xback= (double *) malloc(n * sizeof(double))) == NULL ||  /*added by dawei*/
         (diag = (double *) malloc(n * sizeof(double))) == NULL ||
         (qtf  = (double *) malloc(n * sizeof(double))) == NULL ||
         (fjac = (double *) malloc(n*m*sizeof(double))) == NULL ||
         (wa1  = (double *) malloc(n * sizeof(double))) == NULL ||
         (wa2  = (double *) malloc(n * sizeof(double))) == NULL ||
         (wa3  = (double *) malloc(n * sizeof(double))) == NULL ||
         (wf  = (double *)  malloc(m * sizeof(double))) == NULL ||
         (ipvt = (int *)    malloc(n * sizeof(int)   )) == NULL    ) {
        S->outcome = 9;
        return;
    }

    if (!C->scale_diag) {
        for (j = 0; j < n; j++)
            diag[j] = 1.;
    }

	/* get the sum of validation */
	
	(*evaluate)(x,m2,data2,fvec2, &(S->userbreak) );
	temp_validation=0.0;
	for(j=0;j<m2;j++)
		temp_validation+=fvec2[j]*fvec2[j];
	validation_sum=temp_validation;
	nalert=0;

/* above code block is added by dawei li*/

/***  Evaluate function at starting point and calculate norm.  ***/

    (*evaluate)( x, m, data, fvec, &(S->userbreak) );
    S->nfev = 1;
    if ( S->userbreak )
        goto terminate;
    fnorm = lm_enorm(m, fvec);
    if( C->verbosity ) {
        fprintf( msgfile, "lmmin start " );
        lm_print_pars( nout, x, validation_sum, fnorm, msgfile );
    }
    if( fnorm <= LM_DWARF ){
        S->outcome = 0; /* sum of squares almost zero, nothing to do */
        goto terminate;
    }



/***  The outer loop: compute gradient, then descend.  ***/

    for( outer=0; ; ++outer ) {

/* validation check added by dawei li */
		
		(*evaluate)(x,m2,data2,fvec2, &(S->userbreak) );
		temp_validation=0.0;
		for(j=0;j<m2;j++)
			temp_validation+=fvec2[j]*fvec2[j];

		if(temp_validation>validation_sum)  
		{
			nalert++;
			if(nalert>4) 
			{
				S->outcome = 12;
				/*restor x from x_back because x is not good but xback is the best set*/
				for(j=0;j<n;j++)
					x[j]=xback[j];
                goto terminate;
			}
		}
		else
		{
			nalert=0;
			validation_sum=temp_validation;
			
			/*backup x to xback*/
			for(j=0;j<n;j++)
				xback[j]=x[j];
		}


/***  [outer]  Calculate the Jacobian.  ***/

        for (j = 0; j < n; j++) {
            temp = x[j];
            step = MAX(eps*eps, eps * fabs(temp));
            x[j] += step; /* replace temporarily */
            (*evaluate)( x, m, data, wf, &(S->userbreak) );
            ++(S->nfev);
            if ( S->userbreak )
                goto terminate;
            for (i = 0; i < m; i++)
                fjac[j*m+i] = (wf[i] - fvec[i]) / step;
            x[j] = temp; /* restore */
        }
        if ( C->verbosity >=10 ) {
            /* print the entire matrix */
            printf("\nlmmin Jacobian\n");
            for (i = 0; i < m; i++) {
                printf("  ");
                for (j = 0; j < n; j++)
                    printf("%.5e ", fjac[j*m+i]);
                printf("\n");
            }
        }

/***  [outer]  Compute the QR factorization of the Jacobian.  ***/

/*      fjac is an m by n array. The upper n by n submatrix of fjac 
 *        is made to contain an upper triangular matrix r with diagonal
 *        elements of nonincreasing magnitude such that
 *
 *              p^T*(jac^T*jac)*p = r^T*r
 *
 *              (NOTE: ^T stands for matrix transposition),
 *
 *        where p is a permutation matrix and jac is the final calculated
 *        Jacobian. Column j of p is column ipvt(j) of the identity matrix.
 *        The lower trapezoidal part of fjac contains information generated
 *        during the computation of r.
 *
 *      ipvt is an integer array of length n. It defines a permutation
 *        matrix p such that jac*p = q*r, where jac is the final calculated
 *        Jacobian, q is orthogonal (not stored), and r is upper triangular
 *        with diagonal elements of nonincreasing magnitude. Column j of p
 *        is column ipvt(j) of the identity matrix.
 */

        lm_qrfac(m, n, fjac, ipvt, wa1, wa2, wa3);
        /* return values are ipvt, wa1=rdiag, wa2=acnorm */

/***  [outer]  Form q^T * fvec and store first n components in qtf.  ***/

        for (i = 0; i < m; i++)
            wf[i] = fvec[i];

        for (j = 0; j < n; j++) {
            temp3 = fjac[j*m+j];
            if (temp3 != 0.) {
                sum = 0;
                for (i = j; i < m; i++)
                    sum += fjac[j*m+i] * wf[i];
                temp = -sum / temp3;
                for (i = j; i < m; i++)
                    wf[i] += fjac[j*m+i] * temp;
            }
            fjac[j*m+j] = wa1[j];
            qtf[j] = wf[j];
        }

/***  [outer]  Compute norm of scaled gradient and detect degeneracy.  ***/

        gnorm = 0;
        for (j = 0; j < n; j++) {
            if (wa2[ipvt[j]] == 0)
                continue;
            sum = 0.;
            for (i = 0; i <= j; i++)
                sum += fjac[j*m+i] * qtf[i];
            gnorm = MAX( gnorm, fabs( sum / wa2[ipvt[j]] / fnorm ) );
        }

        if (gnorm <= C->gtol) {
            S->outcome = 4;
            goto terminate;
        }

/***  [outer]  Initialize / update diag and delta. ***/

        if ( !outer ) { 
            /* first iteration only */
            if (C->scale_diag) {
                /* diag := norms of the columns of the initial Jacobian */
                for (j = 0; j < n; j++)
                    diag[j] = wa2[j] ? wa2[j] : 1;
                /* xnorm := || D x || */
                for (j = 0; j < n; j++)
                    wa3[j] = diag[j] * x[j];
                xnorm = lm_enorm(n, wa3);
                if( C->verbosity >= 2 ) {
                    fprintf( msgfile, "lmmin diag  " );
                    lm_print_pars( nout, x, validation_sum, xnorm, msgfile );
                }
                /* only now print the header for the loop table */
                if( C->verbosity >=3 ) {
                    fprintf( msgfile, "  o  i     lmpar    prered"
                             "          ratio    dirder      delta"
                             "      pnorm                 fnorm" );
                    for (i = 0; i < nout; ++i)
                        fprintf( msgfile, "               p%i", i );
                    fprintf( msgfile, "\n" );
                }
            } else {
                xnorm = lm_enorm(n, x);
            }
            /* initialize the step bound delta. */
            if ( xnorm )
                delta = C->stepbound * xnorm;
            else
                delta = C->stepbound;
        } else {
            if (C->scale_diag) {
                for (j = 0; j < n; j++)
                    diag[j] = MAX( diag[j], wa2[j] );
            }
        }

/***  The inner loop. ***/
        inner = 0;
        do {

/***  [inner]  Determine the Levenberg-Marquardt parameter.  ***/

            lm_lmpar( n, fjac, m, ipvt, diag, qtf, delta, &lmpar,
                      wa1, wa2, wf, wa3 );
            /* used return values are fjac (partly), lmpar, wa1=x, wa3=diag*x */

            /* predict scaled reduction */
            pnorm = lm_enorm(n, wa3);
            temp2 = lmpar * SQR( pnorm / fnorm );
            for (j = 0; j < n; j++) {
                wa3[j] = 0;
                for (i = 0; i <= j; i++)
                    wa3[i] -= fjac[j*m+i] * wa1[ipvt[j]];
            }
            temp1 = SQR( lm_enorm(n, wa3) / fnorm );
            prered = temp1 + 2 * temp2;
            dirder = -temp1 + temp2; /* scaled directional derivative */

            /* at first call, adjust the initial step bound. */
            if ( !outer && pnorm < delta )
                delta = pnorm;

/***  [inner]  Evaluate the function at x + p.  ***/

            for (j = 0; j < n; j++)
                wa2[j] = x[j] - wa1[j];

            (*evaluate)( wa2, m, data, wf, &(S->userbreak) );
            ++(S->nfev);
            if ( S->userbreak )
                goto terminate;
            fnorm1 = lm_enorm(m, wf);

/***  [inner]  Evaluate the scaled reduction.  ***/

            /* actual scaled reduction */
            actred = 1 - SQR(fnorm1/fnorm);

            /* ratio of actual to predicted reduction */
            ratio = prered ? actred/prered : 0;

            if( C->verbosity == 2 ) {
                fprintf( msgfile, "lmmin (%i:%i) ", outer, inner );
                lm_print_pars( nout, wa2, validation_sum, fnorm1, msgfile );
            } else if( C->verbosity >= 3 ) {
                printf( "%3i %2i %9.2g %9.2g %14.6g"
                        " %9.2g %10.3e %10.3e %21.15e",
                        outer, inner, lmpar, prered, ratio,
                        dirder, delta, pnorm, fnorm1 );
                for (i = 0; i < nout; ++i)
                    fprintf( msgfile, " %16.9g", wa2[i] );
                fprintf( msgfile, "\n" );
            }

            /* update the step bound */
            if        ( ratio <= 0.25 ) {
                if      ( actred >= 0 )
                    temp = 0.5;
                else if ( actred > -99 ) /* -99 = 1-1/0.1^2 */
                    temp = MAX( dirder / (2*dirder + actred), 0.1 );
                else
                    temp = 0.1;
                delta = temp * MIN(delta, pnorm / 0.1);
                lmpar /= temp;
            } else if ( ratio >= 0.75 ) {
                delta = 2*pnorm;
                lmpar *= 0.5;
            } else if ( !lmpar ) {
                delta = 2*pnorm;
            }

/***  [inner]  On success, update solution, and test for convergence.  ***/

            inner_success = ratio >= p0001;
            if ( inner_success ) {

                /* update x, fvec, and their norms */
                if (C->scale_diag) {
                    for (j = 0; j < n; j++) {
                        x[j] = wa2[j];
                        wa2[j] = diag[j] * x[j];
                    }
                } else {
                    for (j = 0; j < n; j++)
                        x[j] = wa2[j];
                }
                for (i = 0; i < m; i++)
                    fvec[i] = wf[i];
                xnorm = lm_enorm(n, wa2);
                fnorm = fnorm1;
            }

            /* convergence tests */ 
            S->outcome = 0;
            if( fnorm<=LM_DWARF )
                goto terminate;  /* success: sum of squares almost zero */
            /* test two criteria (both may be fulfilled) */
            if (fabs(actred) <= C->ftol && prered <= C->ftol && ratio <= 2)
                S->outcome = 1;  /* success: x almost stable */
            if (delta <= C->xtol * xnorm)
                S->outcome += 2; /* success: sum of squares almost stable */
            if (S->outcome != 0) {
                goto terminate;
            }

/***  [inner]  Tests for termination and stringent tolerances.  ***/

            if ( S->nfev >= maxfev ){
                S->outcome = 5;
                goto terminate;
            }
            if ( fabs(actred) <= LM_MACHEP &&
                 prered <= LM_MACHEP && ratio <= 2 ){
                S->outcome = 6;
                goto terminate;
            }
            if ( delta <= LM_MACHEP*xnorm ){
                S->outcome = 7;
                goto terminate;
            }
            if ( gnorm <= LM_MACHEP ){
                S->outcome = 8;
                goto terminate;
            }

/***  [inner]  End of the loop. Repeat if iteration unsuccessful.  ***/

            ++inner;
        } while ( !inner_success );

/***  [outer]  End of the loop. ***/

    };

terminate:
    S->fnorm = lm_enorm(m, fvec);
    if ( C->verbosity >= 2 )
        printf("lmmin outcome (%i) xnorm %g ftol %g xtol %g\n",
               S->outcome, xnorm, C->ftol, C->xtol );
    if( C->verbosity & 1 ) {
        fprintf( msgfile, "lmmin final " );
        lm_print_pars( nout, x, validation_sum, S->fnorm, msgfile );
    }
    if ( S->userbreak ) /* user-requested break */
        S->outcome = 11;

/***  Deallocate the workspace.  ***/
    free(fvec);
    free(diag);
    free(qtf);
    free(fjac);
    free(wa1);
    free(wa2);
    free(wa3);
    free(wf);
    free(ipvt);

} /*** lmmin. ***/


/*****************************************************************************/
/*  lm_lmpar (determine Levenberg-Marquardt parameter)                       */
/*****************************************************************************/

void lm_lmpar(int n, double *r, int ldr, int *ipvt, double *diag,
              double *qtb, double delta, double *par, double *x,
              double *sdiag, double *aux, double *xdi)
{
/*     Given an m by n matrix a, an n by n nonsingular diagonal
 *     matrix d, an m-vector b, and a positive number delta,
 *     the problem is to determine a value for the parameter
 *     par such that if x solves the system
 *
 *          a*x = b  and  sqrt(par)*d*x = 0
 *
 *     in the least squares sense, and dxnorm is the euclidean
 *     norm of d*x, then either par=0 and (dxnorm-delta) < 0.1*delta,
 *     or par>0 and abs(dxnorm-delta) < 0.1*delta.
 *
 *     Using lm_qrsolv, this subroutine completes the solution of the problem
 *     if it is provided with the necessary information from the
 *     qr factorization, with column pivoting, of a. That is, if
 *     a*p = q*r, where p is a permutation matrix, q has orthogonal
 *     columns, and r is an upper triangular matrix with diagonal
 *     elements of nonincreasing magnitude, then lmpar expects
 *     the full upper triangle of r, the permutation matrix p,
 *     and the first n components of qT*b. On output
 *     lmpar also provides an upper triangular matrix s such that
 *
 *          p^T*(a^T*a + par*d*d)*p = s^T*s.
 *
 *     s is employed within lmpar and may be of separate interest.
 *
 *     Only a few iterations are generally needed for convergence
 *     of the algorithm. If, however, the limit of 10 iterations
 *     is reached, then the output par will contain the best
 *     value obtained so far.
 *
 *     parameters:
 *
 *      n is a positive integer input variable set to the order of r.
 *
 *      r is an n by n array. on input the full upper triangle
 *        must contain the full upper triangle of the matrix r.
 *        on OUTPUT the full upper triangle is unaltered, and the
 *        strict lower triangle contains the strict upper triangle
 *        (transposed) of the upper triangular matrix s.
 *
 *      ldr is a positive integer input variable not less than n
 *        which specifies the leading dimension of the array r.
 *
 *      ipvt is an integer input array of length n which defines the
 *        permutation matrix p such that a*p = q*r. column j of p
 *        is column ipvt(j) of the identity matrix.
 *
 *      diag is an input array of length n which must contain the
 *        diagonal elements of the matrix d.
 *
 *      qtb is an input array of length n which must contain the first
 *        n elements of the vector (q transpose)*b.
 *
 *      delta is a positive input variable which specifies an upper
 *        bound on the euclidean norm of d*x.
 *
 *      par is a nonnegative variable. on input par contains an
 *        initial estimate of the levenberg-marquardt parameter.
 *        on OUTPUT par contains the final estimate.
 *
 *      x is an OUTPUT array of length n which contains the least
 *        squares solution of the system a*x = b, sqrt(par)*d*x = 0,
 *        for the output par.
 *
 *      sdiag is an array of length n needed as workspace; on OUTPUT
 *        it contains the diagonal elements of the upper triangular matrix s.
 *
 *      aux is a multi-purpose work array of length n.
 *
 *      xdi is a work array of length n. On OUTPUT: diag[j] * x[j].
 *
 */
    int i, iter, j, nsing;
    double dxnorm, fp, fp_old, gnorm, parc, parl, paru;
    double sum, temp;
    static double p1 = 0.1;

/*** lmpar: compute and store in x the gauss-newton direction. if the
     jacobian is rank-deficient, obtain a least squares solution. ***/

    nsing = n;
    for (j = 0; j < n; j++) {
        aux[j] = qtb[j];        
        if (r[j * ldr + j] == 0 && nsing == n)
            nsing = j;
        if (nsing < n)
            aux[j] = 0;
    }
    for (j = nsing - 1; j >= 0; j--) {
        aux[j] = aux[j] / r[j + ldr * j];
        temp = aux[j];
        for (i = 0; i < j; i++)
            aux[i] -= r[j * ldr + i] * temp;
    }

    for (j = 0; j < n; j++)
        x[ipvt[j]] = aux[j];

/*** lmpar: initialize the iteration counter, evaluate the function at the
     origin, and test for acceptance of the gauss-newton direction. ***/

    for (j = 0; j < n; j++)
        xdi[j] = diag[j] * x[j];
    dxnorm = lm_enorm(n, xdi);
    fp = dxnorm - delta;
    if (fp <= p1 * delta) {
#ifdef LMFIT_DEBUG_MESSAGES
        printf("debug lmpar nsing %d n %d, terminate (fp<p1*delta)\n",
               nsing, n);
#endif
        *par = 0;
        return;
    }

/*** lmpar: if the jacobian is not rank deficient, the newton
     step provides a lower bound, parl, for the 0. of
     the function. otherwise set this bound to 0.. ***/

    parl = 0;
    if (nsing >= n) {
        for (j = 0; j < n; j++)
            aux[j] = diag[ipvt[j]] * xdi[ipvt[j]] / dxnorm;

        for (j = 0; j < n; j++) {
            sum = 0.;
            for (i = 0; i < j; i++)
                sum += r[j * ldr + i] * aux[i];
            aux[j] = (aux[j] - sum) / r[j + ldr * j];
        }
        temp = lm_enorm(n, aux);
        parl = fp / delta / temp / temp;
    }

/*** lmpar: calculate an upper bound, paru, for the 0. of the function. ***/

    for (j = 0; j < n; j++) {
        sum = 0;
        for (i = 0; i <= j; i++)
            sum += r[j * ldr + i] * qtb[i];
        aux[j] = sum / diag[ipvt[j]];
    }
    gnorm = lm_enorm(n, aux);
    paru = gnorm / delta;
    if (paru == 0.)
        paru = LM_DWARF / MIN(delta, p1);

/*** lmpar: if the input par lies outside of the interval (parl,paru),
     set par to the closer endpoint. ***/

    *par = MAX(*par, parl);
    *par = MIN(*par, paru);
    if (*par == 0.)
        *par = gnorm / dxnorm;

/*** lmpar: iterate. ***/

    for (iter=0; ; iter++) {

        /** evaluate the function at the current value of par. **/

        if (*par == 0.)
            *par = MAX(LM_DWARF, 0.001 * paru);
        temp = sqrt(*par);
        for (j = 0; j < n; j++)
            aux[j] = temp * diag[j];

        lm_qrsolv( n, r, ldr, ipvt, aux, qtb, x, sdiag, xdi );
        /* return values are r, x, sdiag */

        for (j = 0; j < n; j++)
            xdi[j] = diag[j] * x[j]; /* used as output */
        dxnorm = lm_enorm(n, xdi);
        fp_old = fp;
        fp = dxnorm - delta;
        
        /** if the function is small enough, accept the current value
            of par. Also test for the exceptional cases where parl
            is zero or the number of iterations has reached 10. **/

        if (fabs(fp) <= p1 * delta
            || (parl == 0. && fp <= fp_old && fp_old < 0.)
            || iter == 10) {
#ifdef LMFIT_DEBUG_MESSAGES
            printf("debug lmpar nsing %d iter %d "
                   "par %.4e [%.4e %.4e] delta %.4e fp %.4e\n",
                   nsing, iter, *par, parl, paru, delta, fp);
#endif
            break; /* the only exit from the iteration. */
        }
        
        /** compute the Newton correction. **/

        for (j = 0; j < n; j++)
            aux[j] = diag[ipvt[j]] * xdi[ipvt[j]] / dxnorm;

        for (j = 0; j < n; j++) {
            aux[j] = aux[j] / sdiag[j];
            for (i = j + 1; i < n; i++)
                aux[i] -= r[j * ldr + i] * aux[j];
        }
        temp = lm_enorm(n, aux);
        parc = fp / delta / temp / temp;

        /** depending on the sign of the function, update parl or paru. **/

        if (fp > 0)
            parl = MAX(parl, *par);
        else if (fp < 0)
            paru = MIN(paru, *par);
        /* the case fp==0 is precluded by the break condition  */
        
        /** compute an improved estimate for par. **/
        
        *par = MAX(parl, *par + parc);
        
    }

} /*** lm_lmpar. ***/

/*****************************************************************************/
/*  lm_qrfac (QR factorization, from lapack)                                 */
/*****************************************************************************/

void lm_qrfac(int m, int n, double *a, int *ipvt,
              double *rdiag, double *acnorm, double *wa)
{
/*
 *     This subroutine uses Householder transformations with column
 *     pivoting (optional) to compute a qr factorization of the
 *     m by n matrix a. That is, qrfac determines an orthogonal
 *     matrix q, a permutation matrix p, and an upper trapezoidal
 *     matrix r with diagonal elements of nonincreasing magnitude,
 *     such that a*p = q*r. The Householder transformation for
 *     column k, k = 1,2,...,min(m,n), is of the form
 *
 *          i - (1/u(k))*u*uT
 *
 *     where u has zeroes in the first k-1 positions. The form of
 *     this transformation and the method of pivoting first
 *     appeared in the corresponding linpack subroutine.
 *
 *     Parameters:
 *
 *      m is a positive integer input variable set to the number
 *        of rows of a.
 *
 *      n is a positive integer input variable set to the number
 *        of columns of a.
 *
 *      a is an m by n array. On input a contains the matrix for
 *        which the qr factorization is to be computed. On OUTPUT
 *        the strict upper trapezoidal part of a contains the strict
 *        upper trapezoidal part of r, and the lower trapezoidal
 *        part of a contains a factored form of q (the non-trivial
 *        elements of the u vectors described above).
 *
 *      ipvt is an integer OUTPUT array of length lipvt. This array
 *        defines the permutation matrix p such that a*p = q*r.
 *        Column j of p is column ipvt(j) of the identity matrix.
 *
 *      rdiag is an OUTPUT array of length n which contains the
 *        diagonal elements of r.
 *
 *      acnorm is an OUTPUT array of length n which contains the
 *        norms of the corresponding columns of the input matrix a.
 *        If this information is not needed, then acnorm can coincide
 *        with rdiag.
 *
 *      wa is a work array of length n.
 *
 */
    int i, j, k, kmax, minmn;
    double ajnorm, sum, temp;

/*** qrfac: compute initial column norms and initialize several arrays. ***/

    for (j = 0; j < n; j++) {
        acnorm[j] = lm_enorm(m, &a[j*m]);
        rdiag[j] = acnorm[j];
        wa[j] = rdiag[j];
        ipvt[j] = j;
    }
#ifdef LMFIT_DEBUG_MESSAGES
    printf("debug qrfac\n");
#endif

/*** qrfac: reduce a to r with Householder transformations. ***/

    minmn = MIN(m, n);
    for (j = 0; j < minmn; j++) {

        /** bring the column of largest norm into the pivot position. **/

        kmax = j;
        for (k = j + 1; k < n; k++)
            if (rdiag[k] > rdiag[kmax])
                kmax = k;
        if (kmax == j)
            goto pivot_ok;

        for (i = 0; i < m; i++) {
            temp = a[j*m+i];
            a[j*m+i] = a[kmax*m+i];
            a[kmax*m+i] = temp;
        }
        rdiag[kmax] = rdiag[j];
        wa[kmax] = wa[j];
        k = ipvt[j];
        ipvt[j] = ipvt[kmax];
        ipvt[kmax] = k;

      pivot_ok:
        /** compute the Householder transformation to reduce the
            j-th column of a to a multiple of the j-th unit vector. **/

        ajnorm = lm_enorm(m-j, &a[j*m+j]);
        if (ajnorm == 0.) {
            rdiag[j] = 0;
            continue;
        }

        if (a[j*m+j] < 0.)
            ajnorm = -ajnorm;
        for (i = j; i < m; i++)
            a[j*m+i] /= ajnorm;
        a[j*m+j] += 1;

        /** apply the transformation to the remaining columns
            and update the norms. **/
#pragma omp parallel for private(k,sum,temp,i)
        for (k = j + 1; k < n; k++) {
            sum = 0;

            for (i = j; i < m; i++)
                sum += a[j*m+i] * a[k*m+i];

            temp = sum / a[j + m * j];

#pragma ivdep
            for (i = j; i < m; i++)
                a[k*m+i] -= temp * a[j*m+i];

            if (rdiag[k] != 0.) {
                temp = a[m * k + j] / rdiag[k];
                temp = MAX(0., 1 - temp * temp);
                rdiag[k] *= sqrt(temp);
                temp = rdiag[k] / wa[k];
                if ( 0.05 * SQR(temp) <= LM_MACHEP ) {
                    rdiag[k] = lm_enorm(m-j-1, &a[m*k+j+1]);
                    wa[k] = rdiag[k];
                }
            }
        }

        rdiag[j] = -ajnorm;
    }
} /*** lm_qrfac. ***/


/*****************************************************************************/
/*  lm_qrsolv (linear least-squares)                                         */
/*****************************************************************************/

void lm_qrsolv(int n, double *r, int ldr, int *ipvt, double *diag,
               double *qtb, double *x, double *sdiag, double *wa)
{
/*
 *     Given an m by n matrix a, an n by n diagonal matrix d,
 *     and an m-vector b, the problem is to determine an x which
 *     solves the system
 *
 *          a*x = b  and  d*x = 0
 *
 *     in the least squares sense.
 *
 *     This subroutine completes the solution of the problem
 *     if it is provided with the necessary information from the
 *     qr factorization, with column pivoting, of a. That is, if
 *     a*p = q*r, where p is a permutation matrix, q has orthogonal
 *     columns, and r is an upper triangular matrix with diagonal
 *     elements of nonincreasing magnitude, then qrsolv expects
 *     the full upper triangle of r, the permutation matrix p,
 *     and the first n components of (q transpose)*b. The system
 *     a*x = b, d*x = 0, is then equivalent to
 *
 *          r*z = q^T*b,  p^T*d*p*z = 0,
 *
 *     where x = p*z. If this system does not have full rank,
 *     then a least squares solution is obtained. On output qrsolv
 *     also provides an upper triangular matrix s such that
 *
 *          p^T *(a^T *a + d*d)*p = s^T *s.
 *
 *     s is computed within qrsolv and may be of separate interest.
 *
 *     Parameters
 *
 *      n is a positive integer input variable set to the order of r.
 *
 *      r is an n by n array. On input the full upper triangle
 *        must contain the full upper triangle of the matrix r.
 *        On OUTPUT the full upper triangle is unaltered, and the
 *        strict lower triangle contains the strict upper triangle
 *        (transposed) of the upper triangular matrix s.
 *
 *      ldr is a positive integer input variable not less than n
 *        which specifies the leading dimension of the array r.
 *
 *      ipvt is an integer input array of length n which defines the
 *        permutation matrix p such that a*p = q*r. Column j of p
 *        is column ipvt(j) of the identity matrix.
 *
 *      diag is an input array of length n which must contain the
 *        diagonal elements of the matrix d.
 *
 *      qtb is an input array of length n which must contain the first
 *        n elements of the vector (q transpose)*b.
 *
 *      x is an OUTPUT array of length n which contains the least
 *        squares solution of the system a*x = b, d*x = 0.
 *
 *      sdiag is an OUTPUT array of length n which contains the
 *        diagonal elements of the upper triangular matrix s.
 *
 *      wa is a work array of length n.
 *
 */
    int i, kk, j, k, nsing;
    double qtbpj, sum, temp;
    double _sin, _cos, _tan, _cot; /* local variables, not functions */

/*** qrsolv: copy r and q^T*b to preserve input and initialize s.
     in particular, save the diagonal elements of r in x. ***/

    for (j = 0; j < n; j++) {
        for (i = j; i < n; i++)
            r[j * ldr + i] = r[i * ldr + j];
        x[j] = r[j * ldr + j];
        wa[j] = qtb[j];
    }
/*** qrsolv: eliminate the diagonal matrix d using a Givens rotation. ***/

    for (j = 0; j < n; j++) {

/*** qrsolv: prepare the row of d to be eliminated, locating the
     diagonal element using p from the qr factorization. ***/

        if (diag[ipvt[j]] == 0.)
            goto L90;
        for (k = j; k < n; k++)
            sdiag[k] = 0.;
        sdiag[j] = diag[ipvt[j]];

/*** qrsolv: the transformations to eliminate the row of d modify only 
     a single element of qT*b beyond the first n, which is initially 0. ***/

        qtbpj = 0.;
        for (k = j; k < n; k++) {

            /** determine a Givens rotation which eliminates the
                appropriate element in the current row of d. **/

            if (sdiag[k] == 0.)
                continue;
            kk = k + ldr * k;
            if (fabs(r[kk]) < fabs(sdiag[k])) {
                _cot = r[kk] / sdiag[k];
                _sin = 1 / sqrt(1 + SQR(_cot));
                _cos = _sin * _cot;
            } else {
                _tan = sdiag[k] / r[kk];
                _cos = 1 / sqrt(1 + SQR(_tan));
                _sin = _cos * _tan;
            }

            /** compute the modified diagonal element of r and
                the modified element of ((q^T)*b,0). **/

            r[kk] = _cos * r[kk] + _sin * sdiag[k];
            temp = _cos * wa[k] + _sin * qtbpj;
            qtbpj = -_sin * wa[k] + _cos * qtbpj;
            wa[k] = temp;

            /** accumulate the tranformation in the row of s. **/

            for (i = k + 1; i < n; i++) {
                temp = _cos * r[k * ldr + i] + _sin * sdiag[i];
                sdiag[i] = -_sin * r[k * ldr + i] + _cos * sdiag[i];
                r[k * ldr + i] = temp;
            }
        }

      L90:
        /** store the diagonal element of s and restore
            the corresponding diagonal element of r. **/

        sdiag[j] = r[j * ldr + j];
        r[j * ldr + j] = x[j];
    }

/*** qrsolv: solve the triangular system for z. if the system is
     singular, then obtain a least squares solution. ***/

    nsing = n;
    for (j = 0; j < n; j++) {
        if (sdiag[j] == 0. && nsing == n)
            nsing = j;
        if (nsing < n)
            wa[j] = 0;
    }

    for (j = nsing - 1; j >= 0; j--) {
        sum = 0;
        for (i = j + 1; i < nsing; i++)
            sum += r[j * ldr + i] * wa[i];
        wa[j] = (wa[j] - sum) / sdiag[j];
    }

/*** qrsolv: permute the components of z back to components of x. ***/

    for (j = 0; j < n; j++)
        x[ipvt[j]] = wa[j];

} /*** lm_qrsolv. ***/


/*****************************************************************************/
/*  lm_enorm (Euclidean norm)                                                */
/*****************************************************************************/

double lm_enorm(int n, const double *x)
{
/*     Given an n-vector x, this function calculates the
 *     euclidean norm of x.
 *
 *     The euclidean norm is computed by accumulating the sum of
 *     squares in three different sums. The sums of squares for the
 *     small and large components are scaled so that no overflows
 *     occur. Non-destructive underflows are permitted. Underflows
 *     and overflows do not occur in the computation of the unscaled
 *     sum of squares for the intermediate components.
 *     The definitions of small, intermediate and large components
 *     depend on two constants, LM_SQRT_DWARF and LM_SQRT_GIANT. The main
 *     restrictions on these constants are that LM_SQRT_DWARF**2 not
 *     underflow and LM_SQRT_GIANT**2 not overflow.
 *
 *     Parameters
 *
 *      n is a positive integer input variable.
 *
 *      x is an input array of length n.
 */
    int i;
    double agiant, s1, s2, s3, xabs, x1max, x3max, temp;

    s1 = 0;
    s2 = 0;
    s3 = 0;
    x1max = 0;
    x3max = 0;
    agiant = LM_SQRT_GIANT / n;

    /** sum squares. **/

    for (i = 0; i < n; i++) {
        xabs = fabs(x[i]);
        if (xabs > LM_SQRT_DWARF) {
            if ( xabs < agiant ) {
                s2 += xabs * xabs;
            } else if ( xabs > x1max ) {
                temp = x1max / xabs;
                s1 = 1 + s1 * SQR(temp);
                x1max = xabs;
            } else {
                temp = xabs / x1max;
                s1 += SQR(temp);
            }
        } else if ( xabs > x3max ) {
            temp = x3max / xabs;
            s3 = 1 + s3 * SQR(temp);
            x3max = xabs;
        } else if (xabs != 0.) {
            temp = xabs / x3max;
            s3 += SQR(temp);
        }
    }

    /** calculation of norm. **/

    if (s1 != 0)
        return x1max * sqrt(s1 + (s2 / x1max) / x1max);
    else if (s2 != 0)
        if (s2 >= x3max)
            return sqrt(s2 * (1 + (x3max / s2) * (x3max * s3)));
        else
            return sqrt(x3max * ((s2 / x3max) + (x3max * s3)));
    else
        return x3max * sqrt(s3);

} /*** lm_enorm. ***/

########## NEXT FILE ##########
aa.cpp:::
#include <iostream>
#include <cstdlib>
#include <fstream>
#include <string>
#include <cstring>
#include <vector>
#include <math.h>
#include <time.h>
using namespace std;


#include "aa.h"

#include "debug.h"


void CAminoacid::methyl_ambig(int flag)
{
	return;
}

void CAminoacid::printpdb(FILE *fp,vector<string> atomname,vector<double> x,vector<double> y,vector<double> z,vector<double> b, int &n)
{
	int i;
	struct Atom t;

	for(i=0;i<(int)atoms.size();i++)
	{
		t=atoms.at(i);
		if(t.index>0)
		{
			t.index--;
			fprintf(fp,"%6s","ATOM  ");
			fprintf(fp,"%5d",n); n++;
			fprintf(fp," ");
			fprintf(fp,"%4s",atomname.at(t.index).c_str());
			fprintf(fp," ");
			fprintf(fp,"%3s",ThreeLetterName);
			fprintf(fp," "); //reserved space
			fprintf(fp," "); //chain ID
			fprintf(fp,"%4d",residue);
			fprintf(fp,"    ");
			fprintf(fp,"%8.3f%8.3f%8.3f",x.at(t.index),y.at(t.index),z.at(t.index));
			fprintf(fp,"%6.2f",1.00); //occu
			fprintf(fp,"%6.2f",b.at(t.index));
			fprintf(fp,"\n");
		}
	}
	return;
}

int CAminoacid::get_proton(struct proton *t)
{
	int i;
	int n;
	int b;
	string cname;

	t->code=OneLetterName;
	t->id=residue;
	t->multy=0;

	b=1;
	n=0;
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).cs_name==t->name)
		{
			t->hpos[n]=atoms.at(i).index;
			if(atoms.at(i).index<0)
			{
				b=0;
			}
			t->exp=atoms.at(i).cs_exp;
			t->type=atoms.at(i).proton_type;
			cname=atoms.at(i).carbon_name;
			n++;

		}
	}
	t->nh=n;

	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).name==cname)
		{
			t->cpos=atoms.at(i).index;
			t->exp_c=atoms.at(i).cs_exp;
			break;
		}
	}

	return b;
}

int CAminoacid::get_proton3(struct proton *t)
{
	int i;
	int n;
	int b;
	string cname;

	t->code=OneLetterName;
	t->id=residue;
	t->exp=0.0;
	t->multy=0;


	b=1;
	n=0;
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).cs_name==t->name)
		{
			t->hpos[n]=atoms.at(i).index;
			if(atoms.at(i).index<0)
			{
				b=0;
			}
			t->exp=atoms.at(i).cs_exp;
			t->type=atoms.at(i).proton_type;
			cname=atoms.at(i).carbon_name;
			n++;

		}
	}
	t->nh=n;

	
	
	if(n==1) //not a methyl group or NH2 group or aromatic ring group
	{
		t->exp=0.0;
		b=1;
		n=0;
		for(i=0;i<(int)atoms.size();i++)
		{
			if(atoms.at(i).carbon_name==t->cname )
			{
				t->hpos[n]=atoms.at(i).index;
				if(atoms.at(i).index<0)
				{
					b=0;
				
				}
				t->exp+=atoms.at(i).cs_exp;
				if(n==0)
				{
					t->name=atoms.at(i).name;
					t->exp1=atoms.at(i).cs_exp;
					t->type=atoms.at(i).proton_type;
					cname=atoms.at(i).carbon_name;
				}
				else if(n==1)
				{
					t->multy=1;
					t->name2=atoms.at(i).name;
					t->exp2=atoms.at(i).cs_exp;
					t->type2=atoms.at(i).proton_type;
				}
				n++;
			}
		}
		t->nh=n;
		t->exp/=n;
	}






	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).name==cname)
		{
			t->cpos=atoms.at(i).index;
			t->exp_c=atoms.at(i).cs_exp;
			break;
		}
	}

	return b;
}

void CAminoacid::remove_ambig(int flag)
{
	int i;
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).ambig>1 && atoms.at(i).ambig!=3 )
		{
			if(atoms.at(i).cs_exp>0.0)
				atoms.at(i).cs_exp=999.0;
		}
	}
	return;
};

//
void CAminoacid::combine_hsamec(int flag)
{
	int i,j;
	string oldname,old_basename;
	double cs;

	oldname=atoms.at(0).carbon_name;
	old_basename=atoms.at(0).base_name;
	j=0;

	for(i=1;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).proton==1 && atoms.at(i).bb==0 
			&&  atoms.at(j).proton==1 && atoms.at(j).bb==0 
			&&  atoms.at(i).carbon_name==oldname && atoms.at(i).base_name!=old_basename)
		{
			//mix i and j here
			cs=(atoms.at(i).cs_exp+atoms.at(j).cs_exp)/2.0;
			atoms.at(i).cs_exp=cs;
			atoms.at(j).cs_exp=cs;
		}
		oldname=atoms.at(i).carbon_name;
		old_basename=atoms.at(i).base_name;
		j=i;
	}

	return;
};


void CAminoacid::heavycoor(vector<int> *t)
{
	int i;
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).bb==0 && atoms.at(i).proton==0)
			t->push_back(atoms.at(i).index);
	}
	return;
}

void CAminoacid::bbheavycoor(vector<int> *t)
{
	int i;
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).bb==1 && atoms.at(i).proton==0 && atoms.at(i).name.compare("OXT")!=0)
			t->push_back(atoms.at(i).index);
	}
	return;
}


void CAminoacid::allcoor(vector<int> *t)
{
	int i;
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).index>0)
			t->push_back(atoms.at(i).index);
	}
	return;
}

struct noeatoms CAminoacid::query(string name)
{
	struct noeatoms t;
	vector<int> tt;
	int index;

	if(name=="HN")
		name="H";

	tt.clear();
	index=get(name.c_str()).index;
	if(index<=0 && name=="H")
		index=get("H1").index; 
	if(index>0)
	{
		tt.push_back(index);
		t.atoms.push_back(tt);
		t.length=0.0;
	}
	return t;
}



void CAminoacid::attach_bbprediction(double pre[5])
{
	int i;

	pre_ca=pre[0];
	pre_cb=pre[1];
	pre_c=pre[2];
	pre_h=pre[3];
	pre_n=pre[4];
	pre_ha=pre[5];

	if(OneLetterName=='G')
		pre_cb=999.0;
	else if(OneLetterName=='C')
		pre_ca=pre_cb=pre_c=pre_h=pre_n=999.0;
	else if(OneLetterName=='P')
		pre_h=pre_n=999.0;
	else if(OneLetterName=='U')
		pre_ca=pre_cb=pre_c=pre_h=pre_n=999.0;


	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).name=="CA")
			atoms.at(i).cs_pre=pre_ca;
		if(atoms.at(i).name=="CB")
			atoms.at(i).cs_pre=pre_cb;
		if(atoms.at(i).name=="C")
			atoms.at(i).cs_pre=pre_c;
		if(atoms.at(i).name=="H")
			atoms.at(i).cs_pre=pre_h;
		if(atoms.at(i).name=="N")
			atoms.at(i).cs_pre=pre_n;
		if(atoms.at(i).name=="HA" || atoms.at(i).name=="HA2" || atoms.at(i).name=="HA3")
			atoms.at(i).cs_pre=pre_ha;
	}

}

void  CAminoacid::attach_protonprediction(string name,double cs)
{	
	int i;
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).cs_name==name)
		{
			atoms.at(i).cs_pre=cs;
		}
	}
	return;
}



void CAminoacid::print_prediction(int *index,FILE *fbmrb)
{
	int i;
	string oldname;

	oldname="xxx";
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).cs_pre<450 && atoms.at(i).cs_name!=oldname)
		{
			fprintf(fbmrb,"%8d %8d %8s %8s %8s %8.3f . 1\n",*index,original_residue,ThreeLetterName,atoms.at(i).cs_name.c_str(),
				atoms.at(i).cs_name.c_str(),atoms.at(i).cs_pre);
			(*index)++;
			oldname=atoms.at(i).cs_name;
		}
	}
	return;
}

void CAminoacid::print_bbprediction(FILE *fbmrb)
{
	fprintf(fbmrb,"%8d%8s",original_residue,ThreeLetterName);
	fprintf(fbmrb,"%8.3f%8.3f",get("CA").cs_pre,get("CA").cs_exp);
	fprintf(fbmrb,"%8.3f%8.3f",get("CB").cs_pre,get("CB").cs_exp);
	fprintf(fbmrb,"%8.3f%8.3f",get("C").cs_pre,get("C").cs_exp);
	fprintf(fbmrb,"%8.3f%8.3f",get("H").cs_pre,get("H").cs_exp);
	fprintf(fbmrb,"%8.3f%8.3f",get("N").cs_pre,get("N").cs_exp);
	if(OneLetterName=='G')
		fprintf(fbmrb,"%8.3f%8.3f",get("HA2").cs_pre,get("HA2").cs_exp);
	else
		fprintf(fbmrb,"%8.3f%8.3f",get("HA").cs_pre,get("HA").cs_exp);
	fprintf(fbmrb,"\n");
}

void CAminoacid::print_protonprediction(FILE *fbmrb)
{
	int i;
	string oldname;

	oldname="xxx";
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).cs_pre<990 && atoms.at(i).proton==1 && atoms.at(i).bb==0 && atoms.at(i).cs_name!=oldname)
		{
			oldname=atoms.at(i).cs_name;
			fprintf(fbmrb,"%8d %8c %8s %8.3f %8.3f\n",original_residue,OneLetterName,atoms.at(i).cs_name.c_str(),
				atoms.at(i).cs_pre,atoms.at(i).cs_exp);
		}
	}
	return;
}


void CAminoacid::attach_rmsf(vector<double> t)
{
	int i,j;

	for(i=0;i<atoms.size();i++)
	{
		j=atoms.at(i).index;
		if(j>0)
			atoms.at(i).rmsf=t.at(j-1);
	}
	return;
}

void CAminoacid::print_rmsf(FILE *fp)
{
	int i;

	for(i=0;i<atoms.size();i++)
	{
		if(atoms.at(i).rmsf>0)
			fprintf(fp,"%10d %9c %9s %10.4f\n",residue,OneLetterName,atoms.at(i).name.c_str(),atoms.at(i).rmsf);
	}
	return;
}


int CAminoacid::wang_correct_index(char c)
{
	int index;
	switch(c)
		{
			case 'A': index=0; break;
			case 'C': index=1; break;
			case 'D': index=2; break;
			case 'E': index=3; break;
			case 'F': index=4; break;
			case 'G': index=5; break;
			case 'H': index=6; break;
			case 'I': index=7; break;
			case 'K': index=8; break;
			case 'L': index=9; break;
			case 'M': index=10; break;
			case 'N': index=11; break;
			case 'P': index=12; break;
			case 'Q': index=13; break;
			case 'R': index=14; break;
			case 'S': index=15; break;
			case 'T': index=16; break;
			case 'V': index=17; break;
			case 'W': index=18; break;
			case 'Y': index=19; break;
			default: index=20;
		}

	return index;
}

void CAminoacid::set_coil_wc(char pre, char fol)
{
	int index,index1,index2;
	int i;
	double t[6];

	set_coil(2);
	index1=wang_correct_index(pre);
	index2=wang_correct_index(fol);
	index=wang_rc_index(OneLetterName);

	for(i=0;i<6;i++)
	{
		t[i]=wang_rc[index][i]+wang_c1[index1][i]+wang_c2[index2][i];
	}
	set_wang(t,index);
	return;
}

int CAminoacid::wang_rc_index(char c)
{
	int index;
	switch(c)
		{
			case 'I': index=0; break;
			case 'V': index=1; break;
			case 'D': index=2; break;
			case 'N': index=3; break;
			case 'F': index=4; break;
			case 'H': index=5; break;
			case 'W': index=6; break;
			case 'Y': index=7; break;
			case 'K': index=8; break;
			case 'L': index=9; break;
			case 'M': index=10; break;
			case 'Q': index=11; break;
			case 'R': index=12; break;
			case 'E': index=13; break;
			case 'T': index=14; break;
			case 'C': index=15; break;
			case 'S': index=16; break;
			case 'A': index=17; break;
			case 'G': index=18; break;
			case 'P': index=19; break;
			default: index=20;
		}

	return index;
}

void CAminoacid::set_wang(double *t,int index)
{
	int i;
	//unknown or missing residue. 
	if(index==20)
		return;


	get_address("C")->cs_wang=t[1];
	get_address("CA")->cs_wang=t[2];

	if(index!=19)
	{
		get_address("H")->cs_wang=t[4];
		get_address("N")->cs_wang=t[0];
	}

	if(index!=18) 
	{
		get_address("HA")->cs_wang=t[5];
		get_address("CB")->cs_wang=t[3];
	}
	else
	{
		get_address("HA1")->cs_wang=t[5];
		get_address("HA2")->cs_wang=t[5];
	}

	for(i=0;i<(int)atoms.size();i++)
	{
		atoms.at(i).cs_exp=atoms.at(i).cs_wang;
	}

	return;
}

void CAminoacid::set_coil(int flag=1)
{
	int i;
	if(flag==1)
	{
		for(i=0;i<(int)atoms.size();i++)
		{
			atoms.at(i).cs_exp=atoms.at(i).cs_coil;
		}
	}
	else if(flag==2)
	{
		int index=wang_rc_index(OneLetterName);
		set_wang(wang_rc[index],index);	
	}

	return;
}

void CAminoacid::set_mean()
{
	int i;
	for(i=0;i<(int)atoms.size();i++)
	{
		atoms.at(i).cs_exp=atoms.at(i).cs_mean;
	}
	return;
}

void CAminoacid::clearexp()
{
	int i;
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).cs_exp>0.0)
			atoms.at(i).cs_exp=999.0;
	}
	bexploaded=0;
	exploaded=0;
	return;
}



void CAminoacid::loadexp(struct CBmrbdata data)
{
	int i,j;
	bool bused;
	string name;
	string dataname;

	if(data.name.compare(ThreeLetterName)!=0)
	{
		cout<<"Error. at pos "<<residue<<" PDB is "<<ThreeLetterName<<" while BMRB is "<<data.name<<endl;
		bexploaded=0;
		exploaded=-1;
		for(i=0;i<(int)atoms.size();i++)
		{
			if(atoms.at(i).cs_exp>0.0)
				atoms.at(i).cs_exp=9999.0;
		}
		return;
	}

	for(i=0;i<(int)data.block.size();i++)
	{
		data.block.at(i).used=1;
		bused=0;
		dataname=data.block.at(i).type;

		for(j=0;j<(int)atoms.size();j++)
		{
			name=atoms.at(j).cs_name;
			if(dataname.at(0)=='H' && dataname.size()>1)
			{
				if(data.block.at(i).type.find(name)==0 && name!="H" )
				{
					bused=1;
					if(data.block.at(i).ambig<=3)
					{
						atoms.at(j).cs_exp=data.block.at(i).cs;
						atoms.at(j).ambig=data.block.at(i).ambig;
						data.block.at(i).used=1;
					}
				}
			}

			else if(dataname.at(0)=='C' && dataname.size()>2 && name.size()>1)
			{
				if(data.block.at(i).type.find(name)==0 )
				{
					bused=1;
					if(data.block.at(i).ambig<=3)
					{
						atoms.at(j).cs_exp=data.block.at(i).cs;
						atoms.at(j).ambig=data.block.at(i).ambig;
						data.block.at(i).used=1;
					}
				}
			}

			else if(dataname.at(0)=='C' && dataname.size()>1)
			{
				if(data.block.at(i).type.compare(name)==0 )
				{
					bused=1;
					if(data.block.at(i).ambig<=3)
					{
						atoms.at(j).cs_exp=data.block.at(i).cs;
						atoms.at(j).ambig=data.block.at(i).ambig;
						data.block.at(i).used=1;
					}
				}
			}

			else
			{
				if(data.block.at(i).type.compare(name)==0 )
				{
					bused=1;
					if(data.block.at(i).ambig<=3)
					{
						atoms.at(j).cs_exp=data.block.at(i).cs;
						atoms.at(j).ambig=data.block.at(i).ambig;
						data.block.at(i).used=1;
					}
				}
			}
		}
		if(bused==0)
			cout<<"In "<<residue<<" "<<ThreeLetterName<<", unmatched bmrb data point for "<<data.block.at(i).type.c_str()<<" cs is "<<data.block.at(i).cs<<endl;
	}
	bexploaded=1;
	exploaded=1;
	return;
}

void CAminoacid::set_mismatch(void)
{
	int i;

	bexploaded=0;
	exploaded=-1;

	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).cs_exp>0.0)
			atoms.at(i).cs_exp=9999.0;
	}

	return;
}


void CAminoacid::dihe(vector<dihe_group> * dihe_index)
{
	cout<<"run virtual fuction of base class, sth is wrong!"<<endl;
	return;
}

void CAminoacid::proton(vector<struct proton> *sel)
{
	struct proton t;
	int i;
	string oldname;

	oldname="XXX";
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).bb==0 && atoms.at(i).proton==1 && atoms.at(i).cs_name!=oldname)
		{
			oldname=atoms.at(i).cs_name;
			t.name=atoms.at(i).cs_name;
			if(get_proton(&t))
				sel->push_back(t);
		}
	}
	return;
}


//combine hb2 and hb3 into one.
void CAminoacid::proton3(vector<struct proton> *sel)
{
	struct proton t;
	int i;
	string oldname,cname;

	oldname="XXX";
	cname="YYYY";
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).bb==0 && atoms.at(i).proton==1 && atoms.at(i).cs_name!=oldname && atoms.at(i).carbon_name!=cname)
		{
			oldname=atoms.at(i).cs_name;
			cname=atoms.at(i).carbon_name;
			t.name=atoms.at(i).cs_name;
			t.cname=atoms.at(i).carbon_name;

			t.exp=t.exp1=t.exp2=0.0;
			t.cname2="";
			t.name2="";
			t.cpos=-1;
			t.nh=0;
			t.multy=0;
			t.type=t.type2=0;

			if(get_proton3(&t))
				sel->push_back(t);
		}
	}
	return;
}

void CAminoacid::proton2(vector<struct proton> *)
{
	return;
}

void CAminoacid::ring(vector<ring_group> *ring)
{
	return;
}

void CAminoacid::previous_bb(vector<bb_group> *bb)
{
	if(exploaded==-1)
		bb->at(bb->size()-1).previous_mut=1;
}


void CAminoacid::follow_bb(vector<bb_group> *bb)
{
	if(exploaded==-1)
		bb->at(bb->size()-1).follow_mut=1;

	bb->at(bb->size()-1).follow_hpos=get("H").index;
	bb->at(bb->size()-1).follow_npos=get("N").index;
	bb->at(bb->size()-1).follow_exp_n=get("N").cs_exp;
	bb->at(bb->size()-1).follow_exp_h=get("H").cs_exp;
	bb->at(bb->size()-1).follow_exp_ca=get("CA").cs_exp;
	
	if(OneLetterName=='P')
	{
		bb->at(bb->size()-1).follow_exp_n=999.0;
		bb->at(bb->size()-1).follow_exp_h=999.0;
	}

}

void CAminoacid::follow_bb_assign(vector<bb_group> *bb)
{
    if(exploaded==-1)
        bb->at(bb->size()-1).follow_mut=1;
    
    bb->at(bb->size()-1).follow_hpos=get("H").index;
    bb->at(bb->size()-1).follow_npos=get("N").index;
    bb->at(bb->size()-1).follow_exp_n=get("N").cs_exp;
    bb->at(bb->size()-1).follow_exp_h=get("H").cs_exp;
    bb->at(bb->size()-1).follow_exp_ca=get("CA").cs_exp;
    
    if(OneLetterName=='P')   //Proline won't have peaks in 3D experiments
    {
        bb->at(bb->size()-1).follow_exp_n=999.0;
        bb->at(bb->size()-1).follow_exp_h=999.0;
        
    
         bb->at(bb->size()-1).follow_exp_ca=999.0;
         bb->at(bb->size()-1).exp_ca=999.0;
         bb->at(bb->size()-1).exp_cb=999.0;
         bb->at(bb->size()-1).exp_co=999.0;
    
    }
    
}


void CAminoacid::bb(vector<bb_group> *bb)
{
	struct bb_group t;

	t.chain=chain;
	t.id=residue;
	t.id0=original_residue;
	t.code=OneLetterName;
	t.ss=ss;
	
	t.exploaded=1;
	t.previous_mut=0;
	t.follow_mut=0;

	if(exploaded!=1)
		t.exploaded=0;
	
	t.hpos=get("H").index;
	t.npos=get("N").index;
	t.capos=get("CA").index;
	t.cbpos=get("CB").index;
	t.copos=get("C").index;
	t.opos=get("O").index;
	

	t.exp_ca=get("CA").cs_exp;
	t.exp_cb=get("CB").cs_exp;
	t.exp_co=get("C").cs_exp;
	t.exp_n=get("N").cs_exp;
	t.exp_h=get("H").cs_exp;
	

	if(OneLetterName=='G')
	{
		t.exp_ha=get("HA2").cs_exp;
		t.hapos=get("HA2").index;
		t.exp_ha2=get("HA3").cs_exp;
		t.hapos2=get("HA3").index;
	}
	else
	{
		t.exp_ha=get("HA").cs_exp;
		t.hapos=get("HA").index;
	}


	if(t.cbpos==-2)
		t.exp_cb=-999.0; //GLY
	if(t.hpos==-2)
		t.exp_h=-999.0; //PRO

	t.pre_ca=get("CA").cs_pre;
	t.pre_cb=get("CB").cs_pre;
	t.pre_c=get("C").cs_pre;
	t.pre_n=get("N").cs_pre;
	t.pre_h=get("H").cs_pre;
	

	if(OneLetterName=='G')
	{
		t.pre_ha=get("HA2").cs_pre;
	}
	else
	{
		t.pre_ha=get("HA").cs_pre;
	}

	bb->push_back(t);
	return;
}

void CAminoacid::bbco(vector<struct co_group> *co)
{
	struct co_group t;

	t.id=residue;
	t.code=OneLetterName;
	t.cpos=get("C").index;
	t.opos=get("O").index;
	t.exp_c=get("C").cs_exp;
	t.exp_o=get("O").cs_exp;

	co->push_back(t);
	
	return;
}


void CAminoacid::ired(vector<struct ired> *t, int pos)
{
	int i;
	string s1,s2;
	struct ired red;

	red.id=residue;
	red.id0=original_residue;
	red.chain=chain;
	red.pos=pos;
	red.code=OneLetterName;

	for(i=0;i<(int)order_parameters.size();i++)
	{
		if(order_parameters.at(i).name1=="C0")
			red.index1=previousc;
		else
			red.index1=get(order_parameters.at(i).name1.c_str()).index;
		red.index2=get(order_parameters.at(i).name2.c_str()).index;

		red.s2=order_parameters.at(i);

		if(red.index1>=0 && red.index2>=0)
			t->push_back(red);
	}



	return;
}


void CAminoacid::clearred()
{
	int i;
	for(i=0;i<(int)order_parameters.size();i++)
	{	
		order_parameters.at(i).pre=0.0;
		order_parameters.at(i).exp=0.0;	
	}
	return;
}



void CAminoacid::loadred(struct ired red)
{
	int i;
	struct S2 t;


	{
		for(i=0;i<(int)order_parameters.size();i++)
		{
			t=order_parameters.at(i);
			if( (t.name1==red.s2.name1 && t.name2==red.s2.name2) || (t.name1==red.s2.name2 && t.name2==red.s2.name1) )
			{
				order_parameters.at(i).pre=red.s2.pre;
				order_parameters.at(i).exp=red.s2.exp;
			}
		}
	}

	return;
}



void CAminoacid::bbnh(vector<struct nh_group> *nh)
{
	struct nh_group t;

	t.id=residue;
	t.code=OneLetterName;
	t.hpos=get("H").index;
	t.npos=get("N").index;
	t.exp_h=get("H").cs_exp;
	t.exp_n=get("N").cs_exp;

	if(OneLetterName!='P')
		nh->push_back(t);
	
	return;
}

void CAminoacid::caha(vector<struct index_three> *caha)
{
	struct index_three t;
	t.x1=residue;
	t.x2=get("CA").index;
	t.x3=get("HA").index;
	if(OneLetterName!='G')
		caha->push_back(t);
	return;
}

void CAminoacid::bbhbond(vector<bbhbond_group> *bb)
{
	struct bbhbond_group t;

	t.id=residue;
	t.code=OneLetterName;
	t.npos=get("N").index;
	t.hpos=get("H").index;
	t.cpos=get("C").index;
	t.opos=get("O").index;
	t.type=1;

	bb->push_back(t);
	return;
}

void CAminoacid::schbond(vector<bbhbond_group> *)
{
	//remaining AA don't have sc donor or acceptor group.
	return;
}


void CAminoacid::bbani(vector<struct ani_group> *anistropy)
{
	struct ani_group t;
	t.type=1;
	t.id=residue;
	t.code=OneLetterName;
	t.pos[0]=followingn;
	t.pos[1]=get("C").index;
	t.pos[2]=get("O").index;

	anistropy->push_back(t);
}

void CAminoacid::ani(vector<struct ani_group> *anistropy)
{
	return;
}

void CAminoacid::sccoor(vector<int> *t)
{
	int i;
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).bb==0 && atoms.at(i).proton==0)
			t->push_back(atoms.at(i).index);
	}
	return;
}


void CAminoacid::setcterminal(void)
{
	struct Atom t;
	
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;
	t.bb=0;
	t.proton=0;
	t.ambig=0;
	t.name="OXT";t.cs_name="OXT";t.base_name="OXT";atoms.push_back(t);

	return;
}


void CAminoacid::setnterminal(void)
{
	struct Atom t;
	int i;

	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).name=="H")
			atoms.erase(atoms.begin()+i);
	}

	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;
	t.bb=1;
	t.proton=1;
	t.ambig=0;
	t.name="H1";t.cs_name="H";t.base_name="H";atoms.push_back(t);
	t.name="H2";t.cs_name="H";t.base_name="H";atoms.push_back(t);
	t.name="H3";t.cs_name="H";t.base_name="H";atoms.push_back(t);
}


void CAminoacid::process(vector<string> block)
{
	int i,j,k;
	int index;
	char c;
	bool bmatch;
	string t,t2;
	string atomname,atomname2;
	string part;
	string name;
	vector<string> subblock;

	original_residue=atoi(block.at(0).substr(22,4).c_str());


	vector<int> toremove;
	toremove.resize(block.size(),0);
	for(i=0;i<(int)block.size();i++)
	{
		for(j=i+1;j<(int)block.size();j++)
		{
			atomname=block.at(i).substr(11,5);
			atomname2=block.at(j).substr(11,5);
			if(atomname2==atomname)
			{
				toremove.at(j)=1;
			}
		}
	}

	for(i=(int)toremove.size()-1;i>0;i--)
	{
		if(toremove.at(i)==1)
			block.erase(block.begin()+i);
	}
	toremove.clear();



	
	//replace D to H
	for(i=0;i<(int)block.size();i++)
	{
		t=block[i];
		atomname=t.substr(11,3);
		if(atomname.compare("  D")==0)
		{
			t2=t.substr(0,11);
			t2=t2.append("  H");
			t2=t2.append(t.substr(14));
			//cout<<"Atomname is: "<<atomname<<endl;
			//cout<<"from: "<<t<<endl;
			//cout<<"to:   "<<t2<<endl;
			block.at(i)=t2;
		}
	}

	for(i=0;i<(int)block.size();i++)
	{
		t=block[i];
		atomname=t.substr(11,2);
		if(atomname.compare(" D")==0)
		{
			t2=t.substr(0,11);
			t2=t2.append(" H");
			t2=t2.append(t.substr(13));
			//cout<<"Atomname is: "<<atomname<<endl;
			//cout<<"from: "<<t<<endl;
			//cout<<"to:   "<<t2<<endl;
			block.at(i)=t2;
		}
	}





	for(i=0;i<(int)block.size();i++)
	{
		t=block[i];
		atomname=t.substr(11,5);  //atom name here
		while((j=atomname.find(" ")) != string::npos)
		{
			atomname.replace(j, 1, "");
		}	
		part=t.substr(6,5); //atom index
		index=atoi(part.c_str());

		if(atomname=="OC1")  //C-terminal atoms 
			atomname="O";
		if(atomname=="OC2")
			atomname="OXT";

		if(atomname=="HN")
			atomname="H";


		c=atomname.at(0);
		if(c>'0' && c<'9')  //if name started with number, move that number to the end
		{
			atomname.erase(0,1);
			atomname.append(1,c);
		}

		
		if(OneLetterName=='I')   //gromacs use CD in ILE, should be CD1
		{
			if( atomname=="CD") atomname="CD1"; 	
			if( atomname=="HD1")atomname="HD11"; 	
			if( atomname=="HD2")atomname="HD12"; 	
			if( atomname=="HD3")atomname="HD13"; 	
		}

		c=atomname.at(0);
		if(c=='H' && atomname.compare("H")!=0 && atomname.compare("H1")!=0 && atomname.compare("H2")!=0 && atomname.compare("H3")!=0 )  //started with H, but it is not HN,h1,h2,or h3
		{
			//process protons
			bmatch=0;
			for(j=0;j<(int)atoms.size()  && bmatch==0 ;j++)
			{
				name=atoms.at(j).base_name;
				k=atoms.at(j).index;
				if(name.compare("H")!=0 && atomname.find(name)==0 && k<0)
				{
					atoms.at(j).index=index;
					bmatch=1;
				}
			}
#ifndef BENCHMARK
			if(bmatch==0)  //cannot match atomname, print out error message.
				cout<<"Unknown atom name "<<atomname.c_str()<<" in residue "<<residue<<" "<<ThreeLetterName<<endl;
#endif
		}
		else  //heavy atoms or HN atom. try to match name directly.
		{
			bmatch=0;
			for(j=0;j<(int)atoms.size();j++)
			{
				if(atomname==atoms.at(j).name)
				{
					atoms.at(j).index=index;
					bmatch=1;
				}
			}
#ifndef BENCHMARK
		if(bmatch==0)  //cannot match atomname, print out error message.
			cout<<"Unknown atom name "<<atomname.c_str()<<" in residue "<<residue<<" "<<ThreeLetterName<<endl;
#endif
		}
	}
	return;
}


void CAminoacid::bbdihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;

	t.id=residue;
	t.code=OneLetterName;
	t.type=1;
	t.x1=previousc;
	t.x2=get("N").index;
	t.x3=get("CA").index;
	t.x4=get("C").index;
	t.bgood=0;

	if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0)
		t.bgood=1;
	dihe_index->push_back(t);

	t.id=residue;
	t.code=OneLetterName;
	t.type=2;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("C").index;
	t.x4=followingn;
	t.bgood=0;
	if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0)
		t.bgood=1;
	dihe_index->push_back(t);

	
	return;
}

struct Atom  CAminoacid::get(const char* name)
{
	int i;
	struct Atom t;

	t.index=-2;
	t.cs_exp=-999.0;
	t.cs_pre=-999.0;
	t.name="NO_EXIST";

	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).name==name)
		{
			t=atoms.at(i);
			break;
		}
	}

	if(i==atoms.size())  //didn't find it, so ...
	{
		t.index=-2;
		t.cs_exp=-999.0;
		t.cs_pre=-999.0;
		t.name="NO_EXIST";
	}
	return t;
}

struct Atom*  CAminoacid::get_address(const char* name)
{
	int i;
	struct Atom *t;


	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).name==name)
		{
			t=&(atoms.at(i));
			break;
		}
	}

	if(i==atoms.size())  //didn't find it, so ...
	{
		t=&atom_nouse;
	}
	return t;
}




CAminoacid::CAminoacid() 
{
	OneLetterName='B';
	bexploaded=0;
	exploaded=0;
	ss=0;
	
	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=1;
	t.proton=0;
	t.ambig=0;
	t.proton=0;t.name="N";t.cs_name="N";t.base_name="N";atoms.push_back(t);
	t.proton=1;t.name="H";t.cs_name="H";t.base_name="H";atoms.push_back(t);
	t.proton=0;t.name="CA";t.cs_name="CA";t.base_name="CA";atoms.push_back(t);
	t.proton=1;t.name="HA";t.cs_name="HA";t.base_name="HA";t.carbon_name="CA";atoms.push_back(t);
	t.proton=0;t.name="C";t.cs_name="C";t.base_name="C";atoms.push_back(t);
	t.proton=0;t.name="O";t.cs_name="O";t.base_name="O";atoms.push_back(t);

	struct S2 s2;
	s2.name1="N";s2.name2="H";s2.exp=999.0;s2.pre=999.0;order_parameters.push_back(s2);
	s2.name1="CA";s2.name2="HA";s2.exp=999.0;s2.pre=999.0;order_parameters.push_back(s2);
	s2.name1="N";s2.name2="CA";s2.exp=999.0;s2.pre=999.0;order_parameters.push_back(s2);
	s2.name1="CA";s2.name2="C";s2.exp=999.0;s2.pre=999.0;order_parameters.push_back(s2);
	s2.name1="C0";s2.name2="N";s2.exp=999.0;s2.pre=999.0;order_parameters.push_back(s2);

	for(int i=0;i<6;i++)
	{
		coil_pre[i]=coil_fol[i]=0.0;
	}

}

int CAminoacid::wishart_index()
{
	int index;

	switch(OneLetterName)
	{
		case 'A': index=0;break;
		case 'R': index=1;break;
		case 'N': index=2;break;
		case 'D': index=3;break;
		case 'Q': index=4;break;
		case 'E': index=5;break;
		case 'G': index=6;break;
		case 'H': index=7;break;
		case 'I': index=8;break;
		case 'L': index=9;break;
		case 'K': index=10;break;
		case 'M': index=11;break;
		case 'F': index=12;break;
		case 'P': index=13;break;
		case 'S': index=14;break;
		case 'T': index=15;break;
		case 'W': index=16;break;
		case 'Y': index=17;break;
		case 'V': index=18;break;
		case 'C': index=20;break;
		default: index=21;
	}
	if(strcmp(ThreeLetterName,"XYX")==0) index=19;

	return index;
}



vector<double> CAminoacid::get_wishart()
{
	vector <double> t;
	for(int i=0;i<12;i++)
		t.push_back(wishart[wishart_index()][i]);
	return t;
}


CAminoacid::~CAminoacid() {}



//ALA

struct noeatoms CAla::query(string name)
{
	struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("MB")==0 || name.compare("QB")==0)
	{
		tt.push_back(get("HB1").index);
		tt.push_back(get("HB2").index);
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=0.0;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}


void CAla::dihe(vector<dihe_group> * dihe_index)
{
	return;
}


void CAla::proton2(vector<struct proton> *sel)
{
	struct proton t;

	t.type=1;
	t.name="HB";
	get_proton(&t);
	sel->push_back(t);

	return;
}


CAla::CAla() 
{
	//CAminoacid::CAminoacid();
	OneLetterName='A';	strcpy(ThreeLetterName,"ALA");

	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;
	t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.proton=1;t.carbon_name="CB";
	t.proton_type=1;t.name="HB1";t.cs_name="HB";t.base_name="HB";atoms.push_back(t);
	t.proton_type=1;t.name="HB2";t.cs_name="HB";t.base_name="HB";atoms.push_back(t);
	t.proton_type=1;t.name="HB3";t.cs_name="HB";t.base_name="HB";atoms.push_back(t);

	get_address("H")->cs_coil=8.24;
	get_address("N")->cs_coil=124.2;
	get_address("CA")->cs_coil=52.1;
	get_address("HA")->cs_coil=4.39;
	get_address("CB")->cs_coil=19.3;
	get_address("C")->cs_coil=176.8;

	get_address("H")->cs_mean=8.19;
	get_address("N")->cs_mean=123.22;
	get_address("CA")->cs_mean=53.19;
	get_address("HA")->cs_mean=4.25;
	get_address("CB")->cs_mean=18.98;
	get_address("C")->cs_mean=177.79;

	get_address("N")->cs_wang=123.82;
	get_address("C")->cs_wang=177.28;
	get_address("CA")->cs_wang=52.46;
	get_address("CB")->cs_wang=18.98;
	get_address("H")->cs_wang=8.09;
	get_address("HA")->cs_wang=4.31;

	coil_pre[0]=-2.21;
	coil_pre[1]= 0.14;
	coil_pre[2]=-0.01;
	coil_pre[3]=-0.04;
	coil_pre[4]=-0.07;
	coil_pre[5]=-0.01;

	coil_fol[0]=-0.11;
	coil_fol[1]= 0.05;
	coil_fol[2]= 0.07;
	coil_fol[3]=-0.09;
	coil_fol[4]=-0.01;
	coil_fol[5]=-0.03;
}
CAla::~CAla() {}


//ARG
void CArg::schbond(vector<bbhbond_group> *grp)
{
	bbhbond_group t;
	t.id=residue;
	t.code=OneLetterName;
	t.cpos=-1;
	t.opos=-1;
	t.npos=get("NE").index;
	t.hpos=get("HE").index;
	t.type=13; 

	grp->push_back(t);
	return;
}

struct noeatoms CArg::query(string name)
{
	struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QG")==0)
	{
		tt.clear();
		tt.push_back(get("HG2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HG3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QD")==0)
	{
		tt.clear();
		tt.push_back(get("HD2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HD3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QH1")==0)
	{
		tt.clear();
		tt.push_back(get("HH11").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HH12").index);
		t.atoms.push_back(tt);
	}
	else if(name.compare("QH2")==0)
	{
		tt.clear();
		tt.push_back(get("HH21").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HH22").index);
		t.atoms.push_back(tt);
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}


void CArg::ani(vector<struct ani_group> *anistropy)
{
	struct ani_group t;
	CAminoacid::ani(anistropy);

	t.type=4;
	t.id=residue;
	t.code=OneLetterName;
	t.pos[0]=get("NH1").index;
	t.pos[1]=get("CZ").index;
	t.pos[2]=get("NH2").index;
	anistropy->push_back(t);
	
	return ;
}



void CArg::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;

	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;;
	t.x3=get("CB").index;;
	t.x4=get("CG").index;;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=4;
	t.x1=get("CA").index;
	t.x2=get("CB").index;
	t.x3=get("CG").index;
	t.x4=get("CD").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);
	
	t.type=5;
	t.x1=get("CB").index;
	t.x2=get("CG").index;
	t.x3=get("CD").index;
	t.x4=get("NE").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);
	
	t.type=6;
	t.x1=get("CG").index;
	t.x2=get("CD").index;
	t.x3=get("NE").index;
	t.x4=get("CZ").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);
	
	t.type=7;
	t.x1=get("CD").index;
	t.x2=get("NE").index;
	t.x3=get("CZ").index;
	t.x4=get("NH2").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);
	
	return;
}


CArg::CArg() 
{
	//CAminoacid::CAminoacid();
	OneLetterName='R';strcpy(ThreeLetterName,"ARG");

	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;
	t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG";t.cs_name="CG";t.base_name="CB";atoms.push_back(t);
	t.name="CD";t.cs_name="CD";t.base_name="CB";atoms.push_back(t);
	t.name="NE";t.cs_name="NE";t.base_name="CB";atoms.push_back(t);
	t.name="CZ";t.cs_name="CZ";t.base_name="CB";atoms.push_back(t);
	t.name="NH1";t.cs_name="NH1";t.base_name="CB";atoms.push_back(t);
	t.name="NH2";t.cs_name="NH2";t.base_name="CB";atoms.push_back(t);
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=11;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=12;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);
	t.carbon_name="CG";
	t.proton_type=13;t.name="HG2";t.cs_name="HG2";t.base_name="HG";atoms.push_back(t);
	t.proton_type=14;t.name="HG3";t.cs_name="HG3";t.base_name="HG";atoms.push_back(t);
	t.carbon_name="CD";
	t.proton_type=15;t.name="HD2";t.cs_name="HD2";t.base_name="HD";atoms.push_back(t);
	t.proton_type=16;t.name="HD3";t.cs_name="HD3";t.base_name="HD";atoms.push_back(t);
	t.carbon_name="NE";
	t.proton_type=17;t.name="HE";t.cs_name="HE";t.base_name="HE";atoms.push_back(t);
	t.carbon_name="NH1";
	t.proton_type=18;t.name="HH11";t.cs_name="HH1";t.base_name="HH1";atoms.push_back(t);
	t.proton_type=18;t.name="HH12";t.cs_name="HH1";t.base_name="HH1";atoms.push_back(t);
	t.carbon_name="NH2";
	t.proton_type=19;t.name="HH21";t.cs_name="HH2";t.base_name="HH2";atoms.push_back(t);
	t.proton_type=19;t.name="HH22";t.cs_name="HH2";t.base_name="HH2";atoms.push_back(t);
	
	get_address("H")->cs_coil=8.24;
	get_address("N")->cs_coil=121.7;
	get_address("CA")->cs_coil=55.9;
	get_address("HA")->cs_coil=4.47;
	get_address("CB")->cs_coil=31.0;
	get_address("C")->cs_coil=175.3;

	get_address("H")->cs_mean=8.23;
	get_address("N")->cs_mean=120.76;
	get_address("CA")->cs_mean=56.82;
	get_address("HA")->cs_mean=4.29;
	get_address("CB")->cs_mean=30.65;
	get_address("C")->cs_mean=176.46;

	get_address("H")->cs_wang=8.21;
	get_address("N")->cs_wang=120.75;
	get_address("CA")->cs_wang=56.18;
	get_address("HA")->cs_wang=4.26;
	get_address("CB")->cs_wang=30.36;
	get_address("C")->cs_wang=176.01;

	coil_pre[0]=-0.45;
	coil_pre[1]=-0.07;
	coil_pre[2]= 0.00;
	coil_pre[3]= 0.01;
	coil_pre[4]=-0.03;
	coil_pre[5]= 0.01;

	coil_fol[0]=-0.09;
	coil_fol[1]= 0.16;
	coil_fol[2]= 0.19;
	coil_fol[3]=-0.12;
	coil_fol[4]=-0.01;
	coil_fol[5]=-0.02;
}
CArg::~CArg() {}


// ASN
void CAsn::schbond(vector<bbhbond_group> *grp)
{
	bbhbond_group t;
	t.id=residue;
	t.code=OneLetterName;
	t.npos=-1;
	t.hpos=-1;
	t.cpos=get("CG").index;
	t.opos=get("OD1").index;
	t.type=23; 

	grp->push_back(t);
	return;
}


struct noeatoms CAsn::query(string name)
{
	struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QD")==0)
	{
		tt.clear();
		tt.push_back(get("HD21").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HD22").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}



void CAsn::ani(vector<struct ani_group> *anistropy)
{
	struct ani_group t;
	CAminoacid::ani(anistropy);

	t.type=2;
	t.id=residue;
	t.code=OneLetterName;
	t.pos[0]=get("OD1").index;
	t.pos[1]=get("CG").index;
	t.pos[2]=get("ND2").index;
	anistropy->push_back(t);
	
	return ;
}



void CAsn::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=4;
	t.x1=get("CA").index;
	t.x2=get("CB").index;
	t.x3=get("CG").index;
	t.x4=get("ND2").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	return;
}


CAsn::CAsn() 
{
	//CAminoacid::CAminoacid();
	OneLetterName='N';strcpy(ThreeLetterName,"ASN");
	
	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;
	t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG";t.cs_name="CG";t.base_name="CB";atoms.push_back(t);
	t.name="OD1";t.cs_name="OD1";t.base_name="CB";atoms.push_back(t);
	t.name="ND2";t.cs_name="ND2";t.base_name="CB";atoms.push_back(t);
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=20;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=21;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);
	t.carbon_name="ND2";
	t.proton_type=22;t.name="HD21";t.cs_name="HD21";t.base_name="HD2";atoms.push_back(t);
	t.proton_type=23;t.name="HD22";t.cs_name="HD22";t.base_name="HD2";atoms.push_back(t);

	get_address("H")->cs_coil=8.42;
	get_address("N")->cs_coil=119.4;
	get_address("CA")->cs_coil=53.0;
	get_address("HA")->cs_coil=4.75;
	get_address("CB")->cs_coil=38.9;
	get_address("C")->cs_coil=174.9;

	get_address("H")->cs_mean=8.33;
	get_address("N")->cs_mean=118.89;
	get_address("CA")->cs_mean=53.57;
	get_address("HA")->cs_mean=4.66;
	get_address("CB")->cs_mean=38.69;
	get_address("C")->cs_mean=175.30;


	get_address("H")->cs_wang=8.35;
	get_address("N")->cs_wang=118.50;
	get_address("CA")->cs_wang=53.00;
	get_address("HA")->cs_wang=4.66;
	get_address("CB")->cs_wang=38.43;
	get_address("C")->cs_wang=174.84;

	coil_pre[0]=-0.76;
	coil_pre[1]=-0.19;
	coil_pre[2]= 0.18;
	coil_pre[3]=-0.20;
	coil_pre[4]= 0.01;
	coil_pre[5]=-0.03;


	coil_fol[0]=-0.03;
	coil_fol[1]=-0.23;
	coil_fol[2]=+0.24;
	coil_fol[3]=-0.06;
	coil_fol[4]= 0.04;
	coil_fol[5]=-0.04;
}
	
CAsn::~CAsn() {}




//ASP
void CAsp::schbond(vector<bbhbond_group> *grp)
{
	bbhbond_group t;
	t.id=residue;
	t.code=OneLetterName;
	t.npos=-1;
	t.hpos=-1;
	t.cpos=get("CG").index;
	t.opos=get("OD1").index;
	t.type=22; 

	grp->push_back(t);
	return;
}

	

	


struct noeatoms CAsp::query(string name)
{
	struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}


void CAsp::ani(vector<struct ani_group> *anistropy)
{
	struct ani_group t;
	CAminoacid::ani(anistropy);


	t.type=3;
	t.id=residue;
	t.code=OneLetterName;
	t.pos[0]=get("OD1").index;
	t.pos[1]=get("CG").index;
	t.pos[2]=get("OD2").index;
	anistropy->push_back(t);
	
	return ;
}

void CAsp::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=4;
	t.x1=get("CA").index;
	t.x2=get("CB").index;
	t.x3=get("CG").index;
	t.x4=get("OD1").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	return;
}

CAsp::CAsp() 
{
    //CAminoacid::CAminoacid();
	OneLetterName='D';strcpy(ThreeLetterName,"ASP");

	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;

	t.bb=0;
	t.proton=0;
	t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG";t.cs_name="CG";t.base_name="CB";atoms.push_back(t);
	t.name="OD1";t.cs_name="OD1";t.base_name="CB";atoms.push_back(t);
	t.name="OD2";t.cs_name="OD2";t.base_name="CB";atoms.push_back(t);
	
	t.proton=1;t.carbon_name="CB";
	t.proton_type=24;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=25;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);
		
	get_address("H")->cs_coil=8.31;
	get_address("N")->cs_coil=121.5;
	get_address("CA")->cs_coil=53.8;
	get_address("HA")->cs_coil=4.71;
	get_address("CB")->cs_coil=41.2;
	get_address("C")->cs_coil=175.7;

	get_address("H")->cs_mean=8.30;
	get_address("N")->cs_mean=120.63;
	get_address("CA")->cs_mean=54.71;
	get_address("HA")->cs_mean=4.59;
	get_address("CB")->cs_mean=40.87;
	get_address("C")->cs_mean=176.43;

	get_address("H")->cs_wang=8.31;
	get_address("N")->cs_wang=120.37;
	get_address("CA")->cs_wang=54.00;
	get_address("HA")->cs_wang=4.62;
	get_address("CB")->cs_wang=40.78;
	get_address("C")->cs_wang=176.00;

	coil_pre[0]=-0.43;
	coil_pre[1]= 0.07;
	coil_pre[2]= 0.20;
	coil_pre[3]=-0.07;
	coil_pre[4]=-0.01;
	coil_pre[5]=-0.03;

	coil_fol[0]= 0.23;
	coil_fol[1]=-0.11;
	coil_fol[2]= 0.28;
	coil_fol[3]= 0.11;
	coil_fol[4]= 0.04;
	coil_fol[5]=-0.03;
}
CAsp::~CAsp() {}


//CYS
struct noeatoms CCys::query(string name)
{	
	struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}




void CCys::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("SG").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	return;
}

CCys::CCys() 
{
	//CAminoacid::CAminoacid();
	OneLetterName='C';strcpy(ThreeLetterName,"CYS");
	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;
	t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="SG";t.cs_name="SG";t.base_name="CB";atoms.push_back(t);
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=26;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=27;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);
	t.carbon_name="SG";
	t.proton_type=28;t.name="HG";t.cs_name="HG";t.base_name="HG";atoms.push_back(t);


	get_address("H")->cs_coil=8.20;
	get_address("N")->cs_coil=120.1;
	get_address("CA")->cs_coil=58.2;
	get_address("HA")->cs_coil=4.96;
	get_address("CB")->cs_coil=29.4;
	get_address("C")->cs_coil=174.7;

	get_address("H")->cs_mean=8.38;
	get_address("N")->cs_mean=120.09;
	get_address("CA")->cs_mean=58.31;
	get_address("HA")->cs_mean=4.64;
	get_address("CB")->cs_mean=32.66;
	get_address("C")->cs_mean=174.98;

	get_address("H")->cs_wang=8.10;
	get_address("N")->cs_wang=118.10;
	get_address("CA")->cs_wang=58.24;
	get_address("HA")->cs_wang=4.59;
	get_address("CB")->cs_wang=29.54;
	get_address("C")->cs_wang=175.11;


	coil_pre[0]= 1.36;
	coil_pre[1]=-0.00;
	coil_pre[2]= 0.44;
	coil_pre[3]=-0.18;
	coil_pre[4]= 0.03;
	coil_pre[5]=-0.00;

	coil_fol[0]=-1.17;
	coil_fol[1]= 0.10;
	coil_fol[2]= 0.17;
	coil_fol[3]= 0.21;
	coil_fol[4]= 0.01;
	coil_fol[5]= 0.03;

}
CCys::~CCys() {}




struct noeatoms CCyx::query(string name)
{
	struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}



void CCyx::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("SG").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	return;
}


CCyx::CCyx() 
{
	//CAminoacid::CAminoacid();
	OneLetterName='C';strcpy(ThreeLetterName,"CYX");
	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;
	t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="SG";t.cs_name="SG";t.base_name="CB";atoms.push_back(t);
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=29;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=30;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);
	t.carbon_name="SG";
	t.proton_type=31;t.name="HG";t.cs_name="HG";t.base_name="HG";atoms.push_back(t);


	get_address("H")->cs_coil=8.20;
	get_address("N")->cs_coil=120.1;
	get_address("CA")->cs_coil=58.2;
	get_address("HA")->cs_coil=4.96;
	get_address("CB")->cs_coil=29.4;
	get_address("C")->cs_coil=174.7;

	get_address("H")->cs_mean=8.38;
	get_address("N")->cs_mean=120.09;
	get_address("CA")->cs_mean=58.31;
	get_address("HA")->cs_mean=4.64;
	get_address("CB")->cs_mean=32.66;
	get_address("C")->cs_mean=174.98;

	get_address("H")->cs_wang=8.10;
	get_address("N")->cs_wang=118.10;
	get_address("CA")->cs_wang=58.24;
	get_address("HA")->cs_wang=4.59;
	get_address("CB")->cs_wang=29.54;
	get_address("C")->cs_wang=175.11;

	coil_pre[0]= 1.36;
	coil_pre[1]=-0.00;
	coil_pre[2]= 0.44;
	coil_pre[3]=-0.18;
	coil_pre[4]= 0.03;
	coil_pre[5]=-0.00;

	coil_fol[0]=-1.17;
	coil_fol[1]= 0.10;
	coil_fol[2]= 0.17;
	coil_fol[3]= 0.21;
	coil_fol[4]= 0.01;
	coil_fol[5]= 0.03;
}
CCyx::~CCyx() {}


//GLN
void CGln::schbond(vector<bbhbond_group> *grp)
{
	bbhbond_group t;
	t.id=residue;
	t.code=OneLetterName;
	t.npos=-1;
	t.hpos=-1;
	t.cpos=get("CD").index;
	t.opos=get("OE1").index;
	t.type=23; 

	grp->push_back(t);
	return;
}


struct noeatoms CGln::query(string name)
{
	struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QG")==0)
	{
		tt.clear();
		tt.push_back(get("HG2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HG3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QE")==0)
	{
		tt.clear();
		tt.push_back(get("HE21").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HE22").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}

void CGln::ani(vector<struct ani_group> *anistropy)
{
	struct ani_group t;
	CAminoacid::ani(anistropy);

	t.type=2;
	t.id=residue;
	t.code=OneLetterName;
	t.pos[0]=get("OE1").index;
	t.pos[1]=get("CD").index;
	t.pos[2]=get("NE2").index;
	anistropy->push_back(t);
	
	return ;
}

void CGln::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=4;
	t.x1=get("CA").index;
	t.x2=get("CB").index;
	t.x3=get("CG").index;
	t.x4=get("CD").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=5;
	t.x1=get("CB").index;
	t.x2=get("CG").index;
	t.x3=get("CD").index;
	t.x4=get("NE2").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	return;
}


CGln::CGln() 
{
    //CAminoacid::CAminoacid();
	OneLetterName='Q';strcpy(ThreeLetterName,"GLN");
	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;
	t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG";t.cs_name="CG";t.base_name="CB";atoms.push_back(t);
	t.name="CD";t.cs_name="CD";t.base_name="CB";atoms.push_back(t);
	t.name="OE1";t.cs_name="OE1";t.base_name="CB";atoms.push_back(t);
	t.name="NE2";t.cs_name="NE2";t.base_name="CB";atoms.push_back(t);

	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=32;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=33;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);
	t.carbon_name="CG";
	t.proton_type=34;t.name="HG2";t.cs_name="HG2";t.base_name="HG";atoms.push_back(t);
	t.proton_type=35;t.name="HG3";t.cs_name="HG3";t.base_name="HG";atoms.push_back(t);
	t.carbon_name="NE2";
	t.proton_type=36;t.name="HE21";t.cs_name="HE21";t.base_name="HE2";atoms.push_back(t);
	t.proton_type=37;t.name="HE22";t.cs_name="HE22";t.base_name="HE2";atoms.push_back(t);

	get_address("H")->cs_coil=8.21;
	get_address("N")->cs_coil=120.2;
	get_address("CA")->cs_coil=55.5;
	get_address("HA")->cs_coil=4.43;
	get_address("CB")->cs_coil=29.4;
	get_address("C")->cs_coil=175.7;

	get_address("H")->cs_mean=8.21;
	get_address("N")->cs_mean=119.85;
	get_address("CA")->cs_mean=56.63;
	get_address("HA")->cs_mean=4.26;
	get_address("CB")->cs_mean=29.16;
	get_address("C")->cs_mean=176.37;

	get_address("H")->cs_wang=8.20;
	get_address("N")->cs_wang=119.82;
	get_address("CA")->cs_wang=55.89;
	get_address("HA")->cs_wang=4.29;
	get_address("CB")->cs_wang=29.01;
	get_address("C")->cs_wang=175.75;

	coil_pre[0]=-0.09;
	coil_pre[1]= 0.07;
	coil_pre[2]= 0.13;
	coil_pre[3]= 0.06;
	coil_pre[4]= 0.01;
	coil_pre[5]=-0.00;

	coil_fol[0]=-0.31;
	coil_fol[1]= 0.10;
	coil_fol[2]= 0.37;
	coil_fol[3]=-0.13;
	coil_fol[4]= 0.01;
	coil_fol[5]=-0.05;
}
CGln::~CGln() {}


//GLU
void CGlu::schbond(vector<bbhbond_group> *grp)
{
	bbhbond_group t;
	t.id=residue;
	t.code=OneLetterName;
	t.npos=-1;
	t.hpos=-1;
	t.cpos=get("CD").index;
	t.opos=get("OE1").index;
	t.type=22; 

	grp->push_back(t);
	return;
}


struct noeatoms CGlu::query(string name)
{
struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QG")==0)
	{
		tt.clear();
		tt.push_back(get("HG2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HG3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}

void CGlu::ani(vector<struct ani_group> *anistropy)
{
	struct ani_group t;
	CAminoacid::ani(anistropy);


	t.type=3;
	t.id=residue;
	t.code=OneLetterName;
	t.pos[0]=get("OE1").index;
	t.pos[1]=get("CD").index;
	t.pos[2]=get("OE2").index;
	anistropy->push_back(t);
	
	return ;
}

void CGlu::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=4;
	t.x1=get("CA").index;
	t.x2=get("CB").index;
	t.x3=get("CG").index;
	t.x4=get("CD").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=5;
	t.x1=get("CB").index;
	t.x2=get("CG").index;
	t.x3=get("CD").index;
	t.x4=get("OE1").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	return;
}


CGlu::CGlu() 
{
    //CAminoacid::CAminoacid();
	OneLetterName='E';strcpy(ThreeLetterName,"GLU");
	struct Atom t;
	
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;
	t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG";t.cs_name="CG";t.base_name="CB";atoms.push_back(t);
	t.name="CD";t.cs_name="CD";t.base_name="CB";atoms.push_back(t);
	t.name="OE1";t.cs_name="OE1";t.base_name="CB";atoms.push_back(t);
	t.name="OE2";t.cs_name="OE2";t.base_name="CB";atoms.push_back(t);

	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=38;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=39;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);
	t.carbon_name="CG";
	t.proton_type=40;t.name="HG2";t.cs_name="HG2";t.base_name="HG";atoms.push_back(t);
	t.proton_type=41;t.name="HG3";t.cs_name="HG3";t.base_name="HG";atoms.push_back(t);
	
	get_address("H")->cs_coil=8.36;
	get_address("N")->cs_coil=121.4;
	get_address("CA")->cs_coil=56.3;
	get_address("HA")->cs_coil=4.39;
	get_address("CB")->cs_coil=30.3;
	get_address("C")->cs_coil=175.9;
	
	get_address("H")->cs_mean=8.33;
	get_address("N")->cs_mean=120.66;
	get_address("CA")->cs_mean=57.37;
	get_address("HA")->cs_mean=4.25;
	get_address("CB")->cs_mean=29.98;
	get_address("C")->cs_mean=176.93;


	get_address("H")->cs_wang=8.36;
	get_address("N")->cs_wang=120.62;
	get_address("CA")->cs_wang=56.66;
	get_address("HA")->cs_wang=4.28;
	get_address("CB")->cs_wang=29.87;
	get_address("C")->cs_wang=176.32;

	coil_pre[0]=-0.36;
	coil_pre[1]= 0.04;
	coil_pre[2]= 0.01;
	coil_pre[3]= 0.04;
	coil_pre[4]=-0.01;
	coil_pre[5]=-0.01;

	coil_fol[0]= 0.26;
	coil_fol[1]= 0.14;
	coil_fol[2]= 0.25;
	coil_fol[3]= 0.06;
	coil_fol[4]= 0.07;
	coil_fol[5]=-0.04;
}
CGlu::~CGlu() {}

//GLY

struct noeatoms CGly::query(string name)
{
	struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QA")==0)
	{
		tt.clear();
		tt.push_back(get("HA2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HA3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}



void CGly::dihe(vector<dihe_group> * dihe_index)
{
	return;
}

CGly::CGly() 
{
    //CAminoacid::CAminoacid();
	bexploaded=0;
	atoms.clear();
	order_parameters.clear();
	OneLetterName='G';strcpy(ThreeLetterName,"GLY");
	
	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=1;
	t.proton=0;
	t.ambig=0;
	t.proton=0;t.name="N";t.cs_name="N";t.base_name="N";atoms.push_back(t);
	t.proton=1;t.name="H";t.cs_name="H";t.base_name="H";atoms.push_back(t);
	t.proton=0;t.name="CA";t.cs_name="CA";t.base_name="CA";atoms.push_back(t);
	t.proton=0;t.name="C";t.cs_name="C";t.base_name="C";atoms.push_back(t);
	t.proton=0;t.name="O";t.cs_name="O";t.base_name="O";atoms.push_back(t);
	
	t.proton=1;
	t.carbon_name="CA";
	t.proton_type=42;t.name="HA2";t.cs_name="HA2";t.base_name="HA";atoms.push_back(t);
	t.proton_type=43;t.name="HA3";t.cs_name="HA3";t.base_name="HA";atoms.push_back(t);


	struct S2 s2;
	s2.name1="N";s2.name2="H";s2.exp=999.0;s2.pre=999.0;order_parameters.push_back(s2);
	s2.name1="N";s2.name2="CA";s2.exp=999.0;s2.pre=999.0;order_parameters.push_back(s2);
	s2.name1="CA";s2.name2="C";s2.exp=999.0;s2.pre=999.0;order_parameters.push_back(s2);
	s2.name1="C0";s2.name2="N";s2.exp=999.0;s2.pre=999.0;order_parameters.push_back(s2);

	get_address("H")->cs_coil=8.31;
	get_address("N")->cs_coil=109.8;
	get_address("CA")->cs_coil=45.2;
	get_address("HA1")->cs_coil=4.12;
	get_address("HA2")->cs_coil=4.12;
	get_address("C")->cs_coil=173.9;

	get_address("H")->cs_mean=8.33;
	get_address("N")->cs_mean=109.60;
	get_address("CA")->cs_mean=45.36;
	get_address("HA1")->cs_mean=3.97;
	get_address("HA2")->cs_mean=3.90;
	get_address("C")->cs_mean=173.38;

	get_address("H")->cs_wang=8.37;
	get_address("N")->cs_wang=109.48;
	get_address("CA")->cs_wang=45.28;
	get_address("HA1")->cs_wang=3.97;
	get_address("HA2")->cs_wang=3.97;
	get_address("C")->cs_wang=174.01;

	coil_pre[0]=-0.43;
	coil_pre[1]=-0.09;
	coil_pre[2]=-0.26;
	coil_pre[3]= 0.17;
	coil_pre[4]=-0.10;
	coil_pre[5]= 0.04;


	coil_fol[0]= 0.13;
	coil_fol[1]= 0.47;
	coil_fol[2]= 0.12;
	coil_fol[3]=-0.07;
	coil_fol[4]= 0.06;
	coil_fol[5]=-0.03;
}
CGly::~CGly() {}



//HIS
struct noeatoms CHis::query(string name)
{
	struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}

void CHis::ring(vector<ring_group> *ring)
{
	ring_group t;
	t.x1=3; //type
	t.x2=get("CG").index;
	t.x3=get("ND1").index;
	t.x4=get("CE1").index;
	t.x5=get("NE2").index;
	t.x6=get("CD2").index;
	ring->push_back(t);
	return ;
}

void CHis::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=4;
	t.x1=get("CA").index;
	t.x2=get("CB").index;
	t.x3=get("CG").index;
	t.x4=get("ND1").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	return;
}

CHis::CHis() 
{
    //CAminoacid::CAminoacid();
	OneLetterName='H';strcpy(ThreeLetterName,"HIS");

	struct Atom t;
	
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;
	t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG";t.cs_name="CG";t.base_name="CB";atoms.push_back(t);
	t.name="CD2";t.cs_name="CD2";t.base_name="CB";atoms.push_back(t);
	t.name="ND1";t.cs_name="ND1";t.base_name="CB";atoms.push_back(t);
	t.name="CE1";t.cs_name="CE1";t.base_name="CB";atoms.push_back(t);
	t.name="NE2";t.cs_name="NE2";t.base_name="CB";atoms.push_back(t);
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=44;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=45;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);
	t.carbon_name="ND1";
	t.proton_type=46;t.name="HD1";t.cs_name="HD1";t.base_name="HD1";atoms.push_back(t);
	t.carbon_name="CD2";
	t.proton_type=47;t.name="HD2";t.cs_name="HD2";t.base_name="HD2";atoms.push_back(t);
	t.carbon_name="CE1";
	t.proton_type=48;t.name="HE1";t.cs_name="HE1";t.base_name="HE1";atoms.push_back(t);
	t.carbon_name="NE2";
	t.proton_type=49;t.name="HE2";t.cs_name="HE2";t.base_name="HE2";atoms.push_back(t);
		
	get_address("H")->cs_coil=8.29;
	get_address("N")->cs_coil=119.7;
	get_address("CA")->cs_coil=55.3;
	get_address("HA")->cs_coil=4.73;
	get_address("CB")->cs_coil=30.1;
	get_address("C")->cs_coil=174.4;
	
	get_address("H")->cs_mean=8.24;
	get_address("N")->cs_mean=119.67;
	get_address("CA")->cs_mean=56.55;
	get_address("HA")->cs_mean=4.60;
	get_address("CB")->cs_mean=30.22;
	get_address("C")->cs_mean=175.28;

	get_address("H")->cs_wang=8.18;
	get_address("N")->cs_wang=118.92;
	get_address("CA")->cs_wang=55.74;
	get_address("HA")->cs_wang=4.60;
	get_address("CB")->cs_wang=29.50;
	get_address("C")->cs_wang=174.78;

	coil_pre[0]=-0.05;
	coil_pre[1]=-0.13;
	coil_pre[2]= 0.16;
	coil_pre[3]= 0.07;
	coil_pre[4]=-0.01;
	coil_pre[5]=-0.05;

	coil_fol[0]=-0.09;
	coil_fol[1]=-0.05;
	coil_fol[2]= 0.22;
	coil_fol[3]=-0.24;
	coil_fol[4]=-0.01;
	coil_fol[5]=-0.09;

}
CHis::~CHis() {}



//ILE

struct noeatoms CIle::query(string name)
{
struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QG")==0)
	{
		tt.clear();
		tt.push_back(get("HG12").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HG13").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("MG")==0 || name.compare("QG2")==0)
	{
		tt.push_back(get("HG21").index);
		tt.push_back(get("HG22").index);
		tt.push_back(get("HG23").index);
		t.atoms.push_back(tt);
		t.length=0.0;
	}
	else if(name.compare("MD")==0|| name.compare("QD1")==0)
	{
		tt.push_back(get("HD11").index);
		tt.push_back(get("HD12").index);
		tt.push_back(get("HD13").index);
		t.atoms.push_back(tt);
		t.length=0.0;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}

void CIle::proton2(vector<struct proton> *sel)
{
	struct proton t;

	t.type=9;
	t.name="HG2";
	get_proton(&t);
	sel->push_back(t);

	t.type=10;
	t.name="HD1";
	get_proton(&t);
	sel->push_back(t);

	return;
}


void CIle::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG1").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=4;
	t.x1=get("CA").index;
	t.x2=get("CB").index;
	t.x3=get("CG1").index;
	t.x4=get("CD1").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);
	
	return;
}



CIle::CIle() 
{
	//CAminoacid::CAminoacid();
	OneLetterName='I';strcpy(ThreeLetterName,"ILE");
	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;
	t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG2";t.cs_name="CG2";t.base_name="CB";atoms.push_back(t);
	t.name="CG1";t.cs_name="CG1";t.base_name="CB";atoms.push_back(t);
	t.name="CD1";t.cs_name="CD1";t.base_name="CB";atoms.push_back(t);
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=50;t.name="HB";t.cs_name="HB";t.base_name="HB";atoms.push_back(t);
	t.carbon_name="CG2";
	t.proton_type=9;t.name="HG21";t.cs_name="HG2";t.base_name="HG2";atoms.push_back(t);
	t.proton_type=9;t.name="HG22";t.cs_name="HG2";t.base_name="HG2";atoms.push_back(t);
	t.proton_type=9;t.name="HG23";t.cs_name="HG2";t.base_name="HG2";atoms.push_back(t);
	
	t.carbon_name="CG1";
	t.proton_type=51;t.name="HG12";t.cs_name="HG12";t.base_name="HG1";atoms.push_back(t);
	t.proton_type=52;t.name="HG13";t.cs_name="HG13";t.base_name="HG1";atoms.push_back(t);

	t.carbon_name="CD1";
	t.proton_type=10;t.name="HD11";t.cs_name="HD1";t.base_name="HD1";atoms.push_back(t);
	t.proton_type=10;t.name="HD12";t.cs_name="HD1";t.base_name="HD1";atoms.push_back(t);
	t.proton_type=10;t.name="HD13";t.cs_name="HD1";t.base_name="HD1";atoms.push_back(t);
		
	get_address("H")->cs_coil=8.30;
	get_address("N")->cs_coil=122.0;
	get_address("CA")->cs_coil=60.4;
	get_address("HA")->cs_coil=4.31;
	get_address("CB")->cs_coil=38.7;
	get_address("C")->cs_coil=174.9;
		
	get_address("H")->cs_mean=8.22;
	get_address("N")->cs_mean=121.79;
	get_address("CA")->cs_mean=55.70;
	get_address("HA")->cs_mean=4.30;
	get_address("CB")->cs_mean=42.27;
	get_address("C")->cs_mean=177.06;

	get_address("H")->cs_wang=7.94;
	get_address("N")->cs_wang=120.58;
	get_address("CA")->cs_wang=60.79;
	get_address("HA")->cs_wang=4.18;
	get_address("CB")->cs_wang=38.43;
	get_address("C")->cs_wang=175.52;


	coil_pre[0]= 2.92;
	coil_pre[1]= 0.11;
	coil_pre[2]=-0.15;
	coil_pre[3]= 0.26;
	coil_pre[4]= 0.12;
	coil_pre[5]= 0.04;

	coil_fol[0]=-0.20;
	coil_fol[1]=-0.09;
	coil_fol[2]= 0.03;
	coil_fol[3]= 0.28;
	coil_fol[4]=-0.01;
	coil_fol[5]= 0.03;
}
CIle::~CIle() {}




//LEU

void CLeu::methyl_ambig(int flag)
{
	int i;
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).base_name=="HD1" && atoms.at(i).ambig==2)
		{
			if(atoms.at(i).cs_exp>0.0)
				atoms.at(i).cs_exp=999.0;
		}
		if(atoms.at(i).base_name=="HD2" && atoms.at(i).ambig==2)
		{
			if(atoms.at(i).cs_exp>0.0)
				atoms.at(i).cs_exp=999.0;
		}
	}
	return;
}

struct noeatoms CLeu::query(string name)
{
struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("MD2")==0 || name.compare("QD2")==0)
	{
		tt.push_back(get("HD21").index);
		tt.push_back(get("HD22").index);
		tt.push_back(get("HD23").index);
		t.atoms.push_back(tt);
		t.length=0.0;
	}
	else if(name.compare("MD1")==0|| name.compare("QD1")==0)
	{
		tt.push_back(get("HD11").index);
		tt.push_back(get("HD12").index);
		tt.push_back(get("HD13").index);
		t.atoms.push_back(tt);
		t.length=0.0;
	}
	else if(name.compare("QD")==0)
	{
		tt.clear();
		tt.push_back(get("HD21").index);
		tt.push_back(get("HD22").index);
		tt.push_back(get("HD23").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HD11").index);
		tt.push_back(get("HD12").index);
		tt.push_back(get("HD13").index);
		t.atoms.push_back(tt);
		t.length=5.0;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}

void CLeu::proton2(vector<struct proton> *sel)
{
	struct proton t;


	t.type=7;
	t.name="HD1";
	get_proton(&t);
	sel->push_back(t);

	t.type=8;
	t.name="HD2";
	get_proton(&t);
	sel->push_back(t);

	return;
}


void CLeu::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;	
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=4;
	t.x1=get("CA").index;
	t.x2=get("CB").index;
	t.x3=get("CG").index;
	t.x4=get("CD1").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	return;
}

CLeu::CLeu() 
{
    //CAminoacid::CAminoacid();
	OneLetterName='L';strcpy(ThreeLetterName,"LEU");
	
	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;
	t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG";t.cs_name="CG";t.base_name="CB";atoms.push_back(t);
	t.name="CD1";t.cs_name="CD1";t.base_name="CB";atoms.push_back(t);
	t.name="CD2";t.cs_name="CD2";t.base_name="CB";atoms.push_back(t);
	
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=53;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=54;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);
	
	t.carbon_name="CG";
	t.proton_type=55;t.name="HG";t.cs_name="HG";t.base_name="HG";atoms.push_back(t);
	
	t.carbon_name="CD1";
	t.proton_type=7;t.name="HD11";t.cs_name="HD1";t.base_name="HD1";atoms.push_back(t);
	t.proton_type=7;t.name="HD12";t.cs_name="HD1";t.base_name="HD1";atoms.push_back(t);
	t.proton_type=7;t.name="HD13";t.cs_name="HD1";t.base_name="HD1";atoms.push_back(t);

	t.carbon_name="CD2";
	t.proton_type=8;t.name="HD21";t.cs_name="HD2";t.base_name="HD2";atoms.push_back(t);
	t.proton_type=8;t.name="HD22";t.cs_name="HD2";t.base_name="HD2";atoms.push_back(t);
	t.proton_type=8;t.name="HD23";t.cs_name="HD2";t.base_name="HD2";atoms.push_back(t);
		
	get_address("H")->cs_coil=8.18;
	get_address("N")->cs_coil=122.3;
	get_address("CA")->cs_coil=54.5;
	get_address("HA")->cs_coil=4.47;
	get_address("CB")->cs_coil=42.5;
	get_address("C")->cs_coil=176.4;

		
	get_address("H")->cs_mean=8.22;
	get_address("N")->cs_mean=121.79;
	get_address("CA")->cs_mean=55.70;
	get_address("HA")->cs_mean=4.30;
	get_address("CB")->cs_mean=42.27;
	get_address("C")->cs_mean=177.06;

	get_address("H")->cs_wang=8.06;
	get_address("N")->cs_wang=121.57;
	get_address("CA")->cs_wang=54.77;
	get_address("HA")->cs_wang=4.36;
	get_address("CB")->cs_wang=42.14;
	get_address("C")->cs_wang=176.70;


	coil_pre[0]=-0.76;
	coil_pre[1]= 0.13;
	coil_pre[2]=-0.07;
	coil_pre[3]=-0.03;
	coil_pre[4]=-0.06;
	coil_pre[5]= 0.00;

	coil_fol[0]=-0.49;
	coil_fol[1]= 0.06;
	coil_fol[2]= 0.10;
	coil_fol[3]=-0.10;
	coil_fol[4]=-0.07;
	coil_fol[5]=-0.02;
}
CLeu::~CLeu() {}




//LYS

struct noeatoms CLys::query(string name)
{
struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QG")==0)
	{
		tt.clear();
		tt.push_back(get("HG2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HG3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QD")==0)
	{
		tt.clear();
		tt.push_back(get("HD2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HD3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QE")==0)
	{
		tt.clear();
		tt.push_back(get("HE2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HE3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}

void CLys::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=4;
	t.x1=get("CA").index;
	t.x2=get("CB").index;
	t.x3=get("CG").index;
	t.x4=get("CD").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=5;
	t.x1=get("CB").index;
	t.x2=get("CG").index;
	t.x3=get("CD").index;
	t.x4=get("CE").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=6;
	t.x1=get("CG").index;
	t.x2=get("CD").index;
	t.x3=get("CE").index;
	t.x4=get("NZ").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	return;
}


CLys::CLys() 
{
    //CAminoacid::CAminoacid();
	OneLetterName='K';strcpy(ThreeLetterName,"LYS");
	
	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG";t.cs_name="CG";t.base_name="CB";atoms.push_back(t);
	t.name="CD";t.cs_name="CD";t.base_name="CB";atoms.push_back(t);
	t.name="CE";t.cs_name="CE";t.base_name="CB";atoms.push_back(t);
	t.name="NZ";t.cs_name="NZ";t.base_name="CB";atoms.push_back(t);

	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=56;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=57;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);
	t.carbon_name="CG";
	t.proton_type=58;t.name="HG2";t.cs_name="HG2";t.base_name="HG";atoms.push_back(t);
	t.proton_type=59;t.name="HG3";t.cs_name="HG3";t.base_name="HG";atoms.push_back(t);
	t.carbon_name="CD";
	t.proton_type=60;t.name="HD2";t.cs_name="HD2";t.base_name="HD";atoms.push_back(t);
	t.proton_type=61;t.name="HD3";t.cs_name="HD3";t.base_name="HD";atoms.push_back(t);
	t.carbon_name="CE";
	t.proton_type=62;t.name="HE2";t.cs_name="HE2";t.base_name="HE";atoms.push_back(t);
	t.proton_type=63;t.name="HE3";t.cs_name="HE3";t.base_name="HE";atoms.push_back(t);
	t.carbon_name="NZ";
	t.proton_type=64;t.name="HZ1";t.cs_name="HZ";t.base_name="HZ";atoms.push_back(t);
	t.proton_type=64;t.name="HZ2";t.cs_name="HZ";t.base_name="HZ";atoms.push_back(t);
	t.proton_type=64;t.name="HZ3";t.cs_name="HZ";t.base_name="HZ";atoms.push_back(t);
		
	get_address("H")->cs_coil=8.24;
	get_address("N")->cs_coil=121.8;
	get_address("CA")->cs_coil=56.2;
	get_address("HA")->cs_coil=4.36;
	get_address("CB")->cs_coil=32.8;
	get_address("C")->cs_coil=176.0;
		
	get_address("H")->cs_mean=8.18;
	get_address("N")->cs_mean=121.00;
	get_address("CA")->cs_mean=57.00;
	get_address("HA")->cs_mean=4.26;
	get_address("CB")->cs_mean=32.78;
	get_address("C")->cs_mean=176.71;

	get_address("H")->cs_wang=8.17;
	get_address("N")->cs_wang=121.1;
	get_address("CA")->cs_wang=56.29;
	get_address("HA")->cs_wang=4.28;
	get_address("CB")->cs_wang=32.53;
	get_address("C")->cs_wang=176.15;

	coil_pre[0]=-0.26;
	coil_pre[1]=-0.09;
	coil_pre[2]=-0.07;
	coil_pre[3]= 0.08;
	coil_pre[4]=-0.02;
	coil_pre[5]=-0.00;

	coil_fol[0]=-0.13;
	coil_fol[1]=-0.13;
	coil_fol[2]= 0.08;
	coil_fol[3]= 0.01;
	coil_fol[4]=-0.04;
	coil_fol[5]=-0.03;
}
CLys::~CLys() {}



//MET

struct noeatoms CMet::query(string name)
{
	struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QG")==0)
	{
		tt.clear();
		tt.push_back(get("HG2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HG3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("ME")==0 || name.compare("QE")==0)
	{
		tt.clear();
		tt.push_back(get("HE1").index);
		tt.push_back(get("HE2").index);
		tt.push_back(get("HE3").index);
		t.atoms.push_back(tt);
		t.length=0.0;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}


void CMet::proton2(vector<struct proton> *sel)
{
	struct proton t;


	t.type=3;
	t.name="HE";
	get_proton(&t);
	sel->push_back(t);

	return;
}


void CMet::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=4;
	t.x1=get("CA").index;
	t.x2=get("CB").index;
	t.x3=get("CG").index;
	t.x4=get("SD").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=5;
	t.x1=get("CB").index;
	t.x2=get("CG").index;
	t.x3=get("SD").index;
	t.x4=get("CE").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	return;
}

CMet::CMet() 
{
    //CAminoacid::CAminoacid();
	OneLetterName='M';strcpy(ThreeLetterName,"MET");

	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG";t.cs_name="CG";t.base_name="CB";atoms.push_back(t);
	t.name="SD";t.cs_name="SD";t.base_name="CB";atoms.push_back(t);
	t.name="CE";t.cs_name="CE";t.base_name="CB";atoms.push_back(t);

	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=65;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=66;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);
	t.carbon_name="CG";
	t.proton_type=67;t.name="HG2";t.cs_name="HG2";t.base_name="HG";atoms.push_back(t);
	t.proton_type=68;t.name="HG3";t.cs_name="HG3";t.base_name="HG";atoms.push_back(t);
	
	t.carbon_name="CE";
	t.proton_type=3;t.name="HE1";t.cs_name="HE";t.base_name="HE";atoms.push_back(t);
	t.proton_type=3;t.name="HE2";t.cs_name="HE";t.base_name="HE";atoms.push_back(t);
	t.proton_type=3;t.name="HE3";t.cs_name="HE";t.base_name="HE";atoms.push_back(t);
	
	get_address("H")->cs_coil=8.35;
	get_address("N")->cs_coil=121.2;
	get_address("CA")->cs_coil=55.4;
	get_address("HA")->cs_coil=4.41;
	get_address("CB")->cs_coil=33.7;
	get_address("C")->cs_coil=174.6;

		
	get_address("H")->cs_mean=8.25;
	get_address("N")->cs_mean=120.07;
	get_address("CA")->cs_mean=56.15;
	get_address("HA")->cs_mean=4.40;
	get_address("CB")->cs_mean=32.95;
	get_address("C")->cs_mean=176.24;

	get_address("H")->cs_wang=8.22;
	get_address("N")->cs_wang=120.14;
	get_address("CA")->cs_wang=55.43;
	get_address("HA")->cs_wang=4.47;
	get_address("CB")->cs_wang=32.92;
	get_address("C")->cs_wang=175.94;

	coil_pre[0]= 0.69;
	coil_pre[1]= 0.10;
	coil_pre[2]= 0.09;
	coil_pre[3]= 0.10;
	coil_pre[4]= 0.05;
	coil_pre[5]= 0.05;

	coil_fol[0]=-0.02;
	coil_fol[1]= 0.19;
	coil_fol[2]= 0.22;
	coil_fol[3]= 0.06;
	coil_fol[4]= 0.01;
	coil_fol[5]=-0.01;
}
CMet::~CMet() {}


//PHE 
//special handling for aromatic ring's HD and HE atoms.
/*void CPhe::proton(vector<struct proton> *sel)
{
	struct proton t;
	int i;
	string oldname;

	oldname="XXX";
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).bb==0 && atoms.at(i).proton==1 && atoms.at(i).cs_name!=oldname)
		{
			oldname=atoms.at(i).cs_name;
			t.name=atoms.at(i).cs_name;
			if(get_proton(&t))
				sel->push_back(t);
		}
	}
	return;
}

void CPhe::proton3(vector<struct proton> *sel)
{
	proton(sel);
	return;
}*/


struct noeatoms CPhe::query(string name)
{
struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QD")==0)
	{
		tt.clear();
		tt.push_back(get("HD1").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HD2").index);
		t.atoms.push_back(tt);
		t.length=5.0;
	}
	else if(name.compare("QE")==0)
	{
		tt.clear();
		tt.push_back(get("HE1").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HE2").index);
		t.atoms.push_back(tt);
		t.length=5.0;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}

void CPhe::ring(vector<ring_group> *ring)
{
	ring_group t;

	t.x1=1; //type
	t.x2=get("CG").index;
	t.x3=get("CD1").index;
	t.x4=get("CE1").index;
	t.x5=get("CZ").index;
	t.x6=get("CE2").index;
	t.x7=get("CD2").index;

	ring->push_back(t);
	return ;
}

void CPhe::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=4;
	t.x1=get("CA").index;
	t.x2=get("CB").index;
	t.x3=get("CG").index;
	t.x4=get("CD1").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	return;
}


CPhe::CPhe() 
{
    //CAminoacid::CAminoacid();
	OneLetterName='F';strcpy(ThreeLetterName,"PHE");
	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG";t.cs_name="CG";t.base_name="CB";atoms.push_back(t);
	t.name="CD1";t.cs_name="CD";t.base_name="CB";atoms.push_back(t);
	t.name="CD2";t.cs_name="CD";t.base_name="CB";atoms.push_back(t);
	t.name="CE1";t.cs_name="CE";t.base_name="CB";atoms.push_back(t);
	t.name="CE2";t.cs_name="CE";t.base_name="CB";atoms.push_back(t);
	t.name="CZ";t.cs_name="CZ";t.base_name="CB";atoms.push_back(t);
	
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=69;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=70;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);

	t.carbon_name="CD1";
	t.proton_type=71;t.name="HD1";t.cs_name="HD";t.base_name="HD1";atoms.push_back(t);
	t.carbon_name="CD2";
	t.proton_type=71;t.name="HD2";t.cs_name="HD";t.base_name="HD2";atoms.push_back(t);
	t.carbon_name="CE1";
	t.proton_type=72;t.name="HE1";t.cs_name="HE";t.base_name="HE1";atoms.push_back(t);
	t.carbon_name="CE2";
	t.proton_type=72;t.name="HE2";t.cs_name="HE";t.base_name="HE2";atoms.push_back(t);
	t.carbon_name="CZ";
	t.proton_type=73;t.name="HZ";t.cs_name="HZ";t.base_name="HZ";atoms.push_back(t);

	get_address("H")->cs_coil=8.27;
	get_address("N")->cs_coil=120.1;
	get_address("CA")->cs_coil=57.2;
	get_address("HA")->cs_coil=4.65;
	get_address("CB")->cs_coil=40.2;
	get_address("C")->cs_coil=175.0;
		
	get_address("H")->cs_mean=8.34;
	get_address("N")->cs_mean=120.39;
	get_address("CA")->cs_mean=58.16;
	get_address("HA")->cs_mean=4.62;
	get_address("CB")->cs_mean=39.95;
	get_address("C")->cs_mean=175.48;

	get_address("H")->cs_wang=8.09;
	get_address("N")->cs_wang=119.72;
	get_address("CA")->cs_wang=57.46;
	get_address("HA")->cs_wang=4.59;
	get_address("CB")->cs_wang=39.41;
	get_address("C")->cs_wang=175.46;

	coil_pre[0]= 0.20;
	coil_pre[1]=-0.14;
	coil_pre[2]= 0.02;
	coil_pre[3]=-0.06;
	coil_pre[4]= 0.01;
	coil_pre[5]=-0.01;

	coil_fol[0]=-0.35;
	coil_fol[1]=-0.22;
	coil_fol[2]=-0.04;
	coil_fol[3]=-0.09;
	coil_fol[4]=-0.04;
	coil_fol[5]=-0.02;
}
CPhe::~CPhe() {}


//PRO

struct noeatoms CPro::query(string name)
{
struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QG")==0)
	{
		tt.clear();
		tt.push_back(get("HG2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HG3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QD")==0)
	{
		tt.clear();
		tt.push_back(get("HD2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HD3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}



void CPro::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG").index;
	//dihe_index->push_back(t);

	t.type=3;
	t.x1=get("CA").index;
	t.x2=get("CB").index;
	t.x3=get("CG").index;
	t.x4=get("CD").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=5;
	t.x1=get("CB").index;
	t.x2=get("CG").index;
	t.x3=get("CD").index;
	t.x4=get("n").index;
	//dihe_index->push_back(t);

	return;
}

CPro::CPro() 
{
    //CAminoacid::CAminoacid();
	bexploaded=0;
	atoms.clear();order_parameters.clear();
	OneLetterName='P';strcpy(ThreeLetterName,"PRO");

	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=1;
	t.proton=0;t.ambig=0;
	t.proton=0;t.name="N";t.cs_name="N";t.base_name="N";atoms.push_back(t);
	t.proton=0;t.name="CA";t.cs_name="CA";t.base_name="CA";atoms.push_back(t);
	t.proton=1;t.name="HA";t.cs_name="HA";t.base_name="HA";atoms.push_back(t);
	t.proton=0;t.name="C";t.cs_name="C";t.base_name="C";atoms.push_back(t);
	t.proton=0;t.name="O";t.cs_name="O";t.base_name="O";atoms.push_back(t);

	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;
	t.bb=0;
	t.proton=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG";t.cs_name="CG";t.base_name="CB";atoms.push_back(t);
	t.name="CD";t.cs_name="CD";t.base_name="CB";atoms.push_back(t);
	
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=74;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=75;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);
	t.carbon_name="CG";
	t.proton_type=76;t.name="HG2";t.cs_name="HG2";t.base_name="HG";atoms.push_back(t);
	t.proton_type=77;t.name="HG3";t.cs_name="HG3";t.base_name="HG";atoms.push_back(t);
	t.carbon_name="CD";
	t.proton_type=78;t.name="HD2";t.cs_name="HD2";t.base_name="HD";atoms.push_back(t);
	t.proton_type=79;t.name="HD3";t.cs_name="HD3";t.base_name="HD";atoms.push_back(t);


	get_address("CA")->cs_coil=62.6;
	get_address("HA")->cs_coil=4.44;
	get_address("CB")->cs_coil=31.9;
	get_address("C")->cs_coil=176.1;

		
	get_address("CA")->cs_mean=63.36;
	get_address("HA")->cs_mean=4.39;
	get_address("CB")->cs_mean=31.85;
	get_address("C")->cs_mean=176.76;

	get_address("CA")->cs_wang=63.24;
	get_address("HA")->cs_wang=4.41;
	get_address("CB")->cs_wang=31.81;
	get_address("C")->cs_wang=176.62;

	coil_pre[0]=-0.94;
	coil_pre[1]= 0.21;
	coil_pre[2]= 0.07;
	coil_pre[3]=-0.16;
	coil_pre[4]= 0.14;
	coil_pre[5]=-0.04;

	coil_fol[0]= 0.92;
	coil_fol[1]=-1.19;
	coil_fol[2]=-2.04;
	coil_fol[3]=-0.20;
	coil_fol[4]=-0.17;
	coil_fol[5]= 0.21;

}
CPro::~CPro() {}


//SER
void CSer::schbond(vector<bbhbond_group> *grp)
{
	bbhbond_group t;
	t.id=residue;
	t.code=OneLetterName;
	t.cpos=-1;
	t.opos=-1;
	t.npos=get("OG").index;
	t.hpos=get("HG").index;
	t.type=12; 

	grp->push_back(t);
	return;
}

struct noeatoms CSer::query(string name)
{
	struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}


void CSer::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("OG").index;	
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	return;
}



CSer::CSer() 
{
    //CAminoacid::CAminoacid();
	OneLetterName='S';strcpy(ThreeLetterName,"SER");
	
	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="OG";t.cs_name="OG";t.base_name="CB";atoms.push_back(t);
	
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=80;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=81;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);
	t.carbon_name="OG";
	t.proton_type=82;t.name="HG";t.cs_name="HG";t.base_name="HG";atoms.push_back(t);

	get_address("H")->cs_coil=8.36;
	get_address("N")->cs_coil=116.8;
	get_address("CA")->cs_coil=58.1;
	get_address("HA")->cs_coil=4.55;
	get_address("CB")->cs_coil=64.1;
	get_address("C")->cs_coil=174.2;

		
	get_address("H")->cs_mean=8.28;
	get_address("N")->cs_mean=116.27;
	get_address("CA")->cs_mean=58.76;
	get_address("HA")->cs_mean=4.47;
	get_address("CB")->cs_mean=63.79;
	get_address("C")->cs_mean=174.65;

	get_address("H")->cs_wang=8.22;
	get_address("N")->cs_wang=116.00;
	get_address("CA")->cs_wang=58.20;
	get_address("HA")->cs_wang=4.45;
	get_address("CB")->cs_wang=63.75;
	get_address("C")->cs_wang=174.41;

	coil_pre[0]= 1.16;
	coil_pre[1]=-0.10;
	coil_pre[2]= 0.11;
	coil_pre[3]=-0.06;
	coil_pre[4]= 0.02;
	coil_pre[5]= 0.01;

	coil_fol[0]= 0.30;
	coil_fol[1]= 0.10;
	coil_fol[2]= 0.10;
	coil_fol[3]= 0.14;
	coil_fol[4]= 0.07;
	coil_fol[5]= 0.02;
}
CSer::~CSer() {}


//THR
void CThr::schbond(vector<bbhbond_group> *grp)
{
	bbhbond_group t;
	t.id=residue;
	t.code=OneLetterName;
	t.cpos=-1;
	t.opos=-1;
	t.npos=get("OG1").index;
	t.hpos=get("HG1").index;
	t.type=12; 

	grp->push_back(t);
	return;
}



struct noeatoms CThr::query(string name)
{
	struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("MG")==0|| name.compare("QG2")==0)
	{
		tt.push_back(get("HG21").index);
		tt.push_back(get("HG22").index);
		tt.push_back(get("HG23").index);
		t.atoms.push_back(tt);
		t.length=0.0;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;;
}

void CThr::proton2(vector<struct proton> *sel)
{
	struct proton t;

	t.type=2;
	t.name="HG2";
	get_proton(&t);
	sel->push_back(t);


	return;
}


void CThr::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG2").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	return;
}

CThr::CThr() 
{
    //CAminoacid::CAminoacid();
	OneLetterName='T';strcpy(ThreeLetterName,"THR");
	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="OG1";t.cs_name="OG1";t.base_name="CB";atoms.push_back(t);
	t.name="CG2";t.cs_name="CG2";t.base_name="CB";atoms.push_back(t);
	
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=83;t.name="HB";t.cs_name="HB";t.base_name="HB";atoms.push_back(t);
	t.carbon_name="OG1";
	t.proton_type=84;t.name="HG1";t.cs_name="HG1";t.base_name="HG1";atoms.push_back(t);

	t.carbon_name="CG2";
	t.proton_type=2;t.name="HG21";t.cs_name="HG2";t.base_name="HG2";atoms.push_back(t);
	t.proton_type=2;t.name="HG22";t.cs_name="HG2";t.base_name="HG2";atoms.push_back(t);
	t.proton_type=2;t.name="HG23";t.cs_name="HG2";t.base_name="HG2";atoms.push_back(t);
		
	get_address("H")->cs_coil=8.27;
	get_address("N")->cs_coil=114.6;
	get_address("CA")->cs_coil=60.9;
	get_address("HA")->cs_coil=4.55;
	get_address("CB")->cs_coil=69.7;
	get_address("C")->cs_coil=174.5;
		
	get_address("H")->cs_mean=8.24;
	get_address("N")->cs_mean=115.36;
	get_address("CA")->cs_mean=62.28;
	get_address("HA")->cs_mean=4.45;
	get_address("CB")->cs_mean=69.72;
	get_address("C")->cs_mean=174.57;


	get_address("H")->cs_wang=8.16;
	get_address("N")->cs_wang=113.88;
	get_address("CA")->cs_wang=61.30;
	get_address("HA")->cs_wang=4.44;
	get_address("CB")->cs_wang=68.92;
	get_address("C")->cs_wang=174.78;

	coil_pre[0]= 1.23;
	coil_pre[1]=-0.07;
	coil_pre[2]= 0.05;
	coil_pre[3]=-0.11;
	coil_pre[4]= 0.02;
	coil_pre[5]=-0.00;


	coil_fol[0]= 0.22;
	coil_fol[1]= 0.10;
	coil_fol[2]= 0.02;
	coil_fol[3]= 0.14;
	coil_fol[4]= 0.04;
	coil_fol[5]= 0.08;
	
}
CThr::~CThr() {}


//TRP
void CTrp::schbond(vector<bbhbond_group> *grp)
{
	bbhbond_group t;
	t.id=residue;
	t.code=OneLetterName;
	t.cpos=-1;
	t.opos=-1;
	t.npos=get("NE1").index;
	t.hpos=get("HE1").index;
	t.type=13; 

	grp->push_back(t);
	return;
}

struct noeatoms CTrp::query(string name)
{
struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}


void CTrp::ring(vector<ring_group> *ring)
{
	ring_group t;

	t.x1=4; //type
	t.x2=get("CG").index;
	t.x3=get("CD1").index;
	t.x4=get("NE1").index;
	t.x5=get("CE2").index;
	t.x6=get("CD2").index;
	ring->push_back(t);

	t.x1=5;
	t.x2=get("CD2").index;
	t.x3=get("CE2").index;
	t.x4=get("CZ2").index;
	t.x5=get("CH2").index;
	t.x6=get("CZ3").index;
	t.x7=get("CE3").index;

	ring->push_back(t);
	return ;
}


void CTrp::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=4;
	t.x1=get("CA").index;
	t.x2=get("CB").index;
	t.x3=get("CG").index;
	t.x4=get("CD1").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);
	
	return;
}



CTrp::CTrp() 
{
    //CAminoacid::CAminoacid();
	OneLetterName='W';strcpy(ThreeLetterName,"TRP");
	
	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG";t.cs_name="CG";t.base_name="CB";atoms.push_back(t);
	t.name="CD1";t.cs_name="CD1";t.base_name="CB";atoms.push_back(t);
	t.name="CD2";t.cs_name="CD2";t.base_name="CB";atoms.push_back(t);
	t.name="NE1";t.cs_name="NE1";t.base_name="CB";atoms.push_back(t);
	t.name="CE2";t.cs_name="CE2";t.base_name="CB";atoms.push_back(t);
	t.name="CE3";t.cs_name="CE3";t.base_name="CB";atoms.push_back(t);	
	t.name="CZ2";t.cs_name="CZ2";t.base_name="CB";atoms.push_back(t);
	t.name="CZ3";t.cs_name="CZ3";t.base_name="CB";atoms.push_back(t);
	t.name="CH2";t.cs_name="CH2";t.base_name="CB";atoms.push_back(t);
	
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=85;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=86;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);

	t.carbon_name="CD1";
	t.proton_type=87;t.name="HD1";t.cs_name="HD1";t.base_name="HD1";atoms.push_back(t);
	t.carbon_name="NE1";
	t.proton_type=88;t.name="HE1";t.cs_name="HE1";t.base_name="HE1";atoms.push_back(t);
	t.carbon_name="CE3";
	t.proton_type=89;t.name="HE3";t.cs_name="HE3";t.base_name="HE3";atoms.push_back(t);
	t.carbon_name="CZ2";
	t.proton_type=90;t.name="HZ2";t.cs_name="HZ2";t.base_name="HZ2";atoms.push_back(t);
	t.carbon_name="CZ3";
	t.proton_type=91;t.name="HZ3";t.cs_name="HZ3";t.base_name="HZ3";atoms.push_back(t);
	t.carbon_name="CH2";
	t.proton_type=92;t.name="HH2";t.cs_name="HH2";t.base_name="HH2";atoms.push_back(t);

	get_address("H")->cs_coil=8.19;
	get_address("N")->cs_coil=121.7;
	get_address("CA")->cs_coil=57.3;
	get_address("HA")->cs_coil=4.80;
	get_address("CB")->cs_coil=30.4;
	get_address("C")->cs_coil=175.5;

		
	get_address("H")->cs_mean=8.28;
	get_address("N")->cs_mean=121.58;
	get_address("CA")->cs_mean=57.71;
	get_address("HA")->cs_mean=4.67;
	get_address("CB")->cs_mean=29.98;
	get_address("C")->cs_mean=176.19;

	get_address("H")->cs_wang=7.97;
	get_address("N")->cs_wang=120.99;
	get_address("CA")->cs_wang=57.54;
	get_address("HA")->cs_wang=4.60;
	get_address("CB")->cs_wang=29.60;
	get_address("C")->cs_wang=175.87;

	coil_pre[0]= 0.97;
	coil_pre[1]=-0.46;
	coil_pre[2]= 0.00;
	coil_pre[3]= 0.28;
	coil_pre[4]=-0.08;
	coil_pre[5]=-0.05;


	coil_fol[0]=-0.59;
	coil_fol[1]=-0.33;
	coil_fol[2]=-0.06;
	coil_fol[3]=-0.03;
	coil_fol[4]=-0.10;
	coil_fol[5]=-0.03;

}
CTrp::~CTrp() {}



//TYR
void CTyr::schbond(vector<bbhbond_group> *grp)
{
	bbhbond_group t;
	t.id=residue;
	t.code=OneLetterName;
	t.cpos=-1;
	t.opos=-1;
	t.npos=get("OH").index;
	t.hpos=get("HH").index;
	t.type=12; 

	grp->push_back(t);
	return;
}


struct noeatoms CTyr::query(string name)
{

struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QD")==0)
	{
		tt.clear();
		tt.push_back(get("HD1").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HD2").index);
		t.atoms.push_back(tt);
		t.length=5.0;
	}
	else if(name.compare("QE")==0)
	{
		tt.clear();
		tt.push_back(get("HE1").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HE2").index);
		t.atoms.push_back(tt);
		t.length=5.0;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}


void CTyr::ring(vector<ring_group> *ring)
{
	ring_group t;

	t.x1=2; //type
	t.x2=get("CG").index;
	t.x3=get("CD1").index;
	t.x4=get("CE1").index;
	t.x5=get("CZ").index;
	t.x6=get("CE2").index;
	t.x7=get("CD2").index;
	ring->push_back(t);
	return ;
}

void CTyr::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);
	
	t.type=4;
	t.x1=get("CA").index;
	t.x2=get("CB").index;
	t.x3=get("CG").index;
	t.x4=get("CD1").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);
	
	return;
}


CTyr::CTyr() 
{
    //CAminoacid::CAminoacid();
	OneLetterName='Y';strcpy(ThreeLetterName,"TYR");

	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG";t.cs_name="CG";t.base_name="CB";atoms.push_back(t);
	t.name="CD1";t.cs_name="CD";t.base_name="CB";atoms.push_back(t);
	t.name="CD2";t.cs_name="CD";t.base_name="CB";atoms.push_back(t);
	t.name="CE1";t.cs_name="CE";t.base_name="CB";atoms.push_back(t);
	t.name="CE2";t.cs_name="CE";t.base_name="CB";atoms.push_back(t);
	t.name="CZ";t.cs_name="CZ";t.base_name="CB";atoms.push_back(t);
	t.name="OH";t.cs_name="OH";t.base_name="CB";atoms.push_back(t);
	
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=93;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=94;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);

	t.carbon_name="CD";
	t.proton_type=95;t.name="HD1";t.cs_name="HD";t.base_name="HD1";atoms.push_back(t);
	t.proton_type=95;t.name="HD2";t.cs_name="HD";t.base_name="HD2";atoms.push_back(t);
	t.carbon_name="CE";
	t.proton_type=96;t.name="HE1";t.cs_name="HE";t.base_name="HE1";atoms.push_back(t);
	t.proton_type=96;t.name="HE2";t.cs_name="HE";t.base_name="HE2";atoms.push_back(t);
	
	t.carbon_name="OH";
	t.proton_type=97;t.name="HH";t.cs_name="HH";t.base_name="HH";atoms.push_back(t);

	get_address("H")->cs_coil=8.24;
	get_address("N")->cs_coil=120.0;
	get_address("CA")->cs_coil=57.6;
	get_address("HA")->cs_coil=4.73;
	get_address("CB")->cs_coil=39.4;
	get_address("C")->cs_coil=174.8;

		
	get_address("H")->cs_mean=8.30;
	get_address("N")->cs_mean=120.45;
	get_address("CA")->cs_mean=58.20;
	get_address("HA")->cs_mean=4.61;
	get_address("CB")->cs_mean=39.26;
	get_address("C")->cs_mean=175.45;

	get_address("H")->cs_wang=7.99;
	get_address("N")->cs_wang=119.37;
	get_address("CA")->cs_wang=57.64;
	get_address("HA")->cs_wang=4.56;
	get_address("CB")->cs_wang=38.78;
	get_address("C")->cs_wang=175.29;

	coil_pre[0]= 0.46;
	coil_pre[1]=-0.03;
	coil_pre[2]=-0.19;
	coil_pre[3]=-0.10;
	coil_pre[4]= 0.02;
	coil_pre[5]= 0.01;

	coil_fol[0]=-0.48;
	coil_fol[1]=-0.51;
	coil_fol[2]= 0.10;
	coil_fol[3]= 0.00;
	coil_fol[4]=-0.07;
	coil_fol[5]=-0.06;
}
CTyr::~CTyr() {}



//Val

void CVal::methyl_ambig(int flag)
{
	int i;
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).base_name=="HG1" && atoms.at(i).ambig==2)
		{
			if(atoms.at(i).cs_exp>0.0)
				atoms.at(i).cs_exp=999.0;
		}
		if(atoms.at(i).base_name=="HG2" && atoms.at(i).ambig==2)
		{
			if(atoms.at(i).cs_exp>0.0)
				atoms.at(i).cs_exp=999.0;
		}
	}
	return;
}

struct noeatoms CVal::query(string name)
{
struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("MG1")==0 || name.compare("QG1")==0)
	{
		tt.push_back(get("HG11").index);
		tt.push_back(get("HG12").index);
		tt.push_back(get("HG13").index);
		t.atoms.push_back(tt);
		t.length=0.0;
	}
	else if(name.compare("MG2")==0 || name.compare("QG2")==0)
	{
		tt.push_back(get("HG21").index);
		tt.push_back(get("HG22").index);
		tt.push_back(get("HG23").index);
		t.atoms.push_back(tt);
		t.length=0.0;
	}
	else if(name.compare("QG")==0 || name.compare("QQG")==0)
	{
		tt.clear();
		tt.push_back(get("HG21").index);
		tt.push_back(get("HG22").index);
		tt.push_back(get("HG23").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HG11").index);
		tt.push_back(get("HG12").index);
		tt.push_back(get("HG13").index);
		t.atoms.push_back(tt);
		t.length=5.0;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}

void CVal::proton2(vector<struct proton> *sel)
{
	struct proton t;


	t.type=5;
	t.name="HG1";
	get_proton(&t);
	sel->push_back(t);

	t.type=6;
	t.name="HG2";
	get_proton(&t);
	sel->push_back(t);

	return;
}





void CVal::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG1").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	return;
}

CVal::CVal() 
{
    //CAminoacid::CAminoacid();
	OneLetterName='V';
	strcpy(ThreeLetterName,"VAL");
	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.cs_coil=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;
	t.bb=0;
	t.proton=0;t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG1";t.cs_name="CG1";t.base_name="CB";atoms.push_back(t);
	t.name="CG2";t.cs_name="CG2";t.base_name="CB";atoms.push_back(t);
	
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=98;t.name="HB";t.cs_name="HB";t.base_name="HB";atoms.push_back(t);
	t.carbon_name="CG1";
	t.proton_type=5;t.name="HG11";t.cs_name="HG1";t.base_name="HG1";atoms.push_back(t);
	t.proton_type=5;t.name="HG12";t.cs_name="HG1";t.base_name="HG1";atoms.push_back(t);
	t.proton_type=5;t.name="HG13";t.cs_name="HG1";t.base_name="HG1";atoms.push_back(t);
	t.carbon_name="CG2";
	t.proton_type=6;t.name="HG21";t.cs_name="HG2";t.base_name="HG2";atoms.push_back(t);
	t.proton_type=6;t.name="HG22";t.cs_name="HG2";t.base_name="HG2";atoms.push_back(t);
	t.proton_type=6;t.name="HG23";t.cs_name="HG2";t.base_name="HG2";atoms.push_back(t);

	get_address("H")->cs_coil=8.32;
	get_address("N")->cs_coil=121.8;
	get_address("CA")->cs_coil=61.4;
	get_address("HA")->cs_coil=4.30;
	get_address("CB")->cs_coil=32.8;
	get_address("C")->cs_coil=175.1;

		
	get_address("H")->cs_mean=8.28;
	get_address("N")->cs_mean=121.08;
	get_address("CA")->cs_mean=62.57;
	get_address("HA")->cs_mean=4.17;
	get_address("CB")->cs_mean=32.71;
	get_address("C")->cs_mean=175.68;

	get_address("H")->cs_wang=7.98;
	get_address("N")->cs_wang=119.91;
	get_address("CA")->cs_wang=62.00;
	get_address("HA")->cs_wang=4.13;
	get_address("CB")->cs_wang=32.35;
	get_address("C")->cs_wang=175.66;

	coil_pre[0]=2.77;
	coil_pre[1]=-0.00;
	coil_pre[2]=-0.16;
	coil_pre[3]=0.03;
	coil_pre[4]=0.17;
	coil_pre[5]=0.04;

	coil_fol[0]=-0.05;
	coil_fol[1]=-0.08;
	coil_fol[2]= 0.05;
	coil_fol[3]= 0.18;
	coil_fol[4]= 0.01;
	coil_fol[5]= 0.05;

}
CVal::~CVal() {}

//Missing residue
struct noeatoms CMiss::query(string name)
{
	struct noeatoms t;t.length=0.0;vector<int> tt;
	return t;
}

void CMiss::dihe(vector<dihe_group> * dihe_index)
{
	return;
}

void CMiss::process(vector<string> block)
{
	return;
}


CMiss::CMiss() 
{
    //CAminoacid::CAminoacid();
	resname="Missing";OneLetterName='X';strcpy(ThreeLetterName,"MIS");
	atoms.clear();
	order_parameters.clear();

	for(int i=0;i<6;i++)
	{
		coil_pre[i]=coil_fol[i]=0.0;
	}
}

CMiss::~CMiss() {}

// unknown residue

struct noeatoms CUnk::query(string name)
{
	struct noeatoms t;t.length=0.0;vector<int> tt;
	return t;
}


void CUnk::dihe(vector<dihe_group> * dihe_index)
{
	return;
}



void CUnk::process(vector<string> block)
{
	int i,j;
	int index;
	char c;
	string t;
	string atomname;
	string part;
	vector<string> subblock;
	struct Atom atom;

	for(i=0;i<(int)block.size();i++)
	{
		t=block[i];
		if(i==0)
		{
			head=t.substr(0,6);
			resname=t.substr(17,3);
		}
		atomname=t.substr(11,5);  //atom name here
		while((j=atomname.find(" ")) != string::npos)
		{
			atomname.replace(j, 1, "");
		}	
		part=t.substr(6,5); //atom index
		index=atoi(part.c_str());

		c=atomname.at(0);
		if(c>'0' && c<'9')  //if name started with number, move that number to the end
		{
			atomname.erase(0,1);
			atomname.append(1,c);
		}

		c=atomname.at(0);
		if(c=='H' && atomname.size()>1)  //started with H, but it is not HN
		{
			//do nothing for protons!
		}
		else  //heavy atoms or HN atom, just store them
		{
			atom.name=atomname;
			atom.cs_name=atomname;
			atom.base_name=atomname;
			atom.index=index;
			atom.bb=1;
			atom.proton=0;
			atom.cs_exp=atom.cs_pre=999.0;
		}
	}
	return;
}


CUnk::CUnk() 
{
    //CAminoacid::CAminoacid();
	resname="None";OneLetterName='X';strcpy(ThreeLetterName,"UNK");
	order_parameters.clear();

	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=1;t.name="HB1";t.cs_name="HB";t.base_name="HB";atoms.push_back(t);
	t.proton_type=1;t.name="HB2";t.cs_name="HB";t.base_name="HB";atoms.push_back(t);
	t.proton_type=1;t.name="HB3";t.cs_name="HB";t.base_name="HB";atoms.push_back(t);

	for(int i=0;i<6;i++)
	{
		coil_pre[i]=coil_fol[i]=0.0;
	}
}

CUnk::~CUnk() {}



//water or ligand as a fake residue


CLigand::CLigand() 
{
	atomindexs.clear();
	atomnames.clear();
	id=-1;
	resname="None";
}

CLigand::~CLigand() {}

void CLigand::process(vector<string> block)
{
	int i,j;
	int index;
	string t;
	string atomname;
	string part;
	vector<string> subblock;

	t=block.at(0);
	head=t.substr(0,6);
	resname=t.substr(17,3);

	original_residue=atoi(block.at(0).substr(22,4).c_str());
	
	for(i=0;i<(int)block.size();i++)
	{
		t=block[i];
		atomname=t.substr(11,5);  //atom name here
		while((j=atomname.find(" ")) != string::npos)
		{
			atomname.replace(j, 1, "");
		}
		part=t.substr(6,5); //atom index
		index=atoi(part.c_str());
		atomindexs.push_back(index);
		atomnames.push_back(atomname);
	}
	return;
}

void CLigand::heavycoor(vector<int> *t)
{
	t->insert(t->end(),atomindexs.begin(),atomindexs.end());
}


double CAminoacid::wishart[22][12]={
										{50.86,54.86,21.72,18.27,175.3,179.58,8.59,7.99,4.87,4.03,125.57,121.65},
										{54.63,59.05,32.36,30,175.04,178.11,8.57,8.03,4.85,4,122.6,118.99},
										{52.48,55.67,40.43,38.28,174.55,176.74,8.7,8.2,5.26,4.45,122.7,117.6},
										{53.4,57.04,42.78,40.5,175.15,178.07,8.56,8.05,5.01,4.44,123.82,119.9},
										{54.33,58.61,31.92,28.33,174.5,178.35,8.51,8.11,4.97,4.03,123.14,118.59},
										{55.55,59.3,32.45,29.2,175.01,178.46,8.66,8.32,4.76,3.99,123.52,119.89},
										{45.08,47.02,999,999,173.01,176.31,8.27,8.23,4.09,3.84,110.19,107.34},
										{54.8,59.62,32.2,29.91,173.8,176.83,8.76,8.03,5.07,4.06,121.65,118.09},
										{60,64.68,40.09,37.59,174.79,177.49,8.74,8.06,4.72,3.66,124.12,120.22},
										{53.94,57.54,44.02,41.4,175.16,178.42,8.63,8.02,4.85,4,125.69,120.18},
										{55.01,59.11,34.86,32.31,174.93,177.79,8.54,8.04,4.96,3.98,123.29,119.9},
										{54.1,58.45,34.34,31.7,174.64,177.76,8.43,8.05,4.94,4.03,121.67,118.69},
										{56.33,60.74,41.64,38.91,174.15,176.42,8.8,8.21,5.1,4.11,121.95,119.12},
										{62.79,65.52,32.45,31.08,176.41,178.34,999,999,4.72,4.13,999,999},
										{57.14,60.86,65.39,62.81,173.52,176.51,8.57,8.11,5.08,4.2,117.44,114.78},
										{61.1,65.89,70.82,68.64,173.47,176.62,8.5,8.1,4.81,4.02,118.09,115.3},
										{56.28,60.03,31.78,28.74,175.1,177.81,8.83,8.24,5.24,4.35,124.04,120.48},
										{56.56,61.07,40.79,38.38,174.65,177.05,8.69,8.1,5,4.14,122.55,119.67},
										{60.72,65.96,33.81,31.41,174.66,177.75,8.73,7.99,4.66,3.5,123.27,119.53},
										{57.64,62.86,29.48,26.99,173.86,177.42,9,8.22,5.18,4.16,123.27,117.4},
										{54.19,58.57,43.79,40.02,172.73,176.84,8.68,8.58,5.21,4.53,121.81,119.51},
										{999,999,999,999,999,999,999,999,999,999,999,999}
									};


double CAminoacid::wang_rc[21][6]={
{120.58, 175.52, 60.79, 38.43, 7.94, 4.18},
{119.91, 175.66, 62.00, 32.35, 7.98, 4.13},
{120.37, 176.00, 54.00, 40.78, 8.31, 4.62},
{118.50, 174.84, 53.00, 38.43, 8.35, 4.66},
{119.72, 175.46, 57.46, 39.41, 8.09, 4.59},
{118.92, 174.78, 55.74, 29.50, 8.18, 4.60},
{120.99, 175.87, 57.54, 29.60, 7.97, 4.60},
{119.37, 175.29, 57.64, 38.78, 7.99, 4.56},
{121.10, 176.15, 56.29, 32.53, 8.17, 4.28},
{121.57, 176.70, 54.77, 42.14, 8.06, 4.36},
{120.14, 175.94, 55.43, 32.92, 8.22, 4.47},
{119.82, 175.75, 55.89, 29.01, 8.20, 4.29},
{120.75, 176.01, 56.18, 30.36, 8.21, 4.26},
{120.62, 176.32, 56.66, 29.87, 8.36, 4.28},
{113.88, 174.78, 61.30, 68.92, 8.16, 4.44},
{118.10, 175.11, 58.24, 29.54, 8.10, 4.59},
{116.00, 174.41, 58.20, 63.75, 8.22, 4.45},
{123.82, 177.28, 52.46, 18.98, 8.09, 4.31},
{109.48, 174.01, 45.28, 0, 8.37, 3.97},
{0, 176.62, 63.24, 31.81, 0, 4.41},
{999,999,999,999,999,999}
};

double CAminoacid::wang_c1[21][6]={
{-2.21, 0.14, -0.01, -0.04, -0.07, -0.01},
{1.36, -0.00, 0.44, -0.18, 0.03, -0.00},
{-0.43, 0.07, 0.20, -0.07, -0.01, -0.03},
{-0.36, 0.04, 0.01, 0.04, -0.01, -0.01},
{0.20, -0.14, 0.02, -0.06, 0.01, -0.01},
{-0.43, -0.09, -0.26, 0.17, -0.10, 0.04},
{-0.05, -0.13, 0.16, 0.07, -0.01, -0.05},
{2.92, 0.11, -0.15, 0.26, 0.12, 0.04},
{-0.26, -0.09, -0.07, 0.08, -0.02, -0.00},
{-0.76, 0.13, -0.07, -0.03, -0.06, 0.00},
{0.69, 0.10, 0.09, 0.10, 0.05, 0.05},
{-0.76, -0.19, 0.18, -0.20, 0.01, -0.03},
{-0.94, 0.21, 0.07, -0.16, 0.14, -0.04},
{-0.09, 0.07, 0.13, 0.06, 0.01, -0.00},
{-0.45, -0.07, 0.00, 0.01, -0.03, 0.01},
{1.16, -0.10, 0.11, -0.06, 0.02, 0.01},
{1.23, -0.07, 0.05, -0.11, 0.02, -0.00},
{2.77, -0.00, -0.16, 0.03, 0.17, 0.04},
{0.97, -0.46, 0.00, 0.28, -0.08, -0.05},
{0.46, -0.03, -0.19, -0.10, 0.02, 0.01},
{0,0,0,0,0,0}
};

double CAminoacid::wang_c2[21][6]={
{-0.11, 0.05, 0.07, -0.09, -0.01, -0.03},
{-1.17, 0.10, 0.17, 0.21, 0.01, 0.03},
{0.23, -0.11, 0.28, 0.11, 0.04, -0.03},
{0.26, 0.14, 0.25, 0.06, 0.07, -0.04},
{-0.35, -0.22, -0.04, -0.09, -0.04, -0.02},
{0.13, 0.47, 0.12, -0.07, 0.06, -0.03},
{-0.09, -0.05, 0.22, -0.24, -0.01, -0.09},
{-0.20, -0.09, 0.03, 0.28, -0.01, 0.03},
{-0.13, -0.13, 0.08, 0.01, -0.04, -0.03},
{-0.49, 0.06, 0.10, -0.10, -0.07, -0.02},
{-0.02, 0.19, 0.22, 0.06, 0.01, -0.01},
{-0.03, -0.23, 0.24, -0.06, 0.04, -0.04},
{0.92, -1.19, -2.04, -0.20, -0.17, 0.21},
{-0.31, 0.10, 0.37, -0.13, 0.01, -0.05},
{-0.09, 0.16, 0.19, -0.12, -0.01, -0.02},
{0.30, 0.10, 0.10, 0.14, 0.07, 0.02},
{0.22, 0.10, 0.02, 0.14, 0.04, 0.08},
{-0.05, -0.08, 0.05, 0.18, 0.01, 0.05},
{-0.59, -0.33, -0.06, -0.03, -0.10, -0.03},
{-0.48, -0.51, 0.10, 0.00, -0.07, -0.06},
{0,0,0,0,0,0}
};

########## NEXT FILE ##########
pdb.cpp:::
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <math.h>
#include <time.h>

using namespace std;


#include "pdb.h"

#include "debug.h"

int CDssp::loaddata(string name)
{
	char buffer[255];
	bool begin;
	struct dsspline aadssp;
	string line;

	sprintf(buffer,"dssp %s > dssp.out",name.c_str());
	system(buffer); 

	ifstream fin("dssp.out");
	if (!fin.is_open())
		return 1;

	
	begin=0;
	while(getline(fin,line))
	{
		if(line.find("RESIDUE AA")!=std::string::npos)
		{
			begin=1;
			continue;
		}
		if(begin==1)
		{
			aadssp.id=atoi(line.substr(5,5).c_str());
			aadssp.code=line[13];
			aadssp.ss=line[16];
			data.push_back(aadssp);
		}
	}
	return 0;
}

string CDssp::getseq()
{
	int i;
	string s;

	for(i=0;i<(int)data.size();i++)
		s.push_back(data.at(i).code);
	return s;
}

CDssp::CDssp()
{}
CDssp::~CDssp()
{}

//////////////////////////
// class CPdb           //
//////////////////////////

void CPdb::process_ambig(int flag)
{
	//meaning of flag:
	// 1. remove any ambig assignment
	// 2. combine all hb2, hb3 into mean value, if code is 1 or 2, otherwise remove ambig
	int i;
	if(flag==1)
	{
		for(i=0;i<(int)v.size();i++)
		{
			v.at(i)->remove_ambig(flag);
		}
	}
	
	//not really needed ??? if take mean in function get all proton
	if(flag==2)
	{
		for(i=0;i<(int)v.size();i++)
		{
			v.at(i)->methyl_ambig(flag);
			//v.at(i)->combine_hsamec(flag);
		}
	}

	if(flag==3)
	{
		//remove methyl ambig==2 case
	}
}


void CPdb::clear()
{
	unsigned int i;
	for(i=0;i<(int)v.size();i++)
	{
		delete v.at(i);
	}
	v.clear();
	for(i=0;i<(int)ligand.size();i++)
	{
		delete ligand.at(i);
	}
	ligand.clear();
	chains.clear();
	chain_block.clear();
	chain_ligand.clear();
	blocks.clear();
	pdbseq.clear();
}

void CPdb::print_print(FILE *fp,vector<int> att1, vector<int> att2,int index,int type,double a,double b,double c,double w)
{
	int i,j;

	for(i=0;i<att1.size();i++)
	for(j=0;j<att2.size();j++)
	{	
		fprintf(fp,"%10d%10d%10d%10d%10d",att1.at(i),att2.at(j),1,index,type);
		fprintf(fp,"%10.4f%10.4f%10.4f%10.4f\n",a/10,b/10,c/10,w);  //unit is nm instead of A in Gromacs!
	}
	return;
}

void CPdb::print_gromacs(string filename,vector <struct diheline> *dihecons)
{
	FILE *fp;
	struct noeline tline;
	int i,j;

	fp=fopen(filename.c_str(),"wt");
	fprintf(fp,"[dihedral_restraints]\n");
	for(i=0;i<dihecons->size();i++)
	{
		for(j=0;j<4;j++) fprintf(fp,"%d ",dihecons->at(i).index[j].atoms.at(0).at(0));
		fprintf(fp," 1 1 ");
		fprintf(fp,"%8.3f%8.3f",(float)dihecons->at(i).middle,(float)dihecons->at(i).delta);
		fprintf(fp," 1 2\n");
	}
	fclose(fp);
	return;
}



void CPdb::print_gromacs(string filename,vector <struct noeline> *nmrcons)
{
	FILE *fp;
	struct noeline tline;
	int i,j,index;
	int n1,n2;
	double length1,length2;
	vector<int> att1,att2;
	string filename2;

	vector<int> nshort;
	vector<int> nlong;
	vector< vector<int> > whos;
	vector< vector<int> > pairs;
	vector< vector<int> > used;
	vector< vector<double> > weights;

	nshort.resize(v.size());
	nlong.resize(v.size());
	whos.resize(v.size());
	pairs.resize(v.size());
	weights.resize(v.size());
	used.resize(v.size());
	for(i=0;i<v.size();i++)
		used.at(i).resize(v.size(),0);


	for(i=0;i<pairs.size();i++)
	{
		pairs.at(i).resize(v.size());
		weights.at(i).resize(v.size());
	}

	for(i=0;i<nmrcons->size();i++)
	{
		if(fabs((float)(nmrcons->at(i).resid1-nmrcons->at(i).resid2))<=4)
		{
			nshort.at(nmrcons->at(i).resid1-1)++;
			nshort.at(nmrcons->at(i).resid2-1)++;
		}
		else
		{
			nlong.at(nmrcons->at(i).resid1-1)++;
			nlong.at(nmrcons->at(i).resid2-1)++;
			whos.at(nmrcons->at(i).resid1-1).push_back(nmrcons->at(i).resid2);
			whos.at(nmrcons->at(i).resid2-1).push_back(nmrcons->at(i).resid1);
			pairs.at(nmrcons->at(i).resid1-1).at(nmrcons->at(i).resid2-1)++;
			pairs.at(nmrcons->at(i).resid2-1).at(nmrcons->at(i).resid1-1)++;
		}

	}

	fp=fopen("cons_detail.dat","wt");
	for(i=0;i<v.size();i++)
	{
		fprintf(fp,"%d %d %d\n",i+1,nshort.at(i),nlong.at(i));
	}
	fclose(fp);

	fp=fopen("cons_whos.dat","wt");
	for(i=0;i<whos.size();i++)
	{
		fprintf(fp,"%d",i+1);
		for(j=0;j<whos.at(i).size();j++)
			fprintf(fp," %d",whos.at(i).at(j));
		fprintf(fp,"\n");
	}
	fclose(fp);


	int b1,b2,s1,s2,k1,k2;
	double c;
	for(i=0;i<v.size();i++)
	{
		for(j=0;j<v.size();j++)
		{
			weights.at(i).at(j)=1;
			if(pairs.at(i).at(j)>0)
				weights.at(i).at(j)=1.0/pairs.at(i).at(j);
			c=0;
			b1=-1; if(i==0) b1=0;
			b2=-1; if(j==0) b2=0;
			s1=1; if(i==v.size()-1) s1=0;
			s2=1; if(j==v.size()-1) s2=0;
			for(k1=i+b1;k1<=i+s1;k1++)
			for(k2=j+b2;k2<=j+s2;k2++)
				c+=pairs.at(k1).at(k2);
			c-=pairs.at(i).at(j);
			if(c>0) weights.at(i).at(j)/=sqrt(c);
		}
	}


	index=-1;
	fp=fopen(filename.c_str(),"wt");
	fprintf(fp,"[distance_restraints]\n");
	fprintf(fp,"; all long range noe distance restraints\n");
	for(i=0;i<nmrcons->size();i++)
	{
		if(fabs((float)(nmrcons->at(i).resid1-nmrcons->at(i).resid2))<=4)
			continue;
		tline=nmrcons->at(i);
		length1=0;
		length2=0;

		for(n1=0;n1<(int)nmrcons->at(i).index1.atoms.size();n1++)
		{
			length1=nmrcons->at(i).index1.length;
			for(n2=0;n2<(int)nmrcons->at(i).index2.atoms.size();n2++)
			{
				index++;
				length2=nmrcons->at(i).index1.length;
				att1=nmrcons->at(i).index1.atoms.at(n1);
				att2=nmrcons->at(i).index2.atoms.at(n2);
				print_print(fp,att1,att2,index,1,0,nmrcons->at(i).a+length1+length2,nmrcons->at(i).a+2+length1+length2,weights.at(tline.resid1-1).at(tline.resid2-1));
			}
		}
	}
	fclose(fp);

	fp=fopen("cns_distance.tbl","wt");
	for(i=0;i<nmrcons->size();i++)
	{
		if(nmrcons->at(i).bvio==1)
			continue;
		if(fabs((float)(nmrcons->at(i).resid1-nmrcons->at(i).resid2))<=4)
		{
			tline=nmrcons->at(i);
			fprintf(fp,"assign (resid %d and name %s ) (resid %d and name %s ) %f %f %f\n",
				tline.oldresid1,tline.oldatomname1.c_str(),tline.oldresid2,tline.oldatomname2.c_str(),
				(float)tline.b,(float)tline.c,(float)tline.a);
		}
		else
		{
			tline=nmrcons->at(i);
			if(used.at(tline.resid1-1).at(tline.resid2-1)==0)
			{
				fprintf(fp,"assign (resid %d and name %s ) (resid %d and name %s ) %f %f %f\n",
					tline.oldresid1,tline.oldatomname1.c_str(),tline.oldresid2,tline.oldatomname2.c_str(),
					(float)tline.b,(float)tline.c,(float)tline.a);
				used.at(tline.resid1-1).at(tline.resid2-1)++;
				used.at(tline.resid2-1).at(tline.resid1-1)++;
			}
		}
	}
	fclose(fp);


	index=-1;
	filename2=filename;
	filename2.insert(filename2.find("."),"2");
	fp=fopen(filename2.c_str(),"wt");
	fprintf(fp,"[distance_restraints]\n");
	fprintf(fp,"; vilated noe distance restraints\n");
	for(i=0;i<nmrcons->size();i++)
	{
		if(nmrcons->at(i).bvio==0)
			continue;
		tline=nmrcons->at(i);
		length1=0;
		length2=0;

		for(n1=0;n1<(int)nmrcons->at(i).index1.atoms.size();n1++)
		{
			length1=nmrcons->at(i).index1.length;
			for(n2=0;n2<(int)nmrcons->at(i).index2.atoms.size();n2++)
			{
				index++;
				length2=nmrcons->at(i).index1.length;
				att1=nmrcons->at(i).index1.atoms.at(n1);
				att2=nmrcons->at(i).index2.atoms.at(n2);
				print_print(fp,att1,att2,index,1,0,nmrcons->at(i).a+length1+length2,nmrcons->at(i).a+2+length1+length2,1.0);
			}
		}
	}
	fclose(fp);


	index=-1;
	filename2=filename;
	filename2.insert(filename2.find("."),"3");
	fp=fopen(filename2.c_str(),"wt");
	fprintf(fp,"[distance_restraints]\n");
	fprintf(fp,"; fullfiled noe distance restraints\n");
	for(i=0;i<nmrcons->size();i++)
	{
		if(nmrcons->at(i).bvio==1)
			continue;
		tline=nmrcons->at(i);
		length1=0;
		length2=0;

		for(n1=0;n1<(int)nmrcons->at(i).index1.atoms.size();n1++)
		{
			length1=nmrcons->at(i).index1.length;
			for(n2=0;n2<(int)nmrcons->at(i).index2.atoms.size();n2++)
			{
				index++;
				length2=nmrcons->at(i).index1.length;
				att1=nmrcons->at(i).index1.atoms.at(n1);
				att2=nmrcons->at(i).index2.atoms.at(n2);
				print_print(fp,att1,att2,index,1,0,nmrcons->at(i).a+length1+length2,nmrcons->at(i).a+2+length1+length2,1.0);
			}
		}
	}
	fclose(fp);


	index=-1;
	filename2=filename;
	filename2.insert(filename2.find("."),"4");
	fp=fopen(filename2.c_str(),"wt");
	fprintf(fp,"[distance_restraints]\n");
	fprintf(fp,"; all noe distance restraints\n");
	for(i=0;i<nmrcons->size();i++)
	{
		tline=nmrcons->at(i);
		length1=0;
		length2=0;

		for(n1=0;n1<(int)nmrcons->at(i).index1.atoms.size();n1++)
		{
			length1=nmrcons->at(i).index1.length;
			for(n2=0;n2<(int)nmrcons->at(i).index2.atoms.size();n2++)
			{
				index++;
				length2=nmrcons->at(i).index1.length;
				att1=nmrcons->at(i).index1.atoms.at(n1);
				att2=nmrcons->at(i).index2.atoms.at(n2);
				print_print(fp,att1,att2,index,1,0,nmrcons->at(i).a+length1+length2,nmrcons->at(i).a+2+length1+length2,1.0);
			}
		}
	}
	fclose(fp);

	return;
}


int CPdb::loadnoedata(string filename,string filename2,vector <struct noeline> *nmrcons)
{
	string nmrseq;
	int adj,adj2;
	vector<int> out;
	char c1,c2;
	ifstream fin(filename.c_str());
	ifstream fin2(filename2.c_str());
	istringstream iss;
	string line,p;
	string resname1,atomname1,resname2,atomname2,resname,atomname;
	int resid1,resid2,order,resid;
	double a,b,c;
	int i;
	struct noeline tline;
	bool bfirst;
	int index,index_old;
	int norder1,norder2;

	i=0;
	bfirst=1;
	while(getline(fin,line))
	{
		i++;
		iss.clear();
		iss.str(line);
		iss>>index;
		iss>>p>>order>>p>>p;
		iss>>resid;
		iss>>resname;
		iss>>atomname;
		iss>>p>>p>>p>>p>>p>>p;

		if(bfirst)
		{
			bfirst=0;
			resid1=resid2=-1;
			index_old=index;
			norder1=norder2=0;
		}

		if(index>index_old) //we now reach a new entry
		{
			tline.id=index_old;
			tline.resid1=resid1;
			tline.resid2=resid2;
			tline.resname1=resname1;
			tline.resname2=resname2;
			tline.atomname1=atomname1;
			tline.atomname2=atomname2;
			tline.multi=0;
			if(norder1>1 || norder2>1)
				tline.multi=1;
			nmrcons->push_back(tline);

			resid1=resid2=-1;
			index_old=index;
			norder1=norder2=0;
		}

		if(order==1)
		{
			norder1++;
			resid1=resid;
			resname1=resname;
			atomname1=atomname;
		}
		else if(order==2)
		{
			norder2++;
			resid2=resid;
			resname2=resname;
			atomname2=atomname;
		}
		else
		{
			cout<<"Unsupported order "<<order<<endl;
			break;
		}
	}

	//process the final entry.
	if(resid1>0 && resid2>0)
	{
		tline.id=index_old;
		tline.resid1=resid1;
		tline.resid2=resid2;
		tline.resname1=resname1;
		tline.resname2=resname2;
		tline.atomname1=atomname1;
		tline.atomname2=atomname2;
		nmrcons->push_back(tline);
	}


	i=0;
	while(getline(fin2,line))
	{
		iss.clear();
		iss.str(line);
		iss>>index;
		if(index!=nmrcons->at(i).id)
		{
			cout<<"readin noe data error. index is NOT as expected in second part"<<endl;
			break;
		}
		iss>>p>>p>>p>>p>>p>>p;
		iss>>b>>c>>a;
		iss>>p>>p;
		nmrcons->at(i).a=a;
		nmrcons->at(i).b=b;
		nmrcons->at(i).c=c;


		c1=Sequence::name2code(nmrcons->at(i).resname1);
		c2=Sequence::name2code(nmrcons->at(i).resname2);
		nmrcons->at(i).resid1--;
		nmrcons->at(i).resid2--;
		if(nmrcons->at(i).resid1+1>nmrseq.size())
			nmrseq.resize(nmrcons->at(i).resid1+1,'U');
		nmrseq.at(nmrcons->at(i).resid1)=c1;
		if(nmrcons->at(i).resid2+1>nmrseq.size())
			nmrseq.resize(nmrcons->at(i).resid2+1,'U');
		nmrseq.at(nmrcons->at(i).resid2)=c2;

		i++;
	}

	out=Sequence::align(pdbseq,nmrseq);
	adj=0;adj2=0;
	for(i=0;i<out.size();i++)
	{
		if(out.at(i)!=0)
		{
			adj+=(out.at(i)-i);
			adj2++;
		}
	}
	adj/=adj2;


	//remove entry with multiply atoms
	for(i=nmrcons->size()-1;i>=0;i--)
	{
		nmrcons->at(i).resid1++;
		nmrcons->at(i).resid2++;
		if(nmrcons->at(i).multi==1)
		{
			cout<<"Remove noe entry with umbigirious assignment. "<<nmrcons->at(i).id<<endl;
			nmrcons->erase(nmrcons->begin()+i);
		}
	}


	for(i=0;i<nmrcons->size();i++)
	{
		nmrcons->at(i).index1.length=0.0;
		nmrcons->at(i).index2.length=0.0;
		nmrcons->at(i).resid1-=adj;
		nmrcons->at(i).resid2-=adj;

		if(nmrcons->at(i).resid1>=1 && nmrcons->at(i).resid2>=1 && nmrcons->at(i).resid1<=(int)v.size() && nmrcons->at(i).resid2<=(int)v.size() )
		{
			nmrcons->at(i).index1=v.at(nmrcons->at(i).resid1-1)->query(nmrcons->at(i).atomname1);
			nmrcons->at(i).index2=v.at(nmrcons->at(i).resid2-1)->query(nmrcons->at(i).atomname2);
		}
		else
		{
			nmrcons->erase(nmrcons->begin()+i);
			i--;
		}
	}
	return adj;

}




int CPdb::loadnoedata(string filename,vector <struct noeline> *nmrcons)
{

	ifstream fin(filename.c_str());
	string line;
	vector<string> block1, block2;
	bool bstart,inloop,begin1,begin2;

	bstart=0;
	inloop=0;
	begin1=0;
	begin2=0;

	while(getline(fin,line))
	{
		if(line.size()<4)
			continue;

		if(begin2==1 &&  line.find("stop_")!=string::npos)
			bstart=begin2=0;
		if(begin1==1 &&  line.find("stop_")!=string::npos)
			begin1=0;


		if(begin1==1)
			block1.push_back(line);
		if(begin2==1)
			block2.push_back(line);

		if(line.find("loop_")!=string::npos)
			inloop=1;
		if(line.find("stop_")!=string::npos)
			inloop=0;

		if(inloop==0 && ( line.find("save_CNS/XPLOR_distance_constraints")!=string::npos || line.find("save_DYANA/DIANA_distance_constraints")!=string::npos) )
		{
			getline(fin,line);
			getline(fin,line);
			getline(fin,line);
			getline(fin,line);
			
			if(line.find("_Distance_constraint_list.Constraint_type")!=string::npos)
			{
				if( line.find("NOE")!=string::npos )
					bstart=1;
			}
			getline(fin,line);
			getline(fin,line);
		}

		if(bstart==1 && inloop==1 && line.find("_Dist_constraint.Distance_constraint_list_ID")!=string::npos)
			begin1=1;
		if(bstart==1 && inloop==1 && line.find("_Dist_constraint_value.Distance_constraint_list_ID")!=string::npos)
			begin2=1;
	}

	return actualload(&block1,&block2,nmrcons);
}
      



 
int CPdb::actualload(vector<string> *b1, vector<string> *b2, vector <struct noeline> *nmrcons)
{
	string nmrseq;
	int adj,adj2;
	vector<int> out;
	char c1,c2;
	istringstream iss;
	string line,p;
	string resname1,atomname1,resname2,atomname2,resname,atomname;
	string oldatomname,oldatomname1,oldatomname2;
	int resid1,resid2,order,resid,oldresid,oldresid1,oldresid2;
	double a,b,c;
	int i,ii,iii;
	struct noeline tline;
	bool bfirst;
	int index,index_old;
	int norder1,norder2;


	bfirst=1;
	for(i=0;i<b1->size();i++)
	{
		
		iss.clear();
		iss.str(b1->at(i));
		iss>>index;
		iss>>p>>order>>p>>p;
		iss>>resid;
		iss>>resname;
		iss>>atomname;
		iss>>p>>oldresid>>p>>oldatomname>>p>>p;

		if(bfirst)
		{
			bfirst=0;
			resid1=resid2=-1;
			index_old=index;
			norder1=norder2=0;
		}

		if(index>index_old) //we now reach a new entry
		{
			tline.id=index_old;
			tline.resid1=resid1;
			tline.resid2=resid2;
			tline.resname1=resname1;
			tline.resname2=resname2;
			tline.atomname1=atomname1;
			tline.atomname2=atomname2;
			tline.oldresid1=oldresid1;
			tline.oldresid2=oldresid2;
			tline.oldatomname1=oldatomname1;
			tline.oldatomname2=oldatomname2;
			tline.multi=0;
			if(norder1>1 || norder2>1)
				tline.multi=1;
			nmrcons->push_back(tline);

			resid1=resid2=-1;
			index_old=index;
			norder1=norder2=0;
		}

		if(order==1)
		{
			norder1++;
			resid1=resid;
			resname1=resname;
			atomname1=atomname;
			oldresid1=oldresid;
			oldatomname1=oldatomname;
		}
		else if(order==2)
		{
			norder2++;
			resid2=resid;
			resname2=resname;
			atomname2=atomname;
			oldresid2=oldresid;
			oldatomname2=oldatomname;
		}
		else
		{
			cout<<"Unsupported order "<<order<<endl;
			break;
		}
	}

	//process the final entry.
	if(resid1>0 && resid2>0)
	{
		tline.id=index_old;
		tline.resid1=resid1;
		tline.resid2=resid2;
		tline.resname1=resname1;
		tline.resname2=resname2;
		tline.atomname1=atomname1;
		tline.atomname2=atomname2;
		nmrcons->push_back(tline);
		tline.oldresid1=oldresid1;
		tline.oldresid2=oldresid2;
		tline.oldatomname1=oldatomname1;
		tline.oldatomname2=oldatomname2;
	}


	cout<<"fillin sequence of NOE"<<endl;
	for(i=0;i<b2->size();i++)
	{
		//cout<<"i is "<<i<<" and b2's size is "<<b2->size()<<" and b1's size is "<<b1->size()<<" and nmrcons's size is "<<nmrcons->size()<<endl;
		iss.clear();
		iss.str(b2->at(i));
		iss>>index;

		iss>>p;
		iss>>p;
		iss>>p;
		iss>>p;
		iss>>p;
		iss>>p;
		iss>>p; b=atof(p.c_str());
		iss>>p; c=atof(p.c_str());
		iss>>p; a=atof(p.c_str());
		iss>>p;
		iss>>p;
		iii=-1;
		for(ii=0;ii<nmrcons->size();ii++)
		{
			if(index==nmrcons->at(ii).id)
				iii=ii;
		}

		// not found!
		if(iii<0)
			break;

		nmrcons->at(iii).a=a;
		nmrcons->at(iii).b=b;
		nmrcons->at(iii).c=c;
	}

	for(i=0;i<nmrcons->size();i++)
	{
		c1=Sequence::name2code(nmrcons->at(i).resname1);
		c2=Sequence::name2code(nmrcons->at(i).resname2);

		if(nmrcons->at(i).resid1>nmrseq.size())
		{
			nmrseq.resize(nmrcons->at(i).resid1,'U');
			//cout<<"resize nmrseq to "<<nmrcons->at(i).resid1+1<<endl;
		}
		//cout<<nmrcons->at(i).resid1<<" is filled with "<<c1<<"size of nmrseq is "<<nmrseq.size()<<endl;
		//cout.flush();
		nmrseq.at(nmrcons->at(i).resid1-1)=c1;
		//cout<<"done1"<<endl;
		if(nmrcons->at(i).resid2>nmrseq.size())
		{
			nmrseq.resize(nmrcons->at(i).resid2,'U');
			//cout<<"resize nmrseq to "<<nmrcons->at(i).resid2+1<<endl;
		}
		//cout<<nmrcons->at(i).resid2<<" is filled with "<<c2<<"size of nmrseq is "<<nmrseq.size()<<endl;
		//cout.flush();
		nmrseq.at(nmrcons->at(i).resid2-1)=c2;
		//cout<<"done2"<<endl;
	}

	//cout<<"just before alighment"<<endl;
	out=Sequence::align(pdbseq,nmrseq);
	adj=0;adj2=0;
	for(i=out.size()/10;i<out.size()-out.size()/10;i++)
	{
		if(out.at(i)!=0)
		{
			adj+=(out.at(i)-i);
			adj2++;
		}
	}
	adj/=adj2;
	//cout<<"Alignment of NOE data is "<<adj<<endl;


	//remove entry with multiply atoms
	for(i=nmrcons->size()-1;i>=0;i--)
	{
		if(nmrcons->at(i).multi==1)
		{
			cout<<"Remove noe entry with umbigirious assignment. "<<nmrcons->at(i).id<<endl;
			nmrcons->erase(nmrcons->begin()+i);
		}
	}


	for(i=0;i<nmrcons->size();i++)
	{
        nmrcons->at(i).group=1;
		nmrcons->at(i).index1.length=0.0;
		nmrcons->at(i).index2.length=0.0;
		nmrcons->at(i).resid1-=adj;
		nmrcons->at(i).resid2-=adj;

		if(nmrcons->at(i).resid1>=1 && nmrcons->at(i).resid2>=1 && nmrcons->at(i).resid1<=(int)v.size() && nmrcons->at(i).resid2<=(int)v.size() )
		{
			nmrcons->at(i).index1=v.at(nmrcons->at(i).resid1-1)->query(nmrcons->at(i).atomname1);
			nmrcons->at(i).index2=v.at(nmrcons->at(i).resid2-1)->query(nmrcons->at(i).atomname2);
		}
		else
		{
			nmrcons->erase(nmrcons->begin()+i);
			i--;
		}
	}
	return adj;

}

void CPdb::outputnoe(string filename, vector <struct noeline> * nmrcons)
{
	int i;
	ofstream fout;

	fout.open(filename.c_str());

	for(i=0;i<nmrcons->size();i++)
	{
		fout<<nmrcons->at(i).group<<" ";
		fout<<nmrcons->at(i).resid1<<" ";
		fout<<nmrcons->at(i).resname1<<" ";
		fout<<nmrcons->at(i).atomname1<<" ";
		fout<<nmrcons->at(i).resid2<<" ";
		fout<<nmrcons->at(i).resname2<<" ";
		fout<<nmrcons->at(i).atomname2<<" ";
		fout<<nmrcons->at(i).b<<" ";
		fout<<nmrcons->at(i).c<<" ";
		fout<<nmrcons->at(i).a;
		fout<<endl;
	}
	fout.close();

	return;
}

void CPdb::inputnoe(string filename, vector <struct noeline> * nmrcons)
{
	int i;
	ifstream fin;
	struct noeline noe;
	string line,p;
	vector<string> ps;

	fin.open(filename.c_str());

	istringstream iss;

	i=0;
	while(getline(fin,line))
	{
		iss.clear();
		iss.str(line);
		ps.clear();
		
		while(iss>>p)
		{
			ps.push_back(p);
		}

		if(ps.size()>10)
		{
			noe.group=atoi(ps.at(0).c_str());
			noe.id=i++;
			noe.multi=0;
			noe.resid1=atoi(ps.at(2).c_str());
			noe.resname1=ps.at(3);
			noe.atomname1=ps.at(4);
			noe.resid2=atoi(ps.at(5).c_str());
			noe.resname2=ps.at(6);
			noe.atomname2=ps.at(7);
			noe.b=atof(ps.at(8).c_str());
			noe.c=atof(ps.at(9).c_str());
			noe.a=atof(ps.at(10).c_str());
			nmrcons->push_back(noe);
		}
	}
	fin.close();


	for(i=0;i<nmrcons->size();i++)
	{
		nmrcons->at(i).index1.length=0.0;
		nmrcons->at(i).index2.length=0.0;
		if(nmrcons->at(i).resid1>=1 && nmrcons->at(i).resid2>=1 && nmrcons->at(i).resid1<=(int)v.size() && nmrcons->at(i).resid2<=(int)v.size() )
		{
			nmrcons->at(i).index1=v.at(nmrcons->at(i).resid1-1)->query(nmrcons->at(i).atomname1);
			nmrcons->at(i).index2=v.at(nmrcons->at(i).resid2-1)->query(nmrcons->at(i).atomname2);
		}
	}

	return;
}




int CPdb::load_exactnoe(string filename,vector <struct noeline> *nmrcons)
{
	ifstream fin(filename.c_str());
	string line,p;
	istringstream iss;
	struct noeline tline;
	string nmrseq;
	char c1,c2;
	int i;

	i=0;
	while(getline(fin,line))
	{
		i++;
		tline.id=i;
		iss.clear();
		iss.str(line);
		iss>>tline.resid1>>tline.resname1>>tline.atomname1;
		iss>>tline.resid2>>tline.resname2>>tline.atomname2;
		iss>>tline.a>>tline.c;
		nmrcons->push_back(tline);
	}

	for(i=0;i<nmrcons->size();i++)
	{
		c1=Sequence::name2code(nmrcons->at(i).resname1);
		c2=Sequence::name2code(nmrcons->at(i).resname2);
		if(nmrcons->at(i).resid1>=nmrseq.size())
		{
			nmrseq.resize(nmrcons->at(i).resid1+1,'U');
		}
		nmrseq.at(nmrcons->at(i).resid1)=c1;
		if(nmrcons->at(i).resid2>=nmrseq.size())
		{
			nmrseq.resize(nmrcons->at(i).resid2+1,'U');
		}
		nmrseq.at(nmrcons->at(i).resid2)=c2;
	}

	int adj,adj2;
	string out1,out2,out3;
	vector<int> out=Sequence::aligno(pdbseq,nmrseq,out1,out2,out3);
	adj=0;adj2=0;
	for(i=out.size()/10;i<out.size()-out.size()/10;i++)
	{
		if(out.at(i)!=0)
		{
			adj+=(out.at(i)-i);
			adj2++;
		}
	}
	adj/=adj2;
	cout<<out1<<endl;
	cout<<out2<<endl;
	cout<<out3<<endl;



	for(i=0;i<nmrcons->size();i++)
	{
		nmrcons->at(i).index1.length=0.0;
		nmrcons->at(i).index2.length=0.0;
		nmrcons->at(i).resid1-=adj;nmrcons->at(i).resid1++;
		nmrcons->at(i).resid2-=adj;nmrcons->at(i).resid2++;

		if(nmrcons->at(i).resid1>=1 && nmrcons->at(i).resid2>=1 && nmrcons->at(i).resid1<=(int)v.size() && nmrcons->at(i).resid2<=(int)v.size() )
		{
			nmrcons->at(i).index1=v.at(nmrcons->at(i).resid1-1)->query(nmrcons->at(i).atomname1);
			nmrcons->at(i).index2=v.at(nmrcons->at(i).resid2-1)->query(nmrcons->at(i).atomname2);
		}
		else
		{
			nmrcons->erase(nmrcons->begin()+i);
			i--;
		}
	}

	return 0;
}





int CPdb::loaddihecons(string filename,vector<struct diheline> *dihes)		
{
	ifstream fin(filename.c_str());
	string line;
	vector<string> block;
	bool bstart,inloop,begin;


	bstart=0;
	inloop=0;
	begin=0;

	block.clear();
	while(getline(fin,line))
	{
		if(line.size()<4)
			continue;

		if(begin==1 &&  line.find("stop_")!=string::npos)
		{
			bstart=begin=0;
			dihecons_actualload(&block,dihes);
			block.clear();
		}

		if(begin==1)
			block.push_back(line);


		if(line.find("loop_")!=string::npos)
			inloop=1;
		if(line.find("stop_")!=string::npos)
			inloop=0;

		if(inloop==0 && line.find("save_CNS/XPLOR_dihedral")!=string::npos)
			bstart=1;

		if(bstart==1 && inloop==1 && line.find("_Torsion_angle_constraint.Torsion_angle_constraint_list_ID")!=string::npos)
			begin=1;
	}

	if(block.size()>0) 
	{
		dihecons_actualload(&block,dihes);
		block.clear();
	}
	return 0;
}


int CPdb::dihecons_actualload(vector<string>* block,vector<struct diheline> *dihes)
{
	istringstream iss;
	string p;
	int i,j,m;
	string nmrseq;
	vector<int> out;
	char c1,c2;
	int adj,adj2;
	bool bremove;

	dihes->resize(block->size());
	for(i=0;i<block->size();i++)
	{
		iss.clear();
		iss.str(block->at(i));
		iss>>dihes->at(i).id;
		iss>>p;
		for(j=0;j<4;j++)
		{
			iss>>p>>p;
			iss>>m;dihes->at(i).resid.push_back(m);
			iss>>p;dihes->at(i).resname.push_back(p);
			iss>>p;dihes->at(i).atomname.push_back(p);
		}
		iss>>dihes->at(i).upper>>dihes->at(i).lower;
		dihes->at(i).middle=(dihes->at(i).lower+dihes->at(i).upper)/2.0;
		dihes->at(i).delta=fabs(dihes->at(i).upper-dihes->at(i).lower)/2.0;

		c1=Sequence::name2code(dihes->at(i).resname[0]);
		c2=Sequence::name2code(dihes->at(i).resname[3]);
		for(j=0;j<4;j++)	dihes->at(i).resid[j]--;
		if(dihes->at(i).resid[0]+1>nmrseq.size())
			nmrseq.resize(dihes->at(i).resid[0]+1,'U');
		nmrseq.at(dihes->at(i).resid[0])=c1;
		if(dihes->at(i).resid[3]+1>nmrseq.size())
			nmrseq.resize(dihes->at(i).resid[3]+1,'U');
		nmrseq.at(dihes->at(i).resid[3])=c2;
	}

	out=Sequence::align(pdbseq,nmrseq);
	adj=0;adj2=0;
	for(i=0;i<out.size();i++)
	{
		if(out.at(i)!=0)
		{
			adj+=(out.at(i)-i);
			adj2++;
		}
	}
	adj/=adj2;

	for(i=dihes->size()-1;i>=0;i--)
	{
		bremove=0;
		for(j=0;j<4;j++)
		{
			dihes->at(i).resid[j]++;
			dihes->at(i).resid[j]-=adj;
			if(dihes->at(i).resid[j]<1 || dihes->at(i).resid[j]>v.size())
				bremove=1;
		}
		if(bremove)
		{
			cerr<<"Remove dihes cons ID "<<dihes->at(i).id<<" because it is out-of-bound"<<endl;
			dihes->erase(dihes->begin()+i);
		}
	}




	for(i=0;i<dihes->size();i++)
	{
		dihes->at(i).index.resize(4);
		for(j=0;j<4;j++)
			dihes->at(i).index[j]=v.at(dihes->at(i).resid[j]-1)->query(dihes->at(i).atomname[j]);
	}
	return 0;
}

int CPdb::buildpdb(string seq)
{	
	string residue;
	CAminoacid *t;
	int nres;
	int i;

	for(i=0;i<seq.size();i++)
	{
		residue=Sequence::code2name(seq.at(i));
		t=NULL;
		if(residue=="ALA")	t=new CAla;
		else if(residue=="ARG")	t=new CArg;
		else if(residue=="ASN")	t=new CAsn;
		else if(residue=="ASP")	t=new CAsp;
		else if(residue=="GLN")	t=new CGln;
		else if(residue=="GLU")	t=new CGlu;
		else if(residue=="GLY")	t=new CGly;
		else if(residue=="HIS")	t=new CHis;
		else if(residue=="HID")	t=new CHis;
		else if(residue=="HIE")	t=new CHis;
		else if(residue=="ILE")	t=new CIle;
		else if(residue=="LEU") t=new CLeu;
		else if(residue=="LYS")	t=new CLys;
		else if(residue=="LYP")	t=new CLys;
		else if(residue=="MET")	t=new CMet;
		else if(residue=="PHE")	t=new CPhe;
		else if(residue=="PRO")	t=new CPro;
		else if(residue=="SER")	t=new CSer;
		else if(residue=="THR")	t=new CThr;
		else if(residue=="TYR")	t=new CTyr;
		else if(residue=="VAL")	t=new CVal;
		else if(residue=="TRP")	t=new CTrp;
		else if(residue=="CYS")	t=new CCys;
		else if(residue=="CYN")	t=new CCys;
		else if(residue=="CYX")	t=new CCyx;
		else if(residue=="UNK")	t=new CUnk;
		else t=new CUnk;

		t->setresidue(i+1);

		v.push_back(t);
	}

	nres=v.size();
	natom=0;
	natom2=0;
	chains.push_back(v.size());

	return natom;
}

void CPdb::setup(CAminoacid *t, CLigand *tt, int iligand, string residue , int index_old,vector<string> block)
{
	return;
}

int CPdb::loadpdb(string filename)
{
	string line,part;
	ifstream fin(filename.c_str());
	pdbfilename=filename;
	bool first;
	int iligand;
	int atomindex;
	int index,index_old;
	string chain,chain_old;
	string residue,residue_old;
	struct proteinblock pdbblock;
	string add;
	char buffer[10];
	

	cout<<"load in "<<pdbfilename<<endl;

	clear(); //clear all data before load in new PDB information
	iligand=0;
	atomindex=0;
	first=1;
	index_old=1;
	chain_old=" ";
	while(getline(fin,line))
	{
		part=line.substr(0,6);
		if(part=="SEQADV")
		{

		}



		part=line.substr(0,6);
		if(part=="END" || part=="ENDMDL")
		{
			break;
		}

		part=line.substr(0,3);
		if(part=="TER")
		{
			//following is ligand or water in most case
			//or another chain! need to be taken care of this situation
			iligand=1;
			continue;
		}

		//neglect all entries that are not ATOM or HETATM
		part=line.substr(0,6);
		if(part!="ATOM  " && part!="HETATM")
			continue;


		//ignore water molecules.
		part=line.substr(17,3);
		if(part=="HOH" || part=="WAT")
			continue;

		
		index=atoi(line.substr(22,4).c_str());
		chain=line.substr(21,1);
		residue=line.substr(17,3);

		//Put in real atom index, this is important for coor processing !!
		atomindex++;
		sprintf(buffer,"%5d",atomindex);
		add=buffer;
		line.replace(6,5,add);

		if(first==1)
		{
			first=0;
			index_old=index;
			chain_old=chain;
			residue_old=residue;
			pdbblock.block.push_back(line);
			pdbblock.iligand=iligand;
			pdbblock.residue=residue;
			pdbblock.index=index;
		}
		else if(index==index_old && chain==chain_old )
		{
			pdbblock.block.push_back(line);
		}
		else if(chain==chain_old && index>index_old ) // new residue
		{
			blocks.push_back(pdbblock);
			pdbblock.block.clear();
			pdbblock.block.push_back(line);  
			pdbblock.iligand=iligand;
			pdbblock.index=index;
			pdbblock.residue=residue;
			index_old=index;
			residue_old=residue;
		}
		else if(chain==chain_old && index<index_old ) //most likely a new chain
		{
			blocks.push_back(pdbblock);
			chain_block.push_back(blocks.size());
			iligand=0;
			pdbblock.block.clear();
			pdbblock.block.push_back(line);	
			pdbblock.iligand=iligand;
			pdbblock.index=index;
			pdbblock.residue=residue;
			index_old=index;
			residue_old=residue;
			chain_old=chain;
		}
		else if(chain!=chain_old)
		{
			blocks.push_back(pdbblock);
			chain_block.push_back(blocks.size());
			iligand=0;
			pdbblock.block.clear();
			pdbblock.block.push_back(line);	
			pdbblock.iligand=iligand;
			pdbblock.index=index;
			pdbblock.residue=residue;
			index_old=index;
			residue_old=residue;
			chain_old=chain;
		}
	}
	
	if(pdbblock.block.size()>0)
		blocks.push_back(pdbblock);
	chain_block.push_back(blocks.size());

	//start part 2 here
	int start,begin,stop,stop2;
	CAminoacid *t,*t2;
	CLigand *tt;
	int n;
	int i,j,ii;
	natom=natom2=0;


	for(ii=0;ii<chain_block.size();ii++)
	{
		if(ii==0)
			start=0;
		else
			start=chain_block.at(ii-1);
		stop=chain_block.at(ii);
		n=0;
		stop2=stop;


		pdbblock=blocks.at(stop-1);
		if(pdbblock.iligand==0)
		{
			//even without TER, res has only one line is mostly a ligand,if it is the last entry
			if(pdbblock.block.size()==1 )
			{
					blocks.at(stop-1).iligand=1;
					stop2=stop-1;
			}
		}

		for(i=stop-2;i>=start;i--)
		{
			pdbblock=blocks.at(i);
			if(pdbblock.iligand==0 && blocks.at(i+1).iligand==1)
			{
				//even without TER, res has only one line is mostly a ligand, if following one is also a ligand
				if(pdbblock.block.size()==1 )
				{
					blocks.at(i).iligand=1;
					stop2=i;
				}
			}
		}


		for(i=start;i<stop;i++)
		{
			
			pdbblock=blocks.at(i);
			if(pdbblock.iligand==0)
			{
				residue=pdbblock.residue;
				if(residue=="ALA")	t=new CAla;
				else if(residue=="ARG")	t=new CArg;
				else if(residue=="ASN")	t=new CAsn;
				else if(residue=="ASP")	t=new CAsp;
				else if(residue=="GLN")	t=new CGln;
				else if(residue=="GLU")	t=new CGlu;
				else if(residue=="GLY")	t=new CGly;
				else if(residue=="HIS")	t=new CHis;	
				else if(residue=="HID")	t=new CHis;
				else if(residue=="HIE")	t=new CHis;
				else if(residue=="ILE")	t=new CIle;
				else if(residue=="LEU")	t=new CLeu;
				else if(residue=="LYS")	t=new CLys;
				else if(residue=="LYP")	t=new CLys;
				else if(residue=="MET")	t=new CMet;
				else if(residue=="PHE")	t=new CPhe;
				else if(residue=="PRO")	t=new CPro;
				else if(residue=="SER")	t=new CSer;
				else if(residue=="THR")	t=new CThr;
				else if(residue=="TYR")	t=new CTyr;
				else if(residue=="VAL")	t=new CVal;
				else if(residue=="TRP") t=new CTrp;
				else if(residue=="CYS") t=new CCys;
				else if(residue=="CYN") t=new CCys;
				else if(residue=="CYX") t=new CCyx;
				else if(iligand>=2) tt=new CLigand;
				else
				{
					t=new CUnk;
					#ifndef BENCHMARK
					cout<<"Warning! unrecognized residue name "<<residue<<" for residue "<<index_old<<endl;
					printblock(pdbblock.block);
					#endif
				}

				n++;t->setresidue(n);
				if(i==start) t->setnterminal();
				if(i==stop2-1) t->setcterminal();
				else if(blocks.at(i+1).iligand==1) t->setcterminal();
				t->process(pdbblock.block);
				natom+=pdbblock.block.size();
				
				if(i>start)
				{
					for(j=blocks.at(i-1).index+1;j<pdbblock.index;j++)
					{
						t2=new CMiss;
						n++;t2->setresidue(n);
						v.push_back(t2);
						nmiss++;
					}
				}
				v.push_back(t);
			}
			else //ligand
			{
				tt=new CLigand;
				n++;tt->setresidue(n);
				tt->process(pdbblock.block);
				natom2+=pdbblock.block.size();
				ligand.push_back(tt);
			}
		}//for(i=start;i<stop;i++)

		chains.push_back(v.size());
		chain_ligand.push_back(ligand.size());
	}



	//re-index residues
	for(j=0;j<(int)chains.size();j++)
	{
		if(j==0)
			begin=0;
		else
			begin=chains.at(j-1);
		stop=chains.at(j);

		for(i=begin;i<stop;i++)
		{
			v.at(i)->setresidue(i+1);
		}
	}


	for(j=0;j<(int)chains.size();j++)
	{
		if(j==0)
			begin=0;
		else
			begin=chains.at(j-1);
		stop=chains.at(j);

		//set up chain information
		for(i=begin;i<stop;i++)
			v.at(i)->chain=j;

		for(i=begin;i<stop-1;i++)
		{	
			v.at(i)->setfollowingn(v.at(i+1)->get("N").index);
		}
		v.at(stop-1)->setfollowingn(v.at(stop-1)->get("O").index);
		
		for(i=begin+1;i<stop;i++)
		{
			v.at(i)->setpreviousc(v.at(i-1)->get("C").index);
		}
		v.at(begin)->setpreviousc(v.at(begin)->get("H1").index);

		//residue index from the PDB file may be inconsistent
	}

	for(i=0;i<(int)v.size();i++)
	{
		pdbseq.push_back(v.at(i)->OneLetterName);
	}

	return (natom+natom2);

}


		

int CPdb::loadpdb_old(string filename)
{
	bool bres;
	int i,j,n;
	int begin,stop;
	int atomindex;
	int iligand;
	vector<string> block;
	string line, part, residue,chain,chain_old,add;
	int index,index_old;
	bool first;
	char buffer[6];

	pdbfilename=filename;

	clear();
	
	ifstream fin(filename.c_str());
	CAminoacid *t;
	CLigand *tt;

	
	natom=natom2=0;
	first=1;
	atomindex=0;
	iligand=0;
	nmiss=0;


	cout<<"load in "<<pdbfilename<<endl;
	while(getline(fin,line))
	{
		part=line.substr(0,6);
		if(part=="ENDMDL")
		{
			break;
		}

		part=line.substr(0,3);
		if(part=="TER")
		{
			//following is ligand or water in most case
			//or another chain! need to be taken care of this situation
			iligand=1;
			continue;
		}

		part=line.substr(0,6);
		if(part!="ATOM  " && part!="HETATM")
			continue;

		part=line.substr(17,3);
		if(part=="HOH" || part=="WAT")
			continue;

		atomindex++;
		index=atoi(line.substr(22,4).c_str());
		chain=line.substr(21,1);


		if(first==1)
		{
			first=0;
			index_old=index;
			chain_old=chain;
			residue=line.substr(17,3);
			n=0;
		}
		bres=0;

		if(index==index_old  && chain==chain_old) //same residue
		{
			if(line.substr(17,3)==residue)
			{
				sprintf(buffer,"%5d",atomindex);
				add=buffer;
				line.replace(6,5,add);
				block.push_back(line);
			}
			else
			{
				cout<<"Warning: same residue index but different residue name!   ";
				cout<<line<<endl;
			}
		}
		else if(chain != chain_old) //new chain, so that there is also new residue
		{
			chains.push_back((int)v.size()+1);
			if(chain.compare("A")!=0 ) iligand=0;
			bres=1;
			n=0;
		}
		else if(index!=index_old)//same chain, but new residue.
		{
			bres=1;
		}
		else //must be error, so we break;
		{
			cout<<"Error in processing PDB file! Processing aborted!"<<endl;
			break;
		}


		if(bres==1)  //
		{
			t=NULL;
			tt=NULL;
		if(residue=="ALA")	t=new CAla;
		else if(residue=="ARG")	t=new CArg;
		else if(residue=="ASN")	t=new CAsn;
		else if(residue=="ASP")	t=new CAsp;
		else if(residue=="GLN")	t=new CGln;
		else if(residue=="GLU")	t=new CGlu;
		else if(residue=="GLY")	t=new CGly;
		else if(residue=="HIS")	t=new CHis;	
		else if(residue=="HID")	t=new CHis;
		else if(residue=="HIE")	t=new CHis;
		else if(residue=="ILE")	t=new CIle;
		else if(residue=="LEU")	t=new CLeu;
		else if(residue=="LYS")	t=new CLys;
		else if(residue=="LYP")	t=new CLys;
		else if(residue=="MET")	t=new CMet;
		else if(residue=="PHE")	t=new CPhe;
		else if(residue=="PRO")	t=new CPro;
		else if(residue=="SER")	t=new CSer;
		else if(residue=="THR")	t=new CThr;
		else if(residue=="TYR")	t=new CTyr;
		else if(residue=="VAL")	t=new CVal;
		else if(residue=="TRP") t=new CTrp;
		else if(residue=="CYS") t=new CCys;
		else if(residue=="CYN") t=new CCys;
		else if(residue=="CYX") t=new CCyx;
		else if(iligand>=2) tt=new CLigand;
		else
		{
			t=new CUnk;
#ifndef BENCHMARK
			cout<<"Warning! unrecognized resiude name "<<residue<<" fore residue "<<index_old<<endl;
			printblock(block);
#endif
		}

			if(t!=NULL)
			{
				n++;t->setresidue(n);
				if(n==1) t->setnterminal();
				t->process(block);
				natom+=block.size();
				v.push_back(t);
				if(iligand>0)
					iligand++;
				//cout<<natom<<endl;
			}

			if(tt!=NULL)
			{
				tt->process(block);
				natom2+=block.size();
				ligand.push_back(tt);
			}
			
			//insert missing residues if necessary
			if(iligand<2)
			{
				for(i=index_old+1;i<index;i++)
				{
					t=new CMiss;
					n++;t->setresidue(n);
					v.push_back(t);
					nmiss++;
				}
			}

			

			//prepare for new residues
			index_old=index;
			chain_old=chain;
			block.clear();
			index=atoi(line.substr(22,4).c_str());
			chain=line.substr(21,1);

			sprintf(buffer,"%5d",atomindex);
			add=buffer;
			line.replace(6,5,add);

			block.push_back(line);
			residue=line.substr(17,3);
		}

	}

	

	if(block.size()>0)
	{
		if(iligand>=1)
			iligand++;
		
		t=NULL;
		tt=NULL;
		
		if(residue=="ALA")	t=new CAla;
		else if(residue=="ARG")	t=new CArg;
		else if(residue=="ASN")	t=new CAsn;
		else if(residue=="ASP")	t=new CAsp;
		else if(residue=="GLN")	t=new CGln;
		else if(residue=="GLU")	t=new CGlu;
		else if(residue=="GLY")	t=new CGly;
		else if(residue=="HIS")	t=new CHis;	
		else if(residue=="HID")	t=new CHis;
		else if(residue=="HIE")	t=new CHis;
		else if(residue=="ILE")	t=new CIle;
		else if(residue=="LEU")	t=new CLeu;
		else if(residue=="LYS")	t=new CLys;
		else if(residue=="LYP")	t=new CLys;
		else if(residue=="MET")	t=new CMet;
		else if(residue=="PHE")	t=new CPhe;
		else if(residue=="PRO")	t=new CPro;
		else if(residue=="SER")	t=new CSer;
		else if(residue=="THR")	t=new CThr;
		else if(residue=="TYR")	t=new CTyr;
		else if(residue=="VAL")	t=new CVal;
		else if(residue=="TRP") t=new CTrp;
		else if(residue=="CYS") t=new CCys;
		else if(residue=="CYN") t=new CCys;
		else if(residue=="CYX") t=new CCyx;
		else if(iligand>=2) tt=new CLigand;
		else
		{
			t=new CUnk;
#ifndef BENCHMARK
			cout<<"Warning! unrecognized resiude name "<<residue<<" fore residue "<<index_old<<endl;
			printblock(block);
#endif
		}

		if(t!=NULL)
		{
			n++;t->setresidue(n);
			t->process(block);
			natom+=block.size();
			v.push_back(t);
		}
		if(tt!=NULL)
		{
			tt->process(block);
			ligand.push_back(tt);
			natom2+=block.size();
		}
		chains.push_back((int)v.size());
	}

	//re-index residues
	for(j=0;j<(int)chains.size();j++)
	{
		if(j==0)
			begin=0;
		else
			begin=chains.at(j-1);
		stop=chains.at(j);

		for(i=begin;i<stop;i++)
		{
			v.at(i)->setresidue(i+1-begin);
		}
	}


	for(j=0;j<(int)chains.size();j++)
	{
		if(j==0)
			begin=0;
		else
			begin=chains.at(j-1);
		stop=chains.at(j);

		for(i=begin;i<stop-1;i++)
		{	
			v.at(i)->setfollowingn(v.at(i+1)->get("N").index);
		}
		v.at(stop-1)->setfollowingn(v.at(stop-1)->get("O").index);
		
		for(i=begin+1;i<stop;i++)
		{
			v.at(i)->setpreviousc(v.at(i-1)->get("C").index);
		}
		v.at(begin)->setpreviousc(v.at(begin)->get("H1").index);

		//residue index from the PDB file may be inconsistent
	}

	for(i=0;i<(int)v.size();i++)
	{
		pdbseq.push_back(v.at(i)->OneLetterName);
	}

	return (natom+natom2);
}


bool CPdb::bisunknownmissing()
{
	int i;
	bool flag1,flag2,flag3;

	flag1=0;
	flag2=0;
	flag3=0;

	for(i=0;i<(int)v.size();i++)
	{
		if(v.at(i)->OneLetterName!='X' && flag2==0)
		{
			flag1=1;
			continue;
		}
		if(v.at(i)->OneLetterName=='X' && flag1==1)
		{
			flag1=0;
			flag2=1;
			continue;
		}
		if(v.at(i)->OneLetterName!='X' && flag2==1)
		{
			flag3=1;
			flag1=0;
			flag2=0;
			break;
		}
	}

	return flag3;
}

		



void CPdb::printpdb(char * filename, int flag)
{
	int i,n;
	FILE *fp;

	fp=fopen(filename,"wt");
	n=1;
	for(i=0;i<v.size();i++)
	{
		if(flag==0) v.at(i)->printpdb(fp,atomname,x,y,z,b,n);
		else v.at(i)->printpdb(fp,atomname,x,y,z,b2,n);
	}
	fclose(fp);
	return;
}
	



void CPdb::printblock(vector<string> block)
{
	int i;
	cout<<"*********************************************************"<<endl;
	for(i=0;i<(int)block.size();i++)
		cout<<block.at(i)<<endl;
	cout<<"*********************************************************"<<endl;
	return;
}

vector<int> CPdb::getselect(string input)
{
	int n,n1,n2;
	vector<int> res;
	vector<int> sel;
	vector<string> atoms;
	size_t found_res,found;
	string part1,part2,part3;
	string p,p1,p2;


	stringstream ss;

	try
	{
		found_res=input.find(':');
		if(found_res==string::npos)
			throw "Can't find :";
		if(found_res!=0)
			throw "First charactor is not :";
		found_res=input.find('@');
		//cout<<"input is "<<input<<" found_res is "<<found_res<<endl;
		if(found_res==string::npos)
			throw "Can't find @";
		part1=input.substr(1,found_res-1);
		part2=input.substr(found_res+1,input.length()-found_res-1);
		//cout<<part1<<endl;
		//cout<<part2<<endl;

		//extract & part to part3
		found_res=input.find('&');
		if(found_res!=string::npos)
		{
			part3=part1.substr(found_res,part1.length()-found_res);
			part1=part1.substr(0,found_res-1);
		}


		//processing part1 now
		ss.str(part1);
		while(getline(ss,p,','))
		{
			found=p.find('-');
			if(found==string::npos)
			{
				if(p=="%")
					n=v.size();
				else
					n=atoi(p.c_str());
				if(n<=0)
					throw "Residue number <=0 ??";
				res.push_back(n);
			}
			else
			{
				p1=p.substr(0,found);
				p2=p.substr(found+1,p.length()-found);
				if(p1=="%")
					n1=v.size();
				else
					n1=atoi(p1.c_str());
				if(p2=="%")
					n2=v.size();
				else
					n2=atoi(p2.c_str());
				if(n1<=0 || n2<=0)
					throw "Residue number <=0 ??";
				for(n=n1;n<=n2;n++)
					res.push_back(n);

			}
		}
		//process part3 now
		if(part3.size()>0)
		{
			for(int i=res.size()-1;i>=0;i--)
			{
				n=res.at(i)-1;
				if(n<0)
					throw "Res index is less than 1";
				if(n>=v.size())
					throw "Res index is larger than nres";
				char c=v.at(n)->getdssp();
				if(part3.find(c)==string::npos)
					res.erase(res.begin()+i);
			}
		}

		//precess part2 now
		ss.clear();
		ss.str(part2);
		while(getline(ss,p,','))
		{
			atoms.push_back(p);
		}
	


		unsigned int i,j;
		for(i=0;i<(int)res.size();i++)
		{
			n=res.at(i)-1;
			if(n<0)
				throw "Res index is less than 1";
			if(n>=v.size())
				throw "Res index is larger than nres";

			for(j=0;j<atoms.size();j++)
			{
				
				if(atoms.at(j).compare("allheavy")==0)
				{
					v.at(n)->bbheavycoor(&sel);
					v.at(n)->heavycoor(&sel);
				}
				else if(atoms.at(j).compare("all")==0)
				{
					v.at(n)->allcoor(&sel);
				}
				else if(atoms.at(j).compare("scheavy")==0)
				{
					v.at(n)->heavycoor(&sel);
				}
				else if(atoms.at(j).compare("bbheavy")==0)
				{
					v.at(n)->bbheavycoor(&sel);
				}				
				else
				{
					n1=v.at(n)->get(atoms.at(j).c_str()).index;
					if(n1>0)
						sel.push_back(n1);
					else
						cout<<"Res "<<n+1<<v.at(n)->OneLetterName<<" doesn't have "<<atoms.at(j).c_str()<<" atom"<<endl;
				}
			}
		}
	}


	catch (const char * str)
	{
		cout<<"Input selection phasing exception raised because "<<str<<". Please check."<<endl;
		cout<<"select all Ca atoms of all residues instead!"<<endl;
		sel.clear();getca(&sel);
	}
	return sel;
}


vector<int> CPdb::getselect(string input,vector<int> res)
{
	int n,n1;
	vector<int> sel;
	vector<string> atoms;
	string part1,part2;
	string p,p1,p2;


	stringstream ss;


	ss.clear();
	ss.str(input);
	while(getline(ss,p,','))
	{
		atoms.push_back(p);
	}
	

	unsigned int i,j;
	for(i=0;i<(int)res.size();i++)
	{
		n=res.at(i)-1;

		for(j=0;j<atoms.size();j++)
		{
			if(atoms.at(j).compare("allheavy")==0)
			{
				v.at(n)->bbheavycoor(&sel);
				v.at(n)->heavycoor(&sel);
			}
			else if(atoms.at(j).compare("all")==0)
			{
				v.at(n)->allcoor(&sel);
			}
			else if(atoms.at(j).compare("scheavy")==0)
			{
				v.at(n)->heavycoor(&sel);
			}
			else if(atoms.at(j).compare("bbheavy")==0)
			{
				v.at(n)->bbheavycoor(&sel);
			}					
			else
			{
				n1=v.at(n)->get(atoms.at(j).c_str()).index;
				if(n1>0)
					sel.push_back(n1);
				else
					cout<<"Res "<<n+1<<v.at(n)->OneLetterName<<" doesn't have "<<atoms.at(j).c_str()<<" atom"<<endl;
			}
		}
	}
	return sel;
}



vector<int> CPdb::getselect(vector<int> &num, string input)
{
    int n,n1;
    unsigned int j;
    vector<int> sel;
    vector<string> atoms;
    string part1,part2;
    string p,p1,p2;
    
    
    stringstream ss;
    
    
    ss.clear();
    ss.str(input);
    while(getline(ss,p,','))
    {
        atoms.push_back(p);
    }
    
    
    
    for(n=0;n<v.size();n++)
    {
        
        for(j=0;j<atoms.size();j++)
        {
            if(atoms.at(j).compare("allheavy")==0)
            {
                v.at(n)->bbheavycoor(&sel);
                v.at(n)->heavycoor(&sel);
            }
            else if(atoms.at(j).compare("all")==0)
            {
                v.at(n)->allcoor(&sel);
            }
            else if(atoms.at(j).compare("scheavy")==0)
            {
                v.at(n)->heavycoor(&sel);
            }
            else if(atoms.at(j).compare("bbheavy")==0)
            {
                v.at(n)->bbheavycoor(&sel);
            }					
            else
            {
                n1=v.at(n)->get(atoms.at(j).c_str()).index;
                if(n1>0)
                    sel.push_back(n1);
                else
                    cout<<"Res "<<n+1<<v.at(n)->OneLetterName<<" doesn't have "<<atoms.at(j).c_str()<<" atom"<<endl;
            }
        }
        num.push_back(sel.size());
    }
    return sel;
}



void CPdb::getca(vector<int> *index)
{
	unsigned int i;
	for(i=0;i<(int)v.size();i++)
	{
		//if(i>40 && i<87) continue;
		index->push_back(v.at(i)->getca());
	}

	return;
}

vector<int> CPdb::getselectca(vector<int> res)
{
	unsigned int i;
	int n;
	vector<int> index;

	for(i=0;i<(int)res.size();i++)
	{
		n=res.at(i);
		if(n>=1 && n<=v.size()) index.push_back(v.at(n-1)->getca());
	}
	return index;
}




void CPdb::getdihe(vector<dihe_group> *t, vector<int> *n)
{
	unsigned int i;

	for(i=0;i<(int)v.size();i++)
	{
		v[i]->bbdihe(t);	
		v[i]->dihe(t);
		n->push_back(t->size());
	}
}


void CPdb::getbbdihe(vector<dihe_group> *t)
{
	unsigned int i;

	for(i=0;i<(int)v.size();i++)
	{
		v[i]->bbdihe(t);	
	}
}


void CPdb::getbbdihe(vector<dihe_group> *t,int *ibb)
{
	unsigned int i;

	for(i=0;i<(int)v.size();i++)
	{
		if( i==0 || i==(int)v.size()-1)
		{
			ibb[i]=0;
		}
		else
		{
			v[i]->bbdihe(t);	
			ibb[i]=1;
		}
	}
}

void CPdb::getbbdihe_nopro(vector<dihe_group> *t,int *ibb)
{
	unsigned int i;

	for(i=0;i<(int)v.size();i++)
	{
		if(v.at(i)->OneLetterName=='P' || i==0 || i==(int)v.size()-1)
		{
			ibb[i]=0;
		}
		else
		{
			v[i]->bbdihe(t);	
			ibb[i]=1;
		}
	}
}



void CPdb::getdihe(vector<dihe_group> *t)
{
	unsigned int i;


	for(i=0;i<(int)v.size();i++)
	{
		v[i]->bbdihe(t);	
		v[i]->dihe(t);
	}
}

void CPdb::getbb(vector<bb_group> *t)
{
	int i,j;
	int begin,stop;

	for(j=0;j<chains.size();j++)
	{
		if(j==0)
			begin=0;
		else
			begin=chains.at(j-1);
		stop=chains.at(j);

		if(stop-begin<3)
			cout<<"Chain "<<j<<" only has 1 or 2 residues! I don't know how to do."<<endl;
	
		v[begin+0]->bb(t);
		v[begin+1]->follow_bb(t);

		for(i=begin+1;i<stop-1;i++)
		{
			v[i]->bb(t);
			v[i-1]->previous_bb(t);
			v[i+1]->follow_bb(t);
		}
		v[stop-1]->bb(t);
	}
	return;
}

void CPdb::getbb_assign(vector<bb_group> *t)
{
    int i,j;
    int begin,stop;
    
    for(j=0;j<chains.size();j++)
    {
        if(j==0)
            begin=0;
        else
            begin=chains.at(j-1);
        stop=chains.at(j);
        
        if(stop-begin<3)
            cout<<"Chain "<<j<<" only has 1 or 2 residues! I don't know how to do."<<endl;
        
        v[begin+0]->bb(t);
        v[begin+1]->follow_bb_assign(t);
        
        for(i=begin+1;i<stop-1;i++)
        {
            v[i]->bb(t);
            v[i-1]->previous_bb(t);
            v[i+1]->follow_bb_assign(t);
        }
        v[stop-1]->bb(t);
    }
    return;
}

void CPdb::bbhbond(vector<bbhbond_group> *t)
{	
	unsigned int i;
	for(i=0;i<(int)v.size();i++)
	{
		v[i]->bbhbond(t);
	}
	return;
}





void CPdb::schbond(vector<bbhbond_group> *t)
{
	unsigned int i;
	for(i=0;i<v.size();i++)
	{
		v[i]->schbond(t);
	}
	return;
}

void CPdb::caha(vector<index_three> *t)
{
	int i;
	for(i=0;i<(int)v.size();i++)
	{
		if(v[i]->OneLetterName != 'G')
			v[i]->caha(t);
	}
	return;
}

void CPdb::bbco(vector<co_group> *t)
{
	int i;
	for(i=0;i<(int)v.size()-1;i++)
	{
		v[i]->bbco(t);
	}
	return;
}


void CPdb::bbnh(vector<nh_group> *t)
{
	int i;
	for(i=0+1;i<(int)v.size();i++)
	{
		if(v[i]->OneLetterName != 'P')
			v[i]->bbnh(t);
	}
	return;
}


void CPdb::ired(vector<struct ired> *t)
{
	int i;
	for(i=0;i<(int)v.size();i++)
	{
		v[i]->ired(t,i);
	}
	return;
}

void CPdb::clearred(void)
{
	int i;
	for(i=0;i<v.size();i++)
		v.at(i)->clearred();
	return;
}


void CPdb::loadred(vector<struct ired> *t)
{
	int i;

	clearred();
	for(i=0;i<t->size();i++)
	{
		if(t->at(i).pos>=0 && t->at(i).pos<v.size())
			v.at(t->at(i).pos)->loadred(t->at(i));
	}

	return;
}
		
void CPdb::loadred(string filename)
{
	ifstream fin(filename.c_str());
	string p,line;
	string name1,name2;
	istringstream iss;
	vector<struct ired> red;
	struct ired t;
	int i,j,base;
	string seq1,seq2;
	vector<int> out;
	double dtotal;
	int n,total;

	clearred();

	while(getline(fin,line))
	{
		iss.clear();
		iss.str(line);
		iss>>t.id>>t.code>>t.s2.name1>>t.s2.name2>>t.s2.exp;
		red.push_back(t);
	}
	fin.close();


	if(red.size()>0) base=red.at(0).id-1;
	for(i=0;i<(int)red.size();i++)
		red.at(i).id-=base;

	base=0;
	seq2.clear();
	for(i=0;i<(int)red.size();i++)
	{
		if(red.at(i).id>base)
		{
			base=red.at(i).id;
			if(seq2.size()<base)
				seq2.resize(base,'X');
			seq2.at(base-1)=red.at(i).code;
		}
	}

	for(i=0;i<(int)v.size();i++)
	{
		seq1.push_back(v.at(i)->OneLetterName);
	}
	out=Sequence::align(seq1,seq2);

	dtotal=0.0;
	n=0;
	for(i=2;i<(int)out.size()-1;i++)
	{
		j=out.at(i);
		if(j!=0 && out.at(i)==out.at(i-1)+1 && out.at(i)==out.at(i+1)-1)
		{
			dtotal+=j-i;
			n++;
		}
	}
	dtotal/=n;
	if(dtotal>=0) total=(int)(dtotal+0.5);
	else total=(int)(dtotal-0.5);



	for(i=0;i<(int)red.size();i++)
	{
		red.at(i).pos=red.at(i).id-total-1;
	}

	loadred(&red);

};
	


void CPdb::getring(vector<ring_group> *t)
{	
	int i;

	for(i=0;i<(int)v.size();i++)
	{
		v[i]->ring(t);
	}

	for(i=t->size()-1;i>=0;i--)
	{
		if(t->at(i).x1==3 || t->at(i).x1==4)
		{
			if(t->at(i).x2<0 || t->at(i).x3<0 || t->at(i).x4<0 || t->at(i).x5<0 || t->at(i).x6<0 )
				t->erase(t->begin()+i);
		}
		else
		{
			if(t->at(i).x2<0 || t->at(i).x3<0 || t->at(i).x4<0 || t->at(i).x5<0 || t->at(i).x6<0 || t->at(i).x7<0)
				t->erase(t->begin()+i);
		}
	}

	return;
}

void CPdb::getred(int in,vector<struct ired> *t)
{
	in--;

	if(in<0 || in>v.size()-1)
		;
	else
		v.at(in)->ired(t,in);

	return;
}

char CPdb::code(int in)
{
	char c;
	in=in-1;
	if(in<0 || in >(int)v.size()-1)
		c='X';
	else
		c=v[in]->OneLetterName;

	return c;
}

int CPdb::chain(int in)
{
	int r;
	in=in-1;
	if(in<0 || in>(int)v.size()-1)
		r=-1;
	else
		r=v[in]->chain;
	return r;
}

void CPdb::name(int in,char *name)
{	in=in-1;
	if(in<0 || in >(int)v.size()-1)
		strcpy(name,"err");
	else
		strcpy(name,v[in]->ThreeLetterName);
}

void CPdb::proton(vector<struct proton> *sel, int flag)
{
	int i;
	sel->clear();
	for(i=0;i<(int)v.size();i++)
	{
		v.at(i)->proton2(sel);
	}

	if(flag==1)
	{
		for(i=0;i<sel->size();i++)
		{
			bool bmiss=0;
			for(int j=0;j<sel->at(i).nh;j++)
			{
				if(sel->at(i).hpos[j]<0)
					bmiss=1;
			}
			if(bmiss==1)
			{
#ifndef BENCHMARK
				cerr<<"Residue "<<sel->at(i).id<<" "<<sel->at(i).code<<" contain missing protons "<<sel->at(i).name<<" , removed"<<endl;
#endif
				sel->erase(sel->begin()+i);
				i--;
			}
		}
	}
}


void CPdb::proton(vector<struct proton> *sel)
{
	int i;
	vector<struct proton> tmp;
	sel->clear();
	for(i=0;i<(int)v.size();i++)
	{
		v.at(i)->proton2(&tmp);
	}
	for(i=0;i<tmp.size();i++)
	{
		bool bmiss=0;
		for(int j=0;j<tmp.at(i).nh;j++)
		{
			if(tmp.at(i).hpos[j]<0) {
				bmiss=1;
				break;
			}
		}
		if(bmiss==1) {
#ifndef BENCHMARK
			cerr<<"Residue "<<sel->at(i).id<<" "<<sel->at(i).code<<" contain missing protons "<<sel->at(i).name<<" , removed"<<endl;
#endif
			//sel->erase(sel->begin()+i);
			//i--;
		} else {
			sel->push_back(tmp.at(i));
		}
	}
}


void CPdb::allproton3(vector<struct proton> *sel)
{
	int i;
	vector<struct proton> tmp;
	sel->clear();
	for(i=0;i<(int)(int)v.size();i++)
	{
		v.at(i)->proton3(&tmp);
	}
	for(i=0;i<tmp.size();i++)
	{
		bool bmiss=0;
		for(int j=0;j<tmp.at(i).nh;j++)
		{
			if(tmp.at(i).hpos[j]<0) {
				bmiss=1;
				break;
			}
		}
		if(bmiss==1) {
#ifndef BENCHMARK
			cerr<<"Residue "<<sel->at(i).id<<" "<<sel->at(i).code<<" contain missing protons "<<sel->at(i).name<<" , removed"<<endl;
#endif
			//sel->erase(sel->begin()+i);
			//i--;
		} else {
			sel->push_back(tmp.at(i));
		}
	}
}

void CPdb::allproton(vector<struct proton> *sel)
{
	int i;
	vector<struct proton> tmp;
	sel->clear();
	for(i=0;i<(int)(int)v.size();i++)
	{
		v.at(i)->proton(&tmp);
	}
	for(i=0;i<tmp.size();i++)
	{
		bool bmiss=0;
		for(int j=0;j<tmp.at(i).nh;j++)
		{
			if(tmp.at(i).hpos[j]<0) {
				bmiss=1;
				break;
			}
		}
		if(bmiss==1) {
#ifndef BENCHMARK
			cerr<<"Residue "<<sel->at(i).id<<" "<<sel->at(i).code<<" contain missing protons "<<sel->at(i).name<<" , removed"<<endl;
#endif
			//sel->erase(sel->begin()+i);
			//i--;
		} else {
			sel->push_back(tmp.at(i));
		}
	}
}

void CPdb::ani(vector<struct ani_group> *anistropy)
{
	int i,j;
	int begin,stop;

	for(j=0;j<chains.size();j++)
	{
		if(j==0)
			begin=0;
		else
			begin=chains.at(j-1);
		stop=chains.at(j);

	
		for(i=begin;i<stop-1;i++)
		{
			v[i]->bbani(anistropy);
			v[i]->ani(anistropy);
		}
		if(stop>1) v[stop-1]->ani(anistropy);

	}


	for(i=anistropy->size()-1;i>=0;i--)
	{
		if(anistropy->at(i).pos[0]<0 || anistropy->at(i).pos[1]<0 || anistropy->at(i).pos[2]<0 )
			anistropy->erase(anistropy->begin()+i);
	}

	return;
}

void CPdb::heavycoor()
{
	int i;
	heavy.clear();
	boundary.clear();
	allcoor.clear();
	for(i=0;i<(int)v.size();i++)
	{
		v.at(i)->bbheavycoor(&heavy);
		v.at(i)->heavycoor(&heavy);
		boundary.push_back(heavy.size());
		v.at(i)->allcoor(&allcoor);
	}

	for(i=0;i<(int)ligand.size();i++)
	{
		ligand.at(i)->heavycoor(&heavy);
		boundary.push_back(heavy.size());
	}

	return;
}



void CPdb::output(string filename)
{
	int i,j;
	int begin,stop;
	FILE *fp;

	fp=fopen(filename.c_str(),"wt");

	for(i=0;i<(int)v.size();i++)
	{
		if(i==0)
			begin=0;
		else
			begin=boundary.at(i-1);
		stop=boundary.at(i);
		for(j=begin;j<stop;j++)
		{
			if(heavy.at(j)>0)
			{
				fprintf(fp,"%d %s %s",i+1,v.at(i)->ThreeLetterName,atomname.at(heavy.at(j)-1).c_str());
				//fprintf(fp," %f %f %f",x.at(heavy.at(j)-1),y.at(heavy.at(j)-1),z.at(heavy.at(j)-1));
				fprintf(fp," %f %f\n",b.at(heavy.at(j)-1),b2.at(heavy.at(j)-1));
			}
		}
	}
	fclose(fp);
	return;
}


void CPdb::caoutput(string filename)
{
	int i,j;
	FILE *fp;

	fp=fopen(filename.c_str(),"wt");

	for(i=0;i<(int)v.size();i++)
	{
		if(i==0)
			j=1;
		else
			j=boundary.at(i-1)+1;
		if(heavy.at(j)>0)
		{
			fprintf(fp,"%d %s",i+1,v.at(i)->ThreeLetterName);
			fprintf(fp," %f %f\n",b.at(heavy.at(j)-1),b2.at(heavy.at(j)-1));
		}
	}
	fclose(fp);
	return;
}



void CPdb::attach_bbprediction(int id,double pre[])
{
	v.at(id-1)->attach_bbprediction(pre);
}

void CPdb::attach_protonprediction(int id,string name,double cs)
{
	v.at(id-1)->attach_protonprediction(name,cs);
}

void CPdb::print_prediction()
{
	string test="bmrb_pre.dat";
	print_prediction(test);
}

void CPdb::print_prediction(string name)
{
	int i,j;
	FILE *fp=fopen(name.c_str(),"wt");
	char toprint0[]="loop_\n    _Residue_seq_code\n     _Residue_label\n";
	char toprint[]="      loop_\n      _Atom_shift_assign_ID\n      _Residue_seq_code\n      _Residue_label\n      _Atom_name\n      _Atom_type\n      _Chem_shift_value\n      _Chem_shift_value_error\n      _Chem_shift_ambiguity_code\n";


	fprintf(fp,toprint0);
	for(i=0;i<(int)v.size();i++)
	{
		fprintf(fp," %d %s",i+1,v.at(i)->ThreeLetterName);
		if(i%3==0) fprintf(fp,"\n");
	}
	fprintf(fp,"\n      stop_\n");
	
	
	fprintf(fp,toprint);
	j=1;
	for(i=0;i<(int)v.size();i++)
		v.at(i)->print_prediction(&j,fp);
	fprintf(fp,"      stop_\n");
	fclose(fp);

	fp=fopen("bb_predict.dat","wt");
	fprintf(fp,"%8s%8s%8s%8s%8s%8s%8s%8s%8s%8s%8s%8s%8s%8s\n","index","residue","pre_ca","exp_ca",
		"pre_cb","exp_cb","pre_c","exp_c","pre_h","exp_h","pre_n","exp_n","pre_ha","exp_ha");
	for(i=0;i<(int)v.size();i++)
		v.at(i)->print_bbprediction(fp);
	fclose(fp);

	fp=fopen("proton_predict.dat","wt");
	fprintf(fp,"%8s %8s %8s %8s %8s\n","#  index","aa type","type","cs","exp");
	for(i=0;i<(int)v.size();i++)
		v.at(i)->print_protonprediction(fp);
	fclose(fp);

}

double CPdb::test_bmbr(class CBmrb bmrb)
{
	int i;
	vector<int> index;
	string seq1,seq2;
	vector<int> out;
	int total;



	index.clear();
	seq2=bmrb.getseq(index);
	for(i=0;i<(int)v.size();i++)
	{
		seq1.push_back(v.at(i)->OneLetterName);
	}
	out=Sequence::align(seq1,seq2);

	total=0;
	for(i=1;i<out.size();i++)
	{
		if(out.at(i)>0 && seq1.at(i-1)!='X')
			total++;
	}

	return ((double)total)/seq2.length();
}


int CPdb::attach_bmrb(class CBmrb bmrb)
{
	int i,j;
	vector<int> index;
	string seq1,seq2;
	vector<int> out;
	int total,n,m;
	double dtotal;
	char c1,c2;

	for(i=0;i<v.size();i++)
		v.at(i)->clearexp();


	index.clear();
	seq2=bmrb.getseq();
	for(i=0;i<(int)v.size();i++)
	{
		seq1.push_back(v.at(i)->OneLetterName);
	}
	out=Sequence::align(seq1,seq2);

	dtotal=0.0;
	n=0;
	for(i=2;i<(int)out.size()-1;i++)
	{
		j=out.at(i);
		if(j!=0 && out.at(i)==out.at(i-1)+1 && out.at(i)==out.at(i+1)-1)
		{
			dtotal+=j-i;
			n++;
		}
	}

	dtotal/=n;


	if(dtotal>=0) total=(int)(dtotal+0.5);
	else total=(int)(dtotal-0.5);



	n=0;
	m=0;
	for(i=1;i<(int)out.size();i++)
	{
		for(j=0;j<bmrb.getsize();j++)
		{
			if(bmrb.getdata(j).res-total==i)
			{
				c1=v.at(i-1)->OneLetterName;
				c2=Sequence::name2code(bmrb.getdata(j).name);
				if(c1==c2)
				{
					v.at(i-1)->loadexp(bmrb.getdata(j));
					n++;
				}
				else
				{
					m++;
					v.at(i-1)->set_mismatch();
				}
			}
		}
	}

	return m;
}

void CPdb::clear_cs()
{
	int i;
	for(i=0;i<(int)v.size();i++)
	{
		v.at(i)->bexploaded=0;
		v.at(i)->exploaded=0;
		v.at(i)->clearexp();
	}
	return;
}



void CPdb::attach_rmsf(vector<double> t)
{
	int i;
	for(i=0;i<v.size();i++)
	{
		v.at(i)->attach_rmsf(t);
	}
	return;
}

void CPdb::print_rmsf(string filename)
{
	FILE *fp;
	int i;

	fp=fopen(filename.c_str(),"rt");
	for(i=0;i<v.size();i++)
	{
		v.at(i)->print_rmsf(fp);
	}
	fclose(fp);
	return;
}




//flag=1: bmrb rc
//flag==2: wang' rc
//flag==3: wang's rc with neighboring correction
void CPdb::attach_coil(int flag=1)
{
	int i;

	if(flag==3 && v.size()>=3 )
	{
		v.at(0)->set_coil_wc('X',v.at(1)->OneLetterName);
		for(i=0+1;i<v.size()-1;i++)
			v.at(i)->set_coil_wc(v.at(i-1)->OneLetterName,v.at(i+1)->OneLetterName);
		v.at(i)->set_coil_wc(v.at(i-1)->OneLetterName,'X');
	}
	else
	{
		for(i=0;i<(int)v.size();i++)
		{
			if(v.at(i)->bexploaded==0)
				v.at(i)->set_coil(flag);
		}
	}


	return;
}

void CPdb::attach_mean()
{
	int i;
	for(i=0;i<(int)v.size();i++)
	{
		if(v.at(i)->bexploaded==0)
			v.at(i)->set_mean();
	}
	return;
}

void CPdb::attach_dssp(string filename)
{
	int i,j;
	string seq1,seq2;
	vector<int> out;


	dssp.loaddata(filename);
	for(i=0;i<(int)v.size();i++)
	{
		seq1.push_back(v.at(i)->OneLetterName);
	}
	seq2=dssp.getseq();
	out=Sequence::align(seq1,seq2);
	for(i=1;i<(int)out.size();i++)
	{
		j=out.at(i);
		if(j!=0)
			v.at(i-1)->setdssp(dssp.data.at(j-1).ss);
	}
	return;
}


void CPdb::attach_dssp()
{
	int i,j;
	string seq1,seq2;
	vector<int> out;


	dssp.loaddata(pdbfilename);
	for(i=0;i<(int)v.size();i++)
	{
		seq1.push_back(v.at(i)->OneLetterName);
	}
	seq2=dssp.getseq();
	out=Sequence::align(seq1,seq2);
	for(i=1;i<(int)out.size();i++)
	{
		j=out.at(i);
		if(j!=0)
			v.at(i-1)->setdssp(dssp.data.at(j-1).ss);
	}
	return;
}

char CPdb::getss(int i)
{
	return v.at(i-1)->getdssp();
}

struct noeatoms CPdb::query(int resid,string name)
{
	return v.at(resid-1)->query(name);
}


CPdb::CPdb()
{nmiss=0;};

CPdb::~CPdb()
{
	clear();
};


//CPdbcut
CPdb2::CPdb2()
{};

CPdb2::~CPdb2()
{ clear(); };

void CPdb2::clear()
{
	int i;

	for(i=0;i<pdbs.size();i++)
	{
		delete pdbs.at(i);
	}

	pdbs.clear();
	return;
}

double CPdb2::loadpdb(string filename)
{
	int i,j;
	ifstream fin(filename.c_str());
	string name;
	string line;
	string part1,part2,part3,part4;
	struct modify mod;
	vector<struct modify> mods;
	char chain;
	char old_chain;
	vector<string> block;
	vector< vector<string> > blocks;
	class CPdb *pdb;
	int ixray;
	char buffer[255];
	double resolution;

	blocks.clear();
	clear();

	name=filename.substr(0,filename.find(".pdb"));


	old_chain=0;
	mods.clear();
	ixray=1;
	resolution=0.0;
	while(getline(fin,line))
	{
		//"SEQADV 1NBF GLZ C  3";
		//"76  UNP  P62988    G";
		//"LY    76 MODIFIED RE";
		//"SIDUE";

		part1=line.substr(0,6);
		if(part1.compare("EXPDTA")==0)
		{
			part2=line.substr(10,5);
			if(part2.compare("X-RAY")==0)
				ixray=1;
			if(part2.compare("SOLUT")==0)
				ixray=0;
			if(part2.compare("SOLID")==0)
				ixray=0;
		}

		part1=line.substr(0,22);
		if(part1.compare("REMARK   2 RESOLUTION.")==0)
		{
			part2=line.substr(22,8);
			resolution=atof(part2.c_str());
		}


		if(ixray==0)
		{
			cout<<"neglect nmr structure "<<filename.c_str()<<endl;
			break;
		}
		if(resolution>2.0)
		{
			cout<<"neglect low resolution ("<<resolution<<") xray structure "<<filename.c_str()<<endl;
			break;
		}

		part1=line.substr(0,6);
		part2=line.substr(49,20);
		if(part1.compare("SEQADV")==0 && part2.find("MODIFIED")!=string::npos)
		{
			mod.from=line.substr(12,3);
			mod.to=line.substr(39,3);
			mod.chain=line.at(16);
			mod.res=atoi(line.substr(18,4).c_str());
			mods.push_back(mod);
		}

		part1=line.substr(0,4);
		part2=line.substr(0,6);
		part3=line.substr(0,3);
		if(part1!="ATOM" && part2!="HETATM" && part3 !="TER")
			continue;
		
		chain=line.at(21);

		if(chain==old_chain)
		{
			block.push_back(line);
		}
		else if(chain>old_chain || (old_chain=='Z' && chain=='A'))
		{
			if(block.size()>0)
				blocks.push_back(block);
			old_chain=chain;
			block.clear();
			block.push_back(line);
		}
		else
		{
			//cout<<"old chain id is "<<old_chain<<" and new chain id is "<<chain<<endl;
			break;
		}
	}

	if(block.size()>0)
		blocks.push_back(block);

	ofstream  fout;
	for(i=0;i<blocks.size();i++)
	{
		block=blocks.at(i);
		sprintf(buffer,"%s-%d.pdb",name.c_str(),i);
		fout.open(buffer,ofstream::out);
		line=block.at(0);
		fout<<"REMART   1  PDB seperated from "<<filename.c_str()<<" chain ID is "<<line.at(21)<<endl;
		for(j=0;j<block.size();j++)
		{
			line=block.at(j);
			line.at(21)=' ';
			fout<<line<<endl;
		}
		fout.close();
		pdb=new CPdb;
		pdb->loadpdb(buffer);
		pdbs.push_back(pdb);
	}

	if(ixray==0)
	{ 
		resolution=100.0;
	}

	return resolution;
};



########## NEXT FILE ##########
supply.cpp:::
#include <iostream>
#include <cstdlib>
#include <fstream>
#include <string>
#include <vector>
#include <math.h>
#include <time.h>
#include <assert.h>
#include <cstring>


using namespace std;

#include "supply.h"
using namespace ldw_math;
 


void CCommandline::pharse(int argc, char** argv)
{
	int i,j;
	for(i=1;i<argc;i++)
	{
		for(j=0;j<narg;j++)
		{
			if(arguments.at(j).compare(argv[i])==0 && argv[i][0]=='-' && argv[i][1]=='-') //started with --, multi followings
			{
				parameters.at(j)=" ";			  // remove default one.
				while(i+1<argc && argv[i+1][0]!='-')  //store multi entries in to this value
				{
					parameters.at(j).append(argv[i+1]);
					parameters.at(j).append(" ");
					i++;
				}
			}
			else if(arguments.at(j).compare(argv[i])==0) // //started with -, normal one
			{
				if(i+1<argc && argv[i+1][0]!='-')
				{
					parameters.at(j)=argv[i+1];
					i++;
				}
				else
					parameters.at(j)="yes";
			}
		}
	}
	return;
}


void CCommandline::init(vector<string> in,vector<string> in2)
{
	int i;
	string t;
	
	narg=in.size();
	for(i=0;i<narg;i++)
	{
		if(in.at(i).at(0)=='-')
		{
			arguments.push_back(in.at(i));
			parameters.push_back(in2.at(i));
		}
		else
		{
			t="-";
			t+=in.at(i);
			arguments.push_back(t);
			parameters.push_back(in2.at(i));
		}
	}
	return;
};

void CCommandline::init(vector<string> in,vector<string> in2, vector<string> in3)
{
	int i;
	string t;
	
	narg=in.size();
	for(i=0;i<narg;i++)
	{
		if(in.at(i).at(0)=='-')
		{
			arguments.push_back(in.at(i));
			parameters.push_back(in2.at(i));
			informations.push_back(in3.at(i));
		}
		else
		{
			t="-";
			t+=in.at(i);
			arguments.push_back(t);
			parameters.push_back(in2.at(i));
			informations.push_back(in3.at(i));
		}
	}
	return;
};

string CCommandline::query(string in)
{
	string out;
	int i;

	out="no";
	for(i=0;i<narg;i++)
	{
		if(arguments.at(i).compare(in)==0)
			out=parameters.at(i);
	}

	return out;
}

void CCommandline::print(void)
{
	int i;
	printf("Command line arguments:\n");
	for(i=0;i<(int)arguments.size();i++)
	{
		printf("%-15s %15s",arguments.at(i).c_str(),parameters.at(i).c_str());
		if(i<(int)informations.size()) printf("     %-50s",informations.at(i).c_str());
		printf("\n");
	}
	printf("\n");
	return;
}


CCommandline::CCommandline() {};
CCommandline::~CCommandline() {};


void CRmsd::setup_rotation(float x[],float y[],float z[],
						float x0[],float y0[],float z0[], 
						int n_list)
	{
	  int n;
	  mov_com0 = mov_com1 = mov_com2 = 0.0f;
	  ref_com0 = ref_com1 = ref_com2 = 0.0f;
	  
	  for (n=0; n<n_list; n++) 
	  { 
		  mov_com0 += x0[n];
		  ref_com0 += x[n];
		  mov_com1 += y0[n];
		  ref_com1 += y[n];
		  mov_com2 += z0[n];
		  ref_com2 += z[n];
	  }
	    
	  mov_com0 /= n_list;
	  ref_com0 /= n_list;
	  mov_to_ref0 = ref_com0 - mov_com0;
	  mov_com1 /= n_list;
	  ref_com1 /= n_list;
	  mov_to_ref1 = ref_com1 - mov_com1;
	  mov_com2 /= n_list;
	  ref_com2 /= n_list;
	  mov_to_ref2 = ref_com2 - mov_com2;

	  for (n=0; n<n_list; n++) 
	  { 
		  x0[n] -= mov_com0;
		  x[n] -= ref_com0;
		  y0[n] -= mov_com1;
		  y[n] -= ref_com1;
		  z0[n] -= mov_com2;
		  z[n] -= ref_com2;
	  }

	  R00 = R01 = R02 = 0.0f;
	  R10 = R11 = R12 = 0.0f;
	  R20 = R21 = R22 = 0.0f;
	  E0 = 0.0f;

	  for (n=0; n<n_list; n++) 
	  {	
		  E0 +=x0[n]*x0[n]+x[n]*x[n]+y0[n]*y0[n]+y[n]*y[n]+z0[n]*z0[n]+z[n]*z[n];
		  R00 += x0[n] * x[n];
		  R01 += x0[n] * y[n];
		  R02 += x0[n] * z[n];
		  R10 += y0[n] * x[n];
		  R11 += y0[n] * y[n];
		  R12 += y0[n] * z[n];
		  R20 += z0[n] * x[n];
		  R21 += z0[n] * y[n];
		  R22 += z0[n] * z[n];
	  }
	  E0 *= 0.5f;

	  return;
	  };

int CRmsd::jacobi3(int* n_rot)
	{
	  int count;
	  float tresh, theta, tau, t, sum, s, h, g, c;
	  float b0,b1,b2;
	  float z0,z1,z2;
	  float gg,hh;

	  vec01=vec02=vec10=vec12=vec20=vec21=0.0f;
	  vec00=vec11=vec22=1.0f;
	  b0 = eigenval0 = RtR00;
	  b1 = eigenval1 = RtR11;
	  b2 = eigenval2 = RtR22;

	  z0=z1=z2=0.0f; 
	  *n_rot = 0;

	  /* 50 tries */
	  for (count=0; count<50; count++)     
	  {

		sum = 0.0f;
		sum += (float)fabs(RtR01);
		sum += (float)fabs(RtR02);
		sum += (float)fabs(RtR12);

		if (sum == 0.0) 
			return(1);

		if (count < 3) 
		  tresh = sum * 0.2f / 9.0f;    
		else       
		  tresh = 0.0f;      

		g = 100.0f * (float)fabs(RtR01);
		if ( count > 3  &&  fabs(eigenval0)+g == fabs(eigenval0) &&  fabs(eigenval1)+g == fabs(eigenval1) ) 
		{
			RtR01 = 0.0f;
		} 
		else if (fabs(RtR01) > tresh) 
		{
			h = eigenval1 - eigenval0;         
			if (fabs(h)+g == fabs(h))
				t = RtR01 / h; 
			else 
			{
				theta = 0.5f * h / (RtR01);
				t = 1.0f / ( (float)fabs(theta) + (float)sqrt(1.0f + theta*theta) );
				if (theta < 0.0f) 
					t = -t;
			}
			
			c = 1.0f / (float) sqrt(1 + t*t);
			s = t * c;
			tau = s / (1.0f + c);
			h = t * RtR01;

			z0 -= h;
			z1 += h;
			eigenval0 -= h;
			eigenval1 += h;

			RtR01 = 0.0f;
			gg=RtR02; hh=RtR12; RtR02=gg-s*(hh+gg*tau); RtR12=hh+s*(gg-hh*tau); //ROTATE(RtR, 0, 2, 1, 2)  
			gg=vec00; hh=vec01; vec00=gg-s*(hh+gg*tau); vec01=hh+s*(gg-hh*tau); //ROTATE(vec, 0, 0, 0, 1)
			gg=vec10; hh=vec11; vec10=gg-s*(hh+gg*tau); vec11=hh+s*(gg-hh*tau); //ROTATE(vec, 1, 0, 1, 1)
			gg=vec20; hh=vec21; vec20=gg-s*(hh+gg*tau); vec21=hh+s*(gg-hh*tau); //ROTATE(vec, 2, 0, 2, 1)
			++(*n_rot);
		}

		g = 100.0f * (float)fabs(RtR02);
		if ( count > 3  &&  fabs(eigenval0)+g == fabs(eigenval0) &&  fabs(eigenval2)+g == fabs(eigenval2) ) 
			RtR02 = 0.0f;
		else if (fabs(RtR02) > tresh) 
		{
			h = eigenval2 - eigenval0;
			if (fabs(h)+g == fabs(h))
				t = RtR02 / h;
			else
			{
				theta = 0.5f * h / (RtR02);
				t = 1.0f / ( (float)fabs(theta) + (float)sqrt(1.0f + theta*theta) );
				if (theta < 0.0f) 
					t = -t;
			}
			c = 1.0f / (float) sqrt(1 + t*t);
			s = t * c;
			tau = s / (1.0f + c);
			h = t * RtR02;

			z0 -= h;
			z2 += h;
			eigenval0 -= h;
			eigenval2 += h;

			RtR02 = 0.0f;
   			gg=RtR01; hh=RtR12; RtR01=gg-s*(hh+gg*tau); RtR12=hh+s*(gg-hh*tau);   
			gg=vec00; hh=vec02; vec00=gg-s*(hh+gg*tau); vec02=hh+s*(gg-hh*tau); 
			gg=vec10; hh=vec12; vec10=gg-s*(hh+gg*tau); vec12=hh+s*(gg-hh*tau); 
			gg=vec20; hh=vec22; vec20=gg-s*(hh+gg*tau); vec22=hh+s*(gg-hh*tau); 
			++(*n_rot);
		}

		g = 100.0f * (float)fabs(RtR12);
		if ( count > 3  &&  fabs(eigenval1)+g == fabs(eigenval1) &&  fabs(eigenval2)+g == fabs(eigenval2) )
			RtR12 = 0.0f;
		else if (fabs(RtR12) > tresh) 
		{
			h = eigenval2 - eigenval1;
			if (fabs(h)+g == fabs(h)) 
				t = RtR12 / h;
			else 
			{
				theta = 0.5f * h / (RtR12);
				t = 1.0f / ( (float)fabs(theta) + (float)sqrt(1.0f + theta*theta) );
				if (theta < 0.0f) 
					t = -t;
			}
	          
			c = 1.0f / (float) sqrt(1 + t*t);
			s = t * c;
			tau = s / (1.0f + c);
			h = t * RtR12;

			z1 -= h;
			z2 += h;
			eigenval1 -= h;
			eigenval2 += h;

			RtR12 = 0.0f;
   			gg=RtR01; hh=RtR02; RtR01=gg-s*(hh+gg*tau); RtR02=hh+s*(gg-hh*tau); //ROTATE(a, 0, 1, 0, 2)  
			gg=vec01; hh=vec02; vec01=gg-s*(hh+gg*tau); vec02=hh+s*(gg-hh*tau); //ROTATE(vec, 0, 1, 0, 2)
			gg=vec11; hh=vec12; vec11=gg-s*(hh+gg*tau); vec12=hh+s*(gg-hh*tau); //ROTATE(vec, 1, 1, 1, 2)
			gg=vec21; hh=vec22; vec21=gg-s*(hh+gg*tau); vec22=hh+s*(gg-hh*tau); //ROTATE(vec, 2, 1, 2, 2)
			++(*n_rot);
		}
		
		b0 += z0; eigenval0 = b0; z0 = 0.0f;
		b1 += z1; eigenval1 = b1; z1 = 0.0f;
		b2 += z2; eigenval2 = b2; z2 = 0.0f;
	  }

	  printf("Too many iterations in jacobi3\n");
	  return (0);
	};

int CRmsd::diagonalize_symmetric()
	{
		int k;
		int n_rot;
		float val; 
		
	  if (!jacobi3(&n_rot)) 
	  {
		  printf("convergence failed\n");
		  return (0);
	  }


	  k = 0;
	  val = eigenval0;
	  if (eigenval1 >= val)
	  { 
		  k = 1;
		  val = eigenval1;
	  }
	  if (eigenval2 >= val)
	  { 
		  k = 2;
		  val = eigenval2;
	  }

	  if (k != 0) 
	  {
		  if(k==1)
		  {
			  eigenval1 = eigenval0;
			  eigenval0 = val;
			  val = vec00;
			  vec00 = vec01;
			  vec01 = val;	
				  
			  val = vec10;
			  vec10 = vec11;
			  vec11 = val;
				  
			  val = vec20;
			  vec20 = vec21;
			  vec21 = val;
		  }

		  else
		  {
			  eigenval2 = eigenval0;
			  eigenval0 = val;
			  val = vec00;
			  vec00 = vec02;
			  vec02 = val;	
				  
			  val = vec10;
			  vec10 = vec12;
			  vec12 = val;
				  
			  val = vec20;
			  vec20 = vec22;
			  vec22 = val;
		  }

	  }


	  k = 1;
	  val = eigenval1;
	  if (eigenval2 >= val)
	  { 
		  k = 2;
		  val = eigenval2;
		  eigenval2 = eigenval1;
		  eigenval1 = val;
		  
		  val = vec01;
		  vec01 = vec02;
		  vec02 = val;
			  
		  val = vec11;
		  vec11 = vec12;
		  vec12 = val;
			  
		  val = vec21;
		  vec21 = vec22;
		  vec22 = val;
	  }

	  right_eigenvec00 = vec00;      right_eigenvec01 = vec10;      right_eigenvec02 = vec20;
	  right_eigenvec10 = vec01;      right_eigenvec11 = vec11;      right_eigenvec12 = vec21;
	  right_eigenvec20 = vec02;      right_eigenvec21 = vec12;      right_eigenvec22 = vec22;
	  
	  return (1);
	};

int CRmsd::calculate_rotation_matrix()
	{
	  float Rt00,Rt01,Rt02,Rt10,Rt11,Rt12,Rt20,Rt21,Rt22;
	  float v0,v1,v2;
	  float sigma;

	  Rt00=R00;Rt01=R10;Rt02=R20;Rt10=R01;Rt11=R11;Rt12=R21;Rt20=R02;Rt21=R12;Rt22=R22;

	  RtR00 = 0.0f;
	  RtR00 += Rt00 * R00;
	  RtR00 += Rt10 * R01;
	  RtR00 += Rt20 * R02;
	  RtR01 = 0.0f;
	  RtR01 += Rt00 * R10;
	  RtR01 += Rt10 * R11;
	  RtR01 += Rt20 * R12;
	  RtR02 = 0.0f;
	  RtR02 += Rt00 * R20;
	  RtR02 += Rt10 * R21;
	  RtR02 += Rt20 * R22;

	  RtR10 = 0.0f;
	  RtR10 += Rt01 * R00;
	  RtR10 += Rt11 * R01;
	  RtR10 += Rt21 * R02;
	  RtR11 = 0.0f;
	  RtR11 += Rt01 * R10;
	  RtR11 += Rt11 * R11;
	  RtR11 += Rt21 * R12;
	  RtR12 = 0.0f;
	  RtR12 += Rt01 * R20;
	  RtR12 += Rt11 * R21;
	  RtR12 += Rt21 * R22;

	  RtR20 = 0.0f;
	  RtR20 += Rt02 * R00;
	  RtR20 += Rt12 * R01;
	  RtR20 += Rt22 * R02;
	  RtR21 = 0.0f;
	  RtR21 += Rt02 * R10;
	  RtR21 += Rt12 * R11;
	  RtR21 += Rt22 * R12;
	  RtR22 = 0.0f;
	  RtR22 += Rt02 * R20;
	  RtR22 += Rt12 * R21;
	  RtR22 += Rt22 * R22;



	  if (!diagonalize_symmetric())
		return(0);

	 
	  right_eigenvec20 = -right_eigenvec11*right_eigenvec02 + right_eigenvec12*right_eigenvec01;
	  right_eigenvec21 = -right_eigenvec12*right_eigenvec00 + right_eigenvec10*right_eigenvec02;
	  right_eigenvec22 = -right_eigenvec10*right_eigenvec01 + right_eigenvec11*right_eigenvec00;
	  

	  left_eigenvec00 = right_eigenvec00*Rt00+right_eigenvec01*Rt01+right_eigenvec02*Rt02;
	  left_eigenvec01 = right_eigenvec00*Rt10+right_eigenvec01*Rt11+right_eigenvec02*Rt12;
	  left_eigenvec02 = right_eigenvec00*Rt20+right_eigenvec01*Rt21+right_eigenvec02*Rt22;
	      
	  left_eigenvec10 = right_eigenvec10*Rt00+right_eigenvec11*Rt01+right_eigenvec12*Rt02;
	  left_eigenvec11 = right_eigenvec10*Rt10+right_eigenvec11*Rt11+right_eigenvec12*Rt12;
	  left_eigenvec12 = right_eigenvec10*Rt20+right_eigenvec11*Rt21+right_eigenvec12*Rt22;
	      
	  left_eigenvec20 = right_eigenvec20*Rt00+right_eigenvec21*Rt01+right_eigenvec22*Rt02;
	  left_eigenvec21 = right_eigenvec20*Rt10+right_eigenvec21*Rt11+right_eigenvec22*Rt12;
	  left_eigenvec22 = right_eigenvec20*Rt20+right_eigenvec21*Rt21+right_eigenvec22*Rt22;
	      

	  float tteemmpp;
	  tteemmpp=(float)sqrt(left_eigenvec00*left_eigenvec00+left_eigenvec01*left_eigenvec01+left_eigenvec02*left_eigenvec02);	
	  left_eigenvec00/=tteemmpp;left_eigenvec01/=tteemmpp;left_eigenvec02/=tteemmpp;
	  tteemmpp=(float)sqrt(left_eigenvec10*left_eigenvec10+left_eigenvec11*left_eigenvec11+left_eigenvec12*left_eigenvec12);	
	  left_eigenvec10/=tteemmpp;left_eigenvec11/=tteemmpp;left_eigenvec12/=tteemmpp;
	  tteemmpp=(float)sqrt(left_eigenvec20*left_eigenvec20+left_eigenvec21*left_eigenvec21+left_eigenvec22*left_eigenvec22);	
	  left_eigenvec20/=tteemmpp;left_eigenvec21/=tteemmpp;left_eigenvec22/=tteemmpp;

	  
	  v0=left_eigenvec01*left_eigenvec12-left_eigenvec02*left_eigenvec11;
	  v1=left_eigenvec02*left_eigenvec10-left_eigenvec00*left_eigenvec12;
	  v2=left_eigenvec00*left_eigenvec11-left_eigenvec01*left_eigenvec10;

	  if(v0*left_eigenvec20+v1*left_eigenvec21+v2*left_eigenvec22< 0.0)
		sigma = -1.0f;
	  else 
		sigma = 1.0f;
	  
		
	 
	  left_eigenvec20 = v0; 
	  left_eigenvec21 = v1; 
	  left_eigenvec22 = v2; 

	  
	  
	  residual = E0 - (float) sqrt(fabs(eigenval0)) - (float) sqrt(fabs(eigenval1)) - sigma*(float) sqrt(fabs(eigenval2));
	  return (1);
	};


	void CRmsd::get_rotation_matrix()
	{
	  
	  U00 = 0.0f;
	  U00 += left_eigenvec00 * right_eigenvec00;
	  U00 += left_eigenvec10 * right_eigenvec10;
	  U00 += left_eigenvec20 * right_eigenvec20;
	  U01 = 0.0f;
	  U01 += left_eigenvec00 * right_eigenvec01;
	  U01 += left_eigenvec10 * right_eigenvec11;
	  U01 += left_eigenvec20 * right_eigenvec21;
	  U02 = 0.0f;
	  U02 += left_eigenvec00 * right_eigenvec02;
	  U02 += left_eigenvec10 * right_eigenvec12;
	  U02 += left_eigenvec20 * right_eigenvec22;

	  U10 = 0.0f;
	  U10 += left_eigenvec01 * right_eigenvec00;
	  U10 += left_eigenvec11 * right_eigenvec10;
	  U10 += left_eigenvec21 * right_eigenvec20;
	  U11 = 0.0f;
	  U11 += left_eigenvec01 * right_eigenvec01;
	  U11 += left_eigenvec11 * right_eigenvec11;
	  U11 += left_eigenvec21 * right_eigenvec21;
	  U12 = 0.0f;
	  U12 += left_eigenvec01 * right_eigenvec02;
	  U12 += left_eigenvec11 * right_eigenvec12;
	  U12 += left_eigenvec21 * right_eigenvec22;

	  U20 = 0.0f;
	  U20 += left_eigenvec02 * right_eigenvec00;
	  U20 += left_eigenvec12 * right_eigenvec10;
	  U20 += left_eigenvec22 * right_eigenvec20;
	  U21 = 0.0f;
	  U21 += left_eigenvec02 * right_eigenvec01;
	  U21 += left_eigenvec12 * right_eigenvec11;
	  U21 += left_eigenvec22 * right_eigenvec21;
	  U22 = 0.0f;
	  U22 += left_eigenvec02 * right_eigenvec02;
	  U22 += left_eigenvec12 * right_eigenvec12;
	  U22 += left_eigenvec22 * right_eigenvec22; 
		return;
	};

		

	float CRmsd::calculate_rotation_rmsd(float x[],float y[],float z[],float x0[],float y0[],float z0[],int n_list)
	{
		setup_rotation(x,y,z,x0,y0,z0,n_list);
		calculate_rotation_matrix();	  
		residual = (float)fabs(residual);
		return (float)sqrt( fabs((float) (residual)*2.0/((float)n_list)));
	};

	float CRmsd::direct_rmsd(float x[],float y[],float z[],float x0[],float y0[],float z0[],int n_list)
	{ 
		int n;
		float tx,ty,tz,d;

		//move to center
		for (n=0; n<n_list; n++) 
		{
			x0[n] -= mov_com0;
			x[n] -= ref_com0;
			y0[n] -= mov_com1;
			y[n] -= ref_com1;
			z0[n] -= mov_com2;
			z[n] -= ref_com2;
		}

		get_rotation_matrix();

		//rotate it
		for(n=0;n<n_list;n++)
		{
			tx=x0[n]*U00+y0[n]*U01+z0[n]*U02;
			ty=x0[n]*U10+y0[n]*U11+z0[n]*U12;
			tz=x0[n]*U20+y0[n]*U21+z0[n]*U22;
			x0[n]=tx;
			y0[n]=ty;
			z0[n]=tz;
		}

		//calculate RMSD directly
		d=0;
		for(n=0;n<n_list;n++)
		{
			tx=x0[n]-x[n];
			ty=y0[n]-y[n];
			tz=z0[n]-z[n];
			d+=tx*tx+ty*ty+tz*tz;
		}
		d=d/(n_list);
		d=sqrt(d);

		return d;
		
	};

	CRmsd::CRmsd() {};
	CRmsd::~CRmsd() {};




namespace ldw_math
{
#pragma acc routine seq
	float veclengthf(float x[3])
	{
			return sqrt(x[0]*x[0]+x[1]*x[1]+x[2]*x[2]);
	}

#pragma acc routine seq
	double veclength(double x[3])
	{
			return sqrt(x[0]*x[0]+x[1]*x[1]+x[2]*x[2]);
	}

#pragma acc routine seq
	void cross(double z[3],double x[3],double y[3])
	{
			z[0]=x[1]*y[2]-x[2]*y[1];
			z[1]=-x[0]*y[2]+x[2]*y[0];
			z[2]=x[0]*y[1]-x[1]*y[0];
			return;
	}

#pragma acc routine seq
	double dot(double x[3],double y[3])
	{
			return x[0]*y[0]+x[1]*y[1]+x[2]*y[2];
	}

#pragma acc routine seq
	double coor_to_angle(double x2,double y2,double z2,double x3,double y3,double z3,double x4,double y4,double z4)
	{
			double angle;
			double b[3],c[3];

	        
			b[0]=x3-x2;b[1]=y3-y2;b[2]=z3-z2;
			c[0]=x4-x3;c[1]=y4-y3;c[2]=z4-z3;
			angle=dot(b,c)/veclength(b)/veclength(c);
			if(angle>1.0) angle=1.0;
			if(angle<-1.0) angle=-1.0;
	/*        angle=sqrt(1-angle*angle);*/
			return angle;
	}

	double coor_to_length(double x3,double y3,double z3,double x4,double y4,double z4)
	{
			return (x4-x3)*(x4-x3)+(y4-y3)*(y4-y3)+(z4-z3)*(z4-z3);
	}

	double coor_to_dihe(double x1,double y1,double z1,double x2,double y2,double z2,double x3,double y3,double z3,double x4,double y4,double z4)
	{
			double t;
			double angle;
			double a[3],b[3],c[3];
			double d[3],e[3];
			double f[3];

			a[0]=x2-x1;a[1]=y2-y1;a[2]=z2-z1;
			b[0]=x3-x2;b[1]=y3-y2;b[2]=z3-z2;
			c[0]=x4-x3;c[1]=y4-y3;c[2]=z4-z3;
			cross(d,a,b);
			cross(e,b,c);
			cross(f,d,e);


			angle=dot(d,e)/veclength(d)/veclength(e);
			if(angle>1.0) angle=1.0;
			if(angle<-1.0) angle=-1.0;
			angle=acos(angle);
			if((t=dot(b,f))<0)
					angle=-angle;
			return angle;
	}

#pragma acc routine seq
	double mysign(double a,double b)
	{
			double result;

			a=fabs(a);
			if(b>=0)
			{
					result=a;
			}
			else
			{
					result=-a;
			}

			return result;
	}

#pragma acc routine seq
	double mymax(double a, double b)
	{
			double result;
			if(a>b)
			{
					result=a;
			}
			else
			{
					result=b;
			}
			return result;
	}


#pragma acc routine seq
	double PYTHAG(double a, double b)
	{
		double at = fabs(a), bt = fabs(b), ct, result;

		if (at > bt)       { ct = bt / at; result = at * sqrt(1.0 + ct * ct); }
		else if (bt > 0.0) { ct = at / bt; result = bt * sqrt(1.0 + ct * ct); }
		else result = 0.0;
		return(result);
	}

#pragma acc routine seq
	double area( double a, double b, double c )
	{
	  double s;
	  double y;
	  s = (a + b + c)/2;
	  s =  s * (s - a)*(s - b)*(s - c);
	  if(s<0)
		y=0;
	  else
		y = sqrt( s );
	  return y;
	}


	void fit(vector<double> x,vector<double> y, vector<double> *z,double *a,double *b,double *rms,double *r)
	{
		int i;
		int ndata;
		double t,t2,sxoss,syoss,sx,sy,stx,sty,stz,ss;
		double chi2;

		ndata=x.size();
		
		sx=sy=0.0;
		stx=sty=stz=0.0;
		*b=0;
		*a=0;
		
		for(i=0;i<ndata;i++)
		{
			sx+=x[i];
			sy+=y[i];
		}
		ss=ndata;
		
		sxoss=sx/ss;
		syoss=sy/ss;
		
		for(i=0;i<ndata;i++)
		{
			t=x[i]-sxoss;
			stx+=t*t;
			*b+=t*y[i];
			t2=y[i]-syoss;
			sty+=t2*t2;
			stz+=t*t2;		
		}
		
		*b/=stx;	
		*a=(sy-sx*(*b))/ss;
		
		chi2=0.0;
		for(i=0;i<ndata;i++)
		{
			t=*a+(*b)*x[i];
			z->at(i)=t;
			t=y[i]-t;
			chi2+=t*t;		
		}
		chi2/=ss;
		*rms=sqrt(chi2);	
		*r=stz/sqrt(stx*sty);	
	}

#pragma acc routine seq
	int dsvd(double a[6][3], int m, int n, double *w, double v[3][3])
	{
		int flag, i, its, j, jj, k, l, nm;
		double c, f, h, s, x, y, z;
		double anorm = 0.0, g = 0.0, scale = 0.0;
		double rv1[3];
	  
		//if (m < n) 
		//{
			//fprintf(stderr, "#rows must be > #cols \n");
		//	return 0;
		//}
	  
		//rv1 = (double *)malloc((unsigned int) n*sizeof(double));
		//rv1 = new double[n];

	
		for (i = 0; i < n; i++) 
		{
			
			l = i + 1;
			rv1[i] = scale * g;
			g = 0.0;
			s = 0.0;
			scale = 0.0;
			if (i < m) 
			{
				for (k = i; k < m; k++) 
					scale += fabs((double)a[k][i]);
				if (scale) 
				{
					for (k = i; k < m; k++) 
					{
						a[k][i] = (double)((double)a[k][i]/scale);
						s += ((double)a[k][i] * (double)a[k][i]);
					}
					f = (double)a[i][i];
	                
					//g = -my_mysign(sqrt(s), f);
					g = -mysign(sqrt(s), f);
	                
					h = f * g - s;
					a[i][i] = (double)(f - g);
					if (i != n - 1) 
					{
						for (j = l; j < n; j++) 
						{
							for (s = 0.0, k = i; k < m; k++) 
								s += ((double)a[k][i] * (double)a[k][j]);
							f = s / h;
							for (k = i; k < m; k++) 
								a[k][j] += (double)(f * (double)a[k][i]);
						}
					}
					for (k = i; k < m; k++) 
						a[k][i] = (double)((double)a[k][i]*scale);
				}
			}
			w[i] = (double)(scale * g);
	    
	
			g = 0.0;
			s = 0.0;
			scale = 0.0;
			if (i < m && i != n - 1) 
			{
				for (k = l; k < n; k++) 
					scale += fabs((double)a[i][k]);
				if (scale) 
				{
					for (k = l; k < n; k++) 
					{
						a[i][k] = (double)((double)a[i][k]/scale);
						s += ((double)a[i][k] * (double)a[i][k]);
					}
					f = (double)a[i][l];
					//g = -my_mysign(sqrt(s), f);
					g = -mysign(sqrt(s), f);
					h = f * g - s;
					a[i][l] = (double)(f - g);
					for (k = l; k < n; k++) 
						rv1[k] = (double)a[i][k] / h;
					if (i != m - 1) 
					{
						for (j = l; j < m; j++) 
						{
							for (s = 0.0, k = l; k < n; k++) 
								s += ((double)a[j][k] * (double)a[i][k]);
							for (k = l; k < n; k++) 
								a[j][k] += (double)(s * rv1[k]);
						}
					}
					for (k = l; k < n; k++) 
						a[i][k] = (double)((double)a[i][k]*scale);
				}
			}
			//anorm = my_mymax(anorm, (fabs((double)w[i]) + fabs(rv1[i])));
			anorm = mymax(anorm, (fabs((double)w[i]) + fabs(rv1[i])));


		}
	

		for (i = n - 1; i >= 0; i--) 
		{
			if (i < n - 1) 
			{
				if (g) 
				{
					for (j = l; j < n; j++)
						v[j][i] = (double)(((double)a[i][j] / (double)a[i][l]) / g);
						
					for (j = l; j < n; j++) 
					{
						for (s = 0.0, k = l; k < n; k++) 
							s += ((double)a[i][k] * (double)v[k][j]);
						for (k = l; k < n; k++) 
							v[k][j] += (double)(s * (double)v[k][i]);
					}
				}
				for (j = l; j < n; j++) 
					v[i][j] = v[j][i] = 0.0;
			}
			v[i][i] = 1.0;
			g = rv1[i];
			l = i;
		}

		for (i = n - 1; i >= 0; i--) 
		{
			l = i + 1;
			g = (double)w[i];
			if (i < n - 1) 
				for (j = l; j < n; j++) 
					a[i][j] = 0.0;
			if (g) 
			{
				g = 1.0 / g;
				if (i != n - 1) 
				{
					for (j = l; j < n; j++) 
					{
						for (s = 0.0, k = l; k < m; k++) 
							s += ((double)a[k][i] * (double)a[k][j]);
						f = (s / (double)a[i][i]) * g;
						for (k = i; k < m; k++) 
							a[k][j] += (double)(f * (double)a[k][i]);
					}
				}
				for (j = i; j < m; j++) 
					a[j][i] = (double)((double)a[j][i]*g);
			}
			else 
			{
				for (j = i; j < m; j++) 
					a[j][i] = 0.0;
			}
			++a[i][i];
		}


		for (k = n - 1; k >= 0; k--) 
		{                             
			for (its = 0; its < 30; its++) 
			{                        
				flag = 1;
				for (l = k; l >= 0; l--) 
				{                 
					nm = l - 1;
					if (fabs(rv1[l]) + anorm == anorm) 
					{
						flag = 0;
						break;
					}
					if (fabs((double)w[nm]) + anorm == anorm) 
						break;
				}
				if (flag) 
				{
					c = 0.0;
					s = 1.0;
					for (i = l; i <= k; i++) 
					{
						f = s * rv1[i];
						if (fabs(f) + anorm != anorm) 
						{
							g = (double)w[i];
							//h = my_PYTHAG(f, g);
							h = PYTHAG(f, g);
							w[i] = (double)h; 
							h = 1.0 / h;
							c = g * h;
							s = (- f * h);
							for (j = 0; j < m; j++) 
							{
								y = (double)a[j][nm];
								z = (double)a[j][i];
								a[j][nm] = (double)(y * c + z * s);
								a[j][i] = (double)(z * c - y * s);
							}
						}
					}
				}
		
				z = (double)w[k];
				if (l == k) 
				{                  
					if (z < 0.0) 
					{              
						w[k] = (double)(-z);
						for (j = 0; j < n; j++) 
							v[j][k] = (-v[j][k]);
					}
					//break;
					its = 30;
				} else {
				//if (its >= 30) {
				//	free((void*) rv1);
				//	fprintf(stderr, "No convergence after 30,000! iterations \n");
				//	return(0);
				//}
	    
				
				x = (double)w[l];
				nm = k - 1;
				y = (double)w[nm];
				g = rv1[nm];
				h = rv1[k];
				f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);
				//g = my_PYTHAG(f, 1.0);
				g = PYTHAG(f, 1.0);
				//f = ((x - z) * (x + z) + h * ((y / (f + my_mysign(g, f))) - h)) / x;
				f = ((x - z) * (x + z) + h * ((y / (f + mysign(g, f))) - h)) / x;
	          
				
				c = s = 1.0;
				for (j = l; j <= nm; j++) 
				{
	
					i = j + 1;
					g = rv1[i];
					y = (double)w[i];
					h = s * g;
					g = c * g;
					//z = my_PYTHAG(f, h);
					z = PYTHAG(f, h);
					rv1[j] = z;
					c = f / z;
					s = h / z;
					f = x * c + g * s;
					g = g * c - x * s;
					h = y * s;
					y = y * c;
					for (jj = 0; jj < n; jj++) 
					{
						x = (double)v[jj][j];
						z = (double)v[jj][i];
						v[jj][j] = (double)(x * c + z * s);
						v[jj][i] = (double)(z * c - x * s);
					}
					//z = my_PYTHAG(f, h);
					z = PYTHAG(f, h);
					w[j] = (double)z;
					if (z) 
					{
						z = 1.0 / z;
						c = f * z;
						s = h * z;
					}
					f = (c * g) + (s * y);
					x = (c * y) - (s * g);
					for (jj = 0; jj < m; jj++) 
					{
						y = (double)a[jj][j];
						z = (double)a[jj][i];
						a[jj][j] = (double)(y * c + z * s);
						a[jj][i] = (double)(z * c - y * s);
					}
		
				}
		
				rv1[l] = 0.0;
				rv1[k] = f;
				w[k] = (double)x;
				} // end shitty else
			}
		}
		//delete(rv1);
		//free((void*) rv1);

		return 1;
	}


#pragma acc routine seq
	void ring(double x[6][3], int m, double ori[3])
	{
			int i,j;
			int id;
			double w[3];
			double v[3][3];
			double d;
			double xx[6][3];

			for(i=0;i<m;i++)
			for(j=0;j<3;j++)
					xx[i][j]=x[i][j];


			dsvd(xx, m, 3, w,v);

			d=w[0];id=0;
			if(w[1]<d)
			{
					d=w[1];
					id=1;
			}
			if(w[2]<d)
			{
					d=w[2];
					id=2;
			}

			for(i=0;i<3;i++)
					ori[i]=v[i][id];

			return;
	}



	int dsvd2(double *a, int m, int n, double *w, double v[3][3])
	{
		int flag, i, its, j, jj, k, l, nm;
		double c, f, h, s, x, y, z;
		double anorm = 0.0, g = 0.0, scale = 0.0;
		double *rv1;
	  
		if (m < n) 
		{
			fprintf(stderr, "#rows must be > #cols \n");
			return(0);
		}
	  
		rv1 = (double *)malloc((unsigned int) n*sizeof(double));

	/* Householder reduction to bidiagonal form */
		for (i = 0; i < n; i++) 
		{
			/* left-hand reduction */
			l = i + 1;
			rv1[i] = scale * g;
			g = s = scale = 0.0;
			if (i < m) 
			{
				for (k = i; k < m; k++) 
					scale += fabs((double)a[k*n+i]);
				if (scale) 
				{
					for (k = i; k < m; k++) 
					{
						a[k*n+i] = (double)((double)a[k*n+i]/scale);
						s += ((double)a[k*n+i] * (double)a[k*n+i]);
					}
					f = (double)a[i*n+i];
	                
					g = -mysign(sqrt(s), f);
	                
					h = f * g - s;
					a[i*n+i] = (double)(f - g);
					if (i != n - 1) 
					{
						for (j = l; j < n; j++) 
						{
							for (s = 0.0, k = i; k < m; k++) 
								s += ((double)a[k*n+i] * (double)a[k*n+j]);
							f = s / h;
							for (k = i; k < m; k++) 
								a[k*n+j] += (double)(f * (double)a[k*n+i]);
						}
					}
					for (k = i; k < m; k++) 
						a[k*n+i] = (double)((double)a[k*n+i]*scale);
				}
			}
			w[i] = (double)(scale * g);
	    
			/* right-hand reduction */
			g = s = scale = 0.0;
			if (i < m && i != n - 1) 
			{
				for (k = l; k < n; k++) 
					scale += fabs((double)a[i*n+k]);
				if (scale) 
				{
					for (k = l; k < n; k++) 
					{
						a[i*n+k] = (double)((double)a[i*n+k]/scale);
						s += ((double)a[i*n+k] * (double)a[i*n+k]);
					}
					f = (double)a[i*n+l];
					g = -mysign(sqrt(s), f);
					h = f * g - s;
					a[i*n+l] = (double)(f - g);
					for (k = l; k < n; k++) 
						rv1[k] = (double)a[i*n+k] / h;
					if (i != m - 1) 
					{
						for (j = l; j < m; j++) 
						{
							for (s = 0.0, k = l; k < n; k++) 
								s += ((double)a[j*n+k] * (double)a[i*n+k]);
							for (k = l; k < n; k++) 
								a[j*n+k] += (double)(s * rv1[k]);
						}
					}
					for (k = l; k < n; k++) 
						a[i*n+k] = (double)((double)a[i*n+k]*scale);
				}
			}
			anorm = mymax(anorm, (fabs((double)w[i]) + fabs(rv1[i])));
		}
	  
		/* accumulate the right-hand transformation */
		for (i = n - 1; i >= 0; i--) 
		{
			if (i < n - 1) 
			{
				if (g) 
				{
					for (j = l; j < n; j++)
						v[j][i] = (double)(((double)a[i*n+j] / (double)a[i*n+l]) / g);
						/* double division to avoid underflow */
					for (j = l; j < n; j++) 
					{
						for (s = 0.0, k = l; k < n; k++) 
							s += ((double)a[i*n+k] * (double)v[k][j]);
						for (k = l; k < n; k++) 
							v[k][j] += (double)(s * (double)v[k][i]);
					}
				}
				for (j = l; j < n; j++) 
					v[i][j] = v[j][i] = 0.0;
			}
			v[i][i] = 1.0;
			g = rv1[i];
			l = i;
		}
	  
		/* accumulate the left-hand transformation */
		for (i = n - 1; i >= 0; i--) 
		{
			l = i + 1;
			g = (double)w[i];
			if (i < n - 1) 
				for (j = l; j < n; j++) 
					a[i*n+j] = 0.0;
			if (g) 
			{
				g = 1.0 / g;
				if (i != n - 1) 
				{
					for (j = l; j < n; j++) 
					{
						for (s = 0.0, k = l; k < m; k++) 
							s += ((double)a[k*n+i] * (double)a[k*n+j]);
						f = (s / (double)a[i*n+i]) * g;
						for (k = i; k < m; k++) 
							a[k*n+j] += (double)(f * (double)a[k*n+i]);
					}
				}
				for (j = i; j < m; j++) 
					a[j*n+i] = (double)((double)a[j*n+i]*g);
			}
			else 
			{
				for (j = i; j < m; j++) 
					a[j*n+i] = 0.0;
			}
			++a[i*n+i];
		}

		/* diagonalize the bidiagonal form */
		for (k = n - 1; k >= 0; k--) 
		{                             /* loop over singular values */
			for (its = 0; its < 30; its++) 
			{                         /* loop over allowed iterations */
				flag = 1;
				for (l = k; l >= 0; l--) 
				{                     /* test for splitting */
					nm = l - 1;
					if (fabs(rv1[l]) + anorm == anorm) 
					{
						flag = 0;
						break;
					}
					if (fabs((double)w[nm]) + anorm == anorm) 
						break;
				}
				if (flag) 
				{
					c = 0.0;
					s = 1.0;
					for (i = l; i <= k; i++) 
					{
						f = s * rv1[i];
						if (fabs(f) + anorm != anorm) 
						{
							g = (double)w[i];
							h = PYTHAG(f, g);
							w[i] = (double)h; 
							h = 1.0 / h;
							c = g * h;
							s = (- f * h);
							for (j = 0; j < m; j++) 
							{
								y = (double)a[j*n+nm];
								z = (double)a[j*n+i];
								a[j*n+nm] = (double)(y * c + z * s);
								a[j*n+i] = (double)(z * c - y * s);
							}
						}
					}
				}
				z = (double)w[k];
				if (l == k) 
				{                  /* convergence */
					if (z < 0.0) 
					{              /* make singular value nonnegative */
						w[k] = (double)(-z);
						for (j = 0; j < n; j++) 
							v[j][k] = (-v[j][k]);
					}
					break;
				}
				if (its >= 30) {
					free((void*) rv1);
					fprintf(stderr, "No convergence after 30,000! iterations \n");
					return(0);
				}
	    
				/* shift from bottom 2 x 2 minor */
				x = (double)w[l];
				nm = k - 1;
				y = (double)w[nm];
				g = rv1[nm];
				h = rv1[k];
				f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);
				g = PYTHAG(f, 1.0);
				f = ((x - z) * (x + z) + h * ((y / (f + mysign(g, f))) - h)) / x;
	          
				/* next QR transformation */
				c = s = 1.0;
				for (j = l; j <= nm; j++) 
				{
					i = j + 1;
					g = rv1[i];
					y = (double)w[i];
					h = s * g;
					g = c * g;
					z = PYTHAG(f, h);
					rv1[j] = z;
					c = f / z;
					s = h / z;
					f = x * c + g * s;
					g = g * c - x * s;
					h = y * s;
					y = y * c;
					for (jj = 0; jj < n; jj++) 
					{
						x = (double)v[jj][j];
						z = (double)v[jj][i];
						v[jj][j] = (double)(x * c + z * s);
						v[jj][i] = (double)(z * c - x * s);
					}
					z = PYTHAG(f, h);
					w[j] = (double)z;
					if (z) 
					{
						z = 1.0 / z;
						c = f * z;
						s = h * z;
					}
					f = (c * g) + (s * y);
					x = (c * y) - (s * g);
					for (jj = 0; jj < m; jj++) 
					{
						y = (double)a[jj*n+j];
						z = (double)a[jj*n+i];
						a[jj*n+j] = (double)(y * c + z * s);
						a[jj*n+i] = (double)(z * c - y * s);
					}
				}
				rv1[l] = 0.0;
				rv1[k] = f;
				w[k] = (double)x;
			}
		}
		free((void*) rv1);
		return(1);
	}




	void regression_plane(double* x, int m, double ori[3])
	{
			int i,j;
			int id;
			double w[3];
			double v[3][3];
			double d;
			double *xx;


			xx=new double [m*3];

			for(i=0;i<m;i++)
			for(j=0;j<3;j++)
					xx[i*3+j]=x[i*3+j];


			dsvd2(xx, m, 3, w,v);

			d=w[0];id=0;
			if(w[1]<d)
			{
					d=w[1];
					id=1;
			}
			if(w[2]<d)
			{
					d=w[2];
					id=2;
			}

			for(i=0;i<3;i++)
					ori[i]=v[i][id];

			return;
	}


	void rotation_around_axis(double point[3], double ori[3], double theta)
	{
		double x,y,z;
		double u,v,w;
		double t1_dot,t2_cos,t3_sin;

		x=point[0];
		y=point[1];
		z=point[2];

		u=ori[0];
		v=ori[1];
		w=ori[2];

		t1_dot=u*x+v*y+w*z;
		t2_cos=cos(theta);
		t3_sin=sin(theta);

		point[0]=u*t1_dot*(1-t2_cos)+x*t2_cos+(-w*y+v*z)*t3_sin;
		point[1]=v*t1_dot*(1-t2_cos)+y*t2_cos+(+w*x-u*z)*t3_sin;
		point[2]=w*t1_dot*(1-t2_cos)+z*t2_cos+(-v*x+u*y)*t3_sin;

		return;
	}

	void project(double ori[3], double p1[3], double p2[3])
	{
			double d;
			int i;

			d=ori[0]*p1[0]+ori[1]*p1[1]+ori[2]*p1[2];
			for(i=0;i<3;i++)
			{
					p2[i]=p1[i]-d*ori[i];
			}
			return;
	}

#pragma acc routine seq
	double effect(double x[6][3], int m, double ori[3], double p1[3])
	{
			int i,j;
			double t1[3];
			double t2[3];
			double t3[3];
			double t4[3];
			double tt,d;
			double s,ss;
			double leg1,leg2,leg3;
			double p2[3];

			ss=0;
			project(ori,p1,p2);
			for(i=0;i<m-1;i++)
			{
					for(j=0;j<3;j++)
					{
							t1[j]=x[i][j]-p1[j];
							t2[j]=x[i+1][j]-x[i][j];
							t3[j]=x[i+1][j]-p1[j];
					}
					leg1=veclength(t1);
					leg3=veclength(t3);
					d=1/(leg1*leg1*leg1)+1/(leg3*leg3*leg3);
					cross(t4,t2,t1);
					tt=dot(t4,ori);

					for(j=0;j<3;j++)
					{
							t1[j]=x[i][j]-p2[j];
							t3[j]=x[i+1][j]-p2[j];
					}
					leg1=veclength(t1);
					leg2=veclength(t2);
					leg3=veclength(t3);
					s=area(leg1,leg2,leg3);
					if(tt<0)
							s=-s;
					ss+=s*d;
			}

			//special case
			{
					i=m-1;
					for(j=0;j<3;j++)
					{
							t1[j]=x[i][j]-p1[j];
							t2[j]=x[0][j]-x[i][j];
							t3[j]=x[0][j]-p1[j];
					}
					leg1=veclength(t1);
					leg3=veclength(t3);
					d=1/(leg1*leg1*leg1)+1/(leg3*leg3*leg3);
					cross(t4,t2,t1);
					tt=dot(t4,ori);

					for(j=0;j<3;j++)
					{
							t1[j]=x[i][j]-p2[j];
							t3[j]=x[0][j]-p2[j];
					}
					leg1=veclength(t1);
					leg2=veclength(t2);
					leg3=veclength(t3);
					s=area(leg1,leg2,leg3);
					if(tt<0)
							s=-s;
					ss+=s*d;
			}

			return ss;
	}



	double gaussrand()
	{
		static double V1, V2, S;
		static int phase = 0;
		double X;

		if(phase == 0) {
			do {
				double U1 = (double)rand() / RAND_MAX;
				double U2 = (double)rand() / RAND_MAX;

				V1 = 2 * U1 - 1;
				V2 = 2 * U2 - 1;
				S = V1 * V1 + V2 * V2;
				} while(S >= 1 || S == 0);

			X = V1 * sqrt(-2 * log(S) / S);
		} else
			X = V2 * sqrt(-2 * log(S) / S);

		phase = 1 - phase;

		return X;
	}



vector<int> cluster_pick2(int ndata,vector<double> hs, vector<double> ns, double scale)
{
	vector<int> back;
	int i;
	int b1,b2,b3,b4,fb1,fb2,fb3,fb4;
	double min_dis;
	double d1,d2,d3,d4;
	vector<int> touse;

	if(ndata==3)
	{
		min_dis=1000000.0;
		for(b1=0;b1<ndata;b1++)
		{
			for(b2=b1+1;b2<ndata;b2++)
			{
				d1=(hs.at(b1)-hs.at(b2))*scale;
				d2=ns.at(b1)-ns.at(b2);
				d1=d1*d1+d2*d2;
				if(d1<min_dis)
				{
					min_dis=d1;
					fb1=b1;
					fb2=b2;
				}
			}
		}
		back.resize(ndata,0);
		back.at(fb1)=1;
		back.at(fb2)=1;
	}


	else if(ndata==4)
	{
		min_dis=1000000.0;
		for(b1=0;b1<ndata;b1++)
		{
			for(b2=b1+1;b2<ndata;b2++)
			{
				d1=(hs.at(b1)-hs.at(b2))*scale;
				d2=ns.at(b1)-ns.at(b2);
				d1=d1*d1+d2*d2;


				touse.clear();
				for(i=0;i<ndata;i++)
				{
					if(i!=b1 && i!=b2)
						touse.push_back(i);
				}

				b3=touse.at(0);
				b4=touse.at(1);
				d3=(hs.at(b3)-hs.at(b4))*scale;
				d4=ns.at(b3)-ns.at(b4);
				d1=d3*d3+d4*d4+d1;

				if(d1<min_dis)
				{
					min_dis=d1;
					fb1=b1;
					fb2=b2;
					fb3=b3;
					fb4=b4;
				}
			}
		}
		back.resize(ndata,0);
		back.at(fb1)=1;
		back.at(fb2)=1;
	}

	return back;
}



// ///////////////////////////////////////////////////////////////////////////////////////////////////////////

}//end of ldw_math



namespace Sequence
{
	string code2name(char c)
	{
		string t;
		t="UNK";
		switch(c)
		{
		case 'A':
			t="ALA";
			break;
		case 'G':
			t="GLY";
			break;
		case 'V':
			t="VAL";
			break;
		case 'L':
			t="LEU";
			break;
		case 'M':
			t="MET";
			break;
		case 'I':
			t="ILE";
			break;
		case 'S':
			t="SER";
			break;
		case 'T':
			t="THR";
			break;
		case 'C':
			t="CYS";
			break;
		case 'P':
			t="PRO";
			break;
		case 'N':
			t="ASN";
			break;
		case 'Q':
			t="GLN";
			break;
		case 'F':
			t="PHE";
			break;
		case 'Y':
			t="TYR";
			break;
		case 'W':
			t="TRP";
			break;
		case 'K':
			t="LYS";
			break;
		case 'R':
			t="ARG";
			break;
		case 'H':
			t="HIS";
			break;
		case 'D':
			t="ASP";
			break;
		case 'E':
			t="GLU";
			break;
		case 'X':
			t="UNK";
			break;
		}

		return t;
	}


	int code2pos(char code)
	{ 
		int pos;
		switch (code)
		{
		case 'A':
			pos=0;
			break;
		case 'R':
			pos=1;
			break;
		case 'N':
			pos=2;
			break;
		case 'D':
			pos=3;
			break;
		case 'C':
			pos=4;
			break;
		case 'Q':
			pos=5;
			break;
		case 'E':
			pos=6;
			break;
		case 'G':
			pos=7;
			break;
		case 'H':
			pos=8;
			break;
		case 'I':
			pos=9;
			break;
		case 'L':
			pos=10;
			break;
		case 'K':
			pos=11;
			break;
		case 'M':
			pos=12;
			break;
		case 'F':
			pos=13;
			break;
		case 'P':
			pos=14;
			break;
		case 'S':
			pos=15;
			break;
		case 'T':
			pos=16;
			break;
		case 'W':
			pos=17;
			break;
		case 'Y':
			pos=18;
			break;
		case 'V':
			pos=19;
			break;
		default:
			pos=7;
			//cout<<"unknown AA code "<<code<<endl;
		}

		return pos;
	}


	char name2code(string in)
	{
		char c;
		if(in.compare("ALA")==0)
			c='A';
		else if(in.compare("GLY")==0)
			c='G';
		else if(in.compare("VAL")==0)
			c='V';	
		else if(in.compare("LEU")==0)
			c='L';
		else if(in.compare("MET")==0)
			c='M';
		else if(in.compare("ILE")==0)
			c='I';
		else if(in.compare("SER")==0)
			c='S';
		else if(in.compare("THR")==0)
			c='T';
		else if(in.compare("CYS")==0)
			c='C';
		else if(in.compare("CYX")==0)
			c='C';
		else if(in.compare("PRO")==0)
			c='P';
		else if(in.compare("ASN")==0)
			c='N';
		else if(in.compare("GLN")==0)
			c='Q';
		else if(in.compare("PHE")==0)
			c='F';
		else if(in.compare("TYR")==0)
			c='Y';
		else if(in.compare("TRP")==0)
			c='W';
		else if(in.compare("HIS")==0)
			c='H';
		else if(in.compare("HIE")==0)
			c='H';
		else if(in.compare("HID")==0)
			c='H';
		else if(in.compare("ARG")==0)
			c='R';
		else if(in.compare("LYS")==0)
			c='K';
		else if(in.compare("ASP")==0)
			c='D';
		else if(in.compare("GLU")==0)
			c='E';
		else if(in.compare("UNK")==0)
			c='X';
		else if(in.compare("MIS")==0)
			c='X';
		else
			c='B';

		return c;
	}

	void code2array(char code, int buffer[20])
	{
		int pos;

		for(pos=0;pos<20;pos++)
			buffer[pos]=0;	
		pos=code2pos(code);
		buffer[pos]=1;
		return;
	}



	void code2same(char code, int buffer[20])
	{
		int pos;
		int i;
		
		static int blosum[20][20]=
		{{4,-1,-2,-2,0,-1,-1,0,-2,-1,-1,-1,-1,-2,-1,1,0,-3,-2,0},
		{-1,5,0,-2,-3,1,0,-2,0,-3,-2,2,-1,-3,-2,-1,-1,-3,-2,-3},
		{-2,0,6,1,-3,0,0,0,1,-3,-3,0,-2,-3,-2,1,0,-4,-2,-3},
		{-2,-2,1,6,-3,0,2,-1,-1,-3,-4,-1,-3,-3,-1,0,-1,-4,-3,-3},
		{0,-3,-3,-3,9,-3,-4,-3,-3,-1,-1,-3,-1,-2,-3,-1,-1,-2,-2,-1},
		{-1,1,0,0,-3,5,2,-2,0,-3,-2,1,0,-3,-1,0,-1,-2,-1,-2},
		{-1,0,0,2,-4,2,5,-2,0,-3,-3,1,-2,-3,-1,0,-1,-3,-2,-2},
		{0,-2,0,-1,-3,-2,-2,6,-2,-4,-4,-2,-3,-3,-2,0,-2,-2,-3,-3},
		{-2,0,1,-1,-3,0,0,-2,8,-3,-3,-1,-2,-1,-2,-1,-2,-2,2,-3},
		{-1,-3,-3,-3,-1,-3,-3,-4,-3,4,2,-3,1,0,-3,-2,-1,-3,-1,3},
		{-1,-2,-3,-4,-1,-2,-3,-4,-3,2,4,-2,2,0,-3,-2,-1,-2,-1,1},
		{-1,2,0,-1,-3,1,1,-2,-1,-3,-2,5,-1,-3,-1,0,-1,-3,-2,-2},
		{-1,-1,-2,-3,-1,0,-2,-3,-2,1,2,-1,5,0,-2,-1,-1,-1,-1,1},
		{-2,-3,-3,-3,-2,-3,-3,-3,-1,0,0,-3,0,6,-4,-2,-2,1,3,-1},
		{-1,-2,-2,-1,-3,-1,-1,-2,-2,-3,-3,-1,-2,-4,7,-1,-1,-4,-3,-2},
		{1,-1,1,0,-1,0,0,0,-1,-2,-2,0,-1,-2,-1,4,1,-3,-2,-2},
		{0,-1,0,-1,-1,-1,-1,-2,-2,-1,-1,-1,-1,-2,-1,1,5,-2,-2,0},
		{-3,-3,-4,-4,-2,-2,-3,-2,-2,-3,-2,-3,-1,1,-4,-3,-2,11,2,-3},
		{-2,-2,-2,-3,-2,-1,-2,-3,2,-1,-1,-2,-1,3,-3,-2,-2,2,7,-1},
		{0,-3,-3,-3,-1,-2,-2,-3,-3,3,1,-2,1,-1,-2,-2,0,-3,-1,4}};

		pos=code2pos(code);
		for(i=0;i<20;i++)
			buffer[i]=blosum[pos][i];

		return;
	}


	vector<double> expand(char code,vector<double> *in)
	{
		int i,pos,n;
		vector<double> out;

		pos=code2pos(code); //pos =0 ... 19
		n=in->size();

		out.resize(n*20);

		for(i=0;i<n;i++)
		{
			out.at(i+pos*n)=in->at(i);
		}
		return out;
	}


	vector<double> expand2(int type,vector<double> *in)
	{
		vector<double> out;
		int pos,n;
		int i;

		pos=type-1; //pos=0,1,2,....9
		n=in->size();

		out.resize(n*10);
		for(i=0;i<n;i++)
			out.at(i+pos*n)=in->at(i);

		return out;
	}




	vector<int> align(string c1,string c2)
	//c1: sequence of MD run. c2: sequence from bmrb.
	{
		int s1,s2;
		int i,j;
		int *score,*point;
		int score1,score2,score3;
		vector<int> out;

		s1=c1.length();
		s2=c2.length();

		out.resize(s1+1);

		score=new int [(s1+1)*(s2+1)];
		point=new int [(s1+1)*(s2+1)];

		for(i=0;i<=s1;i++)
		for(j=0;j<=s2;j++)
		{
			score[j*(s1+1)+i]=0;
			point[j*(s1+1)+i]=0;
		}


		for(i=1;i<=s1;i++)
		{
			score[i]=-i;
			point[i]=3;
		}
		for(j=1;j<=s2;j++)
		{
			score[j*(s1+1)]=-j;	
			point[j*(s1+1)]=2;
		}

		for(i=1;i<=s1;i++)
		{
			for(j=1;j<=s2;j++)
			{
				if(c1[i-1] == c2[j-1] || c1[i-1]=='X' || c2[j-1]=='X') // 'X' can match any AA
					score1=score[(j-1)*(s1+1)+i-1]+1;
				else
					score1=score[(j-1)*(s1+1)+i-1]-1;
				score2=score[(j-1)*(s1+1)+i]-1;
				score3=score[j*(s1+1)+i-1]-1;

				if(score1>score2)
				{
					if(score1>score3)
					{
						score[j*(s1+1)+i]=score1;
						point[j*(s1+1)+i]=1;
					}
					else
					{
						score[j*(s1+1)+i]=score3;
						point[j*(s1+1)+i]=3;
					}
				}
				else
				{
					if(score2>score3)
					{
						score[j*(s1+1)+i]=score2;
						point[j*(s1+1)+i]=2;
					}
					else
					{
						score[j*(s1+1)+i]=score3;
						point[j*(s1+1)+i]=3;
					}
				}
			}
		}


	/*	for(i=0;i<=s1;i++)
		{
			for(j=0;j<=s2;j++)
			{
				cout<<score[j*(s1+1)+i]<<" ";
			}
			cout<<endl;
		}
		cout<<endl;

		for(i=0;i<=s1;i++)
		{
			for(j=0;j<=s2;j++)
			{
				cout<<point[j*(s1+1)+i]<<" ";
			}
			cout<<endl;
		}
		cout<<endl;*/


		i=s1;
		j=s2;
		while(point[j*(s1+1)+i]!=0)
		{
			if(point[j*(s1+1)+i]==1)
			{
				//cout<<c1[i-1];
				//cout<<c2[j-1];
				if(c1[i-1]==c2[j-1] || c1[i-1]=='X' || c2[j-1]=='X' ) 
					out[i]=j;
				i--;
				j--;
				//cout<<endl;
			}
			else if(point[j*(s1+1)+i]==2)
			{
				//cout<<"-";
				//cout<<c2[j-1];
				j--;
				//cout<<endl;
			}
			else if(point[j*(s1+1)+i]==3)
			{
				//cout<<c1[i-1];
				//cout<<"-";
				i--;
				//cout<<endl;
			}
		}


		/*for(i=1;i<out.size();i++)
		{
			cout<<i<<" "<<out.at(i)<<endl;
		}*/

		delete [] score;
		delete [] point;
		
		return out;
	}


	vector<int> aligno(string c1,string c2, string &out1, string &out2, string &out3)
	//c1: sequence of MD run. c2: sequence from bmrb.
	{
		int s1,s2;
		int i,j;
		int *score,*point;
		int score1,score2,score3;
		vector<int> out;

		s1=c1.length();
		s2=c2.length();

		out1.clear();
		out2.clear();

		out.resize(s1+1);

		score=new int [(s1+1)*(s2+1)];
		point=new int [(s1+1)*(s2+1)];

		for(i=0;i<=s1;i++)
		for(j=0;j<=s2;j++)
		{
			score[j*(s1+1)+i]=0;
			point[j*(s1+1)+i]=0;
		}


		for(i=1;i<=s1;i++)
		{
			score[i]=-i;
			point[i]=3;
		}
		for(j=1;j<=s2;j++)
		{
			score[j*(s1+1)]=-j;	
			point[j*(s1+1)]=2;
		}

		for(i=1;i<=s1;i++)
		{
			for(j=1;j<=s2;j++)
			{
				if(c1[i-1] == c2[j-1] || c1[i-1]=='X' || c2[j-1]=='X') // 'X' can match any AA
					score1=score[(j-1)*(s1+1)+i-1]+1;
				else
					score1=score[(j-1)*(s1+1)+i-1]-1;
				score2=score[(j-1)*(s1+1)+i]-1;
				score3=score[j*(s1+1)+i-1]-1;

				if(score1>score2)
				{
					if(score1>score3)
					{
						score[j*(s1+1)+i]=score1;
						point[j*(s1+1)+i]=1;
					}
					else
					{
						score[j*(s1+1)+i]=score3;
						point[j*(s1+1)+i]=3;
					}
				}
				else
				{
					if(score2>score3)
					{
						score[j*(s1+1)+i]=score2;
						point[j*(s1+1)+i]=2;
					}
					else
					{
						score[j*(s1+1)+i]=score3;
						point[j*(s1+1)+i]=3;
					}
				}
			}
		}



		i=s1;
		j=s2;
		while(point[j*(s1+1)+i]!=0)
		{
			if(point[j*(s1+1)+i]==1)
			{
				out1.append(1,c1[i-1]);
				out2.append(1,c2[j-1]);
				if(c1[i-1]==c2[j-1] || c1[i-1]=='X' || c2[j-1]=='X' ) 
				{
					out[i]=j;
					out3.append(1,c1[i-1]);
				}
				else
					out3.append(1,'-');
				i--;
				j--;
			}
			else if(point[j*(s1+1)+i]==2)
			{
				out1.append(1,'-');
				out2.append(1,c2[j-1]);
				out3.append(1,' ');
				j--;
			}
			else if(point[j*(s1+1)+i]==3)
			{
				out1.append(1,c1[i-1]);
				out2.append(1,'-');
				out3.append(1,' ');
				i--;
			}
		}

		delete [] score;
		delete [] point;
		
		return out;
	}

}

########## NEXT FILE ##########
traj.cpp:::
#include <iostream>
#include <cstdlib>
#include <fstream>
#include <cstring>
#include <string>
#include <vector>
#include <math.h>
#include <time.h>
using namespace std;

#include "traj.h"
using namespace ldw_math;

#define USE_ACC_COMPARE
#include "debug.h"

// ///////////////////////////////////////////////////////////////////////////////////////////////////////////

void CTraj::clear()
{
	x.clear();
	y.clear();
	z.clear();
	nframe=0;
}




int CTraj::appendcoor(string filename)
{
	double xx,yy,zz;
	string line,part;

	ifstream fin(filename.c_str());
	
	while(getline(fin,line))
	{
		if(part=="ENDMDL" || part=="END")
		{
			if(x.size()%natom!=0)
				cout<<"In traj reading, suppose to read "<<natom<<" coors but actually read in "<<x.size()<<endl;
		}

		part=line.substr(0,6);
		if(part!="ATOM  " && part!="HETATM")
			continue;

		part=line.substr(30,8);
		xx=atof(part.c_str());
		x.push_back(xx);
		part=line.substr(38,8);
		yy=atof(part.c_str());
		y.push_back(yy);
		part=line.substr(46,8);
		zz=atof(part.c_str());
		z.push_back(zz);
	};


	nframe=x.size()/natom;
	return nframe;
}


int CTraj::loadcoor(string filename)
{
	double xx,yy,zz;
	string line,part;
	bool bend;

	bend=0;


	ifstream fin(filename.c_str());

	
	while(getline(fin,line))
	{
		if(part=="ENDMDL" || part=="END")
		{
			//finished read first molecule 
			bend=1;
			if(x.size()%natom!=0)
				cout<<"In traj reading, suppose to read "<<natom<<" coors but actually read in "<<x.size()<<endl;
		}

		part=line.substr(0,6);
		if(part!="ATOM  " && part!="HETATM")
			continue;

		part=line.substr(30,8);
		xx=atof(part.c_str());
		x.push_back(xx);
		part=line.substr(38,8);
		yy=atof(part.c_str());
		y.push_back(yy);
		part=line.substr(46,8);
		zz=atof(part.c_str());
		z.push_back(zz);
		if(bend==0)
		{
			part=line.substr(12,4);
			atomname.push_back(part);
		}
	};

	if(natom==0)
		nframe=0;
	else
		nframe=x.size()/natom;

#ifdef _OPENACC
#pragma acc enter data copyin(this[:1])
  double *tmp = x.data();
  int sz = x.size();
#pragma acc enter data copyin(tmp[:sz])
  tmp = y.data();
  sz = y.size();
#pragma acc enter data copyin(tmp[:sz])
  tmp = z.data();
  sz = z.size();
#pragma acc enter data copyin(tmp[:sz])
#endif

	return nframe;
}

int CTraj::set_range(int begin,int stop)
{
	if(begin<0)
	{
		begin=0;
		cout<<"Reset begin to "<<begin<<endl;
	}

	if(stop>nframe)
	{
		stop=nframe;
		cout<<"Reset stop to "<<stop<<endl;
	}

	if(stop==0)
		stop=nframe;

	nframe=stop-begin;


	if(stop<nframe)
	{
		x.erase(x.begin()+stop*natom,x.begin()+x.size());
		y.erase(y.begin()+stop*natom,y.begin()+y.size());
		z.erase(z.begin()+stop*natom,z.begin()+z.size());
	}
	if(begin>0)
	{
		x.erase(x.begin(),x.begin()+begin*natom);
		y.erase(y.begin(),y.begin()+begin*natom);
		z.erase(z.begin(),z.begin()+begin*natom);
	}

	cout<<"Using frames from "<<begin<<" to "<<stop<<endl;
	return nframe;
}



void CTraj::getschbond2(vector<struct proton> *protons, vector<struct bbhbond_group> *bb, vector< vector<ehbond> > *effect, vector< vector<eschbond> > *effect_sc)
{
	int i,j,k;
	int base;
	int n,h[3],c,o;
	int nh;
	int nid,cid;
	double u[3];
	float x2,x3,x4,x5;
	float y2,y3,y4,y5;
	float z2,z3,z4,z5;
	float phi,psi,d;

	int kk,good_kk;
	float min_d;

	effect->resize(nres);
	for(i=0;i<(int)effect->size();i++)
	{
		effect->at(i).resize(nframe);
		for(k=0;k<nframe;k++)
		{
			effect->at(i).at(k).n_length=0;
			effect->at(i).at(k).c_length=0;
			effect->at(i).at(k).n_phi=0;
			effect->at(i).at(k).c_phi=0;
			effect->at(i).at(k).n_psi=0;
			effect->at(i).at(k).c_psi=0;
		}
	}

	effect_sc->resize(protons->size());
	for(i=0;i<(int)effect_sc->size();i++)
	{
		effect_sc->at(i).resize(nframe);
		for(k=0;k<nframe;k++)
		{
			effect_sc->at(i).at(k).n_length=0;
			effect_sc->at(i).at(k).c_length=0;
			effect_sc->at(i).at(k).n_phi=0;
			effect_sc->at(i).at(k).c_phi=0;
			effect_sc->at(i).at(k).n_psi=0;
			effect_sc->at(i).at(k).c_psi=0;
		}
	}


	
	for(i=0;i<(int)protons->size();i++)
	{
		for(j=0;j<(int)bb->size();j++)
		{
			nh=protons->at(i).nh;
			for(k=0;k<nh;k++)
				h[k]=protons->at(i).hpos[k];
			n=protons->at(i).cpos;
			if(h[0]<=-1 || n<=-1 || (nh==2 && h[1]<0) || (nh==3 && h[2]<0) ) 
				continue;
			c=bb->at(j).cpos;
			o=bb->at(j).opos;
			if(o<=-1 || c<=-1)
				continue;
			n--;c--;o--;
			for(k=0;k<nh;k++)
				h[k]--;

			for(k=0;k<nframe;k++)
			{
				//cout<<"i,j,k is "<<i<<" "<<j<<" "<<k<<endl;
				min_d=100000.0;
				for(kk=0;kk<nh;kk++)
				{
					base=k*natom;
					u[0]=x[h[kk]+base]-x[o+base];
					u[1]=y[h[kk]+base]-y[o+base];
					u[2]=z[h[kk]+base]-z[o+base];
					d=veclength(u);
					if(d<min_d)
					{
						min_d=d;
						good_kk=kk;
					}
				}
				d=min_d;
				x2=x[n+base];y2=y[n+base];z2=z[n+base];
				x3=x[h[good_kk]+base];y3=y[h[good_kk]+base];z3=z[h[good_kk]+base];
				x4=x[o+base];y4=y[o+base];z4=z[o+base];
				x5=x[c+base];y5=y[c+base];z5=z[c+base];
				phi=coor_to_angle(x2,y2,z2,x3,y3,z3,x4,y4,z4);
				psi=coor_to_angle(x3,y3,z3,x4,y4,z4,x5,y5,z5);
				if(d<3 && phi>0.5 && psi>0.5)
				{
					d=1/(d-1);
					phi*=phi;
					psi*=psi;
					nid=protons->at(i).id-1;
					cid=bb->at(j).id-1; /* C start from 0*/
					
					//effect->at(nid).at(k).n_length=d;
					//effect->at(nid).at(k).n_phi=phi;
					//effect->at(nid).at(k).n_psi=psi;

					effect_sc->at(i).at(k).n_length=d;
					effect_sc->at(i).at(k).n_phi=phi;
					effect_sc->at(i).at(k).n_psi=psi;
					effect_sc->at(i).at(k).id=protons->at(i).id;
					effect_sc->at(i).at(k).type=protons->at(i).type;

					if(bb->at(j).type==1)
					{
						effect->at(cid).at(k).c_length=d;
						effect->at(cid).at(k).c_phi=phi;
						effect->at(cid).at(k).c_psi=psi;
					}
					
				}
			}//for k
		}//for j
	}//for i

	return;
}


//hbond type (1, bb) (12, sc OH) (13,sc NH) (22 or 23, sc CO)
void CTraj::gethbond(vector<bbhbond_group> *hbond,vector<ehbond> *effect)
{
	int i,j,k;
	int base;
	int nid,cid;
	int n,h,c,o;
	double u[3];
	double x2,x3,x4,x5,y2,y3,y4,y5,z2,z3,z4,z5;
	double d,phi,psi;

	bbhbond_group* hbond_arr = hbond->data();
	int hbond_size = hbond->size();
	effect->resize(nres);
	ehbond* effect_arr = effect->data();
	int effect_size = effect->size();
	double* x_arr = this->x.data();
	int x_size = this->x.size();
	double* y_arr = this->y.data();
	int y_size = this->y.size();
	double* z_arr = this->z.data();
	int z_size = this->z.size();

  int nframe = this->nframe;
  int natom  = this->natom;

#pragma acc data \
	copyin(hbond_arr[:hbond_size]) \
	copyout(effect_arr[:effect_size]) \
	present(x_arr[:x_size], y_arr[:y_size], z_arr[:z_size])
{

#pragma acc parallel loop gang
	for(i=0; i<hbond_size; i++)
	{
#pragma acc loop vector \
	private(k,n,h,c,o,base,u[:3],d,x2,x3,x4,x5,y2,y3,y4,y5,\
					z2,z3,z4,z5,phi,psi,nid,cid)
		for(j=0; j<hbond_size; j++)
		{
			//k=j-i;
			if(j-i<3 && j-i>-3)
				continue;
			n=hbond_arr[i].npos-1;
			h=hbond_arr[i].hpos-1;
			//if(h<=-1 || n<=-1) 
			//	continue;
			c=hbond_arr[j].cpos-1;
			o=hbond_arr[j].opos-1;
			//if(o<=-1 || c<=-1)
			//	continue;
			//n--;h--;c--;o--;
			if(h<0 || n<0 || o<0 || c<0)
				continue;

#pragma acc loop seq
			for(k=0;k<nframe;k++)
			{
				base=k*natom;
				u[0]=x_arr[h+base]-x_arr[o+base];
				u[1]=y_arr[h+base]-y_arr[o+base];
				u[2]=z_arr[h+base]-z_arr[o+base];
				d=veclength(u);
				x2=x_arr[n+base];y2=y_arr[n+base];z2=z_arr[n+base];
				x3=x_arr[h+base];y3=y_arr[h+base];z3=z_arr[h+base];
				x4=x_arr[o+base];y4=y_arr[o+base];z4=z_arr[o+base];
				x5=x_arr[c+base];y5=y_arr[c+base];z5=z_arr[c+base];
				phi=coor_to_angle(x2,y2,z2,x3,y3,z3,x4,y4,z4);
				psi=coor_to_angle(x3,y3,z3,x4,y4,z4,x5,y5,z5);
				if(d<3 && phi>0.5 && psi>0.5)
				{
					d=1/(d-1);
					phi*=phi;
					psi*=psi;
					nid=hbond_arr[i].id-1;
					cid=hbond_arr[j].id-1; /* C start from 0*/
					if(hbond_arr[i].type==1)
					{
#pragma acc atomic update
						effect_arr[nid].n_length+=d;
#pragma acc atomic update
						effect_arr[nid].n_phi+=phi;
#pragma acc atomic update
						effect_arr[nid].n_psi+=psi;
					}
					if(hbond_arr[j].type==1)
					{
#pragma acc atomic update
						effect_arr[cid].c_length+=d;
#pragma acc atomic update
						effect_arr[cid].c_phi+=phi;
#pragma acc atomic update
						effect_arr[cid].c_psi+=psi;
					}
				}
			}
		}
	}

#pragma acc parallel loop
	for(i=0; i<effect_size; i++)
	{
		effect_arr[i].n_length/=nframe;
		effect_arr[i].c_length/=nframe;
		effect_arr[i].n_phi/=nframe;
		effect_arr[i].c_phi/=nframe;
		effect_arr[i].n_psi/=nframe;
		effect_arr[i].c_psi/=nframe;
	}

} // end data

	return;
}


//hbond type (1, bb) (12, sc OH) (13,sc NH) (22 or 23, sc CO)
void CTraj::gethbond(vector<bbhbond_group> *hbond,vector<ehbond> *effect, double cutoff)
{

	int i,j,k;
	int base;
	int nid,cid;
	int n,h,c,o;
	double u[3];
	double x2,x3,x4,x5,y2,y3,y4,y5,z2,z3,z4,z5;
	double d,phi,psi;

	
	effect->resize(nres);
	for(i=0;i<(int)hbond->size();i++)
	{

		for(j=0;j<(int)hbond->size();j++)
		{
			k=j-i;
			if(k<3 && k>-3)
				continue;
			n=hbond->at(i).npos;
			h=hbond->at(i).hpos;
			if(h<=-1 || n<=-1) 
				continue;
			c=hbond->at(j).cpos;
			o=hbond->at(j).opos;
			if(o<=-1 || c<=-1)
				continue;
			n--;h--;c--;o--;
			if(h<0 || n<0 || o<0 || c<0)
				continue;



			for(k=0;k<nframe;k++)
			{
				//cout<<"i,j,k is "<<i<<" "<<j<<" "<<k<<endl;
				base=k*natom;
				u[0]=x[h+base]-x[o+base];
				u[1]=y[h+base]-y[o+base];
				u[2]=z[h+base]-z[o+base];
				d=veclength(u);
				x2=x[n+base];y2=y[n+base];z2=z[n+base];
				x3=x[h+base];y3=y[h+base];z3=z[h+base];
				x4=x[o+base];y4=y[o+base];z4=z[o+base];
				x5=x[c+base];y5=y[c+base];z5=z[c+base];
				phi=coor_to_angle(x2,y2,z2,x3,y3,z3,x4,y4,z4);
				psi=coor_to_angle(x3,y3,z3,x4,y4,z4,x5,y5,z5);
				if(d<3 && phi>0.5 && psi>0.5)
				{
					d=1/(d-1);
					phi*=phi;
					psi*=psi;
					nid=hbond->at(i).id-1;
					cid=hbond->at(j).id-1; /* C start from 0*/

					if(d>cutoff)
						d=cutoff;

					if(hbond->at(i).type==1)
					{
						effect->at(nid).n_length+=d;
						effect->at(nid).n_phi+=phi;
						effect->at(nid).n_psi+=psi;
					}
					if(hbond->at(j).type==1)
					{
						effect->at(cid).c_length+=d;
						effect->at(cid).c_phi+=phi;
						effect->at(cid).c_psi+=psi;
					}
				}
			}
		}
	}

	for(i=0;i<(int)effect->size();i++)
	{
		effect->at(i).n_length/=nframe;
		effect->at(i).c_length/=nframe;
		effect->at(i).n_phi/=nframe;
		effect->at(i).c_phi/=nframe;
		effect->at(i).n_psi/=nframe;
		effect->at(i).c_psi/=nframe;
	}
	return;
}



void CTraj::gethbond(vector<bbhbond_group> *hbond,vector< vector<ehbond> > *effect)
{

	int i,j,k;
	int base;
	int nid,cid;
	int n,h,c,o;
	double u[3];
	double x2,x3,x4,x5,y2,y3,y4,y5,z2,z3,z4,z5;
	double d,phi,psi;

	effect->resize(nres);
	for(i=0;i<(int)effect->size();i++)
	{
		effect->at(i).resize(nframe);
		for(k=0;k<nframe;k++)
		{
			effect->at(i).at(k).n_length=0;
			effect->at(i).at(k).c_length=0;
			effect->at(i).at(k).n_phi=0;
			effect->at(i).at(k).c_phi=0;
			effect->at(i).at(k).n_psi=0;
			effect->at(i).at(k).c_psi=0;
		}
	}

	for(i=0;i<(int)hbond->size();i++)
	{

		for(j=0;j<(int)hbond->size();j++)
		{
			k=j-i;
			if(k<3 && k>-3)
				continue;
			n=hbond->at(i).npos;
			h=hbond->at(i).hpos;
			if(h<0) 
				continue;
			c=hbond->at(j).cpos;
			o=hbond->at(j).opos;
			if(o<0)
				continue;
			n--;h--;c--;o--;


			for(k=0;k<nframe;k++)
			{
				//cout<<"i,j,k is "<<i<<" "<<j<<" "<<k<<endl;
				base=k*natom;
				u[0]=x[h+base]-x[o+base];
				u[1]=y[h+base]-y[o+base];
				u[2]=z[h+base]-z[o+base];
				d=veclength(u);
				x2=x[n+base];y2=y[n+base];z2=z[n+base];
				x3=x[h+base];y3=y[h+base];z3=z[h+base];
				x4=x[o+base];y4=y[o+base];z4=z[o+base];
				x5=x[c+base];y5=y[c+base];z5=z[c+base];
				phi=coor_to_angle(x2,y2,z2,x3,y3,z3,x4,y4,z4);
				psi=coor_to_angle(x3,y3,z3,x4,y4,z4,x5,y5,z5);
				if(d<3 && phi>0.5 && psi>0.5)
				{
					d=1/(d-1);
					phi*=phi;
					psi*=psi;
					nid=hbond->at(i).id-1;
					cid=hbond->at(j).id-1; /* C start from 0*/
					if(hbond->at(i).type==1)
					{
						effect->at(nid).at(k).n_length+=d;
						effect->at(nid).at(k).n_phi+=phi;
						effect->at(nid).at(k).n_psi+=psi;
					}
					if(hbond->at(j).type==1)
					{
						effect->at(cid).at(k).c_length+=d;
						effect->at(cid).at(k).c_phi+=phi;
						effect->at(cid).at(k).c_psi+=psi;
					}
				}
			}
		}
	}
	return;
}


void CTraj::gethbond2(vector<bbhbond_group> *hbond,vector< vector<ehbond> > *effect)
{

	int i,j,k;
	int base;
	int nid,cid;
	int n,h,c,o;
	double u[3];
	double x2,x3,x4,x5,y2,y3,y4,y5,z2,z3,z4,z5;
	double d,phi,psi;

	effect->resize(nres);
	for(i=0;i<(int)effect->size();i++)
	{
		effect->at(i).resize(nframe);
		for(k=0;k<nframe;k++)
		{
			effect->at(i).at(k).n_length=0;
			effect->at(i).at(k).c_length=0;
			effect->at(i).at(k).n_phi=0;
			effect->at(i).at(k).c_phi=0;
			effect->at(i).at(k).n_psi=0;
			effect->at(i).at(k).c_psi=0;
		}
	}

	for(i=0;i<(int)hbond->size();i++)
	{

		for(j=0;j<(int)hbond->size();j++)
		{
			k=j-i;
			if(k<=3 && k>=-3)
				continue;
			n=hbond->at(i).npos;
			h=hbond->at(i).hpos;
			if(h<0) 
				continue;
			c=hbond->at(j).cpos;
			o=hbond->at(j).opos;
			if(o<0)
				continue;
			n--;h--;c--;o--;


			for(k=0;k<nframe;k++)
			{
				//cout<<"i,j,k is "<<i<<" "<<j<<" "<<k<<endl;
				base=k*natom;
				u[0]=x[h+base]-x[o+base];
				u[1]=y[h+base]-y[o+base];
				u[2]=z[h+base]-z[o+base];
				d=veclength(u);
				x2=x[n+base];y2=y[n+base];z2=z[n+base];
				x3=x[h+base];y3=y[h+base];z3=z[h+base];
				x4=x[o+base];y4=y[o+base];z4=z[o+base];
				x5=x[c+base];y5=y[c+base];z5=z[c+base];
				phi=coor_to_angle(x2,y2,z2,x3,y3,z3,x4,y4,z4);
				psi=coor_to_angle(x3,y3,z3,x4,y4,z4,x5,y5,z5);
				if(d<3 && phi>0.5 && psi>0.5)
				{
					d=1/(d-1);
					phi*=phi;
					psi*=psi;
					nid=hbond->at(i).id-1;
					cid=hbond->at(j).id-1; /* C start from 0*/
					if(hbond->at(i).type==1)
					{
						effect->at(nid).at(k).n_length=d;
						effect->at(nid).at(k).n_phi=phi;
						effect->at(nid).at(k).n_psi=psi;
					}
					if(hbond->at(i).type==1)
					{
						effect->at(cid).at(k).c_length=d;
						effect->at(cid).at(k).c_phi=phi;
						effect->at(cid).at(k).c_psi=psi;
					}
				}
			}
		}
	}
	return;
}




void CTraj::dis_matrix(vector<int> *index,vector<double> *dis)
{
	int i,j,n1,n2;
	double d1,d2,d3,d;
	for(i=0;i<(int)index->size();i++)
	{
		n1=index->at(i)-1;
		for(j=0;j<(int)index->size();j++)
		{		
			n2=index->at(j)-1;
			d1=x.at(n1)-x.at(n2);
			d2=y.at(n1)-y.at(n2);
			d3=z.at(n1)-z.at(n2);
			d=sqrt(d1*d1+d2*d2+d3*d3);
			dis->push_back(d);
		}
	}
	return;
}


void CTraj::getangle(vector<struct dihe_group> *index, vector<double> * angle)
{
	int i,j;
	int x1,x2,x3,x4;
	int base;
	double t;


	for(i=0;i<nframe;i++)
	{
		base=i*natom-1;  // -1 because of C starts from 0 but not 1 !
		for(j=0;j<(int)index->size();j++)
		{
			x1=base+index->at(j).x1;
			x2=base+index->at(j).x2;
			x3=base+index->at(j).x3;
			x4=base+index->at(j).x4;
			t=coor_to_angle(x[x1],y[x1],z[x1],x[x2],y[x2],z[x2],x[x3],y[x3],z[x3]);
			angle->push_back(t);
			t=coor_to_angle(x[x2],y[x2],z[x2],x[x3],y[x3],z[x3],x[x4],y[x4],z[x4]);
			angle->push_back(t);
		}
	}
	return;
}




void CTraj::getdihe(vector<struct dihe_group> *index, vector<double> * dihe)
{	
	int i,j;
	int x1,x2,x3,x4;
	int base;
	double t;


	for(i=0;i<nframe;i++)
	{
		base=i*natom-1;  // -1 because of C starts from 0 but not 1 !
		for(j=0;j<(int)index->size();j++)
		{
			if(index->at(j).bgood==1)
			{
				x1=base+index->at(j).x1;
				x2=base+index->at(j).x2;
				x3=base+index->at(j).x3;
				x4=base+index->at(j).x4;
				t=coor_to_dihe(x[x1],y[x1],z[x1],x[x2],y[x2],z[x2],x[x3],y[x3],z[x3],x[x4],y[x4],z[x4]);
				dihe->push_back(t);
			}
			else
				dihe->push_back(-1000.0);
		}
	}
	return;
}


void CTraj::getring(vector<struct ring_group> *index, vector<struct nh_group>* select, vector<struct double_five> *ring_effect)
{	
	int i,j,k,ii,jj,m;
	int base;
	int t[6];
	double p1[3],t1[3],t2[3],t3[3];
	double u[6][3];
	double sum[3];
	double ori[3];
	double e;

	ring_group* index_arr = index->data();
	int index_size = index->size();
	nh_group* select_arr = select->data();
	int select_size = select->size();
	ring_effect->resize(select_size);
	double_five* effect_arr = ring_effect->data();
	int effect_size = ring_effect->size();
	double* x_arr = this->x.data();
	int x_size = this->x.size();
	double* y_arr = this->y.data();
	int y_size = this->y.size();
	double* z_arr = this->z.data();
	int z_size = this->z.size();

	int nframe = this->nframe;
	int natom = this->natom;

#pragma acc data \
	copyin(index_arr[:index_size], select_arr[:select_size], \
  	x_arr[:x_size], y_arr[:y_size], z_arr[:z_size]) \
	copyout(effect_arr[:effect_size])
{

#pragma acc parallel loop collapse(2)
	for(i=0; i<select_size; i++)
		for(j=0; j<5; j++)
			effect_arr[i].x[j]=0.0;

	for(i=0;i<nframe;i++)
	{
		base=i*natom;

#pragma acc parallel loop gang \
	private(ii,jj,m,t[:6],u[:6][:3],sum[:3],\
	ori[:3],t1[:3],t2[:3],t3[:3])
		for(j=0; j<index_size; j++)
		{
			if(index_arr[j].x1 == 1 || index_arr[j].x1 == 2 || index_arr[j].x1 == 5){
				m=6;
			} else {
				m=5;
			}

			t[0]=index_arr[j].x2;
			t[1]=index_arr[j].x3;
			t[2]=index_arr[j].x4;
			t[3]=index_arr[j].x5;
			t[4]=index_arr[j].x6;
			t[5]=index_arr[j].x7;

			u[0][0]=x_arr[t[0]+base-1]; u[0][1]=y_arr[t[0]+base-1]; u[0][2]=z_arr[t[0]+base-1];
			u[1][0]=x_arr[t[1]+base-1]; u[1][1]=y_arr[t[1]+base-1]; u[1][2]=z_arr[t[1]+base-1];
			u[2][0]=x_arr[t[2]+base-1]; u[2][1]=y_arr[t[2]+base-1]; u[2][2]=z_arr[t[2]+base-1];
			u[3][0]=x_arr[t[3]+base-1]; u[3][1]=y_arr[t[3]+base-1]; u[3][2]=z_arr[t[3]+base-1];
			u[4][0]=x_arr[t[4]+base-1]; u[4][1]=y_arr[t[4]+base-1]; u[4][2]=z_arr[t[4]+base-1];
			if(m >= 6) {
				u[5][0]=x_arr[t[5]+base-1]; u[5][1]=y_arr[t[5]+base-1]; u[5][2]=z_arr[t[5]+base-1];
			} else {
				u[5][0]=0; u[5][1]=0; u[5][2]=0;
			}

			sum[0] = (u[0][0] + u[1][0] + u[2][0] + u[3][0] + u[4][0] + u[5][0]) / m;
			sum[1] = (u[0][1] + u[1][1] + u[2][1] + u[3][1] + u[4][1] + u[5][1]) / m;
			sum[2] = (u[0][2] + u[1][2] + u[2][2] + u[3][2] + u[4][2] + u[5][2]) / m;

			u[0][0] -= sum[0]; u[0][1] -= sum[1]; u[0][2] -= sum[2];
			u[1][0] -= sum[0]; u[1][1] -= sum[1]; u[1][2] -= sum[2];
			u[2][0] -= sum[0]; u[2][1] -= sum[1]; u[2][2] -= sum[2];
			u[3][0] -= sum[0]; u[3][1] -= sum[1]; u[3][2] -= sum[2];
			u[4][0] -= sum[0]; u[4][1] -= sum[1]; u[4][2] -= sum[2];
			u[5][0] -= sum[0]; u[5][1] -= sum[1]; u[5][2] -= sum[2];

			ring(u,m,ori);

			t1[0] = u[0][0] - u[1][0];
			t1[1] = u[0][1] - u[1][1];
			t1[2] = u[0][2] - u[1][2];
			t2[0] = u[2][0] - u[1][0];
			t2[1] = u[2][1] - u[1][1];
			t2[2] = u[2][2] - u[1][2];

			cross(t3,t1,t2);
			if(dot(t3,ori)<0)
			{
				ori[0] = -ori[0];
				ori[1] = -ori[1];
				ori[2] = -ori[2];
			}

#pragma acc loop vector private(e,p1[:3])
			for(k=0; k<select_size; k++)
			{
				if(select_arr[k].hpos>=1)
				{
					e=0;
					p1[0]=x_arr[base+select_arr[k].hpos-1]-sum[0];
					p1[1]=y_arr[base+select_arr[k].hpos-1]-sum[1];
					p1[2]=z_arr[base+select_arr[k].hpos-1]-sum[2];
					e+=effect(u,m,ori,p1); 
					e=e*10;
#pragma acc atomic update
					effect_arr[k].x[index_arr[j].x1-1]+=e;
				}
			}
		}
	}

#pragma acc parallel loop collapse(2)
	for(ii=0; ii<select_size; ii++)
	{
		for(jj=0;jj<5;jj++)
		{
			effect_arr[ii].x[jj]/=nframe;
		}
	}

} // end data

	return;
}


void CTraj::getring(vector<struct ring_group> *index, vector<struct nh_group>* select, vector< vector<struct double_five> > *ring_effect)
{	
	int i,j,ii,jj,m;
	int base;
	int t[6];
	double p1[3],t1[3],t2[3],t3[3];
	double u[6][3];
	double sum[3];
	double ori[3];
	double e;
	struct double_five temp;
	
	for(i=0;i<5;i++)
		temp.x[i]=0;
	ring_effect->resize(select->size());
	for(ii=0;ii<(int)select->size();ii++)
	{
		for(jj=0;jj<nframe;jj++)
		{
			ring_effect->at(ii).push_back(temp);
		}
	}


	for(i=0;i<nframe;i++)
	{
		base=i*natom;  
		for(j=0;j<(int)index->size();j++)
		{
			switch(index->at(j).x1)
			{
				case 1:
                case 2:
                case 5:
					m=6;
					break;
				case 4:
				case 3:
					m=5;
					break;
			}
			t[0]=index->at(j).x2;
			t[1]=index->at(j).x3;
			t[2]=index->at(j).x4;
			t[3]=index->at(j).x5;
			t[4]=index->at(j).x6;
			t[5]=index->at(j).x7;

           
            for(ii=0;ii<m;ii++)
			{
				u[ii][0]=x[t[ii]+base-1];
                u[ii][1]=y[t[ii]+base-1];
                u[ii][2]=z[t[ii]+base-1];
            }
           
            for(jj=0;jj<3;jj++)
				sum[jj]=0; 
			for(ii=0;ii<m;ii++)
            {
				for(jj=0;jj<3;jj++)
				{
					sum[jj]+=u[ii][jj];
				}
			}
			for(jj=0;jj<3;jj++)
				sum[jj]/=m; 
			for(ii=0;ii<m;ii++)
			{
				for(jj=0;jj<3;jj++)
					u[ii][jj]-=sum[jj];
			}

			ring(u,m,ori);

            for(jj=0;jj<3;jj++)
            {
                   t1[jj]=u[0][jj]-u[1][jj];
                   t2[jj]=u[2][jj]-u[1][jj];
            }
            cross(t3,t1,t2);
            if(dot(t3,ori)<0)
            {
				for(jj=0;jj<3;jj++)
					ori[jj]=-ori[jj];
			}

			for(ii=0;ii<(int)select->size();ii++)
			{
				if(select->at(ii).hpos>=1)
				{
					e=0;
					p1[0]=x[base+select->at(ii).hpos-1]-sum[0];
					p1[1]=y[base+select->at(ii).hpos-1]-sum[1];
					p1[2]=z[base+select->at(ii).hpos-1]-sum[2];
					e+=effect(u,m,ori,p1); 
					e=e*10;
					ring_effect->at(ii).at(i).x[index->at(j).x1-1]+=e;
				}
			}
		}
	}

	return;
}



void CTraj::getring(vector<struct ring_group> *index, vector<struct methyl_group>* select, vector<struct double_five> *ring_effect, enum methyl c)
{	
	int i,j,ii,jj,m,k;
	int base;
	int t[6];
	double p1[3],t1[3],t2[3],t3[3];
	double u[6][3];
	double sum[3];
	double ori[3];
	double e;
	struct double_five temp;
	
	for(i=0;i<5;i++)
		temp.x[i]=0;
	for(i=0;i<(int)select->size();i++)
		ring_effect->push_back(temp);


	for(i=0;i<nframe;i++)
	{
		base=i*natom;  
		for(j=0;j<(int)index->size();j++)
		{
			switch(index->at(j).x1)
			{
				case 1:
                case 2:
                case 5:
					m=6;
					break;
				case 4:
				case 3:
					m=5;
					break;
			}
			t[0]=index->at(j).x2;
			t[1]=index->at(j).x3;
			t[2]=index->at(j).x4;
			t[3]=index->at(j).x5;
			t[4]=index->at(j).x6;
			t[5]=index->at(j).x7;

           
            for(ii=0;ii<m;ii++)
			{
				u[ii][0]=x[t[ii]+base-1];
                u[ii][1]=y[t[ii]+base-1];
                u[ii][2]=z[t[ii]+base-1];
            }
           
            for(jj=0;jj<3;jj++)
				sum[jj]=0; 
			for(ii=0;ii<m;ii++)
            {
				for(jj=0;jj<3;jj++)
				{
					sum[jj]+=u[ii][jj];
				}
			}
			for(jj=0;jj<3;jj++)
				sum[jj]/=m; 
			for(ii=0;ii<m;ii++)
			{
				for(jj=0;jj<3;jj++)
					u[ii][jj]-=sum[jj];
			}

			ring(u,m,ori);

            for(jj=0;jj<3;jj++)
            {
                   t1[jj]=u[0][jj]-u[1][jj];
                   t2[jj]=u[2][jj]-u[1][jj];
            }
            cross(t3,t1,t2);
            if(dot(t3,ori)<0)
            {
				for(jj=0;jj<3;jj++)
					ori[jj]=-ori[jj];
			}

			for(ii=0;ii<(int)select->size();ii++)
			{
				e=0;

				switch(c)
				{
				case hydrogen:
					for(k=0;k<3;k++)
					{
						p1[0]=x[base+select->at(ii).hpos[k]-1]-sum[0];
						p1[1]=y[base+select->at(ii).hpos[k]-1]-sum[1];
						p1[2]=z[base+select->at(ii).hpos[k]-1]-sum[2];
						//cout<<"Ori is "<<ori[0]<<" "<<ori[1]<<" "<<ori[2]<<endl;
						//cout<<"X is "<<p1[0]<<" "<<p1[1]<<" "<<p1[2]<<endl;
						e+=effect(u,m,ori,p1); 
					}
					break;
				case carbon:
					p1[0]=x[base+select->at(ii).cpos-1]-sum[0];
					p1[1]=y[base+select->at(ii).cpos-1]-sum[1];
					p1[2]=z[base+select->at(ii).cpos-1]-sum[2];
					e+=effect(u,m,ori,p1); 
					break;
				}

				e=e*10;
				ring_effect->at(ii).x[index->at(j).x1-1]+=e;
			}
		}
	}

	for(ii=0;ii<(int)select->size();ii++)
	{
		for(jj=0;jj<5;jj++)
		{
			ring_effect->at(ii).x[jj]/=nframe;
		}
	}
	return;
}

void CTraj::getring(vector<struct ring_group> *index, vector<struct proton>* select, vector<struct double_five> *ring_effect)
{	
	int i,j,ii,jj,m,k;
	int base;
	int t[6];
	double p1[3],t1[3],t2[3],t3[3];
	double u[6][3];
	double sum[3];
	double ori[3];
	double e;

	ring_group* index_arr = index->data();
	int index_size = index->size();
	proton* select_arr = select->data();
	int select_size = select->size();
	ring_effect->resize(select_size);
	double_five* effect_arr = ring_effect->data();
	int effect_size = ring_effect->size();
	double* x_arr = this->x.data();
	int x_size = this->x.size();
	double* y_arr = this->y.data();
	int y_size = this->y.size();
	double* z_arr = this->z.data();
	int z_size = this->z.size();

	int nframe = this->nframe;
	int natom = this->natom;

#pragma acc data \
	copyin(index_arr[:index_size], select_arr[:select_size], \
		x_arr[:x_size], y_arr[:y_size], z_arr[:z_size]) \
	copyout(effect_arr[:effect_size])
{

#pragma acc parallel loop collapse(2)
	for(i=0; i<select_size; i++)
		for(j=0; j<5; j++)
			effect_arr[i].x[j]=0.0;

	for(i=0;i<nframe;i++)
	{
		base=i*natom;  

#pragma acc parallel loop gang \
	private(m,t[:6],u[:6][:3],sum[:3],ori[:3],t1[:3],t2[:3],t3[:3])
		for(j=0; j<index_size; j++)
		{
			if(index_arr[j].x1 == 1 || index_arr[j].x1 == 2 || index_arr[j].x1 == 5){
				m=6;
			} else {
				m=5;
			}

			t[0]=index_arr[j].x2;
			t[1]=index_arr[j].x3;
			t[2]=index_arr[j].x4;
			t[3]=index_arr[j].x5;
			t[4]=index_arr[j].x6;
			t[5]=index_arr[j].x7;

			u[0][0]=x_arr[t[0]+base-1]; u[0][1]=y_arr[t[0]+base-1]; u[0][2]=z_arr[t[0]+base-1];
			u[1][0]=x_arr[t[1]+base-1]; u[1][1]=y_arr[t[1]+base-1]; u[1][2]=z_arr[t[1]+base-1];
			u[2][0]=x_arr[t[2]+base-1]; u[2][1]=y_arr[t[2]+base-1]; u[2][2]=z_arr[t[2]+base-1];
			u[3][0]=x_arr[t[3]+base-1]; u[3][1]=y_arr[t[3]+base-1]; u[3][2]=z_arr[t[3]+base-1];
			u[4][0]=x_arr[t[4]+base-1]; u[4][1]=y_arr[t[4]+base-1]; u[4][2]=z_arr[t[4]+base-1];
			if(m >= 6) {
				u[5][0]=x_arr[t[5]+base-1]; u[5][1]=y_arr[t[5]+base-1]; u[5][2]=z_arr[t[5]+base-1];
			} else {
				u[5][0]=0; u[5][1]=0; u[5][2]=0;
			}

			sum[0] = (u[0][0] + u[1][0] + u[2][0] + u[3][0] + u[4][0] + u[5][0]) / m;
			sum[1] = (u[0][1] + u[1][1] + u[2][1] + u[3][1] + u[4][1] + u[5][1]) / m;
			sum[2] = (u[0][2] + u[1][2] + u[2][2] + u[3][2] + u[4][2] + u[5][2]) / m;

			u[0][0] -= sum[0]; u[0][1] -= sum[1]; u[0][2] -= sum[2];
			u[1][0] -= sum[0]; u[1][1] -= sum[1]; u[1][2] -= sum[2];
			u[2][0] -= sum[0]; u[2][1] -= sum[1]; u[2][2] -= sum[2];
			u[3][0] -= sum[0]; u[3][1] -= sum[1]; u[3][2] -= sum[2];
			u[4][0] -= sum[0]; u[4][1] -= sum[1]; u[4][2] -= sum[2];
			u[5][0] -= sum[0]; u[5][1] -= sum[1]; u[5][2] -= sum[2];

			ring(u,m,ori);

			t1[0] = u[0][0] - u[1][0];
			t1[1] = u[0][1] - u[1][1];
			t1[2] = u[0][2] - u[1][2];
			t2[0] = u[2][0] - u[1][0];
			t2[1] = u[2][1] - u[1][1];
			t2[2] = u[2][2] - u[1][2];

			cross(t3,t1,t2);
			if(dot(t3,ori)<0)
			{
				ori[0] = -ori[0];
				ori[1] = -ori[1];
				ori[2] = -ori[2];
			}

#pragma acc loop vector private(k,e,p1[:3])
			for(ii=0; ii<select_size; ii++)
			{
				e=0;
#pragma acc loop seq
				for(k=0; k<select_arr[ii].nh; k++)
				{
					if(select_arr[ii].hpos[k] >= 0) {
						p1[0]=x_arr[base+select_arr[ii].hpos[k]-1]-sum[0];
						p1[1]=y_arr[base+select_arr[ii].hpos[k]-1]-sum[1];
						p1[2]=z_arr[base+select_arr[ii].hpos[k]-1]-sum[2];
					}
					e+=effect(u,m,ori,p1); 
				}
				e=e*10*3/select_arr[ii].nh;
#pragma acc atomic update
				effect_arr[ii].x[index_arr[j].x1-1]+=e;
			}
		}
	}

#pragma acc parallel loop collapse(2)
	for(ii=0; ii<select_size; ii++)
	{
		for(jj=0;jj<5;jj++)
		{
			effect_arr[ii].x[jj]/=nframe;
		}
	}

} // end data

	return;
}



void CTraj::getring(vector<struct ring_group> *index, vector<struct proton>* select, vector< vector<struct double_five> > *ring_effect)
{	
	int i,j,ii,jj,m,k;
	int base;
	int t[6];
	double p1[3],t1[3],t2[3],t3[3];
	double u[6][3];
	double sum[3];
	double ori[3];
	double e;
	struct double_five temp;
	
	for(i=0;i<5;i++)
		temp.x[i]=0;
	ring_effect->resize(select->size());
	for(ii=0;ii<(int)select->size();ii++)
	{
		for(jj=0;jj<nframe;jj++)
		{
			ring_effect->at(ii).push_back(temp);
		}
	}


	for(i=0;i<nframe;i++)
	{
		base=i*natom;  
		for(j=0;j<(int)index->size();j++)
		{
			switch(index->at(j).x1)
			{
				case 1:
                case 2:
                case 5:
					m=6;
					break;
				case 4:
				case 3:
					m=5;
					break;
			}
			t[0]=index->at(j).x2;
			t[1]=index->at(j).x3;
			t[2]=index->at(j).x4;
			t[3]=index->at(j).x5;
			t[4]=index->at(j).x6;
			t[5]=index->at(j).x7;

           
            for(ii=0;ii<m;ii++)
			{
				u[ii][0]=x[t[ii]+base-1];
                u[ii][1]=y[t[ii]+base-1];
                u[ii][2]=z[t[ii]+base-1];
            }
           
            for(jj=0;jj<3;jj++)
				sum[jj]=0; 
			for(ii=0;ii<m;ii++)
            {
				for(jj=0;jj<3;jj++)
				{
					sum[jj]+=u[ii][jj];
				}
			}
			for(jj=0;jj<3;jj++)
				sum[jj]/=m; 
			for(ii=0;ii<m;ii++)
			{
				for(jj=0;jj<3;jj++)
					u[ii][jj]-=sum[jj];
			}

			ring(u,m,ori);

            for(jj=0;jj<3;jj++)
            {
                   t1[jj]=u[0][jj]-u[1][jj];
                   t2[jj]=u[2][jj]-u[1][jj];
            }
            cross(t3,t1,t2);
            if(dot(t3,ori)<0)
            {
				for(jj=0;jj<3;jj++)
					ori[jj]=-ori[jj];
			}

			for(ii=0;ii<(int)select->size();ii++)
			{
				e=0;	
				for(k=0;k<(int)select->at(ii).nh;k++)
				{
					p1[0]=x[base+select->at(ii).hpos[k]-1]-sum[0];
					p1[1]=y[base+select->at(ii).hpos[k]-1]-sum[1];
					p1[2]=z[base+select->at(ii).hpos[k]-1]-sum[2];
					e+=effect(u,m,ori,p1); 
				}
				e=e*10*3/select->at(ii).nh;
				ring_effect->at(ii).at(i).x[index->at(j).x1-1]+=e;
			}
		}
	}
	return;
}


void CTraj::getring_bb(vector<struct ring_group> *index, vector<struct bb_group>* select, vector<struct double_five> *ring_effect, enum bb_carbon c)
{	
	int i,j,ii,jj,m;
	int base;
	int t[6];
	double p1[3],t1[3],t2[3],t3[3];
	double u[6][3];
	double sum[3];
	double ori[3];
	double e;
	struct double_five temp;
	
	for(i=0;i<5;i++)
		temp.x[i]=0;
	for(i=0;i<(int)select->size();i++)
		ring_effect->push_back(temp);


	for(i=0;i<nframe;i++)
	{
		base=i*natom;  
		for(j=0;j<(int)index->size();j++)
		{
			switch(index->at(j).x1)
			{
				case 1:
                case 2:
                case 5:
					m=6;
					break;
				case 4:
				case 3:
					m=5;
					break;
			}
			t[0]=index->at(j).x2;
			t[1]=index->at(j).x3;
			t[2]=index->at(j).x4;
			t[3]=index->at(j).x5;
			t[4]=index->at(j).x6;
			t[5]=index->at(j).x7;

           
            for(ii=0;ii<m;ii++)
			{
				u[ii][0]=x[t[ii]+base-1];
                u[ii][1]=y[t[ii]+base-1];
                u[ii][2]=z[t[ii]+base-1];
            }
           
            for(jj=0;jj<3;jj++)
				sum[jj]=0; 
			for(ii=0;ii<m;ii++)
            {
				for(jj=0;jj<3;jj++)
				{
					sum[jj]+=u[ii][jj];
				}
			}
			for(jj=0;jj<3;jj++)
				sum[jj]/=m; 
			for(ii=0;ii<m;ii++)
			{
				for(jj=0;jj<3;jj++)
					u[ii][jj]-=sum[jj];
			}

			ring(u,m,ori);

            for(jj=0;jj<3;jj++)
            {
                   t1[jj]=u[0][jj]-u[1][jj];
                   t2[jj]=u[2][jj]-u[1][jj];
            }
            cross(t3,t1,t2);
            if(dot(t3,ori)<0)
            {
				for(jj=0;jj<3;jj++)
					ori[jj]=-ori[jj];
			}

			for(ii=0;ii<(int)select->size();ii++)
			{
				e=0;

				if((select->at(ii).capos>=1 && c==bb_ca) || (select->at(ii).cbpos>=1 && c==bb_cb)||(select->at(ii).copos>=1 && c==bb_co))
				switch (c)
				{
				case bb_ca:
					p1[0]=x[base+select->at(ii).capos-1]-sum[0];
					p1[1]=y[base+select->at(ii).capos-1]-sum[1];
					p1[2]=z[base+select->at(ii).capos-1]-sum[2];
					break;
				case bb_cb:
					p1[0]=x[base+select->at(ii).cbpos-1]-sum[0];
					p1[1]=y[base+select->at(ii).cbpos-1]-sum[1];
					p1[2]=z[base+select->at(ii).cbpos-1]-sum[2];
					break;
				case bb_co:
					p1[0]=x[base+select->at(ii).copos-1]-sum[0];
					p1[1]=y[base+select->at(ii).copos-1]-sum[1];
					p1[2]=z[base+select->at(ii).copos-1]-sum[2];
					break;
				}
				e+=effect(u,m,ori,p1); 
				e=e*10;
				ring_effect->at(ii).x[index->at(j).x1-1]+=e;
			}
		}
	}

	for(ii=0;ii<(int)select->size();ii++)
	{
		for(jj=0;jj<5;jj++)
		{
			ring_effect->at(ii).x[jj]/=nframe;
		}
	}
	return;
}



void CTraj::getani(vector<struct ani_group> *index, vector<struct methyl_group>* select, vector<struct double_four> *ani_effect, enum methyl c)
{
	int i,j,ii,jj,k;
	int i1,i2,i3;
	int base;
	double center[3];
	double v1[3];
	double v2[3];
	double ori[3];
	double cosa;
	double length;
	double e;


	struct double_four temp;
	
	for(i=0;i<4;i++)
		temp.x[i]=0;
	for(i=0;i<(int)select->size();i++)
		ani_effect->push_back(temp);
	
	for(i=0;i<nframe;i++)
	{
		base=i*natom;
		for(j=0;j<(int)index->size();j++)
		{
			i1=index->at(j).pos[0]+base-1;
			i2=index->at(j).pos[1]+base-1;
			i3=index->at(j).pos[2]+base-1;
			center[0]=(x[i1]+x[i2]+x[i3])/3;
			center[1]=(y[i1]+y[i2]+y[i3])/3;
			center[2]=(z[i1]+z[i2]+z[i3])/3;

			v1[0]=x[i1]-x[i2];
			v1[1]=y[i1]-y[i2];
			v1[2]=z[i1]-z[i2];

			v2[0]=x[i3]-x[i2];
			v2[1]=y[i3]-y[i2];
			v2[2]=z[i3]-z[i2];

			cross(ori,v1,v2);

			for(jj=0;jj<(int)select->size();jj++)
			{
				e=0;				
				switch(c)
				{
				case hydrogen:
					for(k=0;k<3;k++)
					{
						i1=base+select->at(jj).cpos-1+k+1;
						v1[0]=center[0]-x[i1];
						v1[1]=center[1]-y[i1];
						v1[2]=center[2]-z[i1];
						length=v1[0]*v1[0]+v1[1]*v1[1]+v1[2]*v1[2];
						cosa=dot(v1,ori);
						cosa/=sqrt(ori[0]*ori[0]+ori[1]*ori[1]+ori[2]*ori[2]);
						cosa/=sqrt(length);					 
						e+=(1-3*cosa*cosa)/(length*sqrt(length));
					}
					ani_effect->at(jj).x[index->at(j).type-1]+=e/3.0*1000;
					break;

				case carbon:
					i1=base+select->at(jj).cpos-1;
					v1[0]=center[0]-x[i1];
					v1[1]=center[1]-y[i1];
					v1[2]=center[2]-z[i1];
					length=v1[0]*v1[0]+v1[1]*v1[1]+v1[2]*v1[2];
					cosa=dot(v1,ori);
					cosa/=sqrt(ori[0]*ori[0]+ori[1]*ori[1]+ori[2]*ori[2]);
					cosa/=sqrt(length);					 
					e+=(1-3*cosa*cosa)/(length*sqrt(length));
					ani_effect->at(jj).x[index->at(j).type-1]+=e*1000;
					break;
				}
			}
		}
	}

	for(ii=0;ii<(int)select->size();ii++)
	{
		for(jj=0;jj<4;jj++)
		{
			ani_effect->at(ii).x[jj]/=nframe;
		}
	}
	return;
}


void CTraj::getani(vector<struct ani_group> *index, vector<struct proton>* select, vector<struct double_four> *ani_effect)
{
	int i,j,ii,jj,k;
	int i1,i2,i3,i4;
	int base;
	double center[3];
	double v1[3];
	double v2[3];
	double v3[3];
	double ori[3];
	double cosa;
	double length;
	double e;

	ani_group* index_arr = index->data();
	int index_size = index->size();
	proton* select_arr = select->data();
	int select_size = select->size();
	ani_effect->resize(select_size);
	double_four* effect_arr = ani_effect->data();
	int effect_size = ani_effect->size();
	double* x_arr = this->x.data();
	int x_size = this->x.size();
	double* y_arr = this->y.data();
	int y_size = this->y.size();
	double* z_arr = this->z.data();
	int z_size = this->z.size();

	int nframe = this->nframe;
	int natom = this->natom;

#pragma acc data \
	copyin(index_arr[:index_size], select_arr[:select_size], \
		x_arr[:x_size], y_arr[:y_size], z_arr[:z_size]) \
	copyout(effect_arr[:effect_size])
{

#pragma acc parallel loop collapse(2)
	for(i=0;i<select_size;i++)
		for(j=0;j<4;j++)
			effect_arr[i].x[j]=0.0;
	
	for(i=0;i<nframe;i++)
	{
		base=i*natom;
#pragma acc parallel loop gang private(i1,i2,i3,center[:3], \
	v1[:3],v2[:3],ori[:3])
		for(j=0; j<index_size; j++)
		{
			i1=index_arr[j].pos[0]+base-1;
			i2=index_arr[j].pos[1]+base-1;
			i3=index_arr[j].pos[2]+base-1;
			center[0]=(x_arr[i1]+x_arr[i2]+x_arr[i3])/3;
			center[1]=(y_arr[i1]+y_arr[i2]+y_arr[i3])/3;
			center[2]=(z_arr[i1]+z_arr[i2]+z_arr[i3])/3;

			v1[0]=x_arr[i1]-x_arr[i2];
			v1[1]=y_arr[i1]-y_arr[i2];
			v1[2]=z_arr[i1]-z_arr[i2];

			v2[0]=x_arr[i3]-x_arr[i2];
			v2[1]=y_arr[i3]-y_arr[i2];
			v2[2]=z_arr[i3]-z_arr[i2];

			cross(ori,v1,v2);

#pragma acc loop vector private(k,e,i4,v3[:3],length,cosa)
			for(jj=0; jj<select_size; jj++)
			{
				e=0;		
#pragma acc loop seq		
				for(k=0; k<select_arr[jj].nh; k++)
				{
					i4=base+select_arr[jj].hpos[k]-1;
					v3[0]=center[0]-x_arr[i4];
					v3[1]=center[1]-y_arr[i4];
					v3[2]=center[2]-z_arr[i4];
					length=v3[0]*v3[0]+v3[1]*v3[1]+v3[2]*v3[2];
					cosa=dot(v3,ori);
					cosa/=sqrt(ori[0]*ori[0]+ori[1]*ori[1]+ori[2]*ori[2]);
					cosa/=sqrt(length);		 
					e+=(1-3*cosa*cosa)/(length*sqrt(length));
				}
#pragma acc atomic update
				effect_arr[jj].x[index_arr[j].type-1]+=e/select_arr[jj].nh*1000;
			}
		}
	}

#pragma acc parallel loop collapse(2)
	for(ii=0; ii<select_size; ii++)
	{
		for(jj=0; jj<4; jj++)
		{
			effect_arr[ii].x[jj]/=nframe;
		}
	}

} // end data

	return;
}


void CTraj::getani(vector<struct ani_group> *index, vector<struct proton>* select, vector< vector<struct double_four>  > *ani_effect)
{
	int i,j,ii,jj,k;
	int i1,i2,i3;
	int base;
	double center[3];
	double v1[3];
	double v2[3];
	double ori[3];
	double cosa;
	double length;
	double e;


	struct double_four temp;
	
	for(i=0;i<4;i++)
		temp.x[i]=0;
	ani_effect->resize(select->size());
	for(ii=0;ii<(int)select->size();ii++)
	{
		for(jj=0;jj<nframe;jj++)
		{
			ani_effect->at(ii).push_back(temp);
		}
	}

	
	for(i=0;i<nframe;i++)
	{
		base=i*natom;
		for(j=0;j<(int)index->size();j++)
		{
			i1=index->at(j).pos[0]+base-1;
			i2=index->at(j).pos[1]+base-1;
			i3=index->at(j).pos[2]+base-1;
			center[0]=(x[i1]+x[i2]+x[i3])/3;
			center[1]=(y[i1]+y[i2]+y[i3])/3;
			center[2]=(z[i1]+z[i2]+z[i3])/3;

			v1[0]=x[i1]-x[i2];
			v1[1]=y[i1]-y[i2];
			v1[2]=z[i1]-z[i2];

			v2[0]=x[i3]-x[i2];
			v2[1]=y[i3]-y[i2];
			v2[2]=z[i3]-z[i2];

			cross(ori,v1,v2);

			for(jj=0;jj<(int)select->size();jj++)
			{
				e=0;				
				for(k=0;k<(int)select->at(jj).nh;k++)
				{
					i1=base+select->at(jj).hpos[k]-1;
					v1[0]=center[0]-x[i1];
					v1[1]=center[1]-y[i1];
					v1[2]=center[2]-z[i1];
					length=v1[0]*v1[0]+v1[1]*v1[1]+v1[2]*v1[2];
					cosa=dot(v1,ori);
					cosa/=sqrt(ori[0]*ori[0]+ori[1]*ori[1]+ori[2]*ori[2]);
					cosa/=sqrt(length);					 
					e+=(1-3*cosa*cosa)/(length*sqrt(length));
				}
				ani_effect->at(jj).at(i).x[index->at(j).type-1]+=e/select->at(jj).nh*1000;
			}
		}
	}


	return;
}


void CTraj::getani(vector<struct ani_group> *index, vector<struct nh_group>* select, vector<struct double_four> *ani_effect)
{
	int i,j,ii,k;
	int i1,i2,i3,i4;
	int base;
	double center[3];
	double v1[3];
	double v2[3];
	double v3[3];
	double ori[3];
	double cosa;
	double length;
	double e;

	ani_group* index_arr = index->data();
	int index_size = index->size();
	nh_group* select_arr = select->data();
	int select_size = select->size();
	ani_effect->resize(select_size);
	double_four* effect_arr = ani_effect->data();
	int effect_size = ani_effect->size();
	double* x_arr = this->x.data();
	int x_size = this->x.size();
	double* y_arr = this->y.data();
	int y_size = this->y.size();
	double* z_arr = this->z.data();
	int z_size = this->z.size();

	int nframe = this->nframe;
	int natom = this->natom;

#pragma acc data \
	copyin(index_arr[:index_size], select_arr[:select_size], \
		x_arr[:x_size], y_arr[:y_size], z_arr[:z_size]) \
	copyout(effect_arr[:effect_size])
{

#pragma acc parallel loop collapse(2)
	for(i=0;i<select_size;i++)
		for(j=0;j<4;j++)
			effect_arr[i].x[j]=0.0;

	for(i=0;i<nframe;i++)
	{
		base=i*natom;
#pragma acc parallel loop gang \
	private(i1,i2,i3,center[:3],v1[:3],v2[:3],ori[:3])
		for(j=0; j<index_size; j++)
		{
			i1=index_arr[j].pos[0]+base-1;
			i2=index_arr[j].pos[1]+base-1;
			i3=index_arr[j].pos[2]+base-1;
			center[0]=(x_arr[i1]+x_arr[i2]+x_arr[i3])/3;
			center[1]=(y_arr[i1]+y_arr[i2]+y_arr[i3])/3;
			center[2]=(z_arr[i1]+z_arr[i2]+z_arr[i3])/3;

			v1[0]=x_arr[i1]-x_arr[i2];
			v1[1]=y_arr[i1]-y_arr[i2];
			v1[2]=z_arr[i1]-z_arr[i2];

			v2[0]=x_arr[i3]-x_arr[i2];
			v2[1]=y_arr[i3]-y_arr[i2];
			v2[2]=z_arr[i3]-z_arr[i2];

			cross(ori,v1,v2);

#pragma acc loop vector private(e,i4,v3[:3],length,cosa)
			for(k=0; k<select_size; k++)
			{
				if(select_arr[k].hpos>=1)
				{
					e=0;				
					i4=base+select_arr[k].hpos-1;
					v3[0]=center[0]-x_arr[i4];
					v3[1]=center[1]-y_arr[i4];
					v3[2]=center[2]-z_arr[i4];
					length=v3[0]*v3[0]+v3[1]*v3[1]+v3[2]*v3[2];
					cosa=dot(v3,ori);
					cosa/=sqrt(ori[0]*ori[0]+ori[1]*ori[1]+ori[2]*ori[2]);
					cosa/=sqrt(length);					 
					e+=(1-3*cosa*cosa)/(length*sqrt(length));
#pragma acc atomic update
					effect_arr[k].x[index_arr[j].type-1]+=e*1000;
				}
			}
		}
	}

#pragma acc parallel loop collapse(2)
	for(i=0; i<select_size; i++)
		for(j=0; j<4; j++)
			effect_arr[i].x[j]/=nframe;

} // end data

	return;
}


void CTraj::do_rmsf(void)
{
	int i,j;
	int jump;
	double meanx,meany,meanz;
	double rms;
	double t,tt;

	rmsf.clear();
	for(i=0;i<natom;i++)
	{
		meanx=meany=meanz=0.0;
		for(j=0;j<nframe;j++)
		{
			jump=j*natom+i;
			meanx+=x.at(jump);
			meany+=y.at(jump);
			meanz+=z.at(jump);
		}
		meanx/=nframe;
		meany/=nframe;
		meanz/=nframe;

		rms=0.0;
		for(j=0;j<nframe;j++)
		{
			jump=j*nframe+i;
			t=x.at(jump)-meanx;tt=t*t;
			t=y.at(jump)-meany;tt+=t*t;
			t=z.at(jump)-meanz;tt+=t*t;
			rms+=tt;
		}
		rms=sqrt(rms/nframe);
		rmsf.push_back(rms);
	}

	return;
}



void CTraj::getani(vector<struct ani_group> *index, vector<struct nh_group>* select, vector< vector<struct double_four>  > *ani_effect)
{
	int i,j,ii,jj;
	int i1,i2,i3;
	int base;
	double center[3];
	double v1[3];
	double v2[3];
	double ori[3];
	double cosa;
	double length;
	double e;


	struct double_four temp;
	
	for(i=0;i<4;i++)
		temp.x[i]=0;
	ani_effect->resize(select->size());
	for(ii=0;ii<(int)select->size();ii++)
	{
		for(jj=0;jj<nframe;jj++)
		{
			ani_effect->at(ii).push_back(temp);
		}
	}
	
	for(i=0;i<nframe;i++)
	{
		base=i*natom;
		for(j=0;j<(int)index->size();j++)
		{
			i1=index->at(j).pos[0]+base-1;
			i2=index->at(j).pos[1]+base-1;
			i3=index->at(j).pos[2]+base-1;
			center[0]=(x[i1]+x[i2]+x[i3])/3;
			center[1]=(y[i1]+y[i2]+y[i3])/3;
			center[2]=(z[i1]+z[i2]+z[i3])/3;

			v1[0]=x[i1]-x[i2];
			v1[1]=y[i1]-y[i2];
			v1[2]=z[i1]-z[i2];

			v2[0]=x[i3]-x[i2];
			v2[1]=y[i3]-y[i2];
			v2[2]=z[i3]-z[i2];

			cross(ori,v1,v2);

			for(jj=0;jj<(int)select->size();jj++)
			{
				if(select->at(jj).hpos>=1)
				{
					e=0;				
					i1=base+select->at(jj).hpos-1;
					v1[0]=center[0]-x[i1];
					v1[1]=center[1]-y[i1];
					v1[2]=center[2]-z[i1];
					length=v1[0]*v1[0]+v1[1]*v1[1]+v1[2]*v1[2];
					cosa=dot(v1,ori);
					cosa/=sqrt(ori[0]*ori[0]+ori[1]*ori[1]+ori[2]*ori[2]);
					cosa/=sqrt(length);					 
					e+=(1-3*cosa*cosa)/(length*sqrt(length));
					ani_effect->at(jj).at(i).x[index->at(j).type-1]+=e*1000;
				}
			}
		}
	}

	return;
}

double CTraj::noedistance_frame(vector<int> *att1, vector<int> *att2,int j)
{

	double x0,y0,z0;
	double r2,r6,sum,sumsum;
	int i1,j1;
	int n1,n2;
	int jump;

	sumsum=0;
	for(i1=0;i1<(int)att1->size();i1++)
	for(j1=0;j1<(int)att2->size();j1++)
	{
		n1=att1->at(i1)-1;
		n2=att2->at(j1)-1;
		
		jump=j*natom;
		x0=x.at(jump+n1)-x.at(jump+n2);
		y0=y.at(jump+n1)-y.at(jump+n2);
		z0=z.at(jump+n1)-z.at(jump+n2);
		r2=x0*x0+y0*y0+z0*z0;
		r6=r2*r2*r2;
		sum=1.0/r6;
		sumsum+=sum;
	}
	sumsum/=i1;
	sumsum/=j1;
	r2=pow(sumsum,-1/6.0);
	return r2;
}

double CTraj::noedistance(vector<int> *att1, vector<int> *att2)
{
	double x0,y0,z0;
	double r2,r6,sum,sumsum;
	int i1,j1;
	int n1,n2;
	int j;
	int jump;

	sumsum=0;
	for(i1=0;i1<(int)att1->size();i1++)
	for(j1=0;j1<(int)att2->size();j1++)
	{
		n1=att1->at(i1)-1;
		n2=att2->at(j1)-1;

		sum=0.0;
		for(j=0;j<nframe;j++)
		{
			jump=j*natom;
			x0=x.at(jump+n1)-x.at(jump+n2);
			y0=y.at(jump+n1)-y.at(jump+n2);
			z0=z.at(jump+n1)-z.at(jump+n2);
			r2=x0*x0+y0*y0+z0*z0;
			r6=r2*r2*r2;
			sum+=1.0/r6;
		}
		sum/=nframe;
		sumsum+=sum;
	}
	sumsum/=i1;
	sumsum/=j1;
	r2=pow(sumsum,-1/6.0);
	return r2;
}


void CTraj::evaluatenmrcons_frame(vector<struct noeline> *nmrcons, double cutoff)
{
	int ii,i,j;
	int pos1,pos2;
	int n1,n2;
	vector<int> att1,att2;
	double d;
	ofstream fout("noe_frame.dat");


	for(ii=0;ii<nframe;ii++)
	{
		for(i=0;i<(int)nmrcons->size();i++)
		{	

			if(fabs((float)(nmrcons->at(i).resid1-nmrcons->at(i).resid2))<=2)
				continue;

			nmrcons->at(i).obs.clear();
			nmrcons->at(i).pos1.clear();
			nmrcons->at(i).pos2.clear();
			for(n1=0;n1<(int)nmrcons->at(i).index1.atoms.size();n1++)
			for(n2=0;n2<(int)nmrcons->at(i).index2.atoms.size();n2++)
			{
				att1=nmrcons->at(i).index1.atoms.at(n1);
				att2=nmrcons->at(i).index2.atoms.at(n2);
				nmrcons->at(i).obs.push_back(noedistance_frame(&att1,&att2,ii));
				nmrcons->at(i).pos1.push_back(att1.at(0));
				nmrcons->at(i).pos2.push_back(att2.at(0));
			}

			d=100000.0;
			pos1=pos2=0;
			for(j=0;j<nmrcons->at(i).obs.size();j++)
			{
				if(nmrcons->at(i).obs.at(j)<d)
				{
					d=nmrcons->at(i).obs.at(j);
					pos1=nmrcons->at(i).pos1.at(j);
					pos2=nmrcons->at(i).pos2.at(j);
				}
			}
			nmrcons->at(i).bvio=0;
			nmrcons->at(i).d=d;
			
			if(nmrcons->at(i).a+cutoff<d)
				fout<<d<<" ";
			else
				fout<<d<<" ";
		}
		fout<<endl;

	}
	fout.close();

	ofstream fout2("noe_frame_head.dat");
	for(i=0;i<(int)nmrcons->size();i++)
	{
		if(fabs((float)(nmrcons->at(i).resid1-nmrcons->at(i).resid2))<=2)
			continue;

		fout2<<nmrcons->at(i).resid1<<" ";
		fout2<<nmrcons->at(i).resname1<<" ";
		fout2<<nmrcons->at(i).atomname1<<" ";
		fout2<<nmrcons->at(i).resid2<<" ";
		fout2<<nmrcons->at(i).resname2<<" ";
		fout2<<nmrcons->at(i).atomname2<<" ";
		fout2<<nmrcons->at(i).b<<" ";
		fout2<<nmrcons->at(i).c<<" ";
		fout2<<nmrcons->at(i).a<<endl;
	}
	fout2.close();
	return;
}

void CTraj::evulatenmrcons(vector<struct noeline> *nmrcons, double cutoff)
{
	int i,j;
	int pos1,pos2;
	int n1,n2;
	vector<int> att1,att2;
	double d;
	ofstream fout("violation.dat");
	ofstream fout2("fullfilled.dat");
	ofstream fout3("grouped.dat");
	ofstream fchimera("for_chimera.dat");
	ofstream fchimera2("for_chimera2.dat");


	
	for(i=0;i<(int)nmrcons->size();i++)
	{	
		for(n1=0;n1<(int)nmrcons->at(i).index1.atoms.size();n1++)
		for(n2=0;n2<(int)nmrcons->at(i).index2.atoms.size();n2++)
		{
			att1=nmrcons->at(i).index1.atoms.at(n1);
			att2=nmrcons->at(i).index2.atoms.at(n2);
			nmrcons->at(i).obs.push_back(noedistance(&att1,&att2));
			nmrcons->at(i).pos1.push_back(att1.at(0));
			nmrcons->at(i).pos2.push_back(att2.at(0));
		}
	}

	for(i=0;i<(int)nmrcons->size();i++)
	{
		d=100000.0;
		pos1=pos2=0;
		for(j=0;j<nmrcons->at(i).obs.size();j++)
		{
			if(nmrcons->at(i).obs.at(j)<d)
			{
				d=nmrcons->at(i).obs.at(j);
				pos1=nmrcons->at(i).pos1.at(j);
				pos2=nmrcons->at(i).pos2.at(j);
			}
		}
		nmrcons->at(i).bvio=0;
		nmrcons->at(i).d=d;

		if(nmrcons->at(i).a+cutoff<d)
		{
			nmrcons->at(i).bvio=1;
			fout<<nmrcons->at(i).group<<" ";
			fout<<i<<" "<<nmrcons->at(i).resid1<<" "<<nmrcons->at(i).resname1<<" "<<nmrcons->at(i).atomname1<<" ";
			fout<<nmrcons->at(i).resid2<<" "<<nmrcons->at(i).resname2<<" "<<nmrcons->at(i).atomname2<<" ";
			fout<<d<<" "<<nmrcons->at(i).c<<" "<<nmrcons->at(i).a<<endl;
			if(abs(nmrcons->at(i).resid1-nmrcons->at(i).resid2)>2 && d-nmrcons->at(i).a>cutoff)
			{
				fchimera<<"distance @/serialNumber="<<pos1<<" @/serialNumber="<<pos2<<endl;
				fchimera<<"display :"<<nmrcons->at(i).resid1<<endl;
				fchimera<<"display :"<<nmrcons->at(i).resid2<<endl;
				fchimera2<<"distance :"<<nmrcons->at(i).resid1<<"@CA :"<<nmrcons->at(i).resid2<<"@CA"<<endl;
			}
		}
		else
		{		
			fout2<<nmrcons->at(i).group<<" ";
			fout2<<i<<" "<<nmrcons->at(i).resid1<<" "<<nmrcons->at(i).resname1<<" "<<nmrcons->at(i).atomname1<<" ";
			fout2<<nmrcons->at(i).resid2<<" "<<nmrcons->at(i).resname2<<" "<<nmrcons->at(i).atomname2<<" ";
			fout2<<d<<" "<<nmrcons->at(i).c<<" "<<nmrcons->at(i).a<<endl;
		}
	}

	int ngroup=nmrcons->at(i-1).group;
	int i1=0;
	int i2=0;


	for(i=0;i<=ngroup;i++)
	{
		for(;i1<nmrcons->size() && nmrcons->at(i1).group<=i;i1++)
		{
			if(nmrcons->at(i1).a+cutoff<nmrcons->at(i1).d)
			{
				fout3<<nmrcons->at(i1).group<<" ";
				fout3<<i1<<" "<<nmrcons->at(i1).resid1<<" "<<nmrcons->at(i1).resname1<<" "<<nmrcons->at(i1).atomname1<<" ";
				fout3<<nmrcons->at(i1).resid2<<" "<<nmrcons->at(i1).resname2<<" "<<nmrcons->at(i1).atomname2<<" ";
				fout3<<nmrcons->at(i1).d<<" "<<nmrcons->at(i1).c<<" "<<nmrcons->at(i1).a<<" VIOLATED "<<endl;
			}
		}
		

		for(;i2<nmrcons->size() && nmrcons->at(i2).group<=i;i2++)
		{
			if(nmrcons->at(i2).a+cutoff>=nmrcons->at(i2).d)
			{
				fout3<<nmrcons->at(i2).group<<" ";
				fout3<<i2<<" "<<nmrcons->at(i2).resid1<<" "<<nmrcons->at(i2).resname1<<" "<<nmrcons->at(i2).atomname1<<" ";
				fout3<<nmrcons->at(i2).resid2<<" "<<nmrcons->at(i2).resname2<<" "<<nmrcons->at(i2).atomname2<<" ";
				fout3<<nmrcons->at(i2).d<<" "<<nmrcons->at(i2).c<<" "<<nmrcons->at(i2).a<<endl;
			}
		}
		fout3<<endl;
	}
	
	fout.close();
	fout2.close();
	fout3.close();
	fchimera.close();
	fchimera2.close();


	return;
}


void CTraj::rmsd_matrix(vector< vector<double> > *rmsd,vector<int> *ca, int skip)
{
	float *x1,*y1,*z1,*x2,*y2,*z2;
	int nca,jumpi,jumpj;
	int i,j,k;
	vector< double> t;
	class CRmsd rmsdf;

	nca=ca->size();
	
	x1=new float[nframe*nca];
	x2=new float[nframe*nca];
	y1=new float[nframe*nca];
	y2=new float[nframe*nca];
	z1=new float[nframe*nca];
	z2=new float[nframe*nca];

	for(i=0;i<nframe;i++)
	{
		if((i+1)%skip==0)
		{
			
			t.clear();
			jumpi=i*natom-1;
			for(j=0;j<i;j++)
				t.push_back(rmsd->at(j).at(i));
			t.push_back(0.0);
			for(j=i+1;j<nframe;j++)
			{
				if((j+1)%skip==0)
				{
					jumpj=j*natom-1;
					for(k=0;k<nca;k++)
					{
						x1[k]=x[jumpi+ca->at(k)];
						y1[k]=y[jumpi+ca->at(k)];
						z1[k]=z[jumpi+ca->at(k)];

						x2[k]=x[jumpj+ca->at(k)];
						y2[k]=y[jumpj+ca->at(k)];
						z2[k]=z[jumpj+ca->at(k)];
					}

					t.push_back(rmsdf.calculate_rotation_rmsd(x1,y1,z1,x2,y2,z2,nca));
				}
			}
			rmsd->push_back(t);
		}
	}
	return;
}



void CTraj::getvector(vector<struct index_three> nh,vector<double> *xx,vector<double> *yy,vector<double> *zz)
{
	int i,m,j;
	double r;
	double x1,y1,z1;
	for(i=0;i<nframe;i++)
	{	
		m=i*natom-1;		
		for(j=0;j<nh.size();j++)
		{
			x1=x.at(m+nh.at(j).x3)-x.at(m+nh.at(j).x2);
			y1=y.at(m+nh.at(j).x3)-y.at(m+nh.at(j).x2);
			z1=z.at(m+nh.at(j).x3)-z.at(m+nh.at(j).x2);
			r=sqrt(x1*x1+y1*y1+z1*z1);
			if(r>0)
			{
				x1/=r;y1/=r;z1/=r;
			}	
			else
			{
				x1=1.0;y1=z1=0.0;
			}	
			xx->push_back(x1);
			yy->push_back(y1);
			zz->push_back(z1);		
		}
	}
}


void CTraj:: getcoor(int ipos,int iframe,double *xx,double *yy,double *zz)
{
	ipos+=iframe*natom-1;
	*xx=x.at(ipos);
	*yy=y.at(ipos);
	*zz=z.at(ipos);
}


void CTraj::getcoor(vector<int> pos,int iframe,vector<double> *xx,vector<double> *yy,vector<double> *zz)
{
	int j;
	int adj;
	unsigned int i;

	adj=iframe*natom-1;
	for(i=0;i<pos.size();i++)
	{
		j=pos.at(i)+adj;
		xx->push_back(x.at(j));
		yy->push_back(y.at(j));
		zz->push_back(z.at(j));
	}
	return;
}


void CTraj::getcoor(vector<int> pos,vector<float> *xx,vector<float> *yy,vector<float> *zz)
{
	int j;
	int adj;
	unsigned int i,iframe;

	for(iframe=0;iframe<nframe;iframe++)
	{
		adj=iframe*natom-1;
		for(i=0;i<pos.size();i++)
		{
			j=pos.at(i)+adj;
			xx->push_back(x.at(j));
			yy->push_back(y.at(j));
			zz->push_back(z.at(j));
		}
	}
	return;
}

void CTraj::getcoor(vector<int> pos,int iframe,vector<float> *xx,vector<float> *yy,vector<float> *zz)
{
	int j;
	int adj;
	unsigned int i;

	adj=iframe*natom-1;
	for(i=0;i<pos.size();i++)
	{
		j=pos.at(i)+adj;
		xx->push_back(x.at(j));
		yy->push_back(y.at(j));
		zz->push_back(z.at(j));
	}
	return;
}

void CTraj::get_contact(float rc,float shift, vector<int> pos, vector<int> used, vector<float> * result)
{
	int i,j;
	int ii,jj;
	float contact;
	float x0,y0,z0;
	float rr;

	int *used_arr = used.data();
	int used_size = used.size();
	double *x_arr = x.data();
	int x_size = x.size();
	double *y_arr = y.data();
	int y_size = y.size();
	double *z_arr = z.data();
	int z_size = z.size();

#pragma acc data copyin(used_arr[:used_size], \
 x_arr[:x_size], y_arr[:y_size], z_arr[:z_size])
	for(i=0;i<(int)pos.size();i++)
	{
		contact=0.0;
		ii=pos.at(i);
		if(ii<1)
		{
			result->push_back(-1.0);
			continue;
		}
		ii--;
		x0=x.at(ii);
		y0=y.at(ii);
		z0=z.at(ii);
#pragma acc parallel loop \
 private(jj, rr) \
 reduction(+:contact)
		for(j=0;j<used_size;j++)
		{
			jj=used_arr[j]-1;
			if(jj<0)
				continue;
			rr=(x_arr[jj]-x0)*(x_arr[jj]-x0)+(y_arr[jj]-y0)*(y_arr[jj]-y0)+(z_arr[jj]-z0)*(z_arr[jj]-z0);
			rr=sqrt(rr)-shift;
			contact+=exp(-rr/rc);				
		}
		result->push_back(contact);
	}

	return;
}


void CTraj::get_contact(vector<int> pos, vector<int> used, vector<float> * result)
{
	int i,j;
	int ii,jj;
	float contact;
	float x0,y0,z0;
	float rr;

	for(i=0;i<(int)pos.size();i++)
	{
		contact=0.0;
		ii=pos.at(i);
		if(ii<0)
		{
			result->push_back(-1.0);
			continue;
		}
		ii--;
		x0=x.at(ii);
		y0=y.at(ii);
		z0=z.at(ii);
		for(j=0;j<(int)used.size();j++)
		{
			jj=used.at(j);
			if(jj<0)
				continue;
			jj--;
			rr=(x.at(jj)-x0)*(x.at(jj)-x0)+(y.at(jj)-y0)*(y.at(jj)-y0)+(z.at(jj)-z0)*(z.at(jj)-z0);
			rr=sqrt(rr);
			contact+=exp(-rr/3.0);				
		}
		result->push_back(contact);
	}

	return;
}

void CTraj::get_contacts(vector<struct bb_group> bb, vector<struct index_two> index, vector<int> c2, vector<float> *results)
{
	int i,j,p;
	int ii,jj;
	float contact;
	float x0,y0,z0;
	float rr;

	bb_group* bb_arr = bb.data();
	int bb_size = bb.size();
	index_two* index_arr = index.data();
	int index_size = index.size();
	int* c2_arr = c2.data();
	int c2_size = c2.size();
	results->resize(index_size*3);
	float* results_arr = results->data();
	int results_size = results->size();
	double* x_arr = this->x.data();
	int x_size = this->x.size();
	double* y_arr = this->y.data();
	int y_size = this->y.size();
	double* z_arr = this->z.data();
	int z_size = this->z.size();

#pragma acc data copyin(bb_arr[:bb_size], index_arr[:index_size], \
 c2_arr[:c2_size], x_arr[:x_size], y_arr[:y_size], z_arr[:z_size]) \
 copyout(results_arr[:results_size])
{

#pragma acc parallel loop gang collapse(2) private(ii,x0,y0,z0,contact)
	for(i=1; i<index_size-1; i++)
	{
  	for(p=0; p<3; p++)
		{
			if(p==0) {
					ii=bb_arr[index_arr[i].x1-1].capos;
			} else if(p==1) {
					ii=bb_arr[index_arr[i].x1-1].cbpos;
			} else {
					ii=bb_arr[index_arr[i].x1-1].copos;
			}

			if(ii < 1 || ii > x_size) {
				results_arr[i*3+p]=-1.0;
				continue;
			}

			contact=0.0;

			ii--;
			x0=x_arr[ii];
			y0=y_arr[ii];
			z0=z_arr[ii];

#pragma acc loop vector private(jj,rr) reduction(+:contact)
			for(j=0;j<c2_size;j++)
			{
				jj=c2_arr[j];
				if(jj<=1 || jj>x_size) continue;

				jj--;
				rr=(x_arr[jj]-x0)*(x_arr[jj]-x0)+(y_arr[jj]-y0)*(y_arr[jj]-y0)+(z_arr[jj]-z0)*(z_arr[jj]-z0);
				rr=sqrt(rr);
				contact+=exp(-rr/3.0);			
			}

			results_arr[i*3+p]=contact;

		}
	}

} // end data

	return;

}	



CTraj::CTraj()
{
	natom=0;
	nres=0;
	nframe=0;
};

CTraj::~CTraj()
{
  double *tmp = x.data();
#pragma acc exit data delete(tmp)
  tmp = y.data();
#pragma acc exit data delete(tmp)
  tmp = z.data();
#pragma acc exit data delete(tmp)
#pragma acc exit data delete(this)
};







void smtry::getdata(double x[3][3],double y[3])
{
	int i,j;
	for(i=0;i<3;i++)
	for(j=0;j<3;j++)
		matrix[i][j]=x[i][j];
	for(i=0;i<3;i++)
		motion[i]=y[i];
	return;
}

void smtry::trans(double x[3],double y[3])
{
	for(int i=0;i<3;i++)
		y[i]=x[0]*matrix[i][0]+x[1]*matrix[i][1]+x[2]*matrix[i][2]+motion[i];
	return;
}

void smtry::print()
{
	int j;
	for(int i=0;i<3;i++)
	{
		for(j=0;j<3;j++)
			cout<<matrix[i][j]<<" ";
		cout<<motion[i]<<endl;
	}
	return ;
}





void CTraj2::clear()
{
	x.clear();
	y.clear();
	z.clear();
	b.clear();
	crystal_sym_array.clear();
	nframe=0;
	natom=0;
	nres=0;
	memset(translation,0,sizeof(double)*9);
	memset(scale,0,sizeof(double)*9);
	btrans=0;
	bsmtry=0;
}

int CTraj2::select(vector<int> t)
{	
	int i,j;
	int nmiss=0;
	vector<double> xx,yy,zz,bb;
	for(i=0;i<(int)t.size();i++)
	{
		j=t.at(i)-1;
		if(j>=0)
		{
			xx.push_back(x.at(j));
			yy.push_back(y.at(j));
			zz.push_back(z.at(j));
			bb.push_back(b.at(j));
		}
		else
		{
			nmiss++;
		}
	}
	x=xx;
	y=yy;
	z=zz;
	b=bb;
	natom=x.size();
	return nmiss;
}


int CTraj2::loadcoor(string filename)
{
	double xx,yy,zz,bb;
	string line,part,part1,part2;
	double cx[3][3];
	double cy[3];
	class smtry crystal_sym;
	crystal_sym_array.clear();


	ifstream fin(filename.c_str());
	while(getline(fin,line))
	{
		part1.clear();
		part2.clear();

		if(line.size()>18)
		{
			part1=line.substr(0,10);
			part2=line.substr(13,5);
		}
		if(part1=="REMARK 290" && part2=="SMTRY")
		{
			bsmtry=1;
			cx[0][0]=atof(line.substr(24,9).c_str());
			cx[0][1]=atof(line.substr(34,9).c_str());
			cx[0][2]=atof(line.substr(44,9).c_str());
			cy[0]=atof(line.substr(59,9).c_str());
			getline(fin,line);
			cx[1][0]=atof(line.substr(24,9).c_str());
			cx[1][1]=atof(line.substr(34,9).c_str());
			cx[1][2]=atof(line.substr(44,9).c_str());
			cy[1]=atof(line.substr(59,9).c_str());
			getline(fin,line);
			cx[2][0]=atof(line.substr(24,9).c_str());
			cx[2][1]=atof(line.substr(34,9).c_str());
			cx[2][2]=atof(line.substr(44,9).c_str());
			cy[2]=atof(line.substr(59,9).c_str());
			
			if(!(cx[0][0]==1 && cx[1][1]==1 && cx[2][2]==1 && cx[0][1]==0 && cx[1][0]==0 && cx[0][2]==0 && cx[2][0]==0
						  && cx[1][2]==0 && cx[2][1]==0 && cy[0]==0 && cy[1]==0 && cy[2]==0))
			{
				crystal_sym.getdata(cx,cy);crystal_sym_array.push_back(crystal_sym);
			}
		}

		if(line.size()>5)
			part1=line.substr(0,5);
		else
			part1.clear();
		if(part1=="SCALE")
		{
			scale[0][0]=atof(line.substr(10,10).c_str());
			scale[0][1]=atof(line.substr(20,10).c_str());
			scale[0][2]=atof(line.substr(30,10).c_str());
			getline(fin,line);
			scale[1][0]=atof(line.substr(10,10).c_str());
			scale[1][1]=atof(line.substr(20,10).c_str());
			scale[1][2]=atof(line.substr(30,10).c_str());
			getline(fin,line);
			scale[2][0]=atof(line.substr(10,10).c_str());
			scale[2][1]=atof(line.substr(20,10).c_str());
			scale[2][2]=atof(line.substr(30,10).c_str());
			process_tran();
			btrans=1;
		}
		if(part1=="CRYST")
		{
			part1=line.substr(67,4);
			ncry=atoi(part1.c_str());
		}

		if(line.size()>6)
			part=line.substr(0,6);
		else
			part.clear();
		if(part=="ENDMDL" || part=="END")
		{
			//finished read first molecule 
			if(x.size()%natom!=0)
				cout<<"In traj reading, suppose to read "<<natom<<" coors but actually read in "<<x.size()<<endl;
		}


		part=line.substr(0,6);
		if(part!="ATOM  " && part!="HETATM")
			continue;

		part=line.substr(17,3);
		if(part=="HOH" || part=="WAT")
			continue;

		part=line.substr(30,8);
		xx=atof(part.c_str());
		x.push_back(xx);
		part=line.substr(38,8);
		yy=atof(part.c_str());
		y.push_back(yy);
		part=line.substr(46,8);
		zz=atof(part.c_str());
		z.push_back(zz);
		part=line.substr(60,6);
		bb=atof(part.c_str());
		b.push_back(bb);
		part=line.substr(12,4);
		atomname.push_back(part);
	};

	if(natom==0)
		nframe=0;
	else
		nframe=x.size()/natom;
	return nframe;
}

void CTraj2::process_tran()
{
	if(scale[1][0]!=0 || scale[2][0]!=0 || scale[2][1]!=0)
		return;
		
	translation[0][0]=1/scale[0][0];
	translation[0][1]=-scale[0][1]/(scale[1][1]*scale[0][0]);
	translation[0][2]=(scale[0][1]*scale[1][2]/scale[1][1]-scale[0][2])/(scale[0][0]*scale[2][2]);

	translation[1][0]=0;
	translation[1][1]=1/scale[1][1];
	translation[1][2]=-scale[1][2]/(scale[1][1]*scale[2][2]);

	translation[2][0]=0;
	translation[2][1]=0;
	translation[2][2]=1/scale[2][2];
	
	return;
}



int CTraj2::unitcell(void)
{
	class smtry crystal_sym;
	double xmean,ymean,zmean;
	double xscale,yscale,zscale;
	double xtran,ytran,ztran;
	double yold[3];
	double ynew[3];
	int n;
	int i,j;


	n=x.size();
	for(i=0;i<(int)crystal_sym_array.size();i++)
	{
		xmean=ymean=zmean=0;
		crystal_sym=crystal_sym_array.at(i);			
		for(j=0;j<n;j++)
		{
			yold[0]=x.at(j);
			yold[1]=y.at(j);
			yold[2]=z.at(j);
			crystal_sym.trans(yold,ynew);
			x.push_back(ynew[0]);
			y.push_back(ynew[1]);
			z.push_back(ynew[2]);
			xmean+=ynew[0];
			ymean+=ynew[1];
			zmean+=ynew[2];				
		}
		xmean/=n;
		ymean/=n;
		zmean/=n;

		xscale=scale[0][0]*xmean+scale[0][1]*ymean+scale[0][2]*zmean;
		yscale=scale[1][0]*xmean+scale[1][1]*ymean+scale[1][2]*zmean;
		zscale=scale[2][0]*xmean+scale[2][1]*ymean+scale[2][2]*zmean;
		
		xscale= xscale>=0 ? -((int)xscale) : -((int)(xscale-0.9999));
		yscale= yscale>=0 ? -((int)yscale) : -((int)(yscale-0.9999));
		zscale= zscale>=0 ? -((int)zscale) : -((int)(zscale-0.9999));	
		
		
		xtran=xscale*translation[0][0]+yscale*translation[0][1]+zscale*translation[0][2];
		ytran=yscale*translation[1][1]+zscale*translation[1][2];
		ztran=zscale*translation[2][2];
		
		for(j=0;j<natom;j++)
		{
			x.at(j+natom*(i+1))+=xtran;
			y.at(j+natom*(i+1))+=ytran;
			z.at(j+natom*(i+1))+=ztran;
		}			
	}

	return i;
}

void CTraj2::ninecells(void)
{
	int i,m,k,n;
	double xtran,ytran,ztran;
	int nnow;

	nnow=x.size();

	for(m=-1;m<=1;m++)
	for(n=-1;n<=1;n++)
	for(k=-1;k<=1;k++)
	{
		if(m==0 && n==0 && k==0)
			continue;
		xtran=m*translation[0][0]+n*translation[0][1]+k*translation[0][2];
		ytran=n*translation[1][1]+k*translation[1][2];
		ztran=k*translation[2][2];
		for(i=0;i<nnow;i++)
		{
			x.push_back(x.at(i)+xtran);
			y.push_back(y.at(i)+ytran);
			z.push_back(z.at(i)+ztran);
		}
	}
	return;
}


CTraj2::CTraj2()
{
	x.clear();
	y.clear();
	z.clear();
	b.clear();
	crystal_sym_array.clear();
	nframe=0;
	natom=0;
	nres=0;
	memset(translation,0,sizeof(double)*9);
	memset(scale,0,sizeof(double)*9);
	btrans=0;
	bsmtry=0;
};

CTraj2::~CTraj2()
{

};

########## NEXT FILE ##########
main.cpp:::

#include <iostream>
#include <cstdlib>
#include <fstream>
#include <string>
#include <cstring>
#include <vector>
#include <math.h>
#include <time.h>
#include <sstream>
using namespace std;

#include "config.h"
#include "supply.h"
#include "bmrb.h"
#include  "aa.h"
#include "pdb.h"
//#include "munkres.h"




vector<double> compare(vector< vector<double> > t,vector<double> shift)
{
	int i,j,n;
	double e,ee;
	bool b;
	vector<bool> bs;
	double sum;
	int count;
	vector<double> diff;

	for(i=0;i<t.at(0).size();i++)
	{
		b=0;
		for(j=0;j<t.size();j++)
		{
			if(t.at(j).at(i)<=0.001 || t.at(j).at(i)>990)
				b=1;
		}
		bs.push_back(b);
		
	}

	cout<<"RMSDs are";
	sum=0.0;
	count=0;
	for(i=1;i<t.size();i++)
	{
		ee=0;
		n=0;
		for(j=0;j<t.at(0).size();j++)
		{
			if(bs.at(j)==0)
			{
				e=t.at(0).at(j)-t.at(i).at(j)-shift.at(i-1);
				ee+=e*e;
				n++;
				sum+=t.at(i).at(j)-t.at(0).at(j);
				count++;
			}
		}
		ee/=n;
		ee=sqrt(ee);
		cout<<" "<<ee;
		if(count>0) diff.push_back(sum/count);
		else diff.push_back(0.0);
	}
	cout<<endl;

	return diff;
}

void output(char *name,vector<int> ids, vector<char> codes, vector<string> names, vector< vector<double> > t)
{
	int i,j;
	FILE * fp;
	fp=fopen(name,"wt");

	for(i=0;i<ids.size();i++)
	{
		fprintf(fp,"%8d%8c%8s",ids.at(i),codes.at(i),names.at(i).c_str());
		for(j=0;j<t.size();j++)
			fprintf(fp,"%8.3f",t.at(j).at(i));
		fprintf(fp,"\n");
	}
	fclose(fp);
	return;
}
		
void output2(char *name,vector<int> ids, vector<char> codes, vector<string> names, vector<int> types, vector< vector<double> > t)
{
	int i,j;
	FILE * fp;
	fp=fopen(name,"wt");

	for(i=0;i<ids.size();i++)
	{
		fprintf(fp,"%8d%8d%8c%8s",ids.at(i),types.at(i),codes.at(i),names.at(i).c_str());
		for(j=0;j<t.size();j++)
			fprintf(fp,"%10.3f",t.at(j).at(i));
		fprintf(fp,"\n");
	}
	fclose(fp);
	return;
}


double process(int &count,double x,double y,double scale)
{
	double s;

	s=(x-y)*scale;
	s=fabs(s);

	if(x>900 || y>900) 
	{
		s=0;
		count--;
	}
	else if(x<-900 && y<-900)
	{
		s=-5.0;
	}
	else if(x<-900 || y<-900)
	{
		s=100;
	}
	else
		s*=s;

	
	return s;
};

double adj(double x, double y, double s)
{
	y=(y-x)*s+x;
	return y;
}

			


/*void bmrb_matrix(double scale,vector<int> &correct_assignment,vector<int> &false_assignment,vector<struct bb_group> bb1,vector<struct bb_group> bb2,int selection, int nnoise, double std, double cutoff, double wc, double wh, double wn, double wha)
{
	int n,count;
	int total;
	int i,j;
	struct bb_group b1,b2;
	double s,ss;
	Munkres *m;
	bool bfalse;
	int c,f;

	ofstream fout("cs_matrix.dat");
	ofstream fassign("assign.dat");

	n=bb1.size();
	if(n!=bb2.size())
		return;

	for(i=0;i<bb2.size();i++)
	{
		bb2.at(i).exp_ca=adj(bb1.at(i).exp_ca,bb2.at(i).exp_ca,scale);
		bb2.at(i).exp_cb=adj(bb1.at(i).exp_cb,bb2.at(i).exp_cb,scale);
		bb2.at(i).exp_co=adj(bb1.at(i).exp_co,bb2.at(i).exp_co,scale);
		bb2.at(i).follow_exp_n=adj(bb1.at(i).follow_exp_n,bb2.at(i).follow_exp_n,scale);
		bb2.at(i).follow_exp_h=adj(bb1.at(i).follow_exp_h,bb2.at(i).follow_exp_h,scale);
	}

	Matrix<double> matrix(n, n);  //nrow, ncolumn
	Matrix<double> matrix2(n, n);  //nrow, ncolumn
	Matrix<double> outmatrix(n, n);  //nrow, ncolumn
	
	for(i=0;i<n;i++)
	{
		b1=bb1.at(i);
		for(j=0;j<n;j++)
		{
			b2=bb2.at(j);
			ss=0;


			if(selection==1) //ca cb ha
			{
				count=3;
				ss+=process(count,b1.exp_ca,b2.exp_ca,wc);
				ss+=process(count,b1.exp_cb,b2.exp_cb,wc);
				ss+=process(count,b1.exp_ha,b2.exp_ha,wha);
			}
			else if(selection==2) //co h n
			{
				count=3;
				ss+=process(count,b1.exp_ca,b2.exp_ca,wc);
				ss+=process(count,b1.follow_exp_h,b2.follow_exp_h,wh);
				ss+=process(count,b1.follow_exp_n,b2.follow_exp_n,wn);
			}
			else if(selection==3) //ca cb h n
			{
				count=4;
				ss+=process(count,b1.exp_ca,b2.exp_ca,wc);
				ss+=process(count,b1.exp_cb,b2.exp_cb,wc);
				ss+=process(count,b1.follow_exp_h,b2.follow_exp_h,wh);
				ss+=process(count,b1.follow_exp_n,b2.follow_exp_n,wn);
			}
			else if(selection==4) //ca cb h n ha
			{
				count=5;
				ss+=process(count,b1.exp_ca,b2.exp_ca,wc);
				ss+=process(count,b1.exp_cb,b2.exp_cb,wc);
				ss+=process(count,b1.follow_exp_h,b2.follow_exp_h,wh);
				ss+=process(count,b1.follow_exp_n,b2.follow_exp_n,wn);
				ss+=process(count,b1.exp_ha,b2.exp_ha,wha);
			}
			else  // all 
			{
				count=6;
				ss+=process(count,b1.exp_ca,b2.exp_ca,wc);
				ss+=process(count,b1.exp_cb,b2.exp_cb,wc);
				ss+=process(count,b1.exp_co,b2.exp_co,wc);
				ss+=process(count,b1.follow_exp_h,b2.follow_exp_h,wh);
				ss+=process(count,b1.follow_exp_n,b2.follow_exp_n,wn);
				ss+=process(count,b1.exp_ha,b2.exp_ha,wha);
			}

			if(ss<0)
				ss=0.0;

			if(count>0)
				ss=sqrt(ss/count);
			else
				ss=10.0;

			fout<<ss<<" ";
			matrix(i,j)=ss;
		}
		fout<<endl;
	}
	fout<<endl<<endl;
	

	
	for ( int row = 0 ; row < n ; row++ )
	for ( int col = 0 ; col < n ; col++ )
	{
		outmatrix(row,col)=0.0;
	}

	for(i=0;i<nnoise;i++)
	{
		if(i>0)
		{
			for ( int row = 0 ; row < n ; row++ )
			{
				for ( int col = 0 ; col < n ; col++ )
				{
					matrix2(row,col)=matrix(row,col)+ldw_math::gaussrand()*std;
				}
			}
		}
		else
		{
			for ( int row = 0 ; row < n ; row++ )
			{
				for ( int col = 0 ; col < n ; col++ )
				{
					matrix2(row,col)=matrix(row,col);
				}
			}
		}

		m=new Munkres;
		m->solve(matrix2);
		delete m;

		for ( int row = 0 ; row < n ; row++ )
		{
			for ( int col = 0 ; col < n ; col++ )
			{
				fout<<matrix2(row,col)+1<<" ";
			}
			fout<<endl;
		}
		fout<<endl<<endl;

		for ( int row = 0 ; row < n ; row++ )
		{
			for ( int col = 0 ; col < n ; col++ )
			{
				outmatrix(row,col)=outmatrix(row,col)+matrix2(row,col)+1;
			}			
		}
	}

	f=c=0;
	for ( int row = 0 ; row < n ; row++ )
	{
		bfalse=0;
		for ( int col = 0 ; col < n ; col++ )
		{
			fassign << outmatrix(row,col) << " ";
			if(col!=row && outmatrix(row,col)>=cutoff*nnoise)
			{
				bfalse=1;
				false_assignment.push_back(bb1.at(row).id);
				false_assignment.push_back(bb2.at(col).id);
			}
		}
		fassign << endl;
		if(bfalse)
			f++;
		else if(outmatrix(row,row)>=cutoff*nnoise)
		{
			c++;
			correct_assignment.push_back(bb1.at(row).id);
		}
	}
		
	fassign.close();
	fout.close();
	cout<<"correctly assign "<<c<<" while false positive is "<<f<<" and total is "<<n<<endl;
	return;
}
*/

double cal_diff(double &count,double x,double y,double scale)
{
	double s;

	if(fabs(x)>900 || fabs(y)>900) 
	{
		s=0.0;
		count-=scale;
	}
	else if(fabs(x)<=0.01 || fabs(y)<=0.01)
	{
		s=0.0;
		count-=scale;
	}
	else
	{
		s=(x-y)*scale;
		s*=s;
	}

	return s;
};
			

void compare_cs(vector<struct bb_group> bb1,vector<struct bb_group> bb2, vector<double> &errors)
{
	int i;
	struct bb_group b1,b2;
	double error;
	double count;
	
	for(i=0;i<(int)bb1.size() && i<(int)bb2.size() ;i++)
	{
		b1=bb1.at(i);
		b2=bb2.at(i);

		count=3.0;
		error=0.0;
		error+=cal_diff(count,b1.exp_ca,b2.exp_ca,1.0);
		error+=cal_diff(count,b1.exp_cb,b2.exp_cb,1.0);
		error+=cal_diff(count,b1.exp_co,b2.exp_co,1.0);
		//error+=cal_diff(count,b1.exp_h,b2.exp_h,2.0);
		//error+=cal_diff(count,b1.exp_n,b2.exp_n,0.4);
		
		if(count>=1.0)
			error=error/count;
		else
			error=0.0;
		errors.push_back(sqrt(error));
	}
	return;
}


	
void computer_rmsd(vector < vector<struct bb_group> > *bbs, string filename)
{
	int i,j;
	vector<struct bb_group> bb1,bb2;
	vector<double> errors;
	vector<int> ids;
	vector< vector<double> > all_errors;
	ofstream fout(filename.c_str());

	bb1=bbs->at(0);
	for(i=0;i<(int)bb1.size();i++)
		ids.push_back(bb1.at(i).id);
	for(i=1;i<(int)bbs->size();i++)
	{
		bb2.clear();
		errors.clear();
		bb2=bbs->at(i);
		compare_cs(bb1,bb2,errors);
		all_errors.push_back(errors);
	}

	for(i=0;i<(int)ids.size();i++)
	{
		fout<<ids.at(i);
		for(j=0;j<all_errors.size();j++)
			fout<<" "<<all_errors.at(j).at(i);
		fout<<endl;
	}
}


int main(int argc,char ** argv)
{
	int i,j;
	class CPdb pdb;
	class CBmrb bmrb,bmrb0;
	string filename;
	vector<struct bb_group> bb;
	vector<struct bb_group> bb2;
	vector < vector<struct bb_group> > bbs;
	vector<struct proton> proton;
	vector< vector<double> > cas,cbs,cos,hs,ns,hydrogens,has;
	vector<double> ca,cb,co,h,n,hydrogen,ha;
	vector<int> ids,ids2;
	vector<char> codes,codes2;
	vector<int> types;
	vector<string> names,names2;
	vector<string> args,args2;
	CCommandline cmdline;
	stringstream ss;
	string p;
	string bmrbname;
	string pre_name;
	bool bfirst;
	vector<int> false_assignment;
	vector<int> correct_assignment;
	string seq;



	vector<double> shift,shift1,shift2,shift3;
	

	bbs.clear();

	cout<<"NMR suit Version "<<NMR_VERSION_MAJOR<<"."<<NMR_VERSION_MINOR<<endl;

	
	args.push_back("-pdb");args2.push_back("pdb.pdb");
	args.push_back("--bmrb");args2.push_back("bmrb.dat bmrb_pre.dat");
	args.push_back("--sparta");args2.push_back("");
	args.push_back("-bb");args2.push_back("yes");
	args.push_back("-proton");args2.push_back("yes");
	args.push_back("-rmsd");args2.push_back("yes");


	cmdline.init(args,args2);
	cmdline.pharse(argc,argv);
	cmdline.print();


	FILE *fp=fopen(cmdline.query("-pdb").c_str(),"rt");
	if(fp==NULL)
	{
		bmrbname=cmdline.query("--bmrb");
		ss.clear();
		ss<<bmrbname;
		if(ss>>p)
		{
			bmrb0.clear();
			bmrb0.process(p.c_str());
			bmrb0.loaddetail("cs.dat");
			while(ss>>p)
			{
				bmrb.clear();
				bmrb.process(p.c_str());
				bmrb0.attach_bmrb(bmrb);
			}
		}

		bmrb0.print("detail.dat");

	}
	else
	{
		pdb.loadpdb(cmdline.query("-pdb").c_str());

		bfirst=1;

		bmrbname=cmdline.query("--bmrb");
		ss.clear();
		ss<<bmrbname;
		while(ss>>p)
		{
			pdb.loadpdb(cmdline.query("-pdb").c_str());
			bmrb.clear();
			bmrb.process(p.c_str());
			pdb.attach_bmrb(bmrb);
			bb.clear();
			pdb.getbb(&bb);
			bbs.push_back(bb);

			ca.clear();cb.clear();co.clear();h.clear();n.clear();ha.clear();


			for(j=0;j<bb.size();j++)
			{
				if(bfirst==1)
				{
					ids.push_back(bb.at(j).id);
					codes.push_back(bb.at(j).code);
					names.push_back(Sequence::code2name(bb.at(j).code));
				}
				ca.push_back(bb.at(j).exp_ca);
				cb.push_back(bb.at(j).exp_cb);
				co.push_back(bb.at(j).exp_co);
				 h.push_back(bb.at(j).exp_h);
				 n.push_back(bb.at(j).exp_n);
				ha.push_back(bb.at(j).exp_ha);
			}
			cas.push_back(ca);
			cbs.push_back(cb);
			cos.push_back(co);
			has.push_back(ha);
			hs.push_back(h);
			ns.push_back(n);

			proton.clear();
			pdb.allproton(&proton);
			hydrogen.clear();
			for(j=0;j<proton.size();j++)
			{
				if(bfirst==1)
				{
					ids2.push_back(proton.at(j).id);
					codes2.push_back(proton.at(j).code);
					names2.push_back(proton.at(j).name);
					types.push_back(proton.at(j).type);
				}
				hydrogen.push_back(proton.at(j).exp);
			}
			hydrogens.push_back(hydrogen);

			bfirst=0;
		}


		bmrbname=cmdline.query("--sparta");
		ss.clear();
		ss<<bmrbname;
		while(ss>>p)
		{
			pdb.loadpdb(cmdline.query("-pdb").c_str());
			bmrb.clear();
			bmrb.run_sparta(p,0);
			pdb.attach_bmrb(bmrb);
			pre_name=p.append("_bmrb.dat");
			pdb.print_prediction(pre_name);
		
			bb.clear();
			pdb.getbb(&bb);
			bbs.push_back(bb);

			ca.clear();cb.clear();co.clear();h.clear();n.clear();ha.clear();
			for(j=0;j<bb.size();j++)
			{
				if(bfirst==1)
				{
					ids.push_back(bb.at(j).id);
					codes.push_back(bb.at(j).code);
					names.push_back(Sequence::code2name(bb.at(j).code));
				}
				ca.push_back(bb.at(j).exp_ca);
				cb.push_back(bb.at(j).exp_cb);
				co.push_back(bb.at(j).exp_co);
				 h.push_back(bb.at(j).exp_h);
				 n.push_back(bb.at(j).exp_n);
				ha.push_back(bb.at(j).exp_ha);
			}
			cas.push_back(ca);
			cbs.push_back(cb);
			cos.push_back(co);
			has.push_back(ha);
			hs.push_back(h);
			ns.push_back(n);

			proton.clear();
			pdb.allproton(&proton);
			hydrogen.clear();
			for(j=0;j<proton.size();j++)
			{
				if(bfirst==1)
				{
					ids2.push_back(proton.at(j).id);
					codes2.push_back(proton.at(j).code);
					names2.push_back(proton.at(j).name);
					types.push_back(proton.at(j).type);
				}
				hydrogen.push_back(proton.at(j).exp);
			}
			hydrogens.push_back(hydrogen);

			bfirst=0;
		}

	

	
	if(cmdline.query("-bb").compare("yes")==0)
	{
		for(i=1;i<cas.size();i++)
			shift.push_back(0.0);

		cout<<"Ca ";shift1=compare(cas,shift);
		cout<<"Cb ";shift2=compare(cbs,shift);
		cout<<"Co ";shift3=compare(cos,shift);




		output("ca.out",ids,codes,names,cas);output("cb.out",ids,codes,names,cbs);output("co.out",ids,codes,names,cos);
		output("h.out",ids,codes,names,hs);output("n.out",ids,codes,names,ns);
		output("ha.out",ids,codes,names,has);

		shift.clear();
		for(i=1;i<cas.size();i++)
		{
			shift.push_back(-(shift1.at(i-1)+shift2.at(i-1))/2.0);
            cout<<"autoref of cacb is "<<-(shift1.at(i-1)+shift2.at(i-1))/2.0<<endl;
		}
        

		cout<<"Ca ";compare(cas,shift);
		cout<<"Cb ";compare(cbs,shift);

		shift.clear();
		for(i=1;i<cas.size();i++)
		{
			shift.push_back(-shift3.at(i-1));
            cout<<"autoref of co is "<<-shift3.at(i-1)<<endl;
		}

		cout<<"Co ";compare(cos,shift);

		shift.clear();
		for(i=1;i<cas.size();i++)
			shift.push_back(0.0);

		cout<<"ha ";compare(has,shift);
		cout<<"h  ";compare(hs,shift);
		cout<<"n  ";compare(ns,shift);
	}

	if(cmdline.query("-proton").compare("yes")==0)
	{
		shift.clear();
		for(i=0;i<hydrogens.size();i++)
			shift.push_back(0.0);
		output2("proton.out",ids2,codes2,names2,types,hydrogens);
		cout<<"Side chain proton ";
		compare(hydrogens,shift);
	}

	}



	return 0;
}



		



########## NEXT FILE ##########
main.cpp:::
#include <iostream>
#include <cstdlib>
#include <fstream>
#include <string>
#include <cstring>
#include <vector>
#include <math.h>
#include <time.h>
#include <sstream>

using namespace std;
#include "lmmin.h"
#include "config.h"
#include "supply.h"
#include "bmrb.h"
#include  "aa.h"
#include "pdb.h"
#include "traj.h"
#include "mainbody.h"

#include "debug.h"

#ifdef BENCHMARK
#include <omp.h>
#endif

// ///////////////////////////////////////////////////////////////////////////////////////////////////////////
int main(int argc, char ** argv)
{
	int begin,stop;
	bool bh,bdetail,bnew,bann,btest,bnew_pdb,blinear,bold;
	class CMainbody mainbody;
	string pdbname;
	string spartaname;
	string gmxname;
	string bmrbname;
	int para;
	int nconf;

	cout<<"PPM: an enemble-based chemical shifts predictor"<<endl;

#ifdef BENCHMARK
	double clock = omp_get_wtime();
#endif

	bh=bdetail=bnew=btest=bnew_pdb=bann=blinear=bold=0;

	CCommandline cmdline;
	vector<string> args,args2,args3;

	args.push_back("-h");		args2.push_back("no");						args3.push_back("print help informaiton then quit");
	args.push_back("-mode");	args2.push_back("ann");						args3.push_back("prediciton algorithm: ann(default) or linear");
	args.push_back("-pdb");		args2.push_back("pdb.pdb");					args3.push_back("input pdb file name");
	args.push_back("-bmrb");	args2.push_back("bmrb.dat");				args3.push_back("input experimental chemical shifts file in NMRSTAR format");
    args.push_back("-pre");		args2.push_back("bmrb_pre.dat");			args3.push_back("output filename for predicted chemical shifts in NMRSTAR format");
	args.push_back("-begin");	args2.push_back("0");						args3.push_back("Index of first snapshot to be used (start from 0)");
	args.push_back("-stop");	args2.push_back("0");						args3.push_back("Index of last snapshot to be used (0 means last snapshot)");
	args.push_back("-para");	args2.push_back("pdb");                     args3.push_back("Parameter set: pdb(ppm_one) or old(ppm)");
    args.push_back("-detail(s)");	args2.push_back("no");					args3.push_back("calculate chemical shifts for each snapshots, only applicable to ensemble predictions");

		
	cmdline.init(args,args2,args3);
	cmdline.pharse(argc,argv);


	spartaname="sparta.pdb";
	pdbname=cmdline.query("-pdb");
	bmrbname=cmdline.query("-bmrb");
	begin=atoi(cmdline.query("-begin").c_str());
	stop=atoi(cmdline.query("-stop").c_str());
    


	if(cmdline.query("-h").compare("yes")==0)		bh=1;
	if(cmdline.query("-mode").compare("linear")==0)		{blinear=1;bann=0;}
	if(cmdline.query("-mode").compare("ann")==0)		{blinear=0;bann=1;}


	if(cmdline.query("-para").compare("pdb")==0)		para=2;
	if(cmdline.query("-para").compare("old")==0)		bold=1;
    
    if(cmdline.query("-detail").compare("yes")==0)		bdetail=1;
    if(cmdline.query("-details").compare("yes")==0)		bdetail=1;



	cmdline.print();

	if(bh==1)
	{	
		exit(0);
	}


	nconf=mainbody.loadpdb(pdbname,gmxname);
	mainbody.set_range(begin,stop);
	mainbody.load(bmrbname);




	if(bold)  //previous generation PPM
	{
		cout<<"Prediction using the old PPM parameters\n";
		cout<<"Chemical shifts root-mean-square deviations (RMSDs) between predicted and experimental values:"<<endl;
        if(bdetail)
        {
            mainbody.predict_proton2();
            mainbody.predict_bb2();
        }
        else
        {
            mainbody.predict_proton();
            mainbody.predict_bb();
        }
		mainbody.print_prediction(cmdline.query("-pre"));
	}
	else if(blinear && para==2)
	{
		cout<<"Prediction using the linear model with static parameters set\n";
		cout<<"Chemical shifts root-mean-square deviations (RMSDs) between predicted and experimental values:"<<endl;
		mainbody.predict_bb_static_new();
		mainbody.predict_proton_static_new();
		mainbody.print_prediction(cmdline.query("-pre"));
	}


	else if(bann && para==2)
	{
		cout<<"Prediction using the ANN model with static parameters set\n";
		cout<<"Chemical shifts root-mean-square deviations (RMSDs) between predicted and experimental values:"<<endl;
		mainbody.predict_bb_static_ann();
		mainbody.predict_proton_static_new();
		mainbody.print_prediction(cmdline.query("-pre"));
	}

	else
	{
		cout<<"Unrecognized command line arguments!\n";
	}

#ifdef BENCHMARK
	printf("Total runtime: %.4f\n", omp_get_wtime()-clock);
#endif

	return 0;
}










########## NEXT FILE ##########
mainbody.cpp:::
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <string>
#include <vector>
#include <math.h>
#include <time.h>
#include <sstream>
using namespace std;

#include "ann.h"
#include "mainbody.h"

#include "debug.h"

#ifdef BENCHMARK
#include <omp.h>
#endif



//class Dihe_process, used by ppm only

void CDihe_process::init(vector<int> innum,vector<double> *indihe)
{
	num=innum;
	dihe=indihe;
	if(num.size()>2)
	{
		ndihe=num.at(num.size()-1);
		nframe=dihe->size()/ndihe;
	}
	else
	{
		ndihe=0;
		nframe=0;
	}

	return;
}

void CDihe_process::init(vector<int> innum,vector<double> *indihe, vector<dihe_group> *indihe_index)
{
	num=innum;
	dihe=indihe;
	dihe_index=indihe_index;

	if(num.size()>2)
	{
		ndihe=num.at(num.size()-1);
		nframe=dihe->size()/ndihe;
	}
	else
	{
		ndihe=0;
		nframe=0;
	}

	return;
}

void CDihe_process::init(vector<int> innum,vector<double> *indihe, vector<double> *inangle)
{
	num=innum;
	dihe=indihe;
	angle=inangle;
	if(num.size()>2)
	{
		ndihe=num.at(num.size()-1);
		nframe=dihe->size()/ndihe;
	}
	else
	{
		ndihe=0;
		nframe=0;
	}

	return;
}


void CDihe_process::hb_expand(int type)
{
	int i;
	int begin,stop;
	vector<double> temp;

	begin=table[type]*8;
	stop=table[type]*8+8;

	if(stop==0)
	{
		out.clear();
		out.resize(18*8,0.0);
	}
	else
	{
		temp.resize(18*8,0.0);
		for(i=begin;i<stop;i++)
			temp.at(i)=out.at(i-begin);
		out=temp;
	}

	return;
}

void CDihe_process::hb_expand2(int type)
{
    int i;
    int begin,stop;
    vector< vector<double> > temp;
    vector<double> t;
    
    t.resize(nframe,0.0);
    
    begin=table[type]*8;
    stop=table[type]*8+8;
    
    if(stop==0)
    {
        out2.clear();
        out2.resize(18*8,t);
    }
    else
    {
        temp.resize(18*8,t);
        for(i=begin;i<stop;i++)
            temp.at(i)=out2.at(i-begin);
        out2=temp;
    }
    
    return;
}


vector<int> CDihe_process::pos(int in)
{
	int i;
	int base,stop;
	vector<int> out;


	if(in==1)
		base=1;
	else
		base=num.at(in-2)+1;
	
	stop=num.at(in-1);

	if(in<=0)
		base=num.at(num.size()-1)+100;
	if(in>(int)num.size())
		base=num.at(num.size()-1)+100;

	
	for(i=base;i<=stop;i++)
	{
		out.push_back(i);
		//cout<<"in is "<<in<<" "<<i<<endl;
	}

	return out;
}


vector<int> CDihe_process::pos_angle(int in)
{
	int i;
	int base,stop;
	vector<int> out;


	if(in==1)
		base=1;
	else
		base=num.at(in-2)*2+1;
	
	stop=num.at(in-1)*2;

	if(in<=0)
		base=num.at(num.size()-1)+100;
	if(in>(int)num.size())
		base=num.at(num.size()-1)+100;

	
	for(i=base;i<=stop;i++)
	{
		out.push_back(i);
		//cout<<"in is "<<in<<" "<<i<<endl;
	}

	return out;
}

void CDihe_process::allproton(int id)
{
	out.clear();
	process(id,2,2,2);
	return;
}

void CDihe_process::allproton2(int id)
{
    out2.clear();
    process2(id,2,2,2);
    return;
}

bool CDihe_process::test_good(int id,int cut)
{
	bool r;
	vector<int> index;
	int t,i;

	index=pos(id);

	if((int)index.size()>=cut)
		t=cut;
	else
		t=index.size();

	r=1;
	for(i=0;i<t;i++)
	{
		if(dihe_index->at(index.at(i)-1).bgood==0)
			r=0;
	}

	return r;
}


bool CDihe_process::test(int id, int t1, int t2)
{
	bool r;
	if(test_good(id-1,t2) && test_good(id,t1) && test_good(id+1,t2) )
		r=1;
	else
		r=0;
	return r;
}


bool CDihe_process::test_proton(int id, int type)
{
	return ((table[type]==-1) || test_good(id,2));
}


bool CDihe_process::ca_static_new(int id)
{
	out.clear();
	bool r;

	if(test_good(id-1,3) && test_good(id,4) && test_good(id+1,3) )
	{
		process_static_new(id-1,3,2,2);
		process_static_new(id  ,4,3,3);
		process_static_new(id+1,3,2,2);
		r=1;
	}
	else
		r=0;

	return r;
	
}

void CDihe_process::md_new(int id)
{
	out.clear();

	process_static_new(id-1,4,2,2);
	process_static_new(id  ,4,3,3);
	process_static_new(id+1,4,2,2);
  	return;
}

void CDihe_process::md_new_detail(int id, int n)
{
	out.clear();
    
	process_md_sep(n,id-1,4,2,2);
	process_md_sep(n,id  ,4,3,3);
	process_md_sep(n,id+1,4,2,2);
  	return;
}


void CDihe_process::ca(int id)
{
	out.clear();

	process(id-1,3,3,3);
	process(id  ,4,3,3);
	process(id+1,3,3,3);
  	return;
}



void CDihe_process::ca_ann(int id)
{
	out.clear();

	process_static_new(id-1,4,1,1);
	process_static_new(id  ,4,2,2);
	process_static_new(id+1,4,1,1);
  	return;
}

void CDihe_process::md_ann(int id,int n)
{
	out.clear();
	process_md_sep(n,id-1,4,1,1);
	process_md_sep(n,id  ,4,1,1);
	process_md_sep(n,id+1,4,1,1);
	return;
}


void CDihe_process::process_md_sep(int nn,int id,int cut, int order1, int order2)
{
	int i,ii,j,p;
	int base;
	int t;
	double phi;
	int order;
	vector<int> index;
	vector<double> temp;

	index=pos(id);
	if((int)index.size()>=cut)
		t=cut;
	else
		t=index.size();


	for(i=0;i<t;i++)
	{
		p=index.at(i);
		order=order1;
		if(i>1) order=order2;

		for(ii=1;ii<=order;ii++)
		{
			j=nn;
			base=j*ndihe;
			phi=dihe->at(base+p-1);
			out.push_back(cos(phi*ii));
			
			j=nn;
			base=j*ndihe;
			phi=dihe->at(base+p-1);
			out.push_back(sin(phi*ii));
		}
	}

	for(i=t;i<cut;i++)
	{
		for(ii=1;ii<=order2;ii++)
		{
			out.push_back(0.0);
			out.push_back(0.0);
		}
	}

	return;
}

void CDihe_process::process(int id,int cut,int order,int order2)
{
	int p,i,j,k,t,base;
	vector<int> index;
	double phi;
	double cosphi[10];
	double sinphi[10];

	

	index=pos(id);
	if((int)index.size()>=cut)
		t=cut;
	else
		t=index.size();

	for(i=0;i<2;i++)
	{
		p=index.at(i);
		for(k=1;k<=order;k++)
			cosphi[k]=sinphi[k]=0.0;
		for(j=0;j<nframe;j++)
		{
			base=j*ndihe;
			phi=dihe->at(base+p-1);
			for(k=1;k<=order;k++)
			{
				cosphi[k]+=cos(phi*k);
				sinphi[k]+=sin(phi*k);
			}
		}
		for(k=1;k<=order;k++)
		{
			out.push_back(cosphi[k]/nframe);
		}
		for(k=1;k<=order;k++)
		{
			out.push_back(sinphi[k]/nframe);
		}
	}

	for(i=2;i<t;i++)
        {
                p=index.at(i);
                for(k=1;k<=order2;k++)
                        cosphi[k]=sinphi[k]=0.0;
                for(j=0;j<nframe;j++)
                {
                        base=j*ndihe;
                        phi=dihe->at(base+p-1);
                        for(k=1;k<=order2;k++)
                        {
                                cosphi[k]+=cos(phi*k);
                                sinphi[k]+=sin(phi*k);
                        }
                }
                for(k=1;k<=order2;k++)
                {
                        out.push_back(cosphi[k]/nframe);
                }
                for(k=1;k<=order2;k++)
                {
                        out.push_back(sinphi[k]/nframe);
                }
        }

	for(i=t;i<cut;i++)
	{
		for(j=0;j<order2*2;j++)
			out.push_back(0.0);
	}
}


void CDihe_process::process_static_new(int id,int cut,int order,int order2)
{
	int p,i,j,k,t,base;
	vector<int> index;
	double phi;
	double cosphi[10];
	double sinphi[10];


	index=pos(id);
	if((int)index.size()>=cut)
		t=cut;
	else
		t=index.size();

	for(i=0;i<2;i++)
	{
		p=index.at(i);
		for(k=1;k<=order;k++)
			cosphi[k]=sinphi[k]=0.0;
		for(j=0;j<nframe;j++)
		{
			base=j*ndihe;
			phi=dihe->at(base+p-1);
			for(k=1;k<=order;k++)
			{
				cosphi[k]+=cos(phi*k);
				sinphi[k]+=sin(phi*k);
			}
		}
		for(k=1;k<=order;k++)
		{
			out.push_back(cosphi[k]/nframe);
			out.push_back(sinphi[k]/nframe);
		}
	}

	for(i=2;i<t;i++)
        {
                p=index.at(i);
                for(k=1;k<=order2;k++)
                        cosphi[k]=sinphi[k]=0.0;
                for(j=0;j<nframe;j++)
                {
                        base=j*ndihe;
                        phi=dihe->at(base+p-1);
                        for(k=1;k<=order2;k++)
                        {
                                cosphi[k]+=cos(phi*k);
                                sinphi[k]+=sin(phi*k);
                        }
                }
                for(k=1;k<=order2;k++)
                {
                        out.push_back(cosphi[k]/nframe);
						out.push_back(sinphi[k]/nframe);
                }
        }

	for(i=t;i<cut;i++)
	{
		for(j=0;j<order2*2;j++)
			out.push_back(0.0);
	}
}

void CDihe_process::proton(int id)
{
	out2.clear();
	process_fit(id,7);
  	return;
}


void CDihe_process::ca2(int id)
{
	out2.clear();

	process2(id-1,3,3,3);
	process2(id  ,4,3,3);
	process2(id+1,3,3,3);
  	return;
}

void CDihe_process::for_fit(int id)
{
	out2.clear();

	process_fit(id-1,4);
	process_fit(id,4);
	process_fit(id+1,4);
	return;
}


void CDihe_process::fit_angle(int id)
{
	int i,j,p,base;
	vector<int> index;
	vector<double> temp;
	double phi;

	index=pos_angle(id);

	out2.clear();

	int touse[5]={0,1,3,4,5};

	
	for(i=0;i<5;i++)
	{
		if(touse[i]<(int)index.size())
		{
			p=index.at(touse[i]);
			temp.clear();
			for(j=0;j<nframe;j++)
			{
				base=j*ndihe*2;
				phi=angle->at(base+p-1);
				temp.push_back(phi);
			}
			out2.push_back(temp);
		}
		else
		{
			temp.clear();
			for(j=0;j<nframe;j++)
			{
				temp.push_back(0.0);
			}
			out2.push_back(temp);
		}

	}

}


void CDihe_process::process_fit(int id,int cut)
{
	int i,j,p;
	int base;
	int t;
	double phi;
	vector<int> index;
	vector<double> temp;

	index=pos(id);
	if((int)index.size()>=cut)
		t=cut;
	else
		t=index.size();


	for(i=0;i<t;i++)
	{
		p=index.at(i);
		temp.clear();
		for(j=0;j<nframe;j++)
		{
			base=j*ndihe;
			phi=dihe->at(base+p-1);
			temp.push_back(phi);
		}
		out2.push_back(temp);
	}

	for(i=t;i<cut;i++)
	{
		temp.clear();
		for(j=0;j<nframe;j++)
		{
			temp.push_back(0.0);
		}
		out2.push_back(temp);
	}

	return;
}





void CDihe_process::process2(int id,int cut,int order,int order2)
{
	int p,i,j,k,t,base;
	vector<int> index;
	double phi;
	vector< vector<double> > t1,t2;

	

	index=pos(id);
	if((int)index.size()>=cut)
		t=cut;
	else
		t=index.size();

	for(i=0;i<2;i++)
	{
		p=index.at(i);
		t1.clear();
		t2.clear();
		t1.resize(order);
		t2.resize(order);
		for(j=0;j<nframe;j++)
		{
			base=j*ndihe;
			phi=dihe->at(base+p-1);
			for(k=1;k<=order;k++)
			{
				t1.at(k-1).push_back(cos(phi*k));
				t2.at(k-1).push_back(sin(phi*k));
			}
		}
		for(k=1;k<=order;k++)
		{
			out2.push_back(t1.at(k-1));
		}
		for(k=1;k<=order;k++)
		{
			out2.push_back(t2.at(k-1));
		}
	}

	for(i=2;i<t;i++)
    {
		p=index.at(i);
		t1.clear();
		t2.clear();
		t1.resize(order2);
		t2.resize(order2);
		for(j=0;j<nframe;j++)
        {
			base=j*ndihe;
            phi=dihe->at(base+p-1);
            for(k=1;k<=order2;k++)
            {
				t1.at(k-1).push_back(cos(phi*k));
				t2.at(k-1).push_back(sin(phi*k));
			}
		}
        for(k=1;k<=order2;k++)
		{
			out2.push_back(t1.at(k-1));
		}
        for(k=1;k<=order2;k++)
        {
			out2.push_back(t2.at(k-1));
		}
    }

	for(i=t;i<cut;i++)
	{
		t1.clear();
		t2.clear();
		t1.resize(order2);
		t2.resize(order2);
		for(j=0;j<nframe;j++)
		{
			for(k=1;k<=order2;k++)
            {
				t1.at(k-1).push_back(0.0);
				t2.at(k-1).push_back(0.0);
			}
		}
		for(k=1;k<=order2;k++)
		{
			out2.push_back(t1.at(k-1));
		}
        for(k=1;k<=order2;k++)
        {
			out2.push_back(t2.at(k-1));
		}
	}
}

vector<double> CDihe_process::output()
{
	return out;
}

vector< vector<double> > CDihe_process::output2()
{
	return out2;
}

CDihe_process::CDihe_process(void)
{
	int i;
	table=new int[98+1];
	for(i=0;i<98+1;i++)
		table[i]=-1;

	for(i=0;i<18;i++)
		table[hbs[i]]=i;

};


CDihe_process::~CDihe_process(void)
{
	delete [] table ;
};



CMainbody::CMainbody()
{
	int i;

	bnew=0;
	
	sep_table=new int[98+1];
	for(i=0;i<98+1;i++)
		sep_table[i]=-1;

	for(i=0;i<19;i++)
		sep_table[sep[i]]=i;
};

CMainbody::~CMainbody()
{
	if(bnew)
	{
		delete pdb;
		delete traj;
	}
	delete [] sep_table;
};



int CMainbody::loadpdb(CPdb *p_pdb, CTraj * p_traj)
{
	pdb=p_pdb;
	traj=p_traj;

	natom=pdb->getnatom();
	nres=pdb->getnres();
	nconf=traj->getnframe();

	return nconf;
}



int CMainbody::loadpdb(string name)
{
	pdb=new CPdb;
	traj=new CTraj;
	bnew=1;

	natom=pdb->loadpdb(name);
	nres=pdb->getnres();
	traj->setnres(nres);
	traj->setnatom(natom);
	nconf=traj->loadcoor(name);
	return nconf;
}

int CMainbody::loadpdb(string name,string name2)
{
	pdb=new CPdb;
	traj=new CTraj;
	bnew=1;

	pdb_name=name;

	natom=pdb->loadpdb(name);
	nres=pdb->getnres();
	traj->setnres(nres);
	traj->setnatom(natom);

	
	
    nconf=traj->loadcoor(name);


	return nconf;
}




void CMainbody::load(string bmrbname)
{
	bmrb.process(bmrbname.c_str());
	pdb->attach_bmrb(bmrb);
	pdb->getdihe(&dihe_index,&dihe_num);
	pdb->getring(&ring_index);
	pdb->ani(&anistropy);
	pdb->proton(&protons);
	pdb->allproton(&allprotons);
	pdb->process_ambig(2);
	pdb->allproton3(&allprotons3);
	heavy=pdb->getheavy();
	pdb->getbb(&bb);
	pdb->bbnh(&bbnh);
	pdb->bbhbond(&hbond);
	pdb->schbond(&hbond);  //This is new !
	ndihe=dihe_index.size();
	traj->getdihe(&dihe_index,&dihe);
	dihe_process.init(dihe_num,&dihe,&dihe_index);
	//process bb to remove all entry that has missing part !!
	//bbnh willn't take effect if bb is not there for particular residue
	bb=clear(bb);
	allprotons=clear(allprotons);
	allprotons3=clear(allprotons3);

	//seperate ring group to two, one for internal, one for surface, according to contact sum !
	int i;
	vector<int> ring_atom;
	vector<float> result;
	ring_atom.clear();
	result.clear();
	for(i=0;i<(int)ring_index.size();i++)
	{
		ring_atom.push_back(ring_index.at(i).x2);
	}
#ifdef BENCHMARK
	double clock = omp_get_wtime();
#endif
	traj->get_contact(1.00,0.0,ring_atom,heavy,&result);
#ifdef BENCHMARK
	printf("%.4f traj->get_contact\n", omp_get_wtime()-clock);
#endif
	ring_index_internal.clear();
	ring_index_external.clear();

	for(i=0;i<(int)ring_index.size();i++)
	{
		if(result.at(i)>2.5)
			ring_index_internal.push_back(ring_index.at(i));
		else
			ring_index_external.push_back(ring_index.at(i));
	}

	return;
}

vector<struct proton> CMainbody::clear(vector<struct proton> &protons)
{
	int i;
	int id,type;
	vector<struct proton> newprotons;
	newprotons.reserve(protons.size());

	for(i=0;i<protons.size();i++)
	{
		id=protons.at(i).id;
		type=protons.at(i).type;

		if(id<1 || id>pdb->getnres())
		{
			//protons.erase(protons.begin()+i);
			continue;
		}
		if(dihe_process.test_proton(id,type)==0) //==0 means missing dihedral angles in this calculation !!
		{
			//protons.erase(protons.begin()+i);
			continue;
		}
		newprotons.push_back(protons.at(i));
	}
	return newprotons;
}


vector<struct bb_group> CMainbody::clear(vector<struct bb_group> &bb)
{
	int i;
	int id;
	char code,code_pre,code_fol;
	vector<struct bb_group> newbb;
	newbb.reserve(bb.size());
	
	for(i=0;i<bb.size();i++)
	{
		//cout<<i<<endl;
		id=bb.at(i).id;

		//first and last residue are excluded
		if(id<=1)
		{
			//bb.erase(bb.begin()+i);
			continue;
		}
		if(id>=pdb->getnres())
		{
			//bb.erase(bb.begin()+i);
			continue;
		}

		code=pdb->code(id);
		code_pre=pdb->code(id-1);
		code_fol=pdb->code(id+1);

		//previous or following residue actually belong to another chain. 
		if(pdb->chain(id)!=pdb->chain(id-1) || pdb->chain(id)!=pdb->chain(id+1))
		{
			//bb.erase(bb.begin()+i);
			continue;
		}

		//missing or unknow residue should NOT be predicted. This is also true if either previous or following residue is missing (or unknown)
		if(code_pre=='X' || code_pre=='B' || code_fol=='X' || code_fol=='B'|| code=='X' || code=='B')
		{
			//bb.erase(bb.begin()+i);
			continue;
		}

		if(dihe_process.test(id,4,4)==0) //==0 means missing dihedral angles in this calculation !!
		{
			//bb.erase(bb.begin()+i);
			continue;
		}

		if(bb.at(i).capos<0 ||  bb.at(i).copos<0 || bb.at(i).npos<0 )
		{
			//bb.erase(bb.begin()+i);
			continue;
		}

		if(bb.at(i).cbpos<0 && bb.at(i).code!='G')
		{
			//bb.erase(bb.begin()+i);
			continue;
		}

		if(bb.at(i).hpos<0 && bb.at(i).code!='P')
		{
			//bb.erase(bb.begin()+i);
			continue;
		}

		newbb.push_back(bb.at(i));

	}

	return newbb;
}



int CMainbody::set_range(int begin,int stop)
{
	nconf=traj->set_range(begin,stop);
	return nconf;
}





void CMainbody::predict_bb()
{
	int i,j,j2,jj;
	int id;
	char code;
	vector<double> out;
	vector<double> in,in2;
	vector<struct double_five> ring_effect;
	vector<struct ehbond> hbond_effect;
	vector<struct double_four> ani_effect;
	vector<struct index_two> index;
	double pre[6];
	double temp;
	vector<double> eca,ecb,eco,eh,en;
	

	traj->gethbond(&hbond,&hbond_effect);
	traj->getani(&anistropy,&bbnh,&ani_effect);
	traj->getring(&ring_index,&bbnh,&ring_effect);

	
	/*carbon=bb_ca; exp.loadexp_bb("exp_ca.dat",&bb,carbon);
	carbon=bb_cb; exp.loadexp_bb("exp_cb.dat",&bb,carbon);
	carbon=bb_co; exp.loadexp_bb("exp_co.dat",&bb,carbon);
	exp.loadexp_bbn("exp_n.dat",&bbnh);
	exp.loadexp_bbnh("exp_hn.dat",&bbnh);*/


	index.resize(pdb->getnres());
	for(i=0;i<(int)index.size();i++)
		index.at(i).x1=index.at(i).x2=-1;
	for(i=0;i<(int)bb.size();i++)
		index.at(bb.at(i).id-1).x1=i+1;
	for(i=0;i<(int)bbnh.size();i++)
		index.at(bbnh.at(i).id-1).x2=i+1;
	

	for(i=0+1;i<(int)index.size()-1;i++)
	{
		//cout<<i<<endl;
		if(index.at(i).x1<0)
			continue;
		id=i+1;
		code=pdb->code(id);
		for(jj=0;jj<5;jj++)
			pre[jj]=0.0;
		//ca=cb=co=h=n=0.0;
 
		dihe_process.ca(id); 
		out=dihe_process.output();
		for(j=0;j<30;j++)
		{
			for(jj=0;jj<5;jj++)
				pre[jj]+=c_c[jj][j]*out.at(j);
		}

		for(j=42;j<60;j++)
		{
			for(jj=0;jj<5;jj++)
				pre[jj]+=c_c[jj][j-12]*out.at(j);
		}
			

		in.clear();
		for(j=0;j<12;j++)
		{
			in.push_back(out.at(j+30));
		}
		in2=Sequence::expand(code,&in);
		for(j=0;j<(int)in2.size();j++)
		{
			for(jj=0;jj<5;jj++)
				pre[jj]+=c_c[jj][j+48]*in2.at(j);
		}
		
		
		for(jj=0;jj<5;jj++)
		{
			for(j=-2;j<=0;j++)
			{
				j2=(j+2)*6;
				pre[jj]+=c_c[jj][288+j2]*hbond_effect.at(id+j).c_length;
				pre[jj]+=c_c[jj][289+j2]*hbond_effect.at(id+j).c_phi;
				pre[jj]+=c_c[jj][290+j2]*hbond_effect.at(id+j).c_psi;
				pre[jj]+=c_c[jj][291+j2]*hbond_effect.at(id+j).n_length;
				pre[jj]+=c_c[jj][292+j2]*hbond_effect.at(id+j).n_phi;
				pre[jj]+=c_c[jj][293+j2]*hbond_effect.at(id+j).n_psi;
			}
		}

			//sequence information
			code=pdb->code(id-1);
			Sequence::code2array(code,buffer);
			for(j=0;j<20;j++)		
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j+306]*buffer[j];
			}

			code=pdb->code(id);
			Sequence::code2array(code,buffer);
			for(j=0;j<20;j++)		
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j+326]*buffer[j];
			}

			code=pdb->code(id+1);
			Sequence::code2array(code,buffer);
			for(j=0;j<20;j++)		
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j+346]*buffer[j];
			}

			if(index.at(i).x2>0)
			{
				temp=0.0;
				for(j=0;j<5;j++)
					temp+=ring_effect.at(index.at(i).x2-1).x[j];
				temp*=c_h_add[4];
				for(j=0;j<4;j++)
					temp+=ani_effect.at(index.at(i).x2-1).x[j]*c_h_add[j];
				pre[3]+=temp;
			}
			pre[5]=999.0;
			pdb->attach_bbprediction(id,pre);
	}

	cal_error();
}





void CMainbody::predict_bb_static_ann()
{
	int i,j;
	int id;
	char code,code_pre,code_fol;
	vector<double> out;
	vector<double> in,in2;
	vector<struct double_five> ring_effect,ring_effect_ha;
	vector<struct ehbond> hbond_effect;
	vector<struct double_four> ani_effect,ani_effect_ha;
	vector<struct index_two> index;
	vector<int> c1,c2;
	vector<float> result;
	double pre[6];
	vector<double> eca,ecb,eco,eh,en;

	vector<double> oneline;
	vector<double> oneline_cb;
	vector<double> oneline_co;
	vector<double> oneline_h;
	vector<double> oneline_n;
	vector<double> oneline_ha;

#ifdef BENCHMARK
	double clock;
#endif


	class CAnn ann_ca,ann_cb,ann_co,ann_n,ann_h,ann_ha;

	//ann_ca.load("ann_ca.dat");
	ann_ca.loadp(p_ann_ca);
	ann_cb.loadp(p_ann_cb);
	ann_co.loadp(p_ann_co);
	ann_n.loadp(p_ann_n);
	ann_h.loadp(p_ann_h);
	ann_ha.loadp(p_ann_ha);

#ifdef BENCHMARK
	clock = omp_get_wtime();
#endif
	traj->gethbond(&hbond,&hbond_effect);
#ifdef BENCHMARK
	printf("%.4f gethbond\n", omp_get_wtime()-clock);
	clock = omp_get_wtime();
#endif
	traj->getani(&anistropy,&bbnh,&ani_effect);
#ifdef BENCHMARK
	printf("%.4f getani(bb)\n", omp_get_wtime()-clock);
	clock = omp_get_wtime();
#endif
	traj->getring(&ring_index,&bbnh,&ring_effect);
#ifdef BENCHMARK
	printf("%.4f getring(bb)\n", omp_get_wtime()-clock);
#endif

	
	//gather all ha protons to calculate ring and ani.
	vector<struct proton> ha_protons;
	struct proton ha;
	for(i=0;i<(int)bb.size();i++)
	{
		
		if(bb.at(i).code=='G')
		{
			ha.nh=2;
			ha.hpos[0]=max(0, bb.at(i).hapos);
			ha.hpos[1]=max(0, bb.at(i).hapos2);
			ha.exp=(bb.at(i).exp_ha+bb.at(i).exp_ha2)/2.0;
			ha.exp1=bb.at(i).exp_ha;
			ha.exp2=bb.at(i).exp_ha2;
			ha.type=90;
			ha.name="HB2";
			ha.name2="HB3";
			ha.cname="CA";
			ha.cname2="CA";
		}
		else
		{
			ha.nh=1;
			ha.hpos[0]=max(0, bb.at(i).hapos);
			ha.exp=bb.at(i).exp_ha;
			ha.type=91;
			ha.name="HA";
			ha.cname="CA";
		}
		ha.cpos=bb.at(i).capos;
		ha.exp_c=bb.at(i).exp_ca;
		ha.id=bb.at(i).id;
		ha.code=bb.at(i).code;

		ha_protons.push_back(ha);
	}
#ifdef BENCHMARK
	clock = omp_get_wtime();
#endif
	traj->getani(&anistropy,&ha_protons,&ani_effect_ha);
#ifdef BENCHMARK
	printf("%.4f getani(proton)\n", omp_get_wtime()-clock);
	clock = omp_get_wtime();
#endif
	traj->getring(&ring_index,&ha_protons,&ring_effect_ha);
#ifdef BENCHMARK
	printf("%.4f getring(proton)\n", omp_get_wtime()-clock);
#endif

	index.resize(pdb->getnres());	
	for(i=0;i<(int)index.size();i++)
		index.at(i).x1=index.at(i).x2=-1;
	for(i=0;i<(int)bb.size();i++)
		index.at(bb.at(i).id-1).x1=i+1;
	for(i=0;i<(int)bbnh.size();i++)
		index.at(bbnh.at(i).id-1).x2=i+1;

	c2 = pdb->getselect(":1-%@allheavy");
#ifdef BENCHMARK
	clock = omp_get_wtime();
#endif
	traj->get_contacts(bb,index,c2,&result);
#ifdef BENCHMARK
	printf("%.4f get_contacts\n", omp_get_wtime()-clock);
#endif

	for(i=0+1;i<(int)index.size()-1;i++)
	{
		//cout<<i<<endl;
		if(index.at(i).x1<0)
			continue;
		id=i+1;
		code=pdb->code(id);
		code_pre=pdb->code(id-1);
		code_fol=pdb->code(id+1);
		oneline.clear();

		//sequence information
		//blos62 matrix
		//total 60 terms
		Sequence::code2same(code_pre,buffer);
		for(j=0;j<20;j++)		
		{
			oneline.push_back(buffer[j]);
		}

		code=pdb->code(id);
		Sequence::code2same(code,buffer);
		for(j=0;j<20;j++)		
		{
			oneline.push_back(buffer[j]);
		}

		Sequence::code2same(code_fol,buffer);
		for(j=0;j<20;j++)		
		{
			oneline.push_back(buffer[j]);
		}


		//dihedral angle contribution!
		//total 28 terms
		dihe_process.ca_ann(id); 
		out=dihe_process.output();
		for(j=2;j<26;j++)
		{
			oneline.push_back(out.at(j));
		}
		for(j=28;j<(int)out.size();j++)
		{
			oneline.push_back(out.at(j));
		}


		//hbond effect, 12 terms
		oneline.push_back(hbond_effect.at(id-2).c_length);
		oneline.push_back((hbond_effect.at(id-2).c_phi));
		oneline.push_back((hbond_effect.at(id-2).c_psi));

		


		oneline.push_back(hbond_effect.at(id-1).c_length);
		oneline.push_back(hbond_effect.at(id-1).n_length);
		oneline.push_back((hbond_effect.at(id-1).c_phi));
		oneline.push_back((hbond_effect.at(id-1).c_psi));
		oneline.push_back((hbond_effect.at(id-1).n_phi));
		oneline.push_back((hbond_effect.at(id-1).n_psi));

		oneline.push_back(hbond_effect.at(id).n_length);
		oneline.push_back((hbond_effect.at(id).n_phi));
		oneline.push_back((hbond_effect.at(id).n_psi));


		//contact sum , one term
		//c1.clear();
		//c1.push_back(bb.at(index.at(i).x1-1).capos);
		//c1.push_back(bb.at(index.at(i).x1-1).cbpos);
		//c1.push_back(bb.at(index.at(i).x1-1).copos);
		//c2=pdb->getselect(":1-%@allheavy");
		//result.clear();
		//traj->get_contact(c1,c2,&result);

		oneline_co=oneline_cb=oneline;

		oneline.insert(oneline.begin()+60,result.at(i*3));
		oneline_cb.insert(oneline_cb.begin()+60,result.at(i*3+1));
		oneline_co.insert(oneline_co.begin()+60,result.at(i*3+2));
		oneline_n=oneline;
		
		pre[0]=ann_ca.predict_one(oneline);
		pre[1]=ann_cb.predict_one(oneline_cb);
		pre[2]=ann_co.predict_one(oneline_co);
		pre[4]=ann_n.predict_one(oneline_n);
		
		//hn
		if(index.at(i).x2>0)
		{
			oneline_h=oneline;
			for(j=0;j<5;j++)
				oneline_h.push_back(ring_effect.at(index.at(i).x2-1).x[j]);
			for(j=0;j<4;j++)
				oneline_h.push_back(ani_effect.at(index.at(i).x2-1).x[j]);	
			pre[3]=ann_h.predict_one(oneline_h);
		}
		else
			pre[3]=-999.0;
	

		//ha 
		oneline_ha=oneline;
		for(j=0;j<5;j++)
			oneline_ha.push_back(ring_effect_ha.at(index.at(i).x1-1).x[j]);
		for(j=0;j<4;j++)
			oneline_ha.push_back(ani_effect_ha.at(index.at(i).x1-1).x[j]);
		pre[5]=ann_ha.predict_one(oneline_ha);

		pdb->attach_bbprediction(id,pre);
	}

	cal_error();
};


void CMainbody::predict_bb_static_new()
{
	int i,j,jj;
	int id;
	int jump;
	char code,code_pre,code_fol;
	vector<double> out;
	vector<double> in,in2;
	vector<struct double_five> ring_effect,ring_effect_ha;
	vector<struct ehbond> hbond_effect;
	vector<struct double_four> ani_effect,ani_effect_ha;
	vector<struct index_two> index;
	vector<int> c1,c2;
	vector<float> result;
	double pre[6];
	double temp,temp1,temp2,tt1,tt2;
	vector<double> eca,ecb,eco,eh,en;
	double rc;
	double vhill;
	


	traj->gethbond(&hbond,&hbond_effect);
	traj->getani(&anistropy,&bbnh,&ani_effect);
	traj->getring(&ring_index,&bbnh,&ring_effect);



	

	vector<struct proton> ha_protons;
	struct proton ha;
	for(i=0;i<(int)bb.size();i++)
	{
		
		if(bb.at(i).code=='G')
		{
			ha.nh=2;
			ha.hpos[0]=bb.at(i).hapos;
			ha.hpos[1]=bb.at(i).hapos2;
			ha.exp=(bb.at(i).exp_ha+bb.at(i).exp_ha2)/2.0;
			ha.exp1=bb.at(i).exp_ha;
			ha.exp2=bb.at(i).exp_ha2;
			ha.type=90;
			ha.name="HB2";
			ha.name2="HB3";
			ha.cname="CA";
			ha.cname2="CA";
		}
		else
		{
			ha.nh=1;
			ha.hpos[0]=bb.at(i).hapos;
			ha.exp=bb.at(i).exp_ha;
			ha.type=91;
			ha.name="HA";
			ha.cname="CA";
		}
		ha.cpos=bb.at(i).capos;
		ha.exp_c=bb.at(i).exp_ca;
		ha.id=bb.at(i).id;
		ha.code=bb.at(i).code;

		ha_protons.push_back(ha);
	}
	traj->getani(&anistropy,&ha_protons,&ani_effect_ha);
	traj->getring(&ring_index,&ha_protons,&ring_effect_ha);




	index.resize(pdb->getnres());	
	for(i=0;i<(int)index.size();i++)
		index.at(i).x1=index.at(i).x2=-1;
	for(i=0;i<(int)bb.size();i++)
		index.at(bb.at(i).id-1).x1=i+1;
	for(i=0;i<(int)bbnh.size();i++)
		index.at(bbnh.at(i).id-1).x2=i+1;
	

	for(i=0+1;i<(int)index.size()-1;i++)
	{
		//cout<<i<<endl;
		if(index.at(i).x1<0)
			continue;
		id=i+1;
		code=pdb->code(id);
		code_pre=pdb->code(id-1);
		code_fol=pdb->code(id+1);

		for(jj=0;jj<6;jj++)
			pre[jj]=0.0;
		jump=0;

		//ca=cb=co=h=n=0.0;

		//missing or unknow residue shouldn't be predicted. This is also true if either previous or following residue is missing (or unknown)
		if(code_pre=='X' || code_pre=='B' || code_fol=='X' || code_fol=='B'|| code=='X' || code=='B')
		{
			for(jj=0;jj<6;jj++)
				pre[jj]=-999.0;
			continue;
		}

		//sequence information
		Sequence::code2array(code_pre,buffer);
		for(j=0;j<20;j++)		
		{
			for(jj=0;jj<6;jj++)
				pre[jj]+=static_c[jj][j+jump]*buffer[j];
		}
		jump+=20;
		
		code=pdb->code(id);
		Sequence::code2array(code,buffer);
		for(j=0;j<20;j++)		
		{
			for(jj=0;jj<6;jj++)
				pre[jj]+=static_c[jj][j+jump]*buffer[j];
		}
		jump+=20;

		Sequence::code2array(code_fol,buffer);
		for(j=0;j<20;j++)		
		{
			for(jj=0;jj<6;jj++)
				pre[jj]+=static_c[jj][j+jump]*buffer[j];
		}
		jump+=20;



		//dihedral angle contribution!
		if(dihe_process.ca_static_new(id)==0) //==0 means missing dihedral angles in this calculation !!
		{
			for(jj=0;jj<6;jj++)
				pre[jj]=-999.0;
			continue;
		}

		out=dihe_process.output();

		//pre dihe  12*20 terms
		in.clear();
		for(j=0;j<12;j++)
		{
			in.push_back(out.at(j));
		}
		in2=Sequence::expand(code_pre,&in);
		for(j=0;j<(int)in2.size();j++)
		{
			for(jj=0;jj<6;jj++)
				pre[jj]+=static_c[jj][j+jump]*in2.at(j);
		}
		jump+=240;


		//self dihe 24*20 terms
		in.clear();
		for(j=0;j<24;j++)
		{
			in.push_back(out.at(j+12));
		}
		in2=Sequence::expand(code,&in);
		for(j=0;j<(int)in2.size();j++)
		{
			for(jj=0;jj<6;jj++)
				pre[jj]+=static_c[jj][j+jump]*in2.at(j);
		}
		jump+=480;
		
		//follow dihe  12*20 terms
		in.clear();
		for(j=0;j<12;j++)
		{
			in.push_back(out.at(j+36));
		}
		in2=Sequence::expand(code_fol,&in);
		for(j=0;j<(int)in2.size();j++)
		{
			for(jj=0;jj<6;jj++)
				pre[jj]+=static_c[jj][j+jump]*in2.at(j);
		}
		jump+=240;
		
	
		//hbond effect, length only
		for(jj=0;jj<6;jj++)
		{	
			tt1=temp1=hbond_effect.at(id-1).c_length;
			tt2=temp2=hbond_effect.at(id-1).n_length;
			pre[jj]+=static_c[jj][jump+0]*temp1;
			pre[jj]+=static_c[jj][jump+1]*temp2;

			temp1*=temp1;temp2*=temp2;
			pre[jj]+=static_c[jj][jump+2]*temp1;
			pre[jj]+=static_c[jj][jump+3]*temp2;

			pre[jj]+=static_c[jj][jump+4]*temp1*tt1;
			pre[jj]+=static_c[jj][jump+5]*temp2*tt2;

			temp1*=temp1;temp2*=temp2;
			pre[jj]+=static_c[jj][jump+6]*temp1;
			pre[jj]+=static_c[jj][jump+7]*temp2;
		}
		jump+=8;

						
		if(index.at(i).x2>0)
		{
			temp=0.0;
			for(j=0;j<5;j++)
				temp+=ring_effect.at(index.at(i).x2-1).x[j]*static_h[0][j];
			for(j=0;j<4;j++)
				temp+=ani_effect.at(index.at(i).x2-1).x[j]*static_h[0][j+5];
			pre[3]+=temp;
		}

		temp=0.0;
		for(j=0;j<5;j++)
			temp+=ring_effect_ha.at(index.at(i).x1-1).x[j]*static_h[1][j];
		for(j=0;j<4;j++)
			temp+=ani_effect_ha.at(index.at(i).x1-1).x[j]*static_h[1][j+5];
		pre[5]+=temp;


		//get contact sum adjustment
		c1.clear();
		c1.push_back(bb.at(index.at(i).x1-1).capos);
		c1.push_back(bb.at(index.at(i).x1-1).cbpos);
		c1.push_back(bb.at(index.at(i).x1-1).copos);
		c2=pdb->getselect(":1-%@allheavy");
		result.clear();
		traj->get_contact(c1,c2,&result);
		result.push_back(result.at(0));
		result.push_back(result.at(0));
		result.push_back(result.at(0));

		for(jj=0;jj<6;jj++)
		{
			vhill=hill(result.at(jj),hill_para[jj][0],hill_para[jj][1]);
			rc=(1-vhill)/vhill;
			pre[jj]+=rc*static_c[jj][Sequence::code2pos(code)+jump];
			pre[jj]*=vhill;
		}
		
		pdb->attach_bbprediction(id,pre);
	}
	
	cal_error();

}


void CMainbody::cal_error()
{
	int j;
	vector< vector<double> > cas,cbs,cos,hs,ns,has;
	double e,t,w;


	cas.resize(2);cbs.resize(2);cos.resize(2);hs.resize(2);ns.resize(2);has.resize(2);
	bb.clear();
	pdb->getbb(&bb);
	bb=clear(bb);
	for(j=0;j<(int)bb.size();j++)
	{
		cas.at(0).push_back(bb.at(j).exp_ca);
		cbs.at(0).push_back(bb.at(j).exp_cb);
		cos.at(0).push_back(bb.at(j).exp_co);
		hs.at(0).push_back(bb.at(j).exp_h);
		ns.at(0).push_back(bb.at(j).exp_n);
		has.at(0).push_back(bb.at(j).exp_ha);
	
		cas.at(1).push_back(bb.at(j).pre_ca);
		cbs.at(1).push_back(bb.at(j).pre_cb);
		cos.at(1).push_back(bb.at(j).pre_c);
		hs.at(1).push_back(bb.at(j).pre_h);
		ns.at(1).push_back(bb.at(j).pre_n);
		has.at(1).push_back(bb.at(j).pre_ha);

	}
	compare("CA",cas);compare("CB",cbs);compare("C'",cos);compare("HN",hs);compare("N",ns);compare("HA",has);


	FILE *fp=fopen("cs_rmsd.dat","wt");

	for(j=0;j<(int)bb.size();j++)
	{
		e=0;
		w=0;
		if(fabs(bb.at(j).exp_ca)<490.0 && fabs(bb.at(j).pre_ca)<490.0)
		{
			t=bb.at(j).exp_ca-bb.at(j).pre_ca;
			e+=t*t;
			w+=1.0;
		}
		if(fabs(bb.at(j).exp_cb)<490.0 && fabs(bb.at(j).pre_cb)<490.0)
		{
			t=bb.at(j).exp_cb-bb.at(j).pre_cb;
			e+=t*t;
			w+=1.0;
		}
		if(fabs(bb.at(j).exp_co)<490.0 && fabs(bb.at(j).pre_c)<490.0)
		{
			t=bb.at(j).exp_co-bb.at(j).pre_c;
			e+=t*t;
			w+=1.0;
		}
		if(fabs(bb.at(j).exp_h)<490.0 && fabs(bb.at(j).pre_h)<490.0)
		{
			t=bb.at(j).exp_h-bb.at(j).pre_h;
			e+=t*t*4;
			w+=4.0;
		}
		if(fabs(bb.at(j).exp_n)<490.0 && fabs(bb.at(j).pre_n)<490.0)
		{
			t=bb.at(j).exp_n-bb.at(j).pre_n;
			e+=t*t*0.4;
			w+=0.4;
		}
		if(fabs(bb.at(j).exp_ha)<490.0 && fabs(bb.at(j).pre_ha)<490.0)
		{
			t=bb.at(j).exp_ha-bb.at(j).pre_ha;
			e+=t*t*4;
			w+=4;
		}
		if(w>0.0)
		{
			e=sqrt(e/w);
			fprintf(fp,"%10d%10s%10.2f\n",bb.at(j).id0,Sequence::code2name(bb.at(j).code).c_str(),e);
		}
		else
			e=0.0;

	}		
	fclose(fp);		

}


double CMainbody::hill(double contact, double v1, double v2)
{
	double hill;
	
	if(contact<v1)	
		hill=0.0;
	else if(contact>v2)
		hill=1.0;
	else
	{
		hill=(contact-v1)/(v2-v1)*6-3;
		hill=(1-exp(-2*hill))/(1+exp(-2*hill));
		hill=hill/2+0.5;
	}

	return hill;

}


void CMainbody::predict_bb2()
{
	int i,j,j2,jj,n;
	int id;
	char code;
	vector< vector<double> > out;
	vector<double> in,in2;
	vector< vector<struct double_five> > ring_effect;
	vector< vector<struct ehbond> > hbond_effect;
	vector< vector<struct double_four> > ani_effect;
	vector<struct index_two> index;
	vector<double> cs_ca,cs_cb,cs_c,cs_h,cs_n;
	double pre[6];
	double temp;
	vector<double> eca,ecb,eco,eh,en;
	char name[4];
	FILE *fp;

	fp=fopen("bb_details.dat","w");
	


	traj->gethbond(&hbond,&hbond_effect);
	traj->getani(&anistropy,&bbnh,&ani_effect);
	traj->getring(&ring_index,&bbnh,&ring_effect);

	

	index.resize(pdb->getnres());	
	for(i=0;i<(int)index.size();i++)
		index.at(i).x1=index.at(i).x2=-1;
	for(i=0;i<(int)bb.size();i++)
		index.at(bb.at(i).id-1).x1=i+1;
	for(i=0;i<(int)bbnh.size();i++)
		index.at(bbnh.at(i).id-1).x2=i+1;


	

	for(i=0+1;i<(int)index.size()-1;i++)
	{	//cout<<"i is "<<i<<endl;
		if(index.at(i).x1<0)
			continue;
		id=i+1;
		code=pdb->code(id);
		pdb->name(id,name);

		if(strcmp(name,"CYS")==0)
			continue;

		dihe_process.ca2(id); 
		out=dihe_process.output2();

		cs_ca.clear();
		cs_cb.clear();
		cs_c.clear();
		cs_h.clear();
		cs_n.clear();

		for(n=0;n<nconf;n++)
		{		
			id=i+1;
			code=pdb->code(id);

			for(jj=0;jj<5;jj++)
				pre[jj]=0.0;
	 
			for(j=0;j<30;j++)
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j]*out.at(j).at(n);
			}

			for(j=42;j<60;j++)
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j-12]*out.at(j).at(n);
			}
				

			in.clear();
			for(j=0;j<12;j++)
			{
				in.push_back(out.at(j+30).at(n));
			}
			in2=Sequence::expand(code,&in);


			for(j=0;j<(int)in2.size();j++)
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j+48]*in2.at(j);
			}
			
		
			for(jj=0;jj<5;jj++)
			{
				for(j=-2;j<=0;j++)
				{
					j2=(j+2)*6;
					pre[jj]+=c_c[jj][288+j2]*hbond_effect.at(id+j).at(n).c_length;
					pre[jj]+=c_c[jj][289+j2]*hbond_effect.at(id+j).at(n).c_phi;
					pre[jj]+=c_c[jj][290+j2]*hbond_effect.at(id+j).at(n).c_psi;
					pre[jj]+=c_c[jj][291+j2]*hbond_effect.at(id+j).at(n).n_length;
					pre[jj]+=c_c[jj][292+j2]*hbond_effect.at(id+j).at(n).n_phi;
					pre[jj]+=c_c[jj][293+j2]*hbond_effect.at(id+j).at(n).n_psi;
				}
			}

			//sequence information
			code=pdb->code(id-1);
			Sequence::code2array(code,buffer);
			for(j=0;j<20;j++)		
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j+306]*buffer[j];
			}

			code=pdb->code(id);
			Sequence::code2array(code,buffer);
			for(j=0;j<20;j++)		
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j+326]*buffer[j];
			}

			code=pdb->code(id+1);
			Sequence::code2array(code,buffer);
			for(j=0;j<20;j++)		
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j+346]*buffer[j];
			}


			if(index.at(i).x2>0)
			{
				temp=0.0;
				for(j=0;j<5;j++)
					temp+=ring_effect.at(index.at(i).x2-1).at(n).x[j];
				temp*=c_h_add[4];
				for(j=0;j<4;j++)
					temp+=ani_effect.at(index.at(i).x2-1).at(n).x[j]*c_h_add[j];
				pre[3]+=temp;
			}

			cs_ca.push_back(pre[0]);
			cs_cb.push_back(pre[1]);
			cs_c.push_back(pre[2]);
			cs_n.push_back(pre[4]);
			cs_h.push_back(pre[3]);
		}
	
		fprintf(fp,"%8d%8s",id,name);
		fprintf(fp,"   CA   ");
		fprintf(fp,"%8.3f",bb.at(index.at(i).x1-1).exp_ca);
		for(n=0;n<nconf;n++)
				fprintf(fp,"%8.3f",cs_ca.at(n));

		fprintf(fp,"\n%8d%8s",id,name);
		fprintf(fp,"   CB   ");
		fprintf(fp,"%8.3f",bb.at(index.at(i).x1-1).exp_cb);
		for(n=0;n<nconf;n++)
				fprintf(fp,"%8.3f",cs_cb.at(n));

		fprintf(fp,"\n%8d%8s",id,name);
		fprintf(fp,"   C    ");	
		fprintf(fp,"%8.3f",bb.at(index.at(i).x1-1).exp_co);
		for(n=0;n<nconf;n++)
				fprintf(fp,"%8.3f",cs_c.at(n));

		fprintf(fp,"\n%8d%8s",id,name);
		fprintf(fp,"   H    ");
		if(index.at(i).x2>1)
			fprintf(fp,"%8.3f",bbnh.at(index.at(i).x2-1).exp_h);
		else
			fprintf(fp,"%8.3f",999.0);
		for(n=0;n<nconf;n++)
				fprintf(fp,"%8.3f",cs_h.at(n));

		fprintf(fp,"\n%8d%8s",id,name);
		fprintf(fp,"   N    ");
		if(index.at(i).x2>1)
			fprintf(fp,"%8.3f",bbnh.at(index.at(i).x2-1).exp_n);
		else
			fprintf(fp,"%8.3f",999.0);
		for(n=0;n<nconf;n++)
				fprintf(fp,"%8.3f",cs_n.at(n));
		fprintf(fp,"\n");


		for(n=0;n<5;n++)
			pre[n]=0;
		for(n=0;n<nconf;n++)
		{
			pre[0]+=cs_ca.at(n);
			pre[1]+=cs_cb.at(n);
			pre[2]+=cs_c.at(n);
			pre[3]+=cs_h.at(n);
			pre[4]+=cs_n.at(n);
		}
		for(n=0;n<5;n++)
			pre[n]/=nconf;
		pre[5]=999.0;
		pdb->attach_bbprediction(id,pre);
	}
	return;
}






void CMainbody::predict_proton()
{
	int i,j;
	int id;
	char code;
	int type;

	double c_ring[5]={-0.1939,-0.1629,-0.1620,-0.1872,-0.1987};
	double c_ani[4]={0.004478932,0.000925861,0.001692256,0.00040848288};
	double c_rand[10]={1.3876,1.2671,2.0763,0.0000,1.0064,0.9611,0.9102,0.8890,0.9976,0.8584};

	
	double cs_ring,cs_ani,cs_rand,cs;


	vector< vector<double> > hs;
	hs.resize(2);


	vector<struct double_five> ring_effect;
	vector<struct double_four> ani_effect;

	traj->getani(&anistropy,&protons,&ani_effect);
	traj->getring(&ring_index,&protons,&ring_effect);
		


	for(i=0;i<(int)protons.size();i++)
	{	
		id=protons.at(i).id;
		code=protons.at(i).code;	
		type=protons.at(i).type;


		cs_ring=0;
		for(j=0;j<5;j++)
			cs_ring+=ring_effect.at(i).x[j]*c_ring[j];

		cs_ani=0;
		for(j=0;j<4;j++)
			cs_ani+=ani_effect.at(i).x[j]*c_ani[j];
		cs_rand=c_rand[type-1];
		cs=cs_ring+cs_ani+cs_rand;
		pdb->attach_protonprediction(id,protons.at(i).name,cs);

		hs.at(0).push_back(protons.at(i).exp);
		hs.at(1).push_back(cs);
	}

	compare("Methyl 1H",hs);
	return;
}

void CMainbody::predict_proton2()
{
	int i,j,ii;
	int id;
	char code;
	int type;
	double cs_rand;
	vector<double> cs_ring,cs_ani,cs;
	double ccs_ring,ccs_ani,ccs;
	FILE *fp;

	fp=fopen("proton_details.dat","w");

	double c_ring[5]={-0.1939,-0.1629,-0.1620,-0.1872,-0.1987};
	double c_ani[4]={0.004478932,0.000925861,0.001692256,0.00040848288};
	double c_rand[10]={1.3876,1.2671,2.0763,0.0000,1.0064,0.9611,0.9102,0.8890,0.9976,0.8584};

	vector< vector<struct double_five> > ring_effect;
	vector< vector<struct double_four> > ani_effect;
	traj->getani(&anistropy,&protons,&ani_effect);
	traj->getring(&ring_index,&protons,&ring_effect);

	for(i=0;i<(int)protons.size();i++)
	{	
		id=protons.at(i).id;
		code=protons.at(i).code;	
		type=protons.at(i).type;

		for(ii=0;ii<nconf;ii++)
		{
			cs_ring.push_back(0.0);
			cs_ani.push_back(0.0);
			cs.push_back(0.0);
		}
		for(ii=0;ii<nconf;ii++)
		{
			cs_ring[ii]=0;
			for(j=0;j<5;j++)
				cs_ring[ii]+=ring_effect.at(i).at(ii).x[j]*c_ring[j];
			cs_ani[ii]=0;
			for(j=0;j<4;j++)
				cs_ani[ii]+=ani_effect.at(i).at(ii).x[j]*c_ani[j];
			cs_rand=c_rand[type-1];
			cs[ii]=cs_ring[ii]+cs_ani[ii]+cs_rand;
		}
		fprintf(fp,"%8d %8s %8s",id,Sequence::code2name(code).c_str(),protons.at(i).name.c_str());
		if(fabs(protons.at(i).exp)>0.00001)
			fprintf(fp," %8.3f",protons.at(i).exp);
		else
			fprintf(fp," %8.3f",999.9);
		for(ii=0;ii<nconf;ii++)
			fprintf(fp," %8.3f",cs[ii]);
		fprintf(fp,"\n");


		ccs=ccs_ring=ccs_ani=0.0;
		for(ii=0;ii<nconf;ii++)
		{	
			ccs+=cs[ii];
			ccs_ring+=cs_ring[ii];
			ccs_ani+=cs_ani[ii];
		}
		ccs/=nconf;
		ccs_ring/=nconf;
		ccs_ani/=nconf;
		pdb->attach_protonprediction(id,protons.at(i).name,ccs);
	}
	fclose(fp);
	return;
}


void CMainbody::predict_proton_static_new(void)
{
	int i,j;
	int id;
	int type;
	vector<double> out;
	int jump;
	float pre;
	double *c;
	vector< vector<double> > hs;
	double clock;



	vector<struct double_five> ring_effect;
	vector<struct double_four> ani_effect;
	
	
	allprotons=allprotons3;
	clock = omp_get_wtime();
	traj->getani(&anistropy,&allprotons,&ani_effect);
	printf("%.4f getani(proton)\n", omp_get_wtime()-clock);
	clock = omp_get_wtime();
	traj->getring(&ring_index,&allprotons,&ring_effect);
	printf("%.4f getani(proton)\n", omp_get_wtime()-clock);

	hs.resize(2);

	
		
	for(i=0;i<(int)allprotons.size();i++)
	{		
		type=allprotons.at(i).type;
		id=allprotons.at(i).id;
		
		//too few data point and bad fitting !
		if(type==18 || type==19 || type==28 || type==49 || type==64  || type==82  || type==84  || type==97 )
			continue;
		//bad fitting !
		if(type==36 || type==48 || type==62 )
			continue;

		//use gobal or individual fitting?
		if(sep_table[type]>=0)
			c=c_sep[type-1];
		else
			c=c_all;

		jump=0;
		pre=c[type-1];
		jump+=98;

		for(j=0;j<5;j++)
			pre+=ring_effect.at(i).x[j]*c[j+jump];
		jump+=5;

		for(j=0;j<4;j++)
			pre+=ani_effect.at(i).x[j]*c[j+jump];
		jump+=4;

		dihe_process.allproton(allprotons.at(i).id); 
		dihe_process.hb_expand(type);
		out=dihe_process.output();
		for(j=0;j<8*18;j++)
			pre+=out.at(j)*c[j+jump];
		jump+=8*18;

		pdb->attach_protonprediction(id,allprotons.at(i).name,pre);
		if(allprotons.at(i).name2!="")
			pdb->attach_protonprediction(id,allprotons.at(i).name2,pre);

		hs.at(0).push_back(allprotons.at(i).exp);
		hs.at(1).push_back(pre);
	}
	compare("Side chain protons",hs);
	return;
}



void CMainbody::compare(char * buff, vector< vector<double> > t)
{
	int i,j,n;
	double e,ee;
	bool b;
	vector<bool> bs;

	for(i=0;i<(int)t.at(0).size();i++)
	{
		b=0;
		for(j=0;j<(int)t.size();j++)
		{
			if(t.at(j).at(i)<-400.0 || t.at(j).at(i)>400.0 )
				b=1;
		}
		bs.push_back(b);
		
	}

	cout<<buff<<": ";
	for(i=1;i<(int)t.size();i++)
	{
		ee=0;
		n=0;
		for(j=0;j<(int)t.at(0).size();j++)
		{
			if(bs.at(j)==0)
			{
				e=t.at(0).at(j)-t.at(i).at(j);
				ee+=e*e;
				n++;
			}
		}
		if(n>0)
		{
			ee/=n;
			ee=sqrt(ee);
			cout<<" "<<ee;
		}
		else
			cout<<" N.A.";
	}
	cout<<endl;
}

//This file include all trained parameters in PPM.
#include "data.h"

########## NEXT FILE ##########
main.cpp:::
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// custom user modules 

#include "./custom_modules/cancer_immune_3D.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }
	
	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// PNRG setup 
	SeedRandom(); 
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); 

	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	create_cell_types();
	setup_tissue();
	
	/* Users typically start modifying here. START USERMODS */ 

	double immune_activation_time = 
		parameters.doubles("immune_activation_time"); // 60 * 24 * 14; // activate immune response at 14 days 
	
	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );
	
	// save a simulation snapshot 

	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = cancer_immune_coloring_function;
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	display_citations(); 
	
	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}

	//set the diffusion solver to GPU
	microenvironment.diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_3D_GPU;
	bool first = true;
	
	int outs = 0;

	// main loop 
	
	try 
	{	
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			if (outs == 1){
				microenvironment.translate_array_to_vector();
				sprintf( filename , "%s/first_out" , PhysiCell_settings.folder.c_str() ); 
				save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
			}


			static bool immune_cells_introduced = false; 
			if( PhysiCell_globals.current_time > immune_activation_time - 0.01*diffusion_dt && immune_cells_introduced == false )
			{
				std::cout << "Therapy activated!" << std::endl << std::endl; 
				immune_cells_introduced = true; 
				
				PhysiCell_settings.full_save_interval = 
					parameters.doubles("save_interval_after_therapy_start"); // 3.0; 
				PhysiCell_settings.SVG_save_interval = 
					parameters.doubles("save_interval_after_therapy_start"); // 3.0; 
				
				PhysiCell_globals.next_full_save_time = PhysiCell_globals.current_time; 
				PhysiCell_globals.next_SVG_save_time = PhysiCell_globals.current_time; 
				
				introduce_immune_cells();
			} 

			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				// translate data back to vector and update host
				if (first == false){
					std::cout << "updating host" << std::endl;
					microenvironment.translate_array_to_vector();
					std::cout << "-------continuing-------" << std::endl;
				}
				first = false;
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				std::cout << "2" << std::endl;
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
			}
			
			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			// if( default_microenvironment_options.calculate_gradients )
			// { microenvironment.compute_all_gradient_vectors(); }
			
			// run PhysiCell 
			// ((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			
			// manually call the code for cell sources and sinks, 
			// since these are ordinarily automatically done as part of phenotype.secretion in the 
			// PhysiCell update that we commented out above. Remove this when we go 
			// back to main code 
/*			
			#pragma omp parallel for 
			for( int i=0; i < (*all_cells).size(); i++ )
			{
				(*all_cells)[i]->phenotype.secretion.advance( (*all_cells)[i], (*all_cells)[i]->phenotype , diffusion_dt );
			}			
*/			
			PhysiCell_globals.current_time += diffusion_dt;
			outs++;
		}
		
		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	microenvironment.translate_array_to_vector();

	std::cout << "NUM_DIRICHLET " << microenvironment.num_dirichlet << std::endl;
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );

	return 0; 
}

########## NEXT FILE ##########
BioFVM_mesh.cpp:::
/*
#############################################################################
# If you use BioFVM in your project, please cite BioFVM and the version     #
# number, such as below:                                                    #
#                                                                           #
# We solved the diffusion equations using BioFVM (Version 1.1.7) [1]        #
#                                                                           #
# [1] A. Ghaffarizadeh, S.H. Friedman, and P. Macklin, BioFVM: an efficient #
#    parallelized diffusive transport solver for 3-D biological simulations,#
#    Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730 #
#                                                                           #
#############################################################################
#                                                                           #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)   #
#                                                                           #
# Copyright (c) 2015-2017, Paul Macklin and the BioFVM Project              #
# All rights reserved.                                                      #
#                                                                           #
# Redistribution and use in source and binary forms, with or without        #
# modification, are permitted provided that the following conditions are    #
# met:                                                                      #
#                                                                           #
# 1. Redistributions of source code must retain the above copyright notice, #
# this list of conditions and the following disclaimer.                     #
#                                                                           #
# 2. Redistributions in binary form must reproduce the above copyright      #
# notice, this list of conditions and the following disclaimer in the       #
# documentation and/or other materials provided with the distribution.      #
#                                                                           #
# 3. Neither the name of the copyright holder nor the names of its          #
# contributors may be used to endorse or promote products derived from this #
# software without specific prior written permission.                       #
#                                                                           #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS       #
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED #
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A           #
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER #
# OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  #
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,       #
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR        #
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF    #
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING      #
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS        #
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.              #
#                                                                           #
#############################################################################
*/

#include "BioFVM_vector.h" 
#include "BioFVM_mesh.h" 

namespace BioFVM{
	
/* voxels */
const int mesh_min_x_index=0;
const int mesh_min_y_index=1;
const int mesh_min_z_index=2;
const int mesh_max_x_index=3;
const int mesh_max_y_index=4;
const int mesh_max_z_index=5;	
Voxel::Voxel()
{
	mesh_index = 0; 
	volume = 10*10*10;
	center.assign( 3 , 0.0 ); 
	is_Dirichlet = false;
}

std::ostream& operator<<(std::ostream& os, const Voxel& v)  
{
	static std::string tabbing = "\t\t\t\t"; 
	static std::string tabbing2 = "\t\t\t\t\t"; 
	os	<< tabbing << "<voxel ID=\"" << v.mesh_index << "\">"  << std::endl
		<< tabbing2 << "<center " << v.center << " />" << std::endl  
		<< tabbing2 << "<volume>" << v.volume << "</volume>" << std::endl  
		<< tabbing  << "</voxel>"; 

 return os; 
}

void Voxel::stream_output_with_units( std::ostream& os , std::string units ) const 
{
	static std::string tabbing = "\t\t\t\t"; 
	static std::string tabbing2 = "\t\t\t\t\t"; 
	os	<< tabbing << "<voxel ID=\"" << mesh_index << "\">"  << std::endl
		<< tabbing2 << "<center " << center << " units=\"" << units << "\" />" << std::endl 
		<< tabbing2 << "<volume units=\"cubic " << units << "\">" << volume << "</volume>" << std::endl
		<< tabbing  << "</voxel>"; 
	return; 
}

/* voxel faces */ 

Voxel_Face::Voxel_Face()
{
	mesh_index = 0;  
	
	surface_area = 10*10; 
	center.assign( 3 , 0.0  ); 
	outward_normal.assign( 3 , 0.0 ); 
	inward_normal.assign( 3 , 0.0 ); 
}

std::ostream& operator<<(std::ostream& os, const Voxel_Face& vf)  
{
	static std::string tabbing = "\t\t\t\t"; 
	static std::string tabbing2 = "\t\t\t\t\t"; 
	os	<< tabbing << "<voxel_face ID=\"" << vf.mesh_index << "\">"  << std::endl
		<< tabbing2 << "<center " << vf.center << " />" << std::endl  
		<< tabbing2 << "<outward_normal " << vf.outward_normal << " />" << std::endl  
		<< tabbing2 << "<inward_normal " << vf.inward_normal << " />" << std::endl  
		<< tabbing2 << "<surface_area>" << vf.surface_area << "</surface_area>" << std::endl  
		<< tabbing  << "</voxel_face>"; 

 return os; 
}

void Voxel_Face::stream_output_with_units( std::ostream& os , std::string units ) const
{
	static std::string tabbing = "\t\t\t\t"; 
	static std::string tabbing2 = "\t\t\t\t\t"; 
	os	<< tabbing << "<voxel_face ID=\"" << mesh_index << "\">"  << std::endl
		<< tabbing2 << "<center units=\"" << units << "\" " << center << " />" << std::endl  
		<< tabbing2 << "<outward_normal units=\"" << units << "\" " << outward_normal << " />" << std::endl  
		<< tabbing2 << "<inward_normal units=\"" << units << "\" " << inward_normal << " />" << std::endl  
		<< tabbing2 << "<surface_area units=\"square " << units << "\">" << surface_area << "</surface_area>" << std::endl  
		<< tabbing  << "</voxel_face>"; 
}

/* general meshes */ 

General_Mesh::General_Mesh()
{
	// x1, x2, y1, y2, z1, z2 
	bounding_box.assign(6,0.0); 
	bounding_box[mesh_min_x_index] = -0.5; 
	bounding_box[mesh_min_y_index] = -0.5; 
	bounding_box[mesh_min_z_index] = -0.5; 
	bounding_box[mesh_max_x_index] = 0.5; 
	bounding_box[mesh_max_y_index] = 0.5; 
	bounding_box[mesh_max_z_index] = 0.5; 
	
	voxels.resize( 1 );  
	voxel_faces.resize( 0 ); 
	
	connected_voxel_indices.resize( 1 ); 
	connected_voxel_indices[0].clear(); 

	// voxel_face_index_mapping.clear();
	
	Cartesian_mesh = false; 
	uniform_mesh = false; 
	regular_mesh = false; 
	use_voxel_faces = true; 	
	units = "none"; 
}
 
std::ostream& operator<<(std::ostream& os, const General_Mesh& mesh)  
{
	std::boolalpha( os ); 
	static std::string tabbing = "\t"; 
	static std::string tabbing2 = "\t\t"; 
	static std::string tabbing3 = "\t\t\t"; 
	os	<< tabbing << "<mesh type=\"general\" uniform=\"" << mesh.uniform_mesh << "\" regular=\"" << mesh.regular_mesh << "\" units=\"" << mesh.units << "\">"  << std::endl
		<< tabbing2 << "<voxels>" << std::endl;
	for( unsigned int i=0; i < mesh.voxels.size() ; i++ )
	{ os << mesh.voxels[i] << std::endl; } 
	os 	<< tabbing2 << "</voxels>" << std::endl 
		<< tabbing2 << "<voxel_faces>" << std::endl;
	for( unsigned int i=0; i < mesh.voxel_faces.size() ; i++ )
	{ os << mesh.voxel_faces[i] << std::endl; } 
	os 	<< tabbing2 << "</voxel_faces>" << std::endl; 
	
	os	<< tabbing2 << "<voxel_connections>" << std::endl;
	for( unsigned int i=0 ; i < mesh.connected_voxel_indices.size() ; i++ )
	{
		os << tabbing3 << "<connected_voxel_indices ID=\"" << i << "\">" << std::endl; 
		for( unsigned int j=0; j < mesh.connected_voxel_indices[i].size() ; j++ )
		{
			os 	<< tabbing3 << "\t<index>" << (mesh.connected_voxel_indices[i])[j] << "</index>" << std::endl; 
		}
		os << tabbing3 << "</connected_voxel_indices>" << std::endl; 
	}
	
	os << tabbing2 << "</voxel_connections>" << std::endl; 
	
	
	os	<< tabbing  << "</mesh>"; 
		
		// later: output information on connected faces 
		
		// later: 

 return os; 
}

bool General_Mesh::is_position_valid(double x, double y, double z)
{
	if(x< bounding_box[mesh_min_x_index] || x>bounding_box[mesh_max_x_index])
		return false;
	if(y< bounding_box[mesh_min_y_index] || y>bounding_box[mesh_max_y_index])
		return false;
	if(z< bounding_box[mesh_min_z_index] || z>bounding_box[mesh_max_z_index])
		return false;
	return true;
}

void General_Mesh::connect_voxels_faces_only(int i,int j, double SA) // done 
{
	// check to see if the voxels are connected -- implement later!

	// create a new Voxel_Face connecting i to j

	Voxel_Face VF1; 
	int k = voxel_faces.size(); 
	VF1.mesh_index = k; 
	VF1.surface_area = SA; 
	VF1.outward_normal = voxels[j].center - voxels[i].center ; 
	normalize( &(VF1.outward_normal) );
	VF1.inward_normal = VF1.outward_normal; 
	VF1.inward_normal *= -1.0; 
	
	// convention: face is oriented from lower index to higher index 
	if( j < i )
	{ VF1.outward_normal *= -1.0; VF1.inward_normal *= -1.0; }

	// add it to the vector of voxel faces 
	
	voxel_faces.push_back( VF1 ); 

	return; 
}

void General_Mesh::connect_voxels_indices_only(int i,int j, double SA) // done
{
	// check to see if the voxels are connected -- implement later!
	
	// add j to the list of connected voxels for voxel i 
	
	connected_voxel_indices[i].push_back( j ); 
	connected_voxel_indices[j].push_back( i ); 

	return;
}

void General_Mesh::connect_voxels(int i,int j, double SA)
{
	// check to see if the voxels are connected -- implement later!

	// create a new Voxel_Face connecting i to j

	Voxel_Face VF1; 
	int k = voxel_faces.size(); 
	VF1.mesh_index = k; 
	VF1.surface_area = SA; 
	VF1.outward_normal = voxels[j].center - voxels[i].center ; 
	normalize( &(VF1.outward_normal) );
	VF1.inward_normal = VF1.outward_normal; 
	VF1.inward_normal *= -1.0; 
	
	// convention: face is oriented from lower index to higher index 
	if( j < i )
	{ VF1.outward_normal *= -1.0; VF1.inward_normal *= -1.0; }

	// add it to the vector of voxel faces 
	
	voxel_faces.push_back( VF1 ); 

	return; 
}

void General_Mesh::display_information( std::ostream& os )
{
	os << std::endl << "Mesh information: " << std::endl 
	<< "type: general mesh" << std::endl 
	<< "Domain: " 
	<< "[" << bounding_box[0] << "," << bounding_box[3] << "] " <<  units << " x " 
	<< "[" << bounding_box[1] << "," << bounding_box[4] << "] " <<  units << " x " 
	<< "[" << bounding_box[2] << "," << bounding_box[5] << "] " <<  units << std::endl
	<< "   voxels: " << voxels.size() << std::endl
	<< "   voxel faces: " << voxel_faces.size() << std::endl
	<< "   volume: "; 

	double total_volume = 0.0; 
	for( unsigned int i=0; i < voxels.size(); i++ )
	{ total_volume += voxels[i].volume; }
	os << total_volume << " cubic " << units << std::endl; 
 
	return; 
}

void General_Mesh::write_to_matlab( std::string filename )
{ 
	unsigned int number_of_data_entries = voxels.size();
	unsigned int size_of_each_datum = 3 + 1; // x,y,z, volume 

	FILE* fp = write_matlab_header( size_of_each_datum, number_of_data_entries,  filename, "mesh" );  

	// storing data as cols 
	for( unsigned int i=0; i < number_of_data_entries ; i++ )
	{
		fwrite( (char*) &( voxels[i].center[0] ) , sizeof(double) , 1 , fp ); 
		fwrite( (char*) &( voxels[i].center[1] ) , sizeof(double) , 1 , fp ); 
		fwrite( (char*) &( voxels[i].center[2] ) , sizeof(double) , 1 , fp ); 
		fwrite( (char*) &( voxels[i].volume ) , sizeof(double) , 1 , fp ); 
	}

	fclose( fp ); 
} 

void General_Mesh::read_from_matlab( std::string filename )
{
	unsigned int size_of_each_datum; 
	unsigned int number_of_data_entries; 
	FILE* fp = read_matlab_header( &size_of_each_datum, &number_of_data_entries,  filename ); 

	voxel_faces.resize( 0 ); 
	
	connected_voxel_indices.resize( 1 ); 
	connected_voxel_indices[0].clear(); 
	
	Cartesian_mesh = false; 
	uniform_mesh = false; 
	regular_mesh = false; 
	use_voxel_faces = false; 

	// resize the internal data structure 

	voxels.resize( number_of_data_entries );
	connected_voxel_indices.resize( voxels.size() ); 
	
	// read in the data
	// assumes each column has: x,y,z, dV
	
	bounding_box[0] = 9e99; 
	bounding_box[1] = 9e99; 
	bounding_box[2] = 9e99; 

	bounding_box[3] = -9e99; 
	bounding_box[4] = -9e99; 
	bounding_box[5] = -9e99; 
 
        size_t result;
	for( unsigned int i=0; i < number_of_data_entries ; i++ )
	{
		result = fread( (char*) &( voxels[i].center[0] ) , sizeof(double) , 1 , fp ); 
		result = fread( (char*) &( voxels[i].center[1] ) , sizeof(double) , 1 , fp ); 
		result = fread( (char*) &( voxels[i].center[2] ) , sizeof(double) , 1 , fp ); 
		result = fread( (char*) &( voxels[i].volume ) , sizeof(double) , 1 , fp ); 
		
		// estimate the bounding box; 
		if( voxels[i].center[0] < bounding_box[0] )
		{ bounding_box[0] = voxels[i].center[0]; }
		if( voxels[i].center[0] > bounding_box[3] )
		{ bounding_box[3] = voxels[i].center[0]; }

		if( voxels[i].center[1] < bounding_box[1] )
		{ bounding_box[1] = voxels[i].center[1]; }
		if( voxels[i].center[1] > bounding_box[4] )
		{ bounding_box[4] = voxels[i].center[1]; }

		if( voxels[i].center[2] < bounding_box[2] )
		{ bounding_box[2] = voxels[i].center[2]; }
		if( voxels[i].center[2] > bounding_box[5] )
		{ bounding_box[5] = voxels[i].center[2]; }
	} 
	
	std::cout << "Warning: General_Mesh::read_from_matlab is incomplete. No connection information read." << std::endl; 

	fclose( fp) ; 
	return; 
}

/* Cartesian meshes */

Cartesian_Mesh::Cartesian_Mesh()
{
	Cartesian_mesh = true; 
	uniform_mesh = true; 
	regular_mesh = true; 
	use_voxel_faces = false; 
	
	x_coordinates.assign( 1 , 0.0 ); 
	y_coordinates.assign( 1 , 0.0 ); 
	z_coordinates.assign( 1 , 0.0 ); 
	
	dx = bounding_box[3] - bounding_box[0]; 
	dy = bounding_box[4] - bounding_box[1]; 
	dz = bounding_box[5] - bounding_box[2]; 
	
	static double tolerance = 1e-12; 
	
	if( fabs( dx - dy ) > tolerance ||
		fabs( dy - dz ) > tolerance ||
		fabs( dx - dz ) > tolerance )
	{ uniform_mesh = false; }
	
	dV = dx*dy*dz; 
	dS = dx*dy; 
	dS_xy = dx*dy; 
	dS_yz = dy*dz; 
	dS_xz = dx*dz; 
	
	Voxel template_voxel;
	template_voxel.volume = dV; 
 
	voxels.assign( x_coordinates.size() * y_coordinates.size() * z_coordinates.size() , template_voxel ); 
	voxels[0].center[0] = x_coordinates[0]; 
	voxels[0].center[1] = y_coordinates[0]; 
	voxels[0].center[2] = z_coordinates[0]; 
}

void Cartesian_Mesh::create_voxel_faces( void )
{
	// make connections 
	
	connected_voxel_indices.resize( voxels.size() ); 
	
	int i_jump = 1; 
	int j_jump = x_coordinates.size(); 
	int k_jump = x_coordinates.size() * y_coordinates.size(); 
		
	// x-aligned connections 
	for( unsigned int k=0 ; k < z_coordinates.size() ; k++ )
	{
		for( unsigned int j=0 ; j < y_coordinates.size() ; j++ )
		{
			for( unsigned int i=0 ; i < x_coordinates.size()-1 ; i++ )
			{
				int n = voxel_index(i,j,k); 
				connect_voxels_faces_only(n,n+i_jump, dS_yz ); 
			}
		}
	}
	// y-aligned connections 
	for( unsigned int k=0 ; k < z_coordinates.size() ; k++ )
	{
		for( unsigned int i=0 ; i < x_coordinates.size() ; i++ )
		{
			for( unsigned int j=0 ; j < y_coordinates.size()-1 ; j++ )
			{
				int n = voxel_index(i,j,k); 
				connect_voxels_faces_only(n,n+j_jump, dS_xz ); 
			}
		}
	}	
	// z-aligned connections 
	for( unsigned int j=0 ; j < y_coordinates.size() ; j++ )
	{
		for( unsigned int i=0 ; i < x_coordinates.size() ; i++ )
		{
			for( unsigned int k=0 ; k < z_coordinates.size()-1 ; k++ )
			{
				int n = voxel_index(i,j,k); 
				connect_voxels_faces_only(n,n+k_jump, dS_xy ); 
			}
		}
	}	

	return; 
}

Cartesian_Mesh::Cartesian_Mesh( int xnodes, int ynodes, int znodes )
{
	x_coordinates.assign( xnodes , 0.0 ); 
	y_coordinates.assign( ynodes , 0.0 ); 
	z_coordinates.assign( znodes , 0.0 ); 
	
	dx = 1;
	dy = 1; 
	dz = 1; 
	
	dV = dx*dx*dz; 
	dS = dx*dy; 
	
	dS_xy = dS; 
	dS_yz = dS; 
	dS_xz = dS; 

	uniform_mesh = true; 
	regular_mesh = true; 
	use_voxel_faces = false; 
 
	for( unsigned int i=0; i < x_coordinates.size() ; i++ )
	{ x_coordinates[i] = i*dx; }
	for( unsigned int i=0; i < y_coordinates.size() ; i++ )
	{ y_coordinates[i] = i*dy; }
	for( unsigned int i=0; i < z_coordinates.size() ; i++ )
	{ z_coordinates[i] = i*dz; }	
	
	bounding_box[0] = x_coordinates[0]-dx/2.0; 
	bounding_box[3] = x_coordinates[x_coordinates.size()-1]+dx/2.0; 
	bounding_box[1] = y_coordinates[0]-dy/2.0; 
	bounding_box[4] = y_coordinates[y_coordinates.size()-1]+dy/2.0; 
	bounding_box[2] = z_coordinates[0]-dz/2.0; 
	bounding_box[5] = z_coordinates[z_coordinates.size()-1]+dz/2.0; 
	
	Voxel template_voxel;
	template_voxel.volume = dV; 

	units = "none"; 
	
	voxels.assign( x_coordinates.size() * y_coordinates.size() * z_coordinates.size() , template_voxel ); 

	// initializing and connecting voxels 
 
	int n=0; 
	for( unsigned int k=0 ; k < z_coordinates.size() ; k++ )
	{
		for( unsigned int j=0 ; j < y_coordinates.size() ; j++ )
		{
			for( unsigned int i=0 ; i < x_coordinates.size() ; i++ )
			{
				voxels[n].center[0] = x_coordinates[i]; 
				voxels[n].center[1] = y_coordinates[j]; 
				voxels[n].center[2] = z_coordinates[k]; 
				voxels[n].mesh_index = n; 
				voxels[n].volume = dV; 

				n++; 
			}
		}
	}
	
	// make connections 
	
	connected_voxel_indices.resize( voxels.size() ); 
	
	int i_jump = 1; 
	int j_jump = x_coordinates.size(); 
	int k_jump = x_coordinates.size() * y_coordinates.size(); 
		
	// x-aligned connections 
	for( unsigned int k=0 ; k < z_coordinates.size() ; k++ )
	{
		for( unsigned int j=0 ; j < y_coordinates.size() ; j++ )
		{
			for( unsigned int i=0 ; i < x_coordinates.size()-1 ; i++ )
			{
				int n = voxel_index(i,j,k); 
				connect_voxels_indices_only(n,n+i_jump, dS_yz ); 
			}
		}
	}
	// y-aligned connections 
	for( unsigned int k=0 ; k < z_coordinates.size() ; k++ )
	{
		for( unsigned int i=0 ; i < x_coordinates.size() ; i++ )
		{
			for( unsigned int j=0 ; j < y_coordinates.size()-1 ; j++ )
			{
				int n = voxel_index(i,j,k); 
				connect_voxels_indices_only(n,n+j_jump, dS_xz ); 
			}
		}
	}	
	// z-aligned connections 
	for( unsigned int j=0 ; j < y_coordinates.size() ; j++ )
	{
		for( unsigned int i=0 ; i < x_coordinates.size() ; i++ )
		{
			for( unsigned int k=0 ; k < z_coordinates.size()-1 ; k++ )
			{
				int n = voxel_index(i,j,k); 
				connect_voxels_indices_only(n,n+k_jump, dS_xy ); 
			}
		}
	}	
	
	if( use_voxel_faces )
	{ create_voxel_faces(); }
}	 

void Cartesian_Mesh::create_moore_neighborhood()
{
	moore_connected_voxel_indices.resize( voxels.size() );
	for( unsigned int j=0 ; j < y_coordinates.size() ; j++ )
	{
		for( unsigned int i=0 ; i < x_coordinates.size() ; i++ )
		{
			for( unsigned int k=0 ; k < z_coordinates.size() ; k++ )
			{
				int center_inex = voxel_index(i,j,k); 
				for(int ii=-1;ii<=1;ii++)
					for(int jj=-1;jj<=1;jj++)
						for(int kk=-1;kk<=1;kk++)
							if(i+ii>=0 && i+ii<x_coordinates.size() &&
								j+jj>=0 && j+jj<y_coordinates.size() &&
								k+kk>=0 && k+kk<z_coordinates.size() &&
								!(ii==0 && jj==0 && kk==0))
								{
									int neighbor_index= voxel_index(i+ii,j+jj,k+kk);
									moore_connected_voxel_indices[center_inex].push_back( neighbor_index );
								}
			}
		}
	}
}
#pragma acc routine
unsigned int Cartesian_Mesh::voxel_index( unsigned int i, unsigned int j, unsigned int k )
{
 return ( k*y_coordinates.size() + j )*x_coordinates.size() + i; 
}

std::vector<unsigned int> Cartesian_Mesh::cartesian_indices( unsigned int n )
{
	std::vector<unsigned int> out(3, -1 ); 

	// figure out i; 
	unsigned int XY = x_coordinates.size() * y_coordinates.size();
	out[2] = (unsigned int) floor( n/XY ); 
 
	// figure out j; 
	out[1] = (unsigned int) floor(   (n - out[2]*XY) / x_coordinates.size() );
 
	// figure out k; 
	out[0] = n - x_coordinates.size()*(   out[1] + y_coordinates.size()*out[2] ); 

	return out; 
}

void Cartesian_Mesh::resize( double x_start, double x_end, double y_start, double y_end, double z_start, double z_end , int x_nodes, int y_nodes, int z_nodes )
{
	x_coordinates.assign( x_nodes , 0.0 ); 
	y_coordinates.assign( y_nodes , 0.0 ); 
	z_coordinates.assign( z_nodes , 0.0 ); 

	dx = ( x_end - x_start )/( (double) x_nodes ); 
	if( x_nodes < 2 )
	{ dx = 1; }
	dy = ( y_end - y_start )/( (double) y_nodes ); 
	if( y_nodes < 2 )
	{ dy = 1; }
	dz = ( z_end - z_start )/( (double) z_nodes  ); 
	if( z_nodes < 2 )
	{ dz = 1; }

	uniform_mesh = true; 
	regular_mesh = true; 
	static double tol = 1e-16; 
 
	if( fabs( dx - dy ) > tol && x_nodes > 1 && y_nodes > 1 )
	{ uniform_mesh = false; }
	if( fabs( dy - dz ) > tol && y_nodes > 1 && z_nodes > 1 )
	{ uniform_mesh = false; }
	if( fabs( dx - dz ) > tol && x_nodes > 1 && z_nodes > 1 )
	{ uniform_mesh = false; }

	for( unsigned int i=0; i < x_coordinates.size() ; i++ )
	{ x_coordinates[i] = x_start + (i+0.5)*dx; }
	for( unsigned int i=0; i < y_coordinates.size() ; i++ )
	{ y_coordinates[i] = y_start + (i+0.5)*dy; }
	for( unsigned int i=0; i < z_coordinates.size() ; i++ )
	{ z_coordinates[i] = z_start + (i+0.5)*dz; }

	bounding_box[0] = x_start; 
	bounding_box[3] = x_end; 
	bounding_box[1] = y_start; 
	bounding_box[4] = y_end; 
	bounding_box[2] = z_start; 
	bounding_box[5] = z_end; 

	dV = dx*dy*dz; 
	dS = dx*dy; 
	
	dS_xy = dx*dy; 
	dS_yz = dy*dz; 
	dS_xz = dx*dz; 

	Voxel template_voxel;
	template_voxel.volume = dV; 

	voxels.assign( x_coordinates.size() * y_coordinates.size() * z_coordinates.size() , template_voxel ); 

	int n=0; 
	for( unsigned int k=0 ; k < z_coordinates.size() ; k++ )
	{
		for( unsigned int j=0 ; j < y_coordinates.size() ; j++ )
		{
			for( unsigned int i=0 ; i < x_coordinates.size() ; i++ )
			{
				voxels[n].center[0] = x_coordinates[i]; 
				voxels[n].center[1] = y_coordinates[j]; 
				voxels[n].center[2] = z_coordinates[k]; 
				voxels[n].mesh_index = n; 
				voxels[n].volume = dV; 

				n++; 
			}
		}
	}
	
	// make connections 
	
	connected_voxel_indices.resize( voxels.size() ); 
	voxel_faces.clear(); 
	
	for( unsigned int i=0; i < connected_voxel_indices.size() ; i++ )
	{ connected_voxel_indices[i].clear(); }
	int i_jump = 1; 
	int j_jump = x_coordinates.size(); 
	int k_jump = x_coordinates.size() * y_coordinates.size(); 
	
	// x-aligned connections 
	int count = 0; 
	for( unsigned int k=0 ; k < z_coordinates.size() ; k++ )
	{
		for( unsigned int j=0 ; j < y_coordinates.size() ; j++ )
		{
			for( unsigned int i=0 ; i < x_coordinates.size()-1 ; i++ )
			{
				int n = voxel_index(i,j,k); 
				connect_voxels_indices_only(n,n+i_jump, dS_yz ); 
				count++; 
			}
		}
	}
	// y-aligned connections 
	for( unsigned int k=0 ; k < z_coordinates.size() ; k++ )
	{
		for( unsigned int i=0 ; i < x_coordinates.size() ; i++ )
		{
			for( unsigned int j=0 ; j < y_coordinates.size()-1 ; j++ )
			{
				int n = voxel_index(i,j,k); 
				connect_voxels_indices_only(n,n+j_jump, dS_xz ); 
			}
		}
	}	
	// z-aligned connections 
	for( unsigned int j=0 ; j < y_coordinates.size() ; j++ )
	{
		for( unsigned int i=0 ; i < x_coordinates.size() ; i++ )
		{
			for( unsigned int k=0 ; k < z_coordinates.size()-1 ; k++ )
			{
				int n = voxel_index(i,j,k); 
				connect_voxels_indices_only(n,n+k_jump, dS_xy ); 
			}
		}
	}
	
	if( use_voxel_faces )
	{ create_voxel_faces(); }
	
	create_moore_neighborhood();
	return; 
}

void Cartesian_Mesh::resize( double x_start, double x_end, double y_start, double y_end, double z_start, double z_end , double dx_new, double dy_new , double dz_new )
{
	dx = dx_new;
	dy = dy_new; 
	dz = dz_new; 

	double eps = 1e-16; 
	int x_nodes = (int) ceil( eps + (x_end-x_start)/dx ); 
	int y_nodes = (int) ceil( eps + (y_end-y_start)/dy ); 
	int z_nodes = (int) ceil( eps + (z_end-z_start)/dz ); 

	x_coordinates.assign( x_nodes , 0.0 ); 
	y_coordinates.assign( y_nodes , 0.0 ); 
	z_coordinates.assign( z_nodes , 0.0 ); 

	uniform_mesh = true; 
	regular_mesh = true; 
	double tol = 1e-16; 
	if( fabs( dx - dy ) > tol || fabs( dy - dz ) > tol || fabs( dx - dz ) > tol )
	{ uniform_mesh = false; }

	for( unsigned int i=0; i < x_coordinates.size() ; i++ )
	{ x_coordinates[i] = x_start + (i+0.5)*dx; }
	for( unsigned int i=0; i < y_coordinates.size() ; i++ )
	{ y_coordinates[i] = y_start + (i+0.5)*dy; }
	for( unsigned int i=0; i < z_coordinates.size() ; i++ )
	{ z_coordinates[i] = z_start + (i+0.5)*dz; }

	bounding_box[0] = x_start; 
	bounding_box[3] = x_end; 
	bounding_box[1] = y_start; 
	bounding_box[4] = y_end; 
	bounding_box[2] = z_start; 
	bounding_box[5] = z_end; 

	dV = dx*dy*dz; 
	dS = dx*dy; 

	dS_xy = dx*dy; 
	dS_yz = dy*dz; 
	dS_xz = dx*dz; 
	
	Voxel template_voxel;
	template_voxel.volume = dV; 

	voxels.assign( x_coordinates.size() * y_coordinates.size() * z_coordinates.size() , template_voxel ); 
	
	int n=0; 
	for( unsigned int k=0 ; k < z_coordinates.size() ; k++ )
	{
		for( unsigned int j=0 ; j < y_coordinates.size() ; j++ )
		{
			for( unsigned int i=0 ; i < x_coordinates.size() ; i++ )
			{
				voxels[n].center[0] = x_coordinates[i]; 
				voxels[n].center[1] = y_coordinates[j]; 
				voxels[n].center[2] = z_coordinates[k]; 
				voxels[n].mesh_index = n; 
				voxels[n].volume = dV; 

				n++; 
			}
		}
	}
	
	// make connections 
	
	connected_voxel_indices.resize( voxels.size() ); 
	voxel_faces.clear(); 
	
	for( unsigned int i=0; i < connected_voxel_indices.size() ; i++ )
	{ connected_voxel_indices[i].clear(); }
	
	int i_jump = 1; 
	int j_jump = x_coordinates.size(); 
	int k_jump = x_coordinates.size() * y_coordinates.size(); 
	
	// x-aligned connections 
	int count = 0; 
	for( unsigned int k=0 ; k < z_coordinates.size() ; k++ )
	{
		for( unsigned int j=0 ; j < y_coordinates.size() ; j++ )
		{
			for( unsigned int i=0 ; i < x_coordinates.size()-1 ; i++ )
			{
				int n = voxel_index(i,j,k); 
				connect_voxels_indices_only(n,n+i_jump, dS_yz ); 
				count++; 
			}
		}
	}

	// y-aligned connections 
	for( unsigned int k=0 ; k < z_coordinates.size() ; k++ )
	{
		for( unsigned int i=0 ; i < x_coordinates.size() ; i++ )
		{
			for( unsigned int j=0 ; j < y_coordinates.size()-1 ; j++ )
			{
				int n = voxel_index(i,j,k); 
				connect_voxels_indices_only(n,n+j_jump, dS_xz ); 
			}
		}
	}	

	// z-aligned connections 
	for( unsigned int j=0 ; j < y_coordinates.size() ; j++ )
	{
		for( unsigned int i=0 ; i < x_coordinates.size() ; i++ )
		{
			for( unsigned int k=0 ; k < z_coordinates.size()-1 ; k++ )
			{
				int n = voxel_index(i,j,k); 
				connect_voxels_indices_only(n,n+k_jump, dS_xy ); 
			}
		}
	}
	
	if( use_voxel_faces )
	{ create_voxel_faces(); }
	
	create_moore_neighborhood();
	return; 
}

void Cartesian_Mesh::resize( int x_nodes, int y_nodes, int z_nodes )
{ return resize( 0-.5, x_nodes-1+.5 , 0-.5 , y_nodes-1+.5 , 0-.5 , z_nodes - 1+.5 , x_nodes, y_nodes, z_nodes ); } 

void Cartesian_Mesh::resize_uniform( double x_start, double x_end, double y_start, double y_end, double z_start, double z_end , double dx_new )
{ return resize( x_start, x_end, y_start, y_end, z_start, z_end , dx_new, dx_new , dx_new ); }

int Cartesian_Mesh::nearest_voxel_index( std::vector<double>& position )
{
	unsigned int i = (unsigned int) floor( (position[0]-bounding_box[0])/dx ); 
	unsigned int j = (unsigned int) floor( (position[1]-bounding_box[1])/dy ); 
	unsigned int k = (unsigned int) floor( (position[2]-bounding_box[2])/dz ); 

	//  add some bounds checking -- truncate to inside the computational domain   

	if( i >= x_coordinates.size() ){ i = x_coordinates.size()-1; }
	if( i < 0 ){ i = 0; }

	if( j >= y_coordinates.size() ){ j = y_coordinates.size()-1; }
	if( j < 0 ){ j = 0; }

	if( k >= z_coordinates.size() ){ k = z_coordinates.size()-1; }
	if( k < 0 ){ k = 0; }

	return ( k*y_coordinates.size() + j )*x_coordinates.size() + i; 
}

std::vector<unsigned int> Cartesian_Mesh::nearest_cartesian_indices( std::vector<double>& position )
{
	std::vector<unsigned int> out; 
	out.assign(3, 0 ); 
	out[0] = (unsigned int) floor( (position[0]-bounding_box[0])/dx ); 
	out[1] = (unsigned int) floor( (position[1]-bounding_box[1])/dy ); 
	out[2] = (unsigned int) floor( (position[2]-bounding_box[2])/dz ); 

	//  add some bounds checking -- truncate to inside the computational domain  

	if( out[0] >= x_coordinates.size() ){ out[0] = x_coordinates.size()-1; }
	if( out[0] < 0 ){ out[0] = 0; }

	if( out[1] >= y_coordinates.size() ){ out[1] = y_coordinates.size()-1; }
	if( out[1] < 0 ){ out[1] = 0; }

	if( out[2] >= z_coordinates.size() ){ out[2] = z_coordinates.size()-1; }
	if( out[2] < 0 ){ out[2] = 0; }

	return out; 
}

Voxel& Cartesian_Mesh::nearest_voxel( std::vector<double>& position )
{ return voxels[ nearest_voxel_index( position ) ]; }

void Cartesian_Mesh::display_information( std::ostream& os )
{
	os << std::endl << "Mesh information: " << std::endl;
	if( uniform_mesh ) 
	{ os << "type: uniform Cartesian" << std::endl; }
	else
	{
		if( regular_mesh )
		{ os << "type: regular Cartesian" << std::endl; }
		else
		{ os << "type: general Cartesian" << std::endl; }
	}
	os << "Domain: " 
	<< "[" << bounding_box[0] << "," << bounding_box[3] << "] " <<  units << " x " 
	<< "[" << bounding_box[1] << "," << bounding_box[4] << "] " <<  units << " x " 
	<< "[" << bounding_box[2] << "," << bounding_box[5] << "] " <<  units << std::endl
	<< "   resolution: dx = " << dx << " " << units; 
	if( !uniform_mesh )
	{
		os	<< ", dy = " << dy << " " << units 
			<< ", dz = " << dz << " " << units ; 
	}
	os << std::endl 
	<< "   voxels: " << voxels.size() << std::endl
	<< "   voxel faces: " << voxel_faces.size() << std::endl
	<< "   volume: " << ( bounding_box[3]-bounding_box[0] )*( bounding_box[4]-bounding_box[1] )*( bounding_box[5]-bounding_box[2] ) 
		<< " cubic " << units << std::endl; 	

	return; 
}

void Cartesian_Mesh::read_from_matlab( std::string filename )
{
	unsigned int size_of_each_datum; 
	unsigned int number_of_data_entries; 
	FILE* fp = read_matlab_header( &size_of_each_datum, &number_of_data_entries,  filename ); 

	voxel_faces.resize( 0 ); 
	
	connected_voxel_indices.resize( 1 ); 
	connected_voxel_indices[0].clear(); 
		
	Cartesian_mesh = true; 
	uniform_mesh = false; 
	regular_mesh = true; 
	use_voxel_faces = false; 

	// resize the internal data structure 

	voxels.resize( number_of_data_entries );
	connected_voxel_indices.resize( voxels.size() ); 
	
	x_coordinates.resize( number_of_data_entries );
	y_coordinates.resize( number_of_data_entries );
	z_coordinates.resize( number_of_data_entries );
	
	// read in the data
	// assumes each column has: x,y,z, dV
	
	bounding_box[0] = 9e99; 
	bounding_box[1] = 9e99; 
	bounding_box[2] = 9e99; 

	bounding_box[3] = -9e99; 
	bounding_box[4] = -9e99; 
	bounding_box[5] = -9e99; 
 
        size_t result;
	for( unsigned int i=0; i < number_of_data_entries ; i++ )
	{
		result = fread( (char*) &( voxels[i].center[0] ) , sizeof(double) , 1 , fp ); 
		result = fread( (char*) &( voxels[i].center[1] ) , sizeof(double) , 1 , fp ); 
		result = fread( (char*) &( voxels[i].center[2] ) , sizeof(double) , 1 , fp ); 
		result = fread( (char*) &( voxels[i].volume ) , sizeof(double) , 1 , fp ); 
		
		// estimate the bounding box; 
		if( voxels[i].center[0] < bounding_box[0] )
		{ bounding_box[0] = voxels[i].center[0]; }
		if( voxels[i].center[0] > bounding_box[3] )
		{ bounding_box[3] = voxels[i].center[0]; }

		if( voxels[i].center[1] < bounding_box[1] )
		{ bounding_box[1] = voxels[i].center[1]; }
		if( voxels[i].center[1] > bounding_box[4] )
		{ bounding_box[4] = voxels[i].center[1]; }

		if( voxels[i].center[2] < bounding_box[2] )
		{ bounding_box[2] = voxels[i].center[2]; }
		if( voxels[i].center[2] > bounding_box[5] )
		{ bounding_box[5] = voxels[i].center[2]; }
	} 
	
	// figure out dx, dy, dz 

	double xmin = bounding_box[0]; // voxels[0].center[0]; 
	double ymin = bounding_box[1]; // voxels[0].center[1]; 
	double zmin = bounding_box[2]; // voxels[0].center[2]; 

	// int n = voxels.size(); 
	double xmax = bounding_box[3]; // voxels[n-1].center[0]; 
	double ymax = bounding_box[4]; // voxels[n-1].center[1]; 
	double zmax = bounding_box[5]; // voxels[n-1].center[2]; 

	// figure out number of x nodes  
	int xnodes = 0; 
	while( fabs( voxels[xnodes].center[0] - xmax ) > 1e-15 )
	{ xnodes++; }
	xnodes++; 

	// figure out number of y nodes 
	int ynodes = 0; 

	while( fabs( voxels[ynodes*xnodes].center[1] - ymax ) > 1e-15 )
	{ ynodes += 1; }
	ynodes++;

	// figure out number of z nodes 

	int znodes = 0; 

	while( fabs( voxels[ynodes*xnodes*znodes].center[2] - zmax ) > 1e-15 )
	{ znodes += 1; }
	znodes++;

	// figure out differentials

	dx = ( xmax - xmin ) / ( (double) xnodes - 1.0  ); 
	dy = ( ymax - ymin ) / ( (double) ynodes - 1.0  ); 
	dz = ( zmax - zmin ) / ( (double) znodes - 1.0  ); 
	
	dV = dx*dy*dz; 
	dS = dx*dy;

	dS_xy = dx*dy;
	dS_yz = dy*dz; 
	dS_xz = dx*dz;

	uniform_mesh = true; 
	double tol = 1e-16; 
	if( fabs( dx - dy ) > tol || fabs( dy - dz ) > tol || fabs( dx - dz ) > tol )
	{ uniform_mesh = false; }
	
	// correct the bounding box 
	
	double half_step = dx * 0.5; 
	
	bounding_box[0] -= half_step; 
	bounding_box[3] += half_step;
	
	half_step = dy * 0.5; 
	bounding_box[1] -= half_step; 
	bounding_box[4] += half_step;
	
	half_step = dz * 0.5; 
	bounding_box[2] -= half_step; 
	bounding_box[5] += half_step;
 
	// write out the x,y,z coordinates; 
	x_coordinates.resize( xnodes ); 
	y_coordinates.resize( ynodes ); 
	z_coordinates.resize( znodes ); 

	for( unsigned int i=0; i < x_coordinates.size() ; i++ )
	{ x_coordinates[i] = xmin + i*dx ;   }

	for( unsigned int i=0; i < y_coordinates.size() ; i++ )
	{ y_coordinates[i] = ymin + i*dy ; }

	for( unsigned int i=0; i < z_coordinates.size() ; i++ )
	{ z_coordinates[i] = zmin + i*dz ; }

	dV = dx*dy*dz; 
	
	units = "none";  
	
	// still need to figure out connected indices later 
	std::cout << "Warning: Cartesian_Mesh::read_from_matlab is incomplete. No connection information read." << std::endl; 

	fclose( fp) ; 
	return; 
}

void Voronoi_Mesh::display_information( std::ostream& os )
{
	os << std::endl << "Mesh information: " << std::endl 
	<< "type: Voronoi (not implemented!)" << std::endl
	<< "Domain: " 
	<< "[" << bounding_box[0] << "," << bounding_box[3] << "] " <<  units << " x " 
	<< "[" << bounding_box[1] << "," << bounding_box[4] << "] " <<  units << " x " 
	<< "[" << bounding_box[2] << "," << bounding_box[5] << "] " <<  units << std::endl
	<< "   voxels: " << voxels.size() << std::endl
	<< "   voxel faces: " << voxel_faces.size() << std::endl 
	<< "   volume: "; 

	double total_volume = 0.0; 
	for( unsigned int i=0; i < voxels.size(); i++ )
	{ total_volume += voxels[i].volume; }
	os << total_volume << " cubic " << units << std::endl; 

	return; 
}

};

########## NEXT FILE ##########
BioFVM_microenvironment.cpp:::
/*
#############################################################################
# If you use BioFVM in your project, please cite BioFVM and the version     #
# number, such as below:                                                    #
#                                                                           #
# We solved the diffusion equations using BioFVM (Version 1.1.7) [1]        #
#                                                                           #
# [1] A. Ghaffarizadeh, S.H. Friedman, and P. Macklin, BioFVM: an efficient #
#    parallelized diffusive transport solver for 3-D biological simulations,#
#    Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730 #
#                                                                           #
#############################################################################
#                                                                           #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)   #
#                                                                           #
# Copyright (c) 2015-2017, Paul Macklin and the BioFVM Project              #
# All rights reserved.                                                      #
#                                                                           #
# Redistribution and use in source and binary forms, with or without        #
# modification, are permitted provided that the following conditions are    #
# met:                                                                      #
#                                                                           #
# 1. Redistributions of source code must retain the above copyright notice, #
# this list of conditions and the following disclaimer.                     #
#                                                                           #
# 2. Redistributions in binary form must reproduce the above copyright      #
# notice, this list of conditions and the following disclaimer in the       #
# documentation and/or other materials provided with the distribution.      #
#                                                                           #
# 3. Neither the name of the copyright holder nor the names of its          #
# contributors may be used to endorse or promote products derived from this #
# software without specific prior written permission.                       #
#                                                                           #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS       #
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED #
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A           #
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER #
# OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  #
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,       #
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR        #
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF    #
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING      #
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS        #
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.              #
#                                                                           #
#############################################################################
*/

#include "BioFVM_microenvironment.h"
#include "BioFVM_solvers.h"
#include "BioFVM_vector.h"
#include <cmath>

#include "BioFVM_basic_agent.h"
#include "openacc.h"

namespace BioFVM{

extern std::string BioFVM_version; 
extern std::string BioFVM_URL; 

Microenvironment* default_microenvironment = NULL; 

void set_default_microenvironment( Microenvironment* M )
{ default_microenvironment = M; }
Microenvironment* get_default_microenvironment( void )
{ return default_microenvironment; }

void zero_function( std::vector<double>& position, std::vector<double>& input , std::vector<double>* write_destination )
{
	for( unsigned int i=0 ; i < write_destination->size() ; i++ )
	{ (*write_destination)[i] = 0.0; }
	return; 
}

void one_function( std::vector<double>& position, std::vector<double>& input , std::vector<double>* write_destination )
{
	for( unsigned int i=0 ; i < write_destination->size() ; i++ )
	{ (*write_destination)[i] = 1.0; }
	return; 
}

void zero_function( Microenvironment* pMicroenvironment, int voxel_index, std::vector<double>* write_destination ) 
{
	for( unsigned int i=0 ; i < write_destination->size() ; i++ )
	{ (*write_destination)[i] = 0.0; }
	return; 
}

void one_function( Microenvironment* pMicroenvironment, int voxel_index, std::vector<double>* write_destination )
{
	for( unsigned int i=0 ; i < write_destination->size() ; i++ )
	{ (*write_destination)[i] = 1.0; }
	return; 
}

void empty_diffusion_solver( Microenvironment& S, double dt )
{
	static bool setup_done = false; 
	if( !setup_done )
	{
		std::cout << "Using the empty diffusion solver ... " << std::endl; 
		setup_done = true; 
	}

	return; 
}

Microenvironment::Microenvironment()
{	
	name = "unnamed"; 
	spatial_units = "none"; 
	time_units = "none";
	
	bulk_source_sink_solver_setup_done = false; 
	thomas_setup_done = false; 
	diffusion_solver_setup_done = false; 

	diffusion_decay_solver = empty_diffusion_solver;
	diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_3D; 

	mesh.resize(1,1,1); 

	openacc_data_bool = false; // GPU init
	
	one.resize( 1 , 1.0 ); 
	zero.resize( 1 , 0.0 );
	
	temporary_density_vectors1.resize( mesh.voxels.size() , zero ); 
	temporary_density_vectors2.resize( mesh.voxels.size() , zero ); 
	p_density_vectors = &temporary_density_vectors1;

	gradient_vectors.resize( mesh.voxels.size() ); 
	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		gradient_vectors[k].resize( 1 ); 
		(gradient_vectors[k])[0].resize( 3, 0.0 );
	}
	gradient_vector_computed.resize( mesh.voxels.size() , false ); 

	bulk_supply_rate_function = zero_function; 
	bulk_supply_target_densities_function = zero_function; 
	bulk_uptake_rate_function = zero_function; 

	density_names.assign( 1 , "unnamed" ); 
	density_units.assign( 1 , "none" ); 

	diffusion_coefficients.assign( number_of_densities() , 0.0 ); 
	decay_rates.assign( number_of_densities() , 0.0 ); 
	
	one_half = one; 
	one_half *= 0.5; 
	
	one_third = one; 
	one_third /= 3.0;

/*	
	dirichlet_indices.clear();
	dirichlet_value_vectors.clear();
	
	dirichlet_node_map.assign( mesh.voxels.size() , -1 ); 
*/
	dirichlet_value_vectors.assign( mesh.voxels.size(), one ); 
	dirichlet_activation_vector.assign( 1 , true ); 
	
	if(default_microenvironment==NULL)
	{ default_microenvironment=this; }

	return; 
}

Microenvironment::Microenvironment(std::string name)
{	
	Microenvironment();
	this->name=name;
	
	return; 
}

void Microenvironment::add_dirichlet_node( int voxel_index, std::vector<double>& value )
{
	mesh.voxels[voxel_index].is_Dirichlet=true;
	/*
	dirichlet_indices.push_back( voxel_index );
	dirichlet_value_vectors.push_back( value ); 
	*/
	
	dirichlet_value_vectors[voxel_index] = value; // .assign( mesh.voxels.size(), one ); 
	
	return; 
}

void Microenvironment::update_dirichlet_node( int voxel_index , std::vector<double>& new_value )
{
/*
	if( mesh.voxels[voxel_index].is_Dirichlet == false )
	{ 
		std::cout << "BioFVM Warning: No Dirichlet condition previously specified at voxel " << voxel_index << "! Creating a new one now ... " << std::endl; 
		add_dirichlet_node( voxel_index , new_value ); 
		return; 
	}
	
	int n = 0; 
	while( dirichlet_indices[n] != voxel_index && n < dirichlet_indices.size() )
	{ n++; }
		
	if( n == dirichlet_indices.size() )
	{ 
		std::cout << "BioFVM Warning: No Dirichlet condition previously specified at voxel " << voxel_index << "! Creating a new one now ... " << std::endl; 
		add_dirichlet_node( voxel_index , new_value ); 
		return; 
	}

	dirichlet_value_vectors[n] = new_value; 
	*/
	
	mesh.voxels[voxel_index].is_Dirichlet = true; 
	dirichlet_value_vectors[voxel_index] = new_value; 
	
	return; 
}

void Microenvironment::update_dirichlet_node( int voxel_index , int substrate_index , double new_value )
{
	mesh.voxels[voxel_index].is_Dirichlet = true; 
	dirichlet_value_vectors[voxel_index][substrate_index] = new_value; 
	return; 
}

void Microenvironment::remove_dirichlet_node( int voxel_index )
{
	mesh.voxels[voxel_index].is_Dirichlet = false; 
	
/*	
	if( mesh.voxels[voxel_index].is_Dirichlet == false )
	{ 
		std::cout << "BioFVM Warning: No Dirichlet condition previously specified at voxel " << voxel_index << "! Nothing to remove!" << std::endl; 
		return; 
	}	
	
	int n = 0; 
	mesh.voxels[voxel_index].is_Dirichlet=false;
	while( dirichlet_indices[n] != voxel_index && n < dirichlet_indices.size() )
	{  n++; }
	
	if( n == dirichlet_indices.size() )
	{ 
		std::cout << "BioFVM Warning: No Dirichlet condition previously specified at voxel " << voxel_index << "! Nothing to remove!" << std::endl; 
		return; 
	}
	
	// swap with the final node and then remove it 	
	dirichlet_indices[n] = dirichlet_indices[ dirichlet_indices.size()-1 ]; 
	dirichlet_value_vectors[n] = dirichlet_value_vectors[ dirichlet_value_vectors.size()-1 ]; 
	dirichlet_indices.pop_back();
	dirichlet_value_vectors.pop_back();
*/
	
	return; 
}

bool& Microenvironment::is_dirichlet_node( int voxel_index )
{
	return mesh.voxels[voxel_index].is_Dirichlet; 
}

void Microenvironment::set_substrate_dirichlet_activation( int substrate_index , bool new_value )
{
	dirichlet_activation_vector[substrate_index] = new_value; 
	return; 
}

double Microenvironment::get_substrate_dirichlet_activation( int substrate_index )
{
	return dirichlet_activation_vector[substrate_index]; 
}

void Microenvironment::apply_dirichlet_conditions( void )
{
	/*
	#pragma omp parallel for 
	for( unsigned int i=0 ; i < dirichlet_indices.size() ; i++ )
	{ density_vector( dirichlet_indices[i] ) = dirichlet_value_vectors[i]; }
	*/

	#pragma omp parallel for 
	for( unsigned int i=0 ; i < mesh.voxels.size() ;i++ )
	{
		/*
		if( mesh.voxels[i].is_Dirichlet == true )
		{ density_vector(i) = dirichlet_value_vectors[i]; }
		*/
		if( mesh.voxels[i].is_Dirichlet == true )
		{
			for( unsigned int j=0; j < dirichlet_value_vectors[i].size(); j++ )
			{
				if( dirichlet_activation_vector[j] == true )
				{
					density_vector(i)[j] = dirichlet_value_vectors[i][j]; 
				}
			}
	
		}
	}
	return; 
}

void Microenvironment::resize_voxels( int new_number_of_voxes )
{
	if( mesh.Cartesian_mesh == true )
	{
		std::cout << "Error: only use Microenvironment::" << __FUNCTION__ << " as a fall-back for non-Cartesian meshes." << std::endl
				  << "\tUse one of the Microenvironment::resize_space() functions instead. Ignoring directive." << std::endl; 
		return; 
	}
	
	mesh.voxels.resize( new_number_of_voxes ); 
	
	temporary_density_vectors1.resize( mesh.voxels.size() , zero ); 
	temporary_density_vectors2.resize( mesh.voxels.size() , zero ); 
		
	gradient_vectors.resize( mesh.voxels.size() ); 
	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		gradient_vectors[k].resize( number_of_densities() ); 
		for( unsigned int i=0 ; i < number_of_densities() ; i++ )
		{
			(gradient_vectors[k])[i].resize( 3, 0.0 );
		}
	}
	gradient_vector_computed.resize( mesh.voxels.size() , false ); 	
	
	dirichlet_value_vectors.assign( mesh.voxels.size(), one ); 
	
	return; 
}


void Microenvironment::resize_space( int x_nodes, int y_nodes, int z_nodes )
{
	mesh.resize( x_nodes, y_nodes , z_nodes ); 

	temporary_density_vectors1.assign( mesh.voxels.size() , zero ); 
	temporary_density_vectors2.assign( mesh.voxels.size() , zero ); 
		
	gradient_vectors.resize( mesh.voxels.size() ); 
	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		gradient_vectors[k].resize( number_of_densities() ); 
		for( unsigned int i=0 ; i < number_of_densities() ; i++ )
		{
			(gradient_vectors[k])[i].resize( 3, 0.0 );
		}
	}
	gradient_vector_computed.resize( mesh.voxels.size() , false ); 	
	
	dirichlet_value_vectors.assign( mesh.voxels.size(), one ); 

	return;  
}

void Microenvironment::resize_space( double x_start, double x_end, double y_start, double y_end, double z_start, double z_end , int x_nodes, int y_nodes, int z_nodes )
{
	mesh.resize( x_start, x_end, y_start, y_end, z_start, z_end, x_nodes, y_nodes , z_nodes  ); 

	temporary_density_vectors1.assign( mesh.voxels.size() , zero ); 
	temporary_density_vectors2.assign( mesh.voxels.size() , zero ); 
	
	gradient_vectors.resize( mesh.voxels.size() ); 
	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		gradient_vectors[k].resize( number_of_densities() ); 
		for( unsigned int i=0 ; i < number_of_densities() ; i++ )
		{
			(gradient_vectors[k])[i].resize( 3, 0.0 );
		}
	}
	gradient_vector_computed.resize( mesh.voxels.size() , false ); 	

	dirichlet_value_vectors.assign( mesh.voxels.size(), one ); 
	
	return;  
}

void Microenvironment::resize_space( double x_start, double x_end, double y_start, double y_end, double z_start, double z_end , double dx_new , double dy_new , double dz_new )
{
	mesh.resize( x_start, x_end, y_start, y_end, z_start, z_end,  dx_new , dy_new , dz_new ); 

	temporary_density_vectors1.assign( mesh.voxels.size() , zero ); 
	temporary_density_vectors2.assign( mesh.voxels.size() , zero ); 
	
	gradient_vectors.resize( mesh.voxels.size() ); 
	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		gradient_vectors[k].resize( number_of_densities() ); 
		for( unsigned int i=0 ; i < number_of_densities() ; i++ )
		{
			(gradient_vectors[k])[i].resize( 3, 0.0 );
		}
	}
	gradient_vector_computed.resize( mesh.voxels.size() , false ); 	
	
	dirichlet_value_vectors.assign( mesh.voxels.size(), one ); 
	
	return;  
}

void Microenvironment::resize_space_uniform( double x_start, double x_end, double y_start, double y_end, double z_start, double z_end , double dx_new )
{
 return resize_space( x_start, x_end, y_start, y_end, z_start, z_end , dx_new , dx_new, dx_new ); 
}

void Microenvironment::resize_densities( int new_size )
{
	zero.assign( new_size, 0.0 ); 
	one.assign( new_size , 1.0 );

	temporary_density_vectors1.assign( mesh.voxels.size() , zero );
	temporary_density_vectors2.assign( mesh.voxels.size() , zero );

	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		gradient_vectors[k].resize( number_of_densities() ); 
		for( unsigned int i=0 ; i < number_of_densities() ; i++ )
		{
			(gradient_vectors[k])[i].resize( 3, 0.0 );
		}
	}
	gradient_vector_computed.resize( mesh.voxels.size() , false ); 	
	
	diffusion_coefficients.assign( new_size , 0.0 ); 
	decay_rates.assign( new_size , 0.0 ); 

	density_names.assign( new_size, "unnamed" ); 
	density_units.assign( new_size , "none" ); 

	one_half = one; 
	one_half *= 0.5; 
	
	one_third = one; 
	one_third /= 3.0; 
	
	dirichlet_value_vectors.assign( mesh.voxels.size(), one ); 
	dirichlet_activation_vector.assign( new_size, true ); 

	default_microenvironment_options.Dirichlet_condition_vector.assign( new_size , 1.0 );  
	default_microenvironment_options.Dirichlet_activation_vector.assign( new_size, true ); 
	
	default_microenvironment_options.initial_condition_vector.assign( new_size , 1.0 ); 
	
	return; 
}

void Microenvironment::add_density( void )
{
	// fix in PhysiCell preview November 2017 
	// default_microenvironment_options.use_oxygen_as_first_field = false; 
	
	// update 1, 0 
	zero.push_back( 0.0 ); 
	one.push_back( 1.0 );
	
	// update units
	density_names.push_back( "unnamed" ); 
	density_units.push_back( "none" ); 

	// update coefficients 
	diffusion_coefficients.push_back( 0.0 ); 
	decay_rates.push_back( 0.0 ); 
	
	// update sources and such 
	for( unsigned int i=0; i < temporary_density_vectors1.size() ; i++ )
	{
		temporary_density_vectors1[i].push_back( 0.0 ); 
		temporary_density_vectors2[i].push_back( 0.0 ); 
	}

	// resize the gradient data structures 
	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		gradient_vectors[k].resize( number_of_densities() ); 
		for( unsigned int i=0 ; i < number_of_densities() ; i++ )
		{
			(gradient_vectors[k])[i].resize( 3, 0.0 );
		}
	}

	gradient_vector_computed.resize( mesh.voxels.size() , false ); 	
	
	one_half = one; 
	one_half *= 0.5; 
	
	one_third = one; 
	one_third /= 3.0; 
	
	dirichlet_value_vectors.assign( mesh.voxels.size(), one ); 
	dirichlet_activation_vector.assign( number_of_densities(), true ); 
	
	// Fixes in PhysiCell preview November 2017
	default_microenvironment_options.Dirichlet_condition_vector.push_back( 1.0 ); //  = one; 
	default_microenvironment_options.Dirichlet_activation_vector.push_back( true ); // assign( number_of_densities(), true ); 
	
	default_microenvironment_options.initial_condition_vector.push_back( 1.0 ); 
	
	return; 
}

void Microenvironment::add_density( std::string name , std::string units )
{
	// fix in PhysiCell preview November 2017 
	// default_microenvironment_options.use_oxygen_as_first_field = false; 
	
	// update 1, 0 
	zero.push_back( 0.0 ); 
	one.push_back( 1.0 );

	// update units
	density_names.push_back( name ); 
	density_units.push_back( units ); 

	// update coefficients 
	diffusion_coefficients.push_back( 0.0 ); 
	decay_rates.push_back( 0.0 ); 
	
	// update sources and such 
	for( unsigned int i=0; i < temporary_density_vectors1.size() ; i++ )
	{
		temporary_density_vectors1[i].push_back( 0.0 ); 
		temporary_density_vectors2[i].push_back( 0.0 ); 
	}

	// resize the gradient data structures, 
	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		gradient_vectors[k].resize( number_of_densities() ); 
		for( unsigned int i=0 ; i < number_of_densities() ; i++ )
		{
			(gradient_vectors[k])[i].resize( 3, 0.0 );
		}
	}
	gradient_vector_computed.resize( mesh.voxels.size() , false ); 	

	one_half = one; 
	one_half *= 0.5; 
	
	one_third = one; 
	one_third /= 3.0; 
	
	dirichlet_value_vectors.assign( mesh.voxels.size(), one ); 
	dirichlet_activation_vector.assign( number_of_densities(), true ); 
	
	// fix in PhysiCell preview November 2017 
	default_microenvironment_options.Dirichlet_condition_vector.push_back( 1.0 ); //  = one; 
	default_microenvironment_options.Dirichlet_activation_vector.push_back( true ); // assign( number_of_densities(), true ); 

	default_microenvironment_options.initial_condition_vector.push_back( 1.0 ); 
	
	return; 
}

void Microenvironment::add_density( std::string name , std::string units, double diffusion_constant, double decay_rate )
{
	// fix in PhysiCell preview November 2017 
	// default_microenvironment_options.use_oxygen_as_first_field = false; 
	
	// update 1, 0 
	zero.push_back( 0.0 ); 
	one.push_back( 1.0 );
	
	// update units
	density_names.push_back( name ); 
	density_units.push_back( units ); 

	// update coefficients 
	diffusion_coefficients.push_back( diffusion_constant ); 
	decay_rates.push_back( decay_rate ); 
	
	// update sources and such 
	for( unsigned int i=0; i < temporary_density_vectors1.size() ; i++ )
	{
		temporary_density_vectors1[i].push_back( 0.0 ); 
		temporary_density_vectors2[i].push_back( 0.0 ); 
	}

	// resize the gradient data structures 
	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		gradient_vectors[k].resize( number_of_densities() ); 
		for( unsigned int i=0 ; i < number_of_densities() ; i++ )
		{
			(gradient_vectors[k])[i].resize( 3, 0.0 );
		}
	}
	gradient_vector_computed.resize( mesh.voxels.size() , false ); 	

	one_half = one; 
	one_half *= 0.5; 
	
	one_third = one; 
	one_third /= 3.0; 
	
	dirichlet_value_vectors.assign( mesh.voxels.size(), one ); 
	dirichlet_activation_vector.assign( number_of_densities(), true ); 
	
	// fix in PhysiCell preview November 2017 
	default_microenvironment_options.Dirichlet_condition_vector.push_back( 1.0 ); // = one; 
	default_microenvironment_options.Dirichlet_activation_vector.push_back( true ); // assign( number_of_densities(), true ); 
	
	default_microenvironment_options.initial_condition_vector.push_back( 1.0 ); 
	
	return; 
}

int Microenvironment::find_density_index( std::string name )
{
	for( unsigned int i=0; i < density_names.size() ; i++ )
	{
		if( density_names[i] == name )
		{ return i; }
	}
	return -1; 
}

void Microenvironment::set_density( int index , std::string name , std::string units )
{
	// fix in PhysiCell preview November 2017 
	if( index == 0 )
	{ default_microenvironment_options.use_oxygen_as_first_field = false; }
	
	density_names[index] = name; 
	density_units[index] = units; 
	return; 
}

void Microenvironment::set_density( int index , std::string name , std::string units , double diffusion_constant , double decay_rate )
{
	// fix in PhysiCell preview November 2017 
	if( index == 0 )
	{ default_microenvironment_options.use_oxygen_as_first_field = false; }
	
	density_names[index] = name; 
	density_units[index] = units; 
	
	diffusion_coefficients[index] = diffusion_constant; 
	decay_rates[index] = decay_rate;	
	return; 
}

#pragma acc routine
int Microenvironment::voxel_index( int i, int j, int k )
{ return mesh.voxel_index(i,j,k) ; }

std::vector<unsigned int> Microenvironment::cartesian_indices( int n )
{ return mesh.cartesian_indices( n ); }

int Microenvironment::nearest_voxel_index( std::vector<double>& position )
{ return mesh.nearest_voxel_index( position ); }

Voxel& Microenvironment::voxels( int voxel_index )
{ return mesh.voxels[voxel_index]; }

std::vector<unsigned int> Microenvironment::nearest_cartesian_indices( std::vector<double>& position )
{ return mesh.nearest_cartesian_indices( position ); }
 
Voxel& Microenvironment::nearest_voxel( std::vector<double>& position )
{ return mesh.nearest_voxel( position ); }

std::vector<double>& Microenvironment::nearest_density_vector( std::vector<double>& position )
{ return (*p_density_vectors)[ mesh.nearest_voxel_index( position ) ]; }

std::vector<double>& Microenvironment::nearest_density_vector( int voxel_index )
{ return (*p_density_vectors)[ voxel_index ]; }

std::vector<double>& Microenvironment::operator()( int i, int j, int k )
{ return (*p_density_vectors)[ voxel_index(i,j,k) ]; }

std::vector<double>& Microenvironment::operator()( int i, int j )
{ return (*p_density_vectors)[ voxel_index(i,j,0) ]; }

std::vector<double>& Microenvironment::operator()( int n )
{ return (*p_density_vectors)[ n ]; }

std::vector<double>& Microenvironment::density_vector( int i, int j, int k )
{ return (*p_density_vectors)[ voxel_index(i,j,k) ]; }

std::vector<double>& Microenvironment::density_vector( int i, int j )
{ return (*p_density_vectors)[ voxel_index(i,j,0) ]; }

std::vector<double>& Microenvironment::density_vector( int n )
{ return (*p_density_vectors)[ n ]; }

#pragma acc routine
double& Microenvironment::density_vector_GPU( int n )
{ return (*gpu_p_density_vectors)[ n ]; }

void Microenvironment::simulate_diffusion_decay( double dt )
{
	if( diffusion_decay_solver )
	{ diffusion_decay_solver( *this, dt ); }
	else
	{
		std::cout << "Warning: diffusion-reaction-source/sink solver not set for Microenvironment object at " << this << ". Nothing happened!" << std::endl; 
		std::cout << "   Consider using Microenvironment::auto_choose_diffusion_decay_solver(void) ... " << std::endl 
		<< std::endl; 
	}
	return; 
}

void Microenvironment::auto_choose_diffusion_decay_solver( void )
{
	// set the safest choice 
	diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_explicit; 

	std::cout << "Warning: auto-selection of diffusion-decay-source/sink solver not fully implemented!" << std::endl;

 // eventual logic: if non-Cartesian, use explicit
 // if Cartesian, if non-variable, use the constant coefficient super-fast code
 // otherwise, use the variable coefficient code 

}
 
void Microenvironment::display_information( std::ostream& os )
{
	os << std::endl << "Microenvironment summary: " << name << ": " << std::endl; 
	mesh.display_information( os ); 
	os << "Densities: (" << number_of_densities() << " total)" << std::endl; 
	for( unsigned int i = 0 ; i < density_names.size() ; i++ )
	{
		os << "   " << density_names[i] << ":" << std::endl
		<< "     units: " << density_units[i] << std::endl 
		<< "     diffusion coefficient: " << diffusion_coefficients[i]  
			<< " " << spatial_units << "^2 / " << time_units << std::endl
		<< "     decay rate: " << decay_rates[i] 
			<< " " << time_units << "^-1" << std::endl 
		<< "     diffusion length scale: " << sqrt( diffusion_coefficients[i] / ( 1e-12 + decay_rates[i] ) ) 
			<< " " << spatial_units << std::endl 
		<< "     initial condition: " << default_microenvironment_options.initial_condition_vector[i] 
			<< " " << density_units[i] << std::endl 
		<< "     boundary condition: " << default_microenvironment_options.Dirichlet_condition_vector[i] 
			<< " " << density_units[i] << " (enabled: "; 
		if( dirichlet_activation_vector[i] == true )
		{ os << "true"; }
		else
		{ os << "false"; }
		os << ")" << std::endl; 
	}
	os << std::endl; 
	
	return; 
}
	
unsigned int Microenvironment::number_of_densities( void )
{ return (*p_density_vectors)[0].size(); }

unsigned int Microenvironment::number_of_voxels( void )
{ return mesh.voxels.size(); }

unsigned int Microenvironment::number_of_voxel_faces( void )
{ return mesh.voxel_faces.size(); } 

void Microenvironment::write_to_matlab( std::string filename )
{
	int number_of_data_entries = mesh.voxels.size();
	int size_of_each_datum = 3 + 1 + (*p_density_vectors)[0].size(); 

	FILE* fp = write_matlab_header( size_of_each_datum, number_of_data_entries,  filename, "multiscale_microenvironment" );  

	// storing data as cols 
	for( int i=0; i < number_of_data_entries ; i++ )
	{
		fwrite( (char*) &( mesh.voxels[i].center[0] ) , sizeof(double) , 1 , fp ); 
		fwrite( (char*) &( mesh.voxels[i].center[1] ) , sizeof(double) , 1 , fp );   
		fwrite( (char*) &( mesh.voxels[i].center[2] ) , sizeof(double) , 1 , fp ); 
		fwrite( (char*) &( mesh.voxels[i].volume ) , sizeof(double) , 1 , fp ); 

		// densities  

		for( unsigned int j=0 ; j < (*p_density_vectors)[i].size() ; j++)
		{ fwrite( (char*) &( ((*p_density_vectors)[i])[j] ) , sizeof(double) , 1 , fp ); }
	}

	fclose( fp ); 
	return;
}



void Microenvironment::simulate_bulk_sources_and_sinks( double dt )
{
	if( !bulk_source_sink_solver_setup_done )
	{
		bulk_source_sink_solver_temp1.resize( mesh.voxels.size() , zero );
		bulk_source_sink_solver_temp2.resize( mesh.voxels.size() , zero );
		bulk_source_sink_solver_temp3.resize( mesh.voxels.size() , zero );
		
		bulk_source_sink_solver_setup_done = true; 
	}
	
	#pragma omp parallel for
	for( unsigned int i=0; i < mesh.voxels.size() ; i++ )
	{
		bulk_supply_rate_function( this,i, &bulk_source_sink_solver_temp1[i] ); // temp1 = S
		bulk_supply_target_densities_function( this,i, &bulk_source_sink_solver_temp2[i]); // temp2 = T
		bulk_uptake_rate_function( this,i, &bulk_source_sink_solver_temp3[i] ); // temp3 = U

		
		bulk_source_sink_solver_temp2[i] *= bulk_source_sink_solver_temp1[i]; // temp2 = S*T
		axpy( &(*p_density_vectors)[i] , dt , bulk_source_sink_solver_temp2[i] ); // out = out + dt*temp2 = out + dt*S*T
		bulk_source_sink_solver_temp3[i] += bulk_source_sink_solver_temp1[i]; // temp3 = U+S
		bulk_source_sink_solver_temp3[i] *= dt; // temp3 = dt*(U+S)
		bulk_source_sink_solver_temp3[i] += one; // temp3 = 1 + dt*(U+S)
		
		(*p_density_vectors)[i] /= bulk_source_sink_solver_temp3[i];
	}
	
	return; 
}

void Microenvironment::simulate_cell_sources_and_sinks( std::vector<Basic_Agent*>& basic_agent_list , double dt )
{
	#pragma omp parallel for
	for( unsigned int i=0 ; i < basic_agent_list.size() ; i++ )
	{		
		basic_agent_list[i]->simulate_secretion_and_uptake( this , dt ); 
	}
	
	return; 
}

void Microenvironment::simulate_cell_sources_and_sinks( double dt )
{
	simulate_cell_sources_and_sinks(all_basic_agents, dt);
}

void Microenvironment::update_rates( void )
{
	if( supply_target_densities_times_supply_rates.size() != number_of_voxels() )
	{ supply_target_densities_times_supply_rates.assign( number_of_voxels() , zero ); }

	if( supply_rates.size() != number_of_voxels() )
	{ supply_rates.assign( number_of_voxels() , zero ); }
	
	if( uptake_rates.size() != number_of_voxels() )
	{ uptake_rates.assign( number_of_voxels() , zero ); }

	#pragma omp parallel for 
	for( unsigned int i=0 ; i < number_of_voxels() ; i++ )
	{
		bulk_uptake_rate_function( this,i, &(uptake_rates[i]) ); 		
		bulk_supply_rate_function( this,i, &(supply_rates[i]) ); 		
		bulk_supply_target_densities_function( this,i, &(supply_target_densities_times_supply_rates[i]) );
		
		supply_target_densities_times_supply_rates[i] *= supply_rates[i]; 
	}
	return; 
}

std::vector<gradient>& Microenvironment::gradient_vector(int i, int j, int k)
{
	int n = voxel_index(i,j,k);
	if( gradient_vector_computed[n] == false )
	{
		compute_gradient_vector( n );
	}
	
	return gradient_vectors[n];
}

std::vector<gradient>& Microenvironment::gradient_vector(int i, int j )
{
	int n = voxel_index(i,j,0);
	if( gradient_vector_computed[n] == false )
	{
		compute_gradient_vector( n );
	}
	
	return gradient_vectors[n];
}

std::vector<gradient>& Microenvironment::gradient_vector(int n )
{
	// if the gradient has not yet been computed, then do it!
	if( gradient_vector_computed[n] == false )
	{
		compute_gradient_vector( n );
	}
	
	
	return gradient_vectors[n];
}
	
std::vector<gradient>& Microenvironment::nearest_gradient_vector( std::vector<double>& position )
{
	int n = nearest_voxel_index( position );
	if( gradient_vector_computed[n] == false )
	{
		compute_gradient_vector( n );
	}
	
	return gradient_vectors[n];
}

void Microenvironment::compute_all_gradient_vectors( void )
{
	static double two_dx = mesh.dx; 
	static double two_dy = mesh.dy; 
	static double two_dz = mesh.dz; 
	static bool gradient_constants_defined = false; 
	if( gradient_constants_defined == false )
	{
		two_dx *= 2.0; 
		two_dy *= 2.0; 
		two_dz *= 2.0;
		gradient_constants_defined = true; 
	}
	
	#pragma omp parallel for 
	for( unsigned int k=0; k < mesh.z_coordinates.size() ; k++ )
	{
		for( unsigned int j=0; j < mesh.y_coordinates.size() ; j++ )
		{
			
			for( unsigned int i=1; i < mesh.x_coordinates.size()-1 ; i++ )
			{
				for( unsigned int q=0; q < number_of_densities() ; q++ )
				{
					int n = voxel_index(i,j,k);
					// x-derivative of qth substrate at voxel n
					gradient_vectors[n][q][0] = (*p_density_vectors)[n+thomas_i_jump][q]; 
					gradient_vectors[n][q][0] -= (*p_density_vectors)[n-thomas_i_jump][q]; 
					gradient_vectors[n][q][0] /= two_dx; 
					
					gradient_vector_computed[n] = true; 
 				}
			}
			
		}
	}
	
	#pragma omp parallel for 
	for( unsigned int k=0; k < mesh.z_coordinates.size() ; k++ )
	{
		for( unsigned int i=0; i < mesh.x_coordinates.size() ; i++ )
		{
			
			for( unsigned int j=1; j < mesh.y_coordinates.size()-1 ; j++ )
			{
				for( unsigned int q=0; q < number_of_densities() ; q++ )
				{
					int n = voxel_index(i,j,k);
					// y-derivative of qth substrate at voxel n
					gradient_vectors[n][q][1] = (*p_density_vectors)[n+thomas_j_jump][q]; 
					gradient_vectors[n][q][1] -= (*p_density_vectors)[n-thomas_j_jump][q]; 
					gradient_vectors[n][q][1] /= two_dy; 
					gradient_vector_computed[n] = true; 
				}
			}
			
		}
	}

	#pragma omp parallel for 
	for( unsigned int j=0; j < mesh.y_coordinates.size() ; j++ )
	{
		for( unsigned int i=0; i < mesh.x_coordinates.size() ; i++ )
		{
			
			for( unsigned int k=1; k < mesh.z_coordinates.size()-1 ; k++ )
			{
				for( unsigned int q=0; q < number_of_densities() ; q++ )
				{
					int n = voxel_index(i,j,k);
					// y-derivative of qth substrate at voxel n
					gradient_vectors[n][q][2] = (*p_density_vectors)[n+thomas_k_jump][q]; 
					gradient_vectors[n][q][2] -= (*p_density_vectors)[n-thomas_k_jump][q]; 
					gradient_vectors[n][q][2] /= two_dz; 
					gradient_vector_computed[n] = true; 
				}
			}
			
		}
	}

	return; 
}

void Microenvironment::compute_gradient_vector( int n )
{
	static double two_dx = mesh.dx; 
	static double two_dy = mesh.dy; 
	static double two_dz = mesh.dz; 
	static bool gradient_constants_defined = false; 
	std::vector<unsigned int> indices(3,0);
	
	if( gradient_constants_defined == false )
	{
		two_dx *= 2.0; 
		two_dy *= 2.0; 
		two_dz *= 2.0;
		gradient_constants_defined = true; 
	}	
	
	indices = cartesian_indices( n );
	
	// d/dx 
	if( indices[0] > 0 && indices[0] < mesh.x_coordinates.size()-1 )
	{
		for( unsigned int q=0; q < number_of_densities() ; q++ )
		{
			gradient_vectors[n][q][0] = (*p_density_vectors)[n+thomas_i_jump][q]; 
			gradient_vectors[n][q][0] -= (*p_density_vectors)[n-thomas_i_jump][q]; 
			gradient_vectors[n][q][0] /= two_dx; 
			gradient_vector_computed[n] = true; 
		}
	}
	
	// d/dy 
	if( indices[1] > 0 && indices[1] < mesh.y_coordinates.size()-1 )
	{
		for( unsigned int q=0; q < number_of_densities() ; q++ )
		{
			gradient_vectors[n][q][1] = (*p_density_vectors)[n+thomas_j_jump][q]; 
			gradient_vectors[n][q][1] -= (*p_density_vectors)[n-thomas_j_jump][q]; 
			gradient_vectors[n][q][1] /= two_dy; 
			gradient_vector_computed[n] = true; 
		}
	}
	
	// d/dz 
	if( indices[2] > 0 && indices[2] < mesh.z_coordinates.size()-1 )
	{
		for( unsigned int q=0; q < number_of_densities() ; q++ )
		{
			gradient_vectors[n][q][2] = (*p_density_vectors)[n+thomas_k_jump][q]; 
			gradient_vectors[n][q][2] -= (*p_density_vectors)[n-thomas_k_jump][q]; 
			gradient_vectors[n][q][2] /= two_dz; 
			gradient_vector_computed[n] = true; 
		}
	}
	
	return; 
}

void Microenvironment::reset_all_gradient_vectors( void )
{
	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		for( unsigned int i=0 ; i < number_of_densities() ; i++ )
		{
			(gradient_vectors[k])[i].resize( 3, 0.0 );
		}
	}
	gradient_vector_computed.assign( mesh.voxels.size() , false ); 	
}


Microenvironment microenvironment; 

Microenvironment_Options::Microenvironment_Options()
{
	use_oxygen_as_first_field = true; 
	
	if( get_default_microenvironment() != NULL )
	{
		pMicroenvironment = get_default_microenvironment(); 
	}
	else
	{
		pMicroenvironment = &microenvironment; 
		set_default_microenvironment( pMicroenvironment ); 
	}
	name = "microenvironment"; 
	
	time_units = "min"; 
	spatial_units = "micron"; 
	dx = 20; 
	dy = 20; 
	dz = 20; 
	
	outer_Dirichlet_conditions = false; 
	Dirichlet_condition_vector.assign( pMicroenvironment->number_of_densities() , 1.0 ); 
	Dirichlet_activation_vector.assign( pMicroenvironment->number_of_densities() , true ); 
	
	initial_condition_vector.resize(0); //  = Dirichlet_condition_vector; 
	
	// set a far-field value for oxygen (assumed to be in the first field)
	Dirichlet_condition_vector[0] = 38.0; 
	
	simulate_2D = false; 
	
	X_range.resize(2,500.0); 
	X_range[0] *= -1.0;
	
	Y_range.resize(2,500.0); 
	Y_range[0] *= -1.0;
	
	Z_range.resize(2,500.0); 
	Z_range[0] *= -1.0;
	
	calculate_gradients = false; 
	
	track_internalized_substrates_in_each_agent = false; 
	
	return; 
}

Microenvironment_Options default_microenvironment_options; 

void initialize_microenvironment( void )
{
	// create and name a microenvironment; 
	microenvironment.name = default_microenvironment_options.name;
	// register the diffusion solver 
	if( default_microenvironment_options.simulate_2D == true )
	{
		microenvironment.diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_2D; 
	}
	else
	{
		microenvironment.diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_3D; 
	}
	
	// set the default substrate to oxygen (with typical units of mmHg)
	if( default_microenvironment_options.use_oxygen_as_first_field == true )
	{
		microenvironment.set_density(0, "oxygen" , "mmHg" );
		microenvironment.diffusion_coefficients[0] = 1e5; 
		microenvironment.decay_rates[0] = 0.1; 
	}
	
	// resize the microenvironment  
	if( default_microenvironment_options.simulate_2D == true )
	{
		default_microenvironment_options.Z_range[0] = -default_microenvironment_options.dz/2.0; 
		default_microenvironment_options.Z_range[1] = default_microenvironment_options.dz/2.0;
	}
	microenvironment.resize_space( default_microenvironment_options.X_range[0], default_microenvironment_options.X_range[1] , 
		default_microenvironment_options.Y_range[0], default_microenvironment_options.Y_range[1], 
		default_microenvironment_options.Z_range[0], default_microenvironment_options.Z_range[1], 
		default_microenvironment_options.dx,default_microenvironment_options.dy,default_microenvironment_options.dz );
		
	// set units
	microenvironment.spatial_units = default_microenvironment_options.spatial_units;
	microenvironment.time_units = default_microenvironment_options.time_units;
	microenvironment.mesh.units = default_microenvironment_options.spatial_units;

	// set the initial densities to the values set in the initial_condition_vector
	
	// if the initial condition vector has not been set, use the Dirichlet condition vector 
	if( default_microenvironment_options.initial_condition_vector.size() != 
		microenvironment.number_of_densities() )
	{
		std::cout << "BioFVM Warning: Initial conditions not set. " << std::endl 
				  << "                Using Dirichlet condition vector to set initial substrate values!" << std::endl 
				  << "                In the future, set default_microenvironment_options.initial_condition_vector." 
				  << std::endl << std::endl;  
		default_microenvironment_options.initial_condition_vector = default_microenvironment_options.Dirichlet_condition_vector; 
	}
	
	for( unsigned int n=0; n < microenvironment.number_of_voxels() ; n++ )
	{ microenvironment.density_vector(n) = default_microenvironment_options.initial_condition_vector; }
	
	if( default_microenvironment_options.outer_Dirichlet_conditions == true ) 
	{
		
		for( unsigned int k=0 ; k < microenvironment.mesh.z_coordinates.size() ; k++ )
		{
			// set Dirichlet conditions along the 4 outer edges 
			for( unsigned int i=0 ; i < microenvironment.mesh.x_coordinates.size() ; i++ )
			{
				int J = microenvironment.mesh.y_coordinates.size()-1;
				microenvironment.add_dirichlet_node( microenvironment.voxel_index(i,0,k) , default_microenvironment_options.Dirichlet_condition_vector );
				microenvironment.add_dirichlet_node( microenvironment.voxel_index(i,J,k) , default_microenvironment_options.Dirichlet_condition_vector );
			}
			int I = microenvironment.mesh.x_coordinates.size()-1;
			for( unsigned int j=1; j < microenvironment.mesh.y_coordinates.size()-1 ; j++ )
			{
				microenvironment.add_dirichlet_node( microenvironment.voxel_index(0,j,k) , default_microenvironment_options.Dirichlet_condition_vector );
				microenvironment.add_dirichlet_node( microenvironment.voxel_index(I,j,k) , default_microenvironment_options.Dirichlet_condition_vector );
			}		
		}
		// if 3-D, also along the corresponding additional faces 
		if( default_microenvironment_options.simulate_2D == false )
		{
			int K = microenvironment.mesh.z_coordinates.size()-1; 
			for( unsigned int j=1 ; j < microenvironment.mesh.y_coordinates.size()-1 ; j++ )
			{
				for( unsigned int i=1; i < microenvironment.mesh.x_coordinates.size()-1 ; i++ )
				{
					microenvironment.add_dirichlet_node( microenvironment.voxel_index(i,j,0) , default_microenvironment_options.Dirichlet_condition_vector );
					microenvironment.add_dirichlet_node( microenvironment.voxel_index(i,j,K) , default_microenvironment_options.Dirichlet_condition_vector );
				}	
			}	
		}
		
	}
	
	// set the Dirichlet condition activation vector to match the microenvironment options 
	for( int i=0 ; i < default_microenvironment_options.Dirichlet_activation_vector.size(); i++ )
	{
		microenvironment.set_substrate_dirichlet_activation( i , default_microenvironment_options.Dirichlet_activation_vector[i] ); 
	}
	
	microenvironment.display_information( std::cout );
	return;
}

int Microenvironment::get_size_p1()
{
	return (*p_density_vectors).size();
}

int Microenvironment::get_size_p2()
{
	return (*p_density_vectors)[0].size();
}

void Microenvironment::transfer_2D()
{
	// start gpu_p_density_vectors
	const int bin_p_density_vectors = (*p_density_vectors).size();

	gpu_p_density_vectors = new double*[bin_p_density_vectors];

	sizes_p_density_vectors = new int[bin_p_density_vectors];
	#pragma acc enter data copyin(this[0:1])
	#pragma acc enter data create(this->gpu_p_density_vectors[0:bin_p_density_vectors][0:0])

	for (int i = 0; i < bin_p_density_vectors; i++){
		int sze = (*p_density_vectors)[i].size();
		sizes_p_density_vectors[i] = sze;
		gpu_p_density_vectors[i] = (*p_density_vectors)[i].data();
		#pragma acc enter data copyin(this->gpu_p_density_vectors[i:1][:sze])
	}
	#pragma acc enter data copyin(this->sizes_p_density_vectors[:bin_p_density_vectors])
	// end gpu_p_density_vectors

	// start gpu_thomas_constant1
	const int bin_thomas_constant1 = thomas_constant1.size();

	gpu_thomas_constant1 = new double [bin_thomas_constant1];

	sizes_thomas_constant1 = bin_thomas_constant1;
	#pragma acc enter data create(this->gpu_thomas_constant1[0:bin_thomas_constant1])

		//gpu_thomas_constant1[e] = thomas_constant1.at(e);
		gpu_thomas_constant1 = thomas_constant1.data();

	#pragma acc enter data copyin(this->gpu_thomas_constant1[:bin_thomas_constant1])
	#pragma acc enter data copyin(this->sizes_thomas_constant1)
	// end gpu_thomas_constant1
	
	// start gpu_thomas_denomx
	const int bin_thomas_denomx = thomas_denomx.size();

	gpu_thomas_denomx = new double * [bin_thomas_denomx];

	sizes_thomas_denomx = new int [bin_thomas_denomx];

	#pragma acc enter data create(this->gpu_thomas_denomx[0:bin_thomas_denomx][0:0])
	for (int i = 0; i < bin_thomas_denomx; i ++) {
		int sze = thomas_denomx[i].size();
		gpu_thomas_denomx[i] = thomas_denomx[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_denomx[i:1][:sze])
	}	
	// pragma acc enter data sizes
	// end gpu_thomas_denomx
	
	// start gpu_thomas_denomy
	const int bin_thomas_denomy = thomas_denomy.size();

	gpu_thomas_denomy = new double * [bin_thomas_denomy];

	sizes_thomas_denomy = new int [bin_thomas_denomy];

	#pragma acc enter data create(this->gpu_thomas_denomy[0:bin_thomas_denomy][0:0])
	for (int i = 0; i < bin_thomas_denomy; i ++) {
		int sze = thomas_denomy[i].size();
		gpu_thomas_denomy[i] = thomas_denomy[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_denomy[i:1][:sze])
	}	
	// pragma acc enter data sizes
	// end gpu_thomas_denomy
	
	// start gpu_thomas_i_jump
	gpu_thomas_i_jump = new int;

	*gpu_thomas_i_jump = thomas_i_jump;

	#pragma acc enter data copyin(this->gpu_thomas_i_jump)
	// end gpu_thomas_i_jump
	
	// start gpu_thomas_j_jump
	gpu_thomas_j_jump = new int;

	*gpu_thomas_j_jump = thomas_j_jump;

	#pragma acc enter data copyin(this->gpu_thomas_j_jump)
	// end gpu_thomas_j_jump
	
	// start gpu_thomas_cx
	const int bin_thomas_cx = thomas_cx.size();

	gpu_thomas_cx = new double * [bin_thomas_cx];

	sizes_thomas_cx = new int [bin_thomas_cx];

	#pragma acc enter data create(this->gpu_thomas_cx[0:bin_thomas_cx][0:0])
	for (int i = 0; i < bin_thomas_cx; i ++) {
		int sze = thomas_cx[i].size();
		gpu_thomas_cx[i] = thomas_cx[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_cx[i:1][:sze])
	}
	// end gpu_thomas_cx
	
	// start gpu_thomas_cy
	const int bin_thomas_cy = thomas_cy.size();

	gpu_thomas_cy = new double * [bin_thomas_cy];

	sizes_thomas_cy = new int [bin_thomas_cy];

	#pragma acc enter data create(this->gpu_thomas_cy[0:bin_thomas_cy][0:0])
	for (int i = 0; i < bin_thomas_cy; i ++) {
		int sze = thomas_cy[i].size();
		gpu_thomas_cy[i] = thomas_cy[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_cy[i:1][:sze])
	}
	// end gpu_thomas_cy
	
	// start gpu_dirichlet_value_vectors
	const int bin_dirichlet_value_vectors = dirichlet_value_vectors.size();

	gpu_dirichlet_value_vectors = new double * [bin_dirichlet_value_vectors];

	sizes_dirichlet_value_vectors = new int [bin_dirichlet_value_vectors];

	#pragma acc enter data create(this->gpu_dirichlet_value_vectors[0:bin_dirichlet_value_vectors][0:0])
	for (int i = 0; i < bin_dirichlet_value_vectors; i++) {
		int sze = dirichlet_value_vectors[i].size();
		sizes_dirichlet_value_vectors[i] = sze;
		gpu_dirichlet_value_vectors[i] = dirichlet_value_vectors[i].data();
		#pragma acc enter data copyin(this->gpu_dirichlet_value_vectors[i:1][:sze])
	}	
	#pragma acc enter data copyin(this->sizes_dirichlet_value_vectors[:bin_dirichlet_value_vectors])
	// end gpu_dirichlet_value_vectors
	
	// start gpu_dirichlet_activation_vector
	const int bin_dirichlet_activation_vector = dirichlet_activation_vector.size();

	gpu_dirichlet_activation_vector = new bool [bin_dirichlet_activation_vector];

	#pragma acc enter data create(this->gpu_dirichlet_activation_vector[0:bin_dirichlet_activation_vector])
	for (int i = 0; i < bin_dirichlet_activation_vector; i++) {
		gpu_dirichlet_activation_vector[i] = dirichlet_activation_vector.at(i);
	}
/*
 *potential error here, move copyin to inside interation?
 */
	#pragma acc enter data copyin(this->gpu_dirichlet_activation_vector[:bin_dirichlet_activation_vector])
	// end gpu_dirichlet_activation_vector
	
	// start gpu_voxel_is_dirichlet
	const int bin_mesh = mesh.voxels.size();

	gpu_voxels_is_dirichlet = new bool [bin_mesh];

	#pragma acc enter data create(this->gpu_voxels_is_dirichlet[0:bin_mesh])
	for (int i = 0; i < bin_mesh; i ++) {
		gpu_voxels_is_dirichlet[i] = mesh.voxels[i].is_Dirichlet;
	}
	#pragma acc enter data copyin(this->gpu_voxels_is_dirichlet[:bin_mesh])
	// end gpu_voxel_is_dirichlet

	std::cout << "Done transfer" << std::endl;
}

void Microenvironment::transfer_3D()
{
	// start gpu_p_density_vectors
	const int bin_p_density_vectors = (*p_density_vectors).size();

	gpu_p_density_vectors = new double*[bin_p_density_vectors];

	sizes_p_density_vectors = new int[bin_p_density_vectors];
	#pragma acc enter data copyin(this[0:1])
	#pragma acc enter data create(this->gpu_p_density_vectors[0:bin_p_density_vectors][0:0])

	for (int i = 0; i < bin_p_density_vectors; i++){
		int sze = (*p_density_vectors)[i].size();
		sizes_p_density_vectors[i] = sze;
		gpu_p_density_vectors[i] = (*p_density_vectors)[i].data();
		#pragma acc enter data copyin(this->gpu_p_density_vectors[i:1][:sze])
	}
	#pragma acc enter data copyin(this->sizes_p_density_vectors[:bin_p_density_vectors])
	// end gpu_p_density_vectors

	// start gpu_thomas_constant1
	const int bin_thomas_constant1 = thomas_constant1.size();

	gpu_thomas_constant1 = new double [bin_thomas_constant1];

	sizes_thomas_constant1 = bin_thomas_constant1;
	#pragma acc enter data create(this->gpu_thomas_constant1[0:bin_thomas_constant1])

		//gpu_thomas_constant1[e] = thomas_constant1.at(e);
		gpu_thomas_constant1 = thomas_constant1.data();

	#pragma acc enter data copyin(this->gpu_thomas_constant1[:bin_thomas_constant1])
	#pragma acc enter data copyin(this->sizes_thomas_constant1)
	// end gpu_thomas_constant1
	
	// start gpu_thomas_denomx
	const int bin_thomas_denomx = thomas_denomx.size();

	gpu_thomas_denomx = new double * [bin_thomas_denomx];

	sizes_thomas_denomx = new int [bin_thomas_denomx];

	#pragma acc enter data create(this->gpu_thomas_denomx[0:bin_thomas_denomx][0:0])
	for (int i = 0; i < bin_thomas_denomx; i ++) {
		int sze = thomas_denomx[i].size();
		gpu_thomas_denomx[i] = thomas_denomx[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_denomx[i:1][:sze])
	}	
	// pragma acc enter data sizes
	// end gpu_thomas_denomx
	
	// start gpu_thomas_denomy
	const int bin_thomas_denomy = thomas_denomy.size();

	gpu_thomas_denomy = new double * [bin_thomas_denomy];

	sizes_thomas_denomy = new int [bin_thomas_denomy];

	#pragma acc enter data create(this->gpu_thomas_denomy[0:bin_thomas_denomy][0:0])
	for (int i = 0; i < bin_thomas_denomy; i ++) {
		int sze = thomas_denomy[i].size();
		gpu_thomas_denomy[i] = thomas_denomy[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_denomy[i:1][:sze])
	}	
	// pragma acc enter data sizes
	// end gpu_thomas_denomy

	// start gpu_thomas_denomz
	const int bin_thomas_denomz = thomas_denomz.size();

	gpu_thomas_denomz = new double * [bin_thomas_denomz];

	sizes_thomas_denomz = new int [bin_thomas_denomz];

	#pragma acc enter data create(this->gpu_thomas_denomz[0:bin_thomas_denomz][0:0])
	for (int i = 0; i < bin_thomas_denomz; i ++) {
		int sze = thomas_denomz[i].size();
		gpu_thomas_denomz[i] = thomas_denomz[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_denomz[i:1][:sze])
	}	
	// pragma acc enter data sizes
	// end gpu_thomas_denomz
	
	// start gpu_thomas_i_jump
	gpu_thomas_i_jump = new int;

	*gpu_thomas_i_jump = thomas_i_jump;

	#pragma acc enter data copyin(this->gpu_thomas_i_jump)
	// end gpu_thomas_i_jump
	
	// start gpu_thomas_j_jump
	gpu_thomas_j_jump = new int;

	*gpu_thomas_j_jump = thomas_j_jump;

	#pragma acc enter data copyin(this->gpu_thomas_j_jump)
	// end gpu_thomas_j_jump
	
	// start gpu_thomas_k_jump
	gpu_thomas_k_jump = new int;

	*gpu_thomas_k_jump = thomas_k_jump;

	#pragma acc enter data copyin(this->gpu_thomas_k_jump)
	// end gpu_thomas_k_jump

	// start gpu_thomas_cx
	const int bin_thomas_cx = thomas_cx.size();

	gpu_thomas_cx = new double * [bin_thomas_cx];

	sizes_thomas_cx = new int [bin_thomas_cx];

	#pragma acc enter data create(this->gpu_thomas_cx[0:bin_thomas_cx][0:0])
	for (int i = 0; i < bin_thomas_cx; i ++) {
		int sze = thomas_cx[i].size();
		gpu_thomas_cx[i] = thomas_cx[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_cx[i:1][:sze])
	}
	// end gpu_thomas_cx
	
	// start gpu_thomas_cy
	const int bin_thomas_cy = thomas_cy.size();

	gpu_thomas_cy = new double * [bin_thomas_cy];

	sizes_thomas_cy = new int [bin_thomas_cy];

	#pragma acc enter data create(this->gpu_thomas_cy[0:bin_thomas_cy][0:0])
	for (int i = 0; i < bin_thomas_cy; i ++) {
		int sze = thomas_cy[i].size();
		gpu_thomas_cy[i] = thomas_cy[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_cy[i:1][:sze])
	}
	// end gpu_thomas_cy
	
	// start gpu_thomas_cz
	const int bin_thomas_cz = thomas_cz.size();

	gpu_thomas_cz = new double * [bin_thomas_cz];

	sizes_thomas_cz = new int [bin_thomas_cz];

	#pragma acc enter data create(this->gpu_thomas_cz[0:bin_thomas_cz][0:0])
	for (int i = 0; i < bin_thomas_cz; i ++) {
		int sze = thomas_cz[i].size();
		gpu_thomas_cz[i] = thomas_cz[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_cz[i:1][:sze])
	}
	// end gpu_thomas_cz

	// start gpu_dirichlet_value_vectors
	const int bin_dirichlet_value_vectors = dirichlet_value_vectors.size();

	gpu_dirichlet_value_vectors = new double * [bin_dirichlet_value_vectors];

	sizes_dirichlet_value_vectors = new int [bin_dirichlet_value_vectors];

	#pragma acc enter data create(this->gpu_dirichlet_value_vectors[0:bin_dirichlet_value_vectors][0:0])
	for (int i = 0; i < bin_dirichlet_value_vectors; i++) {
		int sze = dirichlet_value_vectors[i].size();
		sizes_dirichlet_value_vectors[i] = sze;
		gpu_dirichlet_value_vectors[i] = dirichlet_value_vectors[i].data();
		#pragma acc enter data copyin(this->gpu_dirichlet_value_vectors[i:1][:sze])
	}	
	#pragma acc enter data copyin(this->sizes_dirichlet_value_vectors[:bin_dirichlet_value_vectors])
	// end gpu_dirichlet_value_vectors
	
	// start gpu_dirichlet_activation_vector
	const int bin_dirichlet_activation_vector = dirichlet_activation_vector.size();

	gpu_dirichlet_activation_vector = new bool [bin_dirichlet_activation_vector];

//	#pragma acc enter data create(this->gpu_dirichlet_activation_vector[0:bin_dirichlet_activation_vector])
	for (int i = 0; i < bin_dirichlet_activation_vector; i++) {
		gpu_dirichlet_activation_vector[i] = dirichlet_activation_vector.at(i);
	}
		/*
 		*potential error here, move copyin to inside interation?
 		*/
	#pragma acc enter data copyin(this->gpu_dirichlet_activation_vector[:bin_dirichlet_activation_vector])
	// end gpu_dirichlet_activation_vector
	
	// start gpu_voxel_is_dirichlet
	const int bin_mesh = mesh.voxels.size();

	gpu_voxels_is_dirichlet = new bool [bin_mesh];

//	#pragma acc enter data create(this->gpu_voxels_is_dirichlet[0:bin_mesh])
	for (int i = 0; i < bin_mesh; i ++) {
		gpu_voxels_is_dirichlet[i] = mesh.voxels[i].is_Dirichlet;
	}
	#pragma acc enter data copyin(this->gpu_voxels_is_dirichlet[:bin_mesh])
	// end gpu_voxel_is_dirichlet
	

	// Below is num_dirichlet
	num_dirichlet = 0;
	#pragma acc enter data create(this->num_dirichlet)
	// End num_dirichlet

	std::cout << "Done transfer" << std::endl;
}

#pragma acc routine
void Microenvironment::axpy_acc( double* y, double* a , double* x, int size )
{
// #pragma acc parallel loop
 for( int i=0; i < size ; i++ )
 {
  y[i] += a[i] * x[i] ; 
 }
 return; 
}

#pragma acc routine
void Microenvironment::naxpy_acc( double* y, double* a , double* x, int size )
{
// #pragma acc parallel loop
 for( int i=0; i < size ; i++ )
 {
  y[i] -= a[i] * x[i] ; 
 }
 return; 
}

void Microenvironment::apply_dirichlet_conditions_GPU( void ) {
	int mesh_size = mesh.voxels.size();

	#pragma acc parallel loop present(gpu_p_density_vectors, gpu_dirichlet_value_vectors, sizes_dirichlet_value_vectors, gpu_dirichlet_activation_vector, gpu_voxels_is_dirichlet, num_dirichlet)
	for (int i = 0; i < mesh_size; i ++){
		//if (mesh.voxels[i].is_Dirichlet == true){
		if (gpu_voxels_is_dirichlet[i] == true){
					num_dirichlet ++;
			for (int j = 0; j < sizes_dirichlet_value_vectors[i]; j++) {
					num_dirichlet ++;
				if ( gpu_dirichlet_activation_vector[j] == true) {
					gpu_p_density_vectors[i][j] = gpu_dirichlet_value_vectors[i][j];
					//density_vector_GPU(i)[j] = gpu_dirichlet_value_vectors[i][j];
					// TEST whether or not it goes this far with an int
					num_dirichlet ++;
				}
			}
		}
	}	

	return;
}

// X-Diffusion GPU for 2D
void Microenvironment::x_diffusion_GPU_2D(){

	int x_size = mesh.x_coordinates.size();
	int y_size = mesh.y_coordinates.size();

	#pragma acc parallel loop present(gpu_p_density_vectors, sizes_p_density_vectors, gpu_thomas_denomx, gpu_thomas_i_jump, gpu_thomas_cx) 
	for ( int j=0; j < y_size ; j++ ) {
		int n = voxel_index(0, j, 0);
		#pragma acc loop seq 
		for (int q = 0; q < sizes_p_density_vectors[n]; q++)
			{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomx[0][q];}
		n += *gpu_thomas_i_jump;
		#pragma acc loop seq
		for (int i=1; i < x_size ; i++) {
			axpy_acc(gpu_p_density_vectors[n], gpu_thomas_constant1, gpu_p_density_vectors[n-*gpu_thomas_i_jump], sizes_p_density_vectors[n]);
			/*
			#pragma acc loop seq
			for (int k = 0; k < 3; k++) {
				gpu_p_density_vectors[n][k] += gpu_thomas_constant1[k] * gpu_p_density_vectors[n- (*gpu_thomas_i_jump)][k];
			}
			*/
			#pragma acc loop seq
			for (int q = 0; q < sizes_p_density_vectors[n]; q++)
				{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomx[i][q]; }

			n += *gpu_thomas_i_jump;
		}

		// back substitution
		n = voxel_index(x_size-2, j, 0);
		#pragma acc loop seq
		for (int i = x_size-2 ; i >= 0 ; i--) {
			naxpy_acc(gpu_p_density_vectors[n], gpu_thomas_cx[i], gpu_p_density_vectors[n+*gpu_thomas_i_jump], sizes_p_density_vectors[n]);
			/*
			#pragma acc loop seq
			for (int k = 0; k < 3; k++) {
				gpu_p_density_vectors[n][k] -= gpu_thomas_cx[i][k] * gpu_p_density_vectors[n+ (*gpu_thomas_i_jump)][k];
			}
			*/
			n -= *gpu_thomas_i_jump;
		}
	}
//	std::cout << "Done x_diffusion_acc" << std::endl;

}
// end X-Diffusion GPU for 2D

// Y-Diffusion GPU for 2D
void Microenvironment::y_diffusion_GPU_2D(){

	int x_size = mesh.x_coordinates.size();
	int y_size = mesh.y_coordinates.size();

	#pragma acc parallel loop present(gpu_p_density_vectors, sizes_p_density_vectors, gpu_thomas_denomy, gpu_thomas_j_jump, gpu_thomas_cy) 
	for ( int i=0; i < x_size ; i++ ) {
		int n = voxel_index(i, 0, 0);
		#pragma acc loop seq 
		for (int q = 0; q < sizes_p_density_vectors[n]; q++)
			{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomy[0][q];}
		n += *gpu_thomas_j_jump;
		#pragma acc loop seq
		for (int j=1; j < y_size ; j++) {
			axpy_acc(gpu_p_density_vectors[n], gpu_thomas_constant1, gpu_p_density_vectors[n-*gpu_thomas_j_jump], sizes_p_density_vectors[n]);
			/*
			#pragma acc loop seq
			for (int k = 0; k < 3; k++) {
				gpu_p_density_vectors[n][k] += gpu_thomas_constant1[k] * gpu_p_density_vectors[n- (*gpu_thomas_i_jump)][k];
			}
			*/
			#pragma acc loop seq
			for (int q = 0; q < sizes_p_density_vectors[n]; q++)
				{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomy[j][q]; }

			n += *gpu_thomas_j_jump;
		}

		// back substitution
		n = voxel_index(i, y_size-2, 0);
		#pragma acc loop seq
		for (int j = y_size-2 ; j >= 0 ; j--) {
			naxpy_acc(gpu_p_density_vectors[n], gpu_thomas_cy[j], gpu_p_density_vectors[n+*gpu_thomas_j_jump], sizes_p_density_vectors[n]);
			/*
			#pragma acc loop seq
			for (int k = 0; k < 3; k++) {
				gpu_p_density_vectors[n][k] -= gpu_thomas_cx[i][k] * gpu_p_density_vectors[n+ (*gpu_thomas_i_jump)][k];
			}
			*/
			n -= *gpu_thomas_j_jump;
		}
	}
//	std::cout << "Done y_diffusion_acc" << std::endl;

}
// end Y-Diffusion GPU for 2D

// X-Diffusion GPU for 3D
void Microenvironment::x_diffusion_GPU_3D(){

	int x_size = mesh.x_coordinates.size();
	int y_size = mesh.y_coordinates.size();
	int z_size = mesh.z_coordinates.size();

	#pragma acc parallel present(gpu_p_density_vectors, sizes_p_density_vectors, gpu_thomas_denomx, gpu_thomas_i_jump, gpu_thomas_cx) 
	{
	#pragma acc loop independent gang
	for ( int k= 0; k < z_size; k++ )
	{
		#pragma acc loop independent vector
		for ( int j=0; j < y_size ; j++ ) 
		{
			int n = voxel_index(0, j, k);
			#pragma acc loop seq 
			for (int q = 0; q < sizes_p_density_vectors[n]; q++)
				{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomx[0][q];}

			#pragma acc loop seq
			for (int i=1; i < x_size ; i++) 
			{
				n = voxel_index(i, j, k);
				axpy_acc(gpu_p_density_vectors[n], gpu_thomas_constant1, gpu_p_density_vectors[n-*gpu_thomas_i_jump], sizes_p_density_vectors[n]);
				#pragma acc loop seq
			 	for (int q = 0; q < sizes_p_density_vectors[n]; q++)
					{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomx[i][q]; }
	
			}
	
			// back substitution
			// n = voxel_index(x_size-2, j, 0);
			#pragma acc loop seq
			for (int i = x_size-2 ; i >= 0 ; i--) 
			{
				n = voxel_index(i, j, k);
				naxpy_acc(gpu_p_density_vectors[n], gpu_thomas_cx[i], gpu_p_density_vectors[n+*gpu_thomas_i_jump], sizes_p_density_vectors[n]);
			}
		}
	}
//	std::cout << "Done x_diffusion_acc" << std::endl;

	} // end of parallel region
}
// end X-Diffusion GPU for 3D

// Y-Diffusion GPU for 3D
void Microenvironment::y_diffusion_GPU_3D(){

	int x_size = mesh.x_coordinates.size();
	int y_size = mesh.y_coordinates.size();
	int z_size = mesh.z_coordinates.size();

	#pragma acc parallel present(gpu_p_density_vectors, sizes_p_density_vectors, gpu_thomas_denomy, gpu_thomas_j_jump, gpu_thomas_cy) 
	{
	#pragma acc loop independent gang
	for ( int k= 0; k < z_size; k++ )
	{
		#pragma acc loop independent vector
		for ( int i=0; i < x_size ; i++ ) 
		{
			int n = voxel_index(i, 0, k);
			#pragma acc loop seq 
			for (int q = 0; q < sizes_p_density_vectors[n]; q++)
				{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomy[0][q];}

			#pragma acc loop seq
			for (int j=1; j < y_size ; j++) 
			{
				n = voxel_index(i, j, k);
				axpy_acc(gpu_p_density_vectors[n], gpu_thomas_constant1, gpu_p_density_vectors[n-*gpu_thomas_j_jump], sizes_p_density_vectors[n]);
				#pragma acc loop seq
				for (int q = 0; q < sizes_p_density_vectors[n]; q++)
					{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomy[j][q]; }
	
			}
	
			// back substitution
			// n = voxel_index(x_size-2, j, k);
			#pragma acc loop seq
			for (int j = y_size-2 ; j >= 0 ; j--) 
			{
				n = voxel_index(i, j, k);
				naxpy_acc(gpu_p_density_vectors[n], gpu_thomas_cy[j], gpu_p_density_vectors[n+*gpu_thomas_j_jump], sizes_p_density_vectors[n]);
			}
		}
	}
//	std::cout << "Done y_diffusion_acc" << std::endl;

	} // end of parallel region
}
// end Y-Diffusion GPU for 3D

// Z-Diffusion GPU for 3D
void Microenvironment::z_diffusion_GPU_3D(){

	int x_size = mesh.x_coordinates.size();
	int y_size = mesh.y_coordinates.size();
	int z_size = mesh.z_coordinates.size();

	#pragma acc parallel present(gpu_p_density_vectors, sizes_p_density_vectors, gpu_thomas_denomz, gpu_thomas_k_jump, gpu_thomas_cz) 
	{	
	#pragma acc loop independent gang
	for ( int j= 0; j < y_size; j++ )
	{
		#pragma acc loop independent vector
		for ( int i=0; i < x_size ; i++ ) 
		{
			int n = voxel_index(i, j, 0);
			#pragma acc loop seq 
			for (int q = 0; q < sizes_p_density_vectors[n]; q++)
				{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomz[0][q];}

			#pragma acc loop seq
			for (int k=1; k < z_size ; k++) 
			{
				n = voxel_index(i, j, k);
				axpy_acc(gpu_p_density_vectors[n], gpu_thomas_constant1, gpu_p_density_vectors[n-*gpu_thomas_k_jump], sizes_p_density_vectors[n]);
				#pragma acc loop seq
				for (int q = 0; q < sizes_p_density_vectors[n]; q++)
					{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomz[k][q]; }
	
			}
	
			// back substitution
			// n = voxel_index(x_size-2, j, k);
			#pragma acc loop seq
			for (int k = z_size-2 ; k >= 0 ; k--) 
			{
				n = voxel_index(i, j, k);
				naxpy_acc(gpu_p_density_vectors[n], gpu_thomas_cz[k], gpu_p_density_vectors[n+*gpu_thomas_k_jump], sizes_p_density_vectors[n]);
			}
		}
	}
//	std::cout << "Done x_diffusion_acc" << std::endl;
	} // end of parallel region
}
// end Z-Diffusion GPU for 3D

void Microenvironment::translate_vector_to_array()
	/* translate_vector_to_array is actually an update between the two versions
	 * of p_density_vector (DEVICE = gpu_p_density_vector, HOST = p_density_vector),
	 * updating the device with the current values of the 
	 * host p_density_vector
	 */
{
	const int bin_p_density_vectors = (*p_density_vectors).size();

	for (int i = 0; i < bin_p_density_vectors; i++){
		int sze = (*p_density_vectors)[i].size();
		sizes_p_density_vectors[i] = sze;
		gpu_p_density_vectors[i] = (*p_density_vectors)[i].data();
		#pragma acc update device(this->gpu_p_density_vectors[i:1][:sze])
	}
	#pragma acc update device(this->sizes_p_density_vectors[:bin_p_density_vectors])
	
}

void Microenvironment::translate_array_to_vector()
	/* translate_array_to_vector is actually an update between the two versions
	 * of p_density_vector (DEVICE = gpu_p_density_vector, HOST = p_density_vector),
	 * updating the host with the current values of the 
	 * device gpu_p_density_vector
	 */
{
	const int bin_p_density_vectors = (*p_density_vectors).size();

	for (int i = 0; i < bin_p_density_vectors; i++){
		int sze = (*p_density_vectors)[i].size();
		#pragma acc update host(this->gpu_p_density_vectors[i:1][:sze])
	}
	#pragma acc update host(this->sizes_p_density_vectors[:bin_p_density_vectors])

	for (int i = 0; i < bin_p_density_vectors; i++) {
		for (int j = 0; j < this->sizes_p_density_vectors[i]; j++) {
			(*p_density_vectors)[i][j] = this->gpu_p_density_vectors[i][j];
		}
	}

	// Below is num_dirichlet
	#pragma acc update host(this->num_dirichlet)
	// End num_dirichlet
}

};

########## NEXT FILE ##########
BioFVM_solvers.cpp:::
/*
#############################################################################
# If you use BioFVM in your project, please cite BioFVM and the version     #
# number, such as below:                                                    #
#                                                                           #
# We solved the diffusion equations using BioFVM (Version 1.1.7) [1]        #
#                                                                           #
# [1] A. Ghaffarizadeh, S.H. Friedman, and P. Macklin, BioFVM: an efficient #
#    parallelized diffusive transport solver for 3-D biological simulations,#
#    Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730 #
#                                                                           #
#############################################################################
#                                                                           #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)   #
#                                                                           #
# Copyright (c) 2015-2017, Paul Macklin and the BioFVM Project              #
# All rights reserved.                                                      #
#                                                                           #
# Redistribution and use in source and binary forms, with or without        #
# modification, are permitted provided that the following conditions are    #
# met:                                                                      #
#                                                                           #
# 1. Redistributions of source code must retain the above copyright notice, #
# this list of conditions and the following disclaimer.                     #
#                                                                           #
# 2. Redistributions in binary form must reproduce the above copyright      #
# notice, this list of conditions and the following disclaimer in the       #
# documentation and/or other materials provided with the distribution.      #
#                                                                           #
# 3. Neither the name of the copyright holder nor the names of its          #
# contributors may be used to endorse or promote products derived from this #
# software without specific prior written permission.                       #
#                                                                           #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS       #
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED #
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A           #
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER #
# OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  #
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,       #
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR        #
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF    #
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING      #
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS        #
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.              #
#                                                                           #
#############################################################################
*/

#include "BioFVM_solvers.h" 
#include "BioFVM_vector.h" 

#include <iostream>
#include <omp.h>
#include <openacc.h>

namespace BioFVM{

// do I even need this? 
void diffusion_decay_solver__constant_coefficients_explicit( Microenvironment& M, double dt )
{
	static bool precomputations_and_constants_done = false; 
	if( !precomputations_and_constants_done )
	{
		std::cout	<< std::endl << "Using solver: " << __FUNCTION__ << std::endl 
					<< "     (constant diffusion coefficient with explicit stepping, implicit decay) ... " << std::endl << std::endl;  

		if( M.mesh.uniform_mesh == true )
		{
			std::cout << "Uniform mesh detected! Consider switching to a more efficient method, such as " << std::endl  
			<< "     diffusion_decay_solver__constant_coefficients_explicit_uniform_mesh" << std::endl  
			<< std::endl; 
		}

		precomputations_and_constants_done = true; 
	}

	return; 
}

void diffusion_decay_solver__constant_coefficients_explicit_uniform_mesh( Microenvironment& M, double dt )
{
	static bool precomputations_and_constants_done = false; 
	if( !precomputations_and_constants_done )
	{
		std::cout	<< std::endl << "Using solver: " << __FUNCTION__ << std::endl 
					<< "     (constant diffusion coefficient with explicit stepping, implicit decay, uniform mesh) ... " << std::endl << std::endl;  

		if( M.mesh.uniform_mesh == false )
		{ std::cout << "Error. This code is only supported for uniform meshes." << std::endl; }

		precomputations_and_constants_done = true; 
	}

	return; 
}

void diffusion_decay_solver__constant_coefficients_LOD_3D( Microenvironment& M, double dt )
{
	if( M.mesh.uniform_mesh == false || M.mesh.Cartesian_mesh == false )
	{
		std::cout << "Error: This algorithm is written for uniform Cartesian meshes. Try: other solvers!" << std::endl << std::endl; 
	return; 
	}

	// define constants and pre-computed quantities 
	
	if( !M.diffusion_solver_setup_done )
	{
		std::cout << std::endl << "Using method " << __FUNCTION__ << " (implicit 3-D LOD with Thomas Algorithm) ... " 
		<< std::endl << std::endl;  
		
		M.thomas_denomx.resize( M.mesh.x_coordinates.size() , M.zero );
		M.thomas_cx.resize( M.mesh.x_coordinates.size() , M.zero );

		M.thomas_denomy.resize( M.mesh.y_coordinates.size() , M.zero );
		M.thomas_cy.resize( M.mesh.y_coordinates.size() , M.zero );
		
		M.thomas_denomz.resize( M.mesh.z_coordinates.size() , M.zero );
		M.thomas_cz.resize( M.mesh.z_coordinates.size() , M.zero );

		M.thomas_i_jump = 1; 
		M.thomas_j_jump = M.mesh.x_coordinates.size(); 
		M.thomas_k_jump = M.thomas_j_jump * M.mesh.y_coordinates.size(); 

		M.thomas_constant1 =  M.diffusion_coefficients; // dt*D/dx^2 
		M.thomas_constant1a = M.zero; // -dt*D/dx^2; 
		M.thomas_constant2 =  M.decay_rates; // (1/3)* dt*lambda 
		M.thomas_constant3 = M.one; // 1 + 2*constant1 + constant2; 
		M.thomas_constant3a = M.one; // 1 + constant1 + constant2; 		
			
		M.thomas_constant1 *= dt; 
		M.thomas_constant1 /= M.mesh.dx; 
		M.thomas_constant1 /= M.mesh.dx; 

		M.thomas_constant1a = M.thomas_constant1; 
		M.thomas_constant1a *= -1.0; 

		M.thomas_constant2 *= dt; 
		M.thomas_constant2 /= 3.0; // for the LOD splitting of the source 

		M.thomas_constant3 += M.thomas_constant1; 
		M.thomas_constant3 += M.thomas_constant1; 
		M.thomas_constant3 += M.thomas_constant2; 

		M.thomas_constant3a += M.thomas_constant1; 
		M.thomas_constant3a += M.thomas_constant2; 

		// Thomas solver coefficients 

		M.thomas_cx.assign( M.mesh.x_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomx.assign( M.mesh.x_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomx[0] = M.thomas_constant3a; 
		M.thomas_denomx[ M.mesh.x_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.x_coordinates.size() == 1 )
		{ M.thomas_denomx[0] = M.one; M.thomas_denomx[0] += M.thomas_constant2; } 

		M.thomas_cx[0] /= M.thomas_denomx[0]; 
		for( unsigned int i=1 ; i <= M.mesh.x_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomx[i] , M.thomas_constant1 , M.thomas_cx[i-1] ); 
			M.thomas_cx[i] /= M.thomas_denomx[i]; // the value at  size-1 is not actually used  
		}

		M.thomas_cy.assign( M.mesh.y_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomy.assign( M.mesh.y_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomy[0] = M.thomas_constant3a; 
		M.thomas_denomy[ M.mesh.y_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.y_coordinates.size() == 1 )
		{ M.thomas_denomy[0] = M.one; M.thomas_denomy[0] += M.thomas_constant2; } 

		M.thomas_cy[0] /= M.thomas_denomy[0]; 
		for( unsigned int i=1 ; i <= M.mesh.y_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomy[i] , M.thomas_constant1 , M.thomas_cy[i-1] ); 
			M.thomas_cy[i] /= M.thomas_denomy[i]; // the value at  size-1 is not actually used  
		}

		M.thomas_cz.assign( M.mesh.z_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomz.assign( M.mesh.z_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomz[0] = M.thomas_constant3a; 
		M.thomas_denomz[ M.mesh.z_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.z_coordinates.size() == 1 )
		{ M.thomas_denomz[0] = M.one; M.thomas_denomz[0] += M.thomas_constant2; } 

		M.thomas_cz[0] /= M.thomas_denomz[0]; 
		for( unsigned int i=1 ; i <= M.mesh.z_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomz[i] , M.thomas_constant1 , M.thomas_cz[i-1] ); 
			M.thomas_cz[i] /= M.thomas_denomz[i]; // the value at  size-1 is not actually used  
		}	

		M.diffusion_solver_setup_done = true; 
	}

	// x-diffusion 
	
	M.apply_dirichlet_conditions();
	#pragma omp parallel for 
	for( unsigned int k=0; k < M.mesh.z_coordinates.size() ; k++ )
	{
		for( unsigned int j=0; j < M.mesh.y_coordinates.size() ; j++ )
		{
			// Thomas solver, x-direction

			// remaining part of forward elimination, using pre-computed quantities 
			int n = M.voxel_index(0,j,k);
			(*M.p_density_vectors)[n] /= M.thomas_denomx[0]; 

			for( unsigned int i=1; i < M.mesh.x_coordinates.size() ; i++ )
			{
				n = M.voxel_index(i,j,k); 
				axpy( &(*M.p_density_vectors)[n] , M.thomas_constant1 , (*M.p_density_vectors)[n-M.thomas_i_jump] ); 
				(*M.p_density_vectors)[n] /= M.thomas_denomx[i]; 
			}

			for( int i = M.mesh.x_coordinates.size()-2 ; i >= 0 ; i-- )
			{
				n = M.voxel_index(i,j,k); 
				naxpy( &(*M.p_density_vectors)[n] , M.thomas_cx[i] , (*M.p_density_vectors)[n+M.thomas_i_jump] ); 
			}

		}
	}

	// y-diffusion 

	M.apply_dirichlet_conditions();
	#pragma omp parallel for 
	for( unsigned int k=0; k < M.mesh.z_coordinates.size() ; k++ )
	{
		for( unsigned int i=0; i < M.mesh.x_coordinates.size() ; i++ )
		{
   // Thomas solver, y-direction

	// remaining part of forward elimination, using pre-computed quantities 

	int n = M.voxel_index(i,0,k);
	(*M.p_density_vectors)[n] /= M.thomas_denomy[0]; 

	for( unsigned int j=1; j < M.mesh.y_coordinates.size() ; j++ )
	{
		n = M.voxel_index(i,j,k); 
		axpy( &(*M.p_density_vectors)[n] , M.thomas_constant1 , (*M.p_density_vectors)[n-M.thomas_j_jump] ); 
		(*M.p_density_vectors)[n] /= M.thomas_denomy[j]; 
	}

	// back substitution 
	// n = voxel_index( mesh.x_coordinates.size()-2 ,j,k); 

	for( int j = M.mesh.y_coordinates.size()-2 ; j >= 0 ; j-- )
	{
		n = M.voxel_index(i,j,k); 
		naxpy( &(*M.p_density_vectors)[n] , M.thomas_cy[j] , (*M.p_density_vectors)[n+M.thomas_j_jump] ); 
	}

  }
 }

 // z-diffusion 

	M.apply_dirichlet_conditions();
 #pragma omp parallel for 
 for( unsigned int j=0; j < M.mesh.y_coordinates.size() ; j++ )
 {
	 
  for( unsigned int i=0; i < M.mesh.x_coordinates.size() ; i++ )
  {
   // Thomas solver, y-direction

	// remaining part of forward elimination, using pre-computed quantities 

	int n = M.voxel_index(i,j,0);
	(*M.p_density_vectors)[n] /= M.thomas_denomz[0]; 

	// should be an empty loop if mesh.z_coordinates.size() < 2  
	for( unsigned int k=1; k < M.mesh.z_coordinates.size() ; k++ )
	{
		n = M.voxel_index(i,j,k); 
		axpy( &(*M.p_density_vectors)[n] , M.thomas_constant1 , (*M.p_density_vectors)[n-M.thomas_k_jump] ); 
		(*M.p_density_vectors)[n] /= M.thomas_denomz[k]; 
	}

	// back substitution 

	// should be an empty loop if mesh.z_coordinates.size() < 2 
	for( int k = M.mesh.z_coordinates.size()-2 ; k >= 0 ; k-- )
	{
		n = M.voxel_index(i,j,k); 
		naxpy( &(*M.p_density_vectors)[n] , M.thomas_cz[k] , (*M.p_density_vectors)[n+M.thomas_k_jump] ); 
		// n -= i_jump; 
	}
  }
 }
 
	M.apply_dirichlet_conditions();
	
	// reset gradient vectors 
//	M.reset_all_gradient_vectors(); 

	return; 
}

void diffusion_decay_solver__constant_coefficients_LOD_3D_GPU( Microenvironment& M, double dt )
{

	if( M.mesh.uniform_mesh == false || M.mesh.Cartesian_mesh == false )
	{
		std::cout << "Error: This algorithm is written for uniform Cartesian meshes. Try: other solvers!" << std::endl << std::endl; 
	return; 
	}

	// define constants and pre-computed quantities 
	
	if( !M.diffusion_solver_setup_done )
	{
		std::cout << std::endl << "Using method " << __FUNCTION__ << " (implicit 3-D GPU  LOD with Thomas Algorithm) ... " 
		<< std::endl << std::endl;  
		
		M.thomas_denomx.resize( M.mesh.x_coordinates.size() , M.zero );
		M.thomas_cx.resize( M.mesh.x_coordinates.size() , M.zero );

		M.thomas_denomy.resize( M.mesh.y_coordinates.size() , M.zero );
		M.thomas_cy.resize( M.mesh.y_coordinates.size() , M.zero );
		
		M.thomas_denomz.resize( M.mesh.z_coordinates.size() , M.zero );
		M.thomas_cz.resize( M.mesh.z_coordinates.size() , M.zero );

		M.thomas_i_jump = 1; 
		M.thomas_j_jump = M.mesh.x_coordinates.size(); 
		M.thomas_k_jump = M.thomas_j_jump * M.mesh.y_coordinates.size(); 

		M.thomas_constant1 =  M.diffusion_coefficients; // dt*D/dx^2 
		M.thomas_constant1a = M.zero; // -dt*D/dx^2; 
		M.thomas_constant2 =  M.decay_rates; // (1/3)* dt*lambda 
		M.thomas_constant3 = M.one; // 1 + 2*constant1 + constant2; 
		M.thomas_constant3a = M.one; // 1 + constant1 + constant2; 		
			
		M.thomas_constant1 *= dt; 
		M.thomas_constant1 /= M.mesh.dx; 
		M.thomas_constant1 /= M.mesh.dx; 

		M.thomas_constant1a = M.thomas_constant1; 
		M.thomas_constant1a *= -1.0; 

		M.thomas_constant2 *= dt; 
		M.thomas_constant2 /= 3.0; // for the LOD splitting of the source 

		M.thomas_constant3 += M.thomas_constant1; 
		M.thomas_constant3 += M.thomas_constant1; 
		M.thomas_constant3 += M.thomas_constant2; 

		M.thomas_constant3a += M.thomas_constant1; 
		M.thomas_constant3a += M.thomas_constant2; 

		// Thomas solver coefficients 

		M.thomas_cx.assign( M.mesh.x_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomx.assign( M.mesh.x_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomx[0] = M.thomas_constant3a; 
		M.thomas_denomx[ M.mesh.x_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.x_coordinates.size() == 1 )
		{ M.thomas_denomx[0] = M.one; M.thomas_denomx[0] += M.thomas_constant2; } 

		M.thomas_cx[0] /= M.thomas_denomx[0]; 
		for( unsigned int i=1 ; i <= M.mesh.x_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomx[i] , M.thomas_constant1 , M.thomas_cx[i-1] ); 
			M.thomas_cx[i] /= M.thomas_denomx[i]; // the value at  size-1 is not actually used  
		}

		M.thomas_cy.assign( M.mesh.y_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomy.assign( M.mesh.y_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomy[0] = M.thomas_constant3a; 
		M.thomas_denomy[ M.mesh.y_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.y_coordinates.size() == 1 )
		{ M.thomas_denomy[0] = M.one; M.thomas_denomy[0] += M.thomas_constant2; } 

		M.thomas_cy[0] /= M.thomas_denomy[0]; 
		for( unsigned int i=1 ; i <= M.mesh.y_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomy[i] , M.thomas_constant1 , M.thomas_cy[i-1] ); 
			M.thomas_cy[i] /= M.thomas_denomy[i]; // the value at  size-1 is not actually used  
		}

		M.thomas_cz.assign( M.mesh.z_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomz.assign( M.mesh.z_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomz[0] = M.thomas_constant3a; 
		M.thomas_denomz[ M.mesh.z_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.z_coordinates.size() == 1 )
		{ M.thomas_denomz[0] = M.one; M.thomas_denomz[0] += M.thomas_constant2; } 

		M.thomas_cz[0] /= M.thomas_denomz[0]; 
		for( unsigned int i=1 ; i <= M.mesh.z_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomz[i] , M.thomas_constant1 , M.thomas_cz[i-1] ); 
			M.thomas_cz[i] /= M.thomas_denomz[i]; // the value at  size-1 is not actually used  
		}	

		M.diffusion_solver_setup_done = true; 
	}

	if (M.openacc_data_bool == false){
		std::cout << "transfering to device" << std::endl;
		M.transfer_3D();
		std::cout << "-continuing-" << std::endl;
		M.openacc_data_bool = true;
	}
	else {
		//M.translate_vector_to_array(); // used for updating Device if work
		// was done on Host
	}

	
	M.apply_dirichlet_conditions_GPU();

	// z-diffusion on gpu
	M.x_diffusion_GPU_3D();

	M.apply_dirichlet_conditions_GPU();

	// y-diffusion on gpu
	M.y_diffusion_GPU_3D();

	M.apply_dirichlet_conditions_GPU();

	// z-diffusion on gpu 
	M.z_diffusion_GPU_3D();

	M.apply_dirichlet_conditions_GPU();

	// reset gradient vectors 
	//M.reset_all_gradient_vectors(); 

	return; 
}

void diffusion_decay_solver__constant_coefficients_LOD_2D( Microenvironment& M, double dt )
{
	if( M.mesh.uniform_mesh == false )
	{
		std::cout << "Error: This algorithm is written for uniform Cartesian meshes. Try: something else." << std::endl << std::endl; 
		return; 
	}
	
	// constants for the linear solver (Thomas algorithm) 
	
	if( !M.diffusion_solver_setup_done )
	{
		std::cout << std::endl << "Using method " << __FUNCTION__ << " (2D LOD with Thomas Algorithm) ... " << std::endl << std::endl;  
		
		M.thomas_denomx.resize( M.mesh.x_coordinates.size() , M.zero );
		M.thomas_cx.resize( M.mesh.x_coordinates.size() , M.zero );

		M.thomas_denomy.resize( M.mesh.y_coordinates.size() , M.zero );
		M.thomas_cy.resize( M.mesh.y_coordinates.size() , M.zero );
		
		// define constants and pre-computed quantities 

		M.thomas_i_jump = 1; 
		M.thomas_j_jump = M.mesh.x_coordinates.size(); 

		M.thomas_constant1 =  M.diffusion_coefficients; //   dt*D/dx^2 
		M.thomas_constant1a = M.zero; // -dt*D/dx^2; 
		M.thomas_constant2 =  M.decay_rates; // (1/2)*dt*lambda 
		M.thomas_constant3 = M.one; // 1 + 2*constant1 + constant2; 
		M.thomas_constant3a = M.one; // 1 + constant1 + constant2; 
		
		M.thomas_constant1 *= dt; 
		M.thomas_constant1 /= M.mesh.dx; 
		M.thomas_constant1 /= M.mesh.dx; 

		M.thomas_constant1a = M.thomas_constant1; 
		M.thomas_constant1a *= -1.0; 

		M.thomas_constant2 *= dt; 
		M.thomas_constant2 *= 0.5; // for splitting via LOD

		M.thomas_constant3 += M.thomas_constant1; 
		M.thomas_constant3 += M.thomas_constant1; 
		M.thomas_constant3 += M.thomas_constant2; 

		M.thomas_constant3a += M.thomas_constant1; 
		M.thomas_constant3a += M.thomas_constant2; 
		
		// Thomas solver coefficients 

		M.thomas_cx.assign( M.mesh.x_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomx.assign( M.mesh.x_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomx[0] = M.thomas_constant3a; 
		M.thomas_denomx[ M.mesh.x_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.x_coordinates.size() == 1 )
		{ M.thomas_denomx[0] = M.one; M.thomas_denomx[0] += M.thomas_constant2; } 

		M.thomas_cx[0] /= M.thomas_denomx[0]; 
		for( unsigned int i=1 ; i <= M.mesh.x_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomx[i] , M.thomas_constant1 , M.thomas_cx[i-1] ); 
			M.thomas_cx[i] /= M.thomas_denomx[i]; // the value at  size-1 is not actually used  
		}

		M.thomas_cy.assign( M.mesh.y_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomy.assign( M.mesh.y_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomy[0] = M.thomas_constant3a; 
		M.thomas_denomy[ M.mesh.y_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.y_coordinates.size() == 1 )
		{ M.thomas_denomy[0] = M.one; M.thomas_denomy[0] += M.thomas_constant2; } 

		M.thomas_cy[0] /= M.thomas_denomy[0]; 
		for( unsigned int i=1 ; i <= M.mesh.y_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomy[i] , M.thomas_constant1 , M.thomas_cy[i-1] ); 
			M.thomas_cy[i] /= M.thomas_denomy[i]; // the value at  size-1 is not actually used  
		}

		M.diffusion_solver_setup_done = true; 
	}

	// set the pointer
	
	M.apply_dirichlet_conditions();

	// x-diffusion 
	#pragma omp parallel for 
	for( unsigned int j=0; j < M.mesh.y_coordinates.size() ; j++ )
	{
		// Thomas solver, x-direction

		// remaining part of forward elimination, using pre-computed quantities 
		unsigned int n = M.voxel_index(0,j,0);
		(*M.p_density_vectors)[n] /= M.thomas_denomx[0]; 

		n += M.thomas_i_jump; 
		for( unsigned int i=1; i < M.mesh.x_coordinates.size() ; i++ )
		{
			axpy( &(*M.p_density_vectors)[n] , M.thomas_constant1 , (*M.p_density_vectors)[n-M.thomas_i_jump] ); 
			(*M.p_density_vectors)[n] /= M.thomas_denomx[i]; 
			n += M.thomas_i_jump; 
		}

		// back substitution 
		n = M.voxel_index( M.mesh.x_coordinates.size()-2 ,j,0); 

		for( int i = M.mesh.x_coordinates.size()-2 ; i >= 0 ; i-- )
		{
			naxpy( &(*M.p_density_vectors)[n] , M.thomas_cx[i] , (*M.p_density_vectors)[n+M.thomas_i_jump] ); 
			n -= M.thomas_i_jump; 
		}
	}

	// y-diffusion 

	M.apply_dirichlet_conditions();
	#pragma omp parallel for 
	for( unsigned int i=0; i < M.mesh.x_coordinates.size() ; i++ )
	{
		// Thomas solver, y-direction

		// remaining part of forward elimination, using pre-computed quantities 

		int n = M.voxel_index(i,0,0);
		(*M.p_density_vectors)[n] /= M.thomas_denomy[0]; 

		n += M.thomas_j_jump; 
		for( unsigned int j=1; j < M.mesh.y_coordinates.size() ; j++ )
		{
			axpy( &(*M.p_density_vectors)[n] , M.thomas_constant1 , (*M.p_density_vectors)[n-M.thomas_j_jump] ); 
			(*M.p_density_vectors)[n] /= M.thomas_denomy[j]; 
			n += M.thomas_j_jump; 
		}

		// back substitution 
		n = M.voxel_index( i,M.mesh.y_coordinates.size()-2, 0); 

		for( int j = M.mesh.y_coordinates.size()-2 ; j >= 0 ; j-- )
		{
			naxpy( &(*M.p_density_vectors)[n] , M.thomas_cy[j] , (*M.p_density_vectors)[n+M.thomas_j_jump] ); 
			n -= M.thomas_j_jump; 
		}
	}

	M.apply_dirichlet_conditions();
	
	// reset gradient vectors 
//	M.reset_all_gradient_vectors(); 
	
	return; 
}

void diffusion_decay_solver__constant_coefficients_LOD_2D_GPU( Microenvironment& M, double dt )
{
	if( M.mesh.uniform_mesh == false )
	{
		std::cout << "Error: This algorithm is written for uniform Cartesian meshes. Try: something else." << std::endl << std::endl; 
		return; 
	}
	
	// constants for the linear solver (Thomas algorithm) 
	
	if( !M.diffusion_solver_setup_done )
	{
		std::cout << std::endl << "Using method " << __FUNCTION__ << " (2D LOD with Thomas Algorithm) ... " << std::endl << std::endl;  
		
		M.thomas_denomx.resize( M.mesh.x_coordinates.size() , M.zero );
		M.thomas_cx.resize( M.mesh.x_coordinates.size() , M.zero );

		M.thomas_denomy.resize( M.mesh.y_coordinates.size() , M.zero );
		M.thomas_cy.resize( M.mesh.y_coordinates.size() , M.zero );
		
		// define constants and pre-computed quantities 

		M.thomas_i_jump = 1; 
		M.thomas_j_jump = M.mesh.x_coordinates.size(); 

		M.thomas_constant1 =  M.diffusion_coefficients; //   dt*D/dx^2 
		M.thomas_constant1a = M.zero; // -dt*D/dx^2; 
		M.thomas_constant2 =  M.decay_rates; // (1/2)*dt*lambda 
		M.thomas_constant3 = M.one; // 1 + 2*constant1 + constant2; 
		M.thomas_constant3a = M.one; // 1 + constant1 + constant2; 
		
		M.thomas_constant1 *= dt; 
		M.thomas_constant1 /= M.mesh.dx; 
		M.thomas_constant1 /= M.mesh.dx; 

		M.thomas_constant1a = M.thomas_constant1; 
		M.thomas_constant1a *= -1.0; 

		M.thomas_constant2 *= dt; 
		M.thomas_constant2 *= 0.5; // for splitting via LOD

		M.thomas_constant3 += M.thomas_constant1; 
		M.thomas_constant3 += M.thomas_constant1; 
		M.thomas_constant3 += M.thomas_constant2; 

		M.thomas_constant3a += M.thomas_constant1; 
		M.thomas_constant3a += M.thomas_constant2; 
		
		// Thomas solver coefficients 

		M.thomas_cx.assign( M.mesh.x_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomx.assign( M.mesh.x_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomx[0] = M.thomas_constant3a; 
		M.thomas_denomx[ M.mesh.x_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.x_coordinates.size() == 1 )
		{ M.thomas_denomx[0] = M.one; M.thomas_denomx[0] += M.thomas_constant2; } 

		M.thomas_cx[0] /= M.thomas_denomx[0]; 
		for( unsigned int i=1 ; i <= M.mesh.x_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomx[i] , M.thomas_constant1 , M.thomas_cx[i-1] ); 
			M.thomas_cx[i] /= M.thomas_denomx[i]; // the value at  size-1 is not actually used  
		}

		M.thomas_cy.assign( M.mesh.y_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomy.assign( M.mesh.y_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomy[0] = M.thomas_constant3a; 
		M.thomas_denomy[ M.mesh.y_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.y_coordinates.size() == 1 )
		{ M.thomas_denomy[0] = M.one; M.thomas_denomy[0] += M.thomas_constant2; } 

		M.thomas_cy[0] /= M.thomas_denomy[0]; 
		for( unsigned int i=1 ; i <= M.mesh.y_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomy[i] , M.thomas_constant1 , M.thomas_cy[i-1] ); 
			M.thomas_cy[i] /= M.thomas_denomy[i]; // the value at  size-1 is not actually used  
		}

		M.diffusion_solver_setup_done = true; 
	}
	if (M.openacc_data_bool == false){
		M.transfer_2D();
		M.openacc_data_bool = true;
	}
	else {
		//M.translate_vector_to_array() // comment out for exclusive device
	}

	// set the pointer
	
	M.apply_dirichlet_conditions_GPU();

	// x-diffusion on gpu
	M.x_diffusion_GPU_2D();

	M.apply_dirichlet_conditions_GPU();

	// y-diffusion on gpu
	M.y_diffusion_GPU_2D();

	M.apply_dirichlet_conditions_GPU();

	// reset gradient vectors 
	//M.reset_all_gradient_vectors(); 
	
	return; 
}

void diffusion_decay_explicit_uniform_rates( Microenvironment& M, double dt )
{
	using std::vector; 
	using std::cout; 
	using std::endl; 

	// static int n_jump_i = 1; 
	// static int n_jump_j = M.mesh.x_coordinates.size(); 
	// static int n_jump_k = M.mesh.x_coordinates.size() * M.mesh.y_coordinates.size(); 

	if( !M.diffusion_solver_setup_done )
	{	
		M.thomas_i_jump = 1; 
		M.thomas_j_jump = M.mesh.x_coordinates.size(); 
		M.thomas_k_jump = M.thomas_j_jump * M.mesh.y_coordinates.size(); 
	
		M.diffusion_solver_setup_done = true; 
	}
	
	if( M.mesh.uniform_mesh == false )
	{
		cout << "Error: This algorithm is written for uniform Cartesian meshes. Try: something else" << endl << endl; 
		return; 
	}

	// double buffering to reduce memory copy / allocation overhead 

	static vector< vector<double> >* pNew = &(M.temporary_density_vectors1);
	static vector< vector<double> >* pOld = &(M.temporary_density_vectors2);

	// swap the buffers 

	vector< vector<double> >* pTemp = pNew; 
	pNew = pOld; 
	pOld = pTemp; 
	M.p_density_vectors = pNew; 

	// static bool reaction_diffusion_shortcuts_are_set = false; 

	static vector<double> constant1 = (1.0 / ( M.mesh.dx * M.mesh.dx )) * M.diffusion_coefficients; 
	static vector<double> constant2 = dt * constant1; 
	static vector<double> constant3 = M.one + dt * M.decay_rates;

	static vector<double> constant4 = M.one - dt * M.decay_rates;

	#pragma omp parallel for
	for( unsigned int i=0; i < (*(M.p_density_vectors)).size() ; i++ )
	{
		unsigned int number_of_neighbors = M.mesh.connected_voxel_indices[i].size(); 

		double d1 = -1.0 * number_of_neighbors; 

		(*pNew)[i] = (*pOld)[i];  
		(*pNew)[i] *= constant4; 

		for( unsigned int j=0; j < number_of_neighbors ; j++ )
		{
			axpy( &(*pNew)[i], constant2, (*pOld)[  M.mesh.connected_voxel_indices[i][j] ] ); 
		}
		vector<double> temp = constant2; 
		temp *= d1; 
		axpy( &(*pNew)[i] , temp , (*pOld)[i] ); 
	}
	
	// reset gradient vectors 
//	M.reset_all_gradient_vectors(); 

	return; 
}

};

########## NEXT FILE ##########
PhysiCell_cell.cpp:::
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include "PhysiCell_cell.h"
#include "PhysiCell_cell_container.h"
#include "PhysiCell_utilities.h"
#include "PhysiCell_constants.h"
#include "../BioFVM/BioFVM_vector.h" 
#include<limits.h>

namespace PhysiCell{

Cell_Parameters::Cell_Parameters()
{
	o2_hypoxic_threshold = 15.0; // HIF-1alpha at half-max around 1.5-2%, and tumors often are below 2%
	o2_hypoxic_response = 8.0; // genomic / proteomic changes observed at 7-8 mmHg 
	o2_hypoxic_saturation = 4.0; // maximum HIF-1alpha at 0.5% o2 (McKeown)
	
	o2_necrosis_threshold = 5.0; 
	o2_necrosis_max = 2.5; 
	
	o2_proliferation_threshold = 5.0; // assume no proliferation at same level as starting necrosis 
	o2_proliferation_saturation = 160.0; // 5% = 38, 21% = 160 mmHg 
	o2_reference = 160.0; // assume all was measured in normoxic 21% o2 
	
	pReference_live_phenotype = NULL; // reference live (usually physioxic) phenotype 
	
	// necrosis parameters 
	
	max_necrosis_rate = 1.0 / (6.0 * 60.0); // assume cells survive 6 hours in very low oxygen 
	necrosis_type = PhysiCell_constants::deterministic_necrosis;;

	return; 
}

Cell_Definition::Cell_Definition()
{
	// set the microenvironment pointer 
	pMicroenvironment = NULL;
	if( BioFVM::get_default_microenvironment() != NULL )
	{ pMicroenvironment = BioFVM::get_default_microenvironment(); }

	// set up the default parameters 
		// the default Cell_Parameters constructor should take care of this
		
	type = 0; 
	name = "unnamed"; 

	parameters.pReference_live_phenotype = &phenotype; 
		
	// set up the default custom data 
		// the default Custom_Cell_Data constructor should take care of this
		
	// set up the default functions 
	functions.volume_update_function = NULL; // standard_volume_update_function;
	functions.update_migration_bias = NULL; 
	
	functions.update_phenotype = NULL; 
	functions.custom_cell_rule = NULL; 
	
	functions.update_velocity = NULL; // standard_update_cell_velocity;
	functions.add_cell_basement_membrane_interactions = NULL; 
	functions.calculate_distance_to_membrane = NULL; 
	
	functions.set_orientation = NULL;
	
	return; 
}

Cell_Definition::Cell_Definition( Cell_Definition& cd )
{
	// set the microenvironment pointer 
	pMicroenvironment = cd.pMicroenvironment;

	// set up the default parameters 
		// the default Cell_Parameters constructor should take care of this
		
	type = cd.type; 
	name = cd.name; 
	 
	parameters = cd.parameters;
	custom_data = cd.custom_data; 
	functions = cd.functions; 
	phenotype = cd.phenotype; 
	
	// this is the whole reason we need ot make a copy constructor 
	parameters.pReference_live_phenotype = &phenotype; 
	
	return; 
}

Cell_Definition& Cell_Definition::operator=( const Cell_Definition& cd )
{
	// set the microenvironment pointer 
	pMicroenvironment = cd.pMicroenvironment;

	// set up the default parameters 
		// the default Cell_Parameters constructor should take care of this
		
	type = cd.type; 
	name = cd.name; 
	 
	parameters = cd.parameters;
	custom_data = cd.custom_data; 
	functions = cd.functions; 
	phenotype = cd.phenotype; 
	
	// this is the whole reason we need ot make a copy constructor 
	parameters.pReference_live_phenotype = &phenotype; 
	
	return *this; 
}


Cell_Definition cell_defaults; 

Cell_State::Cell_State()
{
	neighbors.resize(0); 
	orientation.resize( 3 , 0.0 ); 
	
	simple_pressure = 0.0; 
	
	return; 
}

void Cell::update_motility_vector( double dt_ )
{
	if( phenotype.motility.is_motile == false )
	{
		phenotype.motility.motility_vector.assign( 3, 0.0 ); 
		return; 
	}
	
	if( UniformRandom() < dt_ / phenotype.motility.persistence_time || phenotype.motility.persistence_time < dt_ )
	{
		// choose a uniformly random unit vector 
		double temp_angle = 6.28318530717959*UniformRandom();
		double temp_phi = 3.1415926535897932384626433832795*UniformRandom();
		
		double sin_phi = sin(temp_phi);
		double cos_phi = cos(temp_phi);
		
		if( phenotype.motility.restrict_to_2D == true )
		{ 
			sin_phi = 1.0; 
			cos_phi = 0.0;
		}
		
		std::vector<double> randvec; 
		randvec.resize(3,sin_phi); 
		
		randvec[0] *= cos( temp_angle ); // cos(theta)*sin(phi)
		randvec[1] *= sin( temp_angle ); // sin(theta)*sin(phi)
		randvec[2] = cos_phi; //  cos(phi)
		
		// if the update_bias_vector function is set, use it  
		if( functions.update_migration_bias )
		{
			functions.update_migration_bias( this,phenotype,dt_ ); 
		}
		
		phenotype.motility.motility_vector = phenotype.motility.migration_bias_direction; // motiltiy = bias_vector
		phenotype.motility.motility_vector *= phenotype.motility.migration_bias; // motility = bias*bias_vector 
		
		double one_minus_bias = 1.0 - phenotype.motility.migration_bias; 
		
		axpy( &(phenotype.motility.motility_vector), one_minus_bias, randvec ); // motility = (1-bias)*randvec + bias*bias_vector
		
		normalize( &(phenotype.motility.motility_vector) ); 
		
		phenotype.motility.motility_vector *= phenotype.motility.migration_speed; 
	}	
	return; 
} 

void Cell::advance_bundled_phenotype_functions( double dt_ )
{
	// call the custom code to update the phenotype 
	if( functions.update_phenotype )
	{	functions.update_phenotype( this , phenotype , dt_ ); }
	
	// update volume 
	if( functions.volume_update_function )
	{
		functions.volume_update_function(this,phenotype,dt_); 
		
		// The following line is needed in every volume 
		// regulation method (it sets BioFVM total_volume)
		
		set_total_volume( phenotype.volume.total ); 
	}
	
	// update geometry
	phenotype.geometry.update( this, phenotype, dt_ );
	
	// check for new death events 
	if( phenotype.death.check_for_death( dt_ ) == true )
	{
		// if so, change the cycle model to the current death model 
		phenotype.cycle.sync_to_cycle_model( phenotype.death.current_model() ); 
		
		// also, turn off motility.
		
		phenotype.motility.is_motile = false; 
		phenotype.motility.motility_vector.assign( 3, 0.0 ); 
		functions.update_migration_bias = NULL;
		
		// turn off secretion, and reduce uptake by a factor of 10 
		phenotype.secretion.set_all_secretion_to_zero();
		phenotype.secretion.scale_all_uptake_by_factor( 0.10 );
		
		// make sure to run the death entry function 
		if( phenotype.cycle.current_phase().entry_function )
		{
			phenotype.cycle.current_phase().entry_function( this, phenotype, dt_ ); 
		}
	}
	
	// advance cycle model (for both cell cycle and death cycle models)
	phenotype.cycle.advance_cycle( this, phenotype, dt_ ); 
	if( phenotype.flagged_for_removal )
	{
		flag_for_removal(); 
		phenotype.flagged_for_removal = false; 
	}
	if( phenotype.flagged_for_division )
	{
		flag_for_division(); 
		phenotype.flagged_for_division = false; 
	}
	
	return; 
}

Cell::Cell()
{
	// use the cell defaults; 
	
	type = cell_defaults.type; 
	type_name = cell_defaults.name; 
	
	custom_data = cell_defaults.custom_data; 
	parameters = cell_defaults.parameters; 
	functions = cell_defaults.functions; 
	
	phenotype = cell_defaults.phenotype; 
	
	phenotype.molecular.sync_to_cell( this ); 
	
	// cell state should be fine by the default constructor 
	
	current_mechanics_voxel_index=-1;
	
	updated_current_mechanics_voxel_index = 0;
	
	is_movable = true;
	is_out_of_domain = false;
	displacement.resize(3,0.0); // state? 
	
	assign_orientation();
	container = NULL;
	
	
	return; 
}

void Cell::flag_for_division( void )
{
	get_container()->flag_cell_for_division( this );
	return; 
}

void Cell::flag_for_removal( void )
{
	get_container()->flag_cell_for_removal( this );
	return;
}

void Cell::start_death( int death_model_index )
{
	// set the death data struture to the indicated death model 
	phenotype.death.trigger_death( death_model_index ); 
	// change the cycle model to the current death model 
	phenotype.cycle.sync_to_cycle_model( phenotype.death.current_model() ); 
		
	// turn off secretion, and reduce uptake by a factor of 10 
	phenotype.secretion.set_all_secretion_to_zero();
	phenotype.secretion.scale_all_uptake_by_factor( 0.10 );
		
	// turn off motility.
	phenotype.motility.is_motile = false; 
	phenotype.motility.motility_vector.assign( 3, 0.0 ); 
	functions.update_migration_bias = NULL;
		
	// make sure to run the death entry function 
	if( phenotype.cycle.current_phase().entry_function )
	{
		phenotype.cycle.current_phase().entry_function( this, phenotype, 0.0 ); 
	}

	return; 
}

void Cell::assign_orientation()
{
	state.orientation.resize(3,0.0);
	if( functions.set_orientation != NULL )
	{
		functions.set_orientation(this, phenotype, 0.0 );
	}
	else
	{
		//assign a random unit vector
		double theta= UniformRandom()*6.28318530717959; //rand*2*pi
		double z= 2* UniformRandom()-1;
		double temp= sqrt(1-z*z);
		state.orientation[0]= temp * cos(theta);
		state.orientation[1]= temp * sin(theta);
		state.orientation[2]= z;
	}
	
	return; 
}

Cell* Cell::divide( )
{
	// phenotype.flagged_for_division = false; 
	// phenotype.flagged_for_removal = false; 
	
	Cell* child = create_cell();
	child->copy_data( this );	
	child->copy_function_pointers(this);
	child->parameters = parameters;
	
	// evenly divide internalized substrates 
	// if these are not actively tracked, they are zero anyway 
	*internalized_substrates *= 0.5; 
	*(child->internalized_substrates) = *internalized_substrates ; 
	
	// The following is already performed by create_cell(). JULY 2017 ***
	// child->register_microenvironment( get_microenvironment() );
	
	// randomly place the new agent close to me, accounting for orientation and 
	// polarity (if assigned)
		
	double temp_angle = 6.28318530717959*UniformRandom();
	double temp_phi = 3.1415926535897932384626433832795*UniformRandom();
	
	double radius= phenotype.geometry.radius;
	std::vector<double> rand_vec (3, 0.0);
	
	rand_vec[0]= cos( temp_angle ) * sin( temp_phi );
	rand_vec[1]= sin( temp_angle ) * sin( temp_phi );
	rand_vec[2]= cos( temp_phi );
	rand_vec = rand_vec- phenotype.geometry.polarity*(rand_vec[0]*state.orientation[0]+ 
		rand_vec[1]*state.orientation[1]+rand_vec[2]*state.orientation[2])*state.orientation;
	
	if( norm(rand_vec) < 1e-16 )
	{
		std::cout<<"************ERROR********************"<<std::endl;
	}
	normalize( &rand_vec ); 
	// rand_vec/= norm(rand_vec);
	child->assign_position(position[0] + 0.5 * radius*rand_vec[0],
						 position[1] + 0.5 * radius*rand_vec[1],
						 position[2] + 0.5 * radius*rand_vec[2]);
	//change my position to keep the center of mass intact and then see if I need to update my voxel index
	static double negative_one_half = -0.5; 
	naxpy( &position, negative_one_half , rand_vec );// position = position - 0.5*rand_vec; 
	// position[0] -= 0.5*radius*rand_vec[0];
	// position[1] -= 0.5*radius*rand_vec[1]; 
	// position[2] -= 0.5*radius*rand_vec[2]; 
	 
	update_voxel_in_container();
	phenotype.volume.divide(); 
	child->phenotype.volume.divide();
	child->set_total_volume(child->phenotype.volume.total);
	set_total_volume(phenotype.volume.total);
	
	// child->set_phenotype( phenotype ); 
	child->phenotype = phenotype; 
	
	return child;
}

bool Cell::assign_position(std::vector<double> new_position)
{
	return assign_position(new_position[0], new_position[1], new_position[2]);
}

void Cell::set_previous_velocity(double xV, double yV, double zV)
{
	previous_velocity[0] = xV;
	previous_velocity[1] = yV;
	previous_velocity[2] = zV;

	return; 
}

bool Cell::assign_position(double x, double y, double z)
{
	if( !get_container()->underlying_mesh.is_position_valid(x,y,z) )
	{	
		is_out_of_domain = true; 
		is_active = false; 
		is_movable = false; 
		
		return false;
	}
	position[0]=x;
	position[1]=y;
	position[2]=z;
	
	// update microenvironment current voxel index
	update_voxel_index();
	// update current_mechanics_voxel_index
	current_mechanics_voxel_index= get_container()->underlying_mesh.nearest_voxel_index( position );
	get_container()->register_agent(this);
	
	return true;
}

void Cell::set_total_volume(double volume)
{
	Basic_Agent::set_total_volume(volume);
	
	// If the new volume is significantly different than the 
	// current total volume, adjust all the sub-volumes 
	// proportionally. 
	
	// if( fabs( phenotype.volume.total - volume ) < 1e-16 )
	if( fabs( phenotype.volume.total - volume ) > 1e-16 )
	{
		double ratio= volume/ phenotype.volume.total;
		phenotype.volume.multiply_by_ratio(ratio);
	}
	
	phenotype.geometry.update( this, phenotype, 0.0 ); 
	// phenotype.update_radius();
	//if( get_container()->max_cell_interactive_distance_in_voxel[get_current_mechanics_voxel_index()] < 
	//	phenotype.geometry.radius * parameters.max_interaction_distance_factor )
	if( get_container()->max_cell_interactive_distance_in_voxel[get_current_mechanics_voxel_index()] < 
		phenotype.geometry.radius * phenotype.mechanics.relative_maximum_adhesion_distance )
	{
		// get_container()->max_cell_interactive_distance_in_voxel[get_current_mechanics_voxel_index()]= phenotype.geometry.radius*parameters.max_interaction_distance_factor;
		get_container()->max_cell_interactive_distance_in_voxel[get_current_mechanics_voxel_index()] = phenotype.geometry.radius
			* phenotype.mechanics.relative_maximum_adhesion_distance;
	}
	
	return; 
}

double& Cell::get_total_volume(void)
{
	static bool I_warned_you = false; 
	if( I_warned_you == false )
	{
		std::cout << "Warning! Do not use " << __FUNCTION__ << "!" << std::endl 
			<< "Use (some_cell).phenotype.volume.total instead!" << std::endl; 
		I_warned_you = true; 
	}
	return phenotype.volume.total; 
}

void Cell::turn_off_reactions(double dt)
{	
	is_active = false;  
	
	for(int i=0;i< phenotype.secretion.uptake_rates.size();i++)
	{
		phenotype.secretion.uptake_rates[i] = 0.0;  
		phenotype.secretion.secretion_rates[i] = 0.0; 
	}
	set_internal_uptake_constants(dt);
	
	return; 
}

Cell_Container * Cell::get_container()
{
	if(container == NULL)
	{
		container = (Cell_Container *)get_microenvironment()->agent_container;
	}
	
	return container;
}

void Cell::die()
{
	delete_cell(this);
	return; 
} 

void Cell::update_position( double dt )
{
	// BioFVM Basic_Agent::update_position(dt) returns without doing anything. 
	// So we remove this to avoid any future surprises. 
	// 
	// Basic_Agent::update_position(dt);
		
	// use Adams-Bashforth 
	static double d1; 
	static double d2; 
	static bool constants_defined = false; 
	if( constants_defined == false )
	{
		d1 = dt; 
		d1 *= 1.5; 
		d2 = dt; 
		d2 *= -0.5; 
		constants_defined = true; 
	}
	
	// new AUgust 2017
	if( default_microenvironment_options.simulate_2D == true )
	{ velocity[2] = 0.0; }
	
	std::vector<double> old_position(position); 
	axpy( &position , d1 , velocity );  
	axpy( &position , d2 , previous_velocity );  
	// overwrite previous_velocity for future use 
	// if(sqrt(dist(old_position, position))>3* phenotype.geometry.radius)
		// std::cout<<sqrt(dist(old_position, position))<<"old_position: "<<old_position<<", new position: "<< position<<", velocity: "<<velocity<<", previous_velocity: "<< previous_velocity<<std::endl;
	
	previous_velocity = velocity; 
	
	velocity[0]=0; velocity[1]=0; velocity[2]=0;
	// #pragma omp critical
	//{update_voxel_in_container();}
	if(get_container()->underlying_mesh.is_position_valid(position[0],position[1],position[2]))
	{
		updated_current_mechanics_voxel_index=get_container()->underlying_mesh.nearest_voxel_index( position );
	}
	else
	{
		updated_current_mechanics_voxel_index=-1;
		
		is_out_of_domain = true; 
		is_active = false; 
		is_movable = false; 
	}
	return; 
}

int Cell::get_current_mechanics_voxel_index()
{
	return current_mechanics_voxel_index;
}

void Cell::update_voxel_in_container()
{
	// call the method from BioFVM_basic_agent to update microenvironment's voxel index
	update_voxel_index();
	// int temp_current_voxel_index;
	// Check to see if we need to remove agents that are pushed out of boundary
	// if(!get_container()->underlying_mesh.is_position_valid(position[0],position[1],position[2]))	
		
	if(updated_current_mechanics_voxel_index==-1)// updated_current_mechanics_voxel_index is updated in update_position
	{
		// check if this agent has a valid voxel index, if so, remove it from previous voxel
		if( get_current_mechanics_voxel_index() >= 0)
		{
			// #pragma omp critical
			{get_container()->remove_agent_from_voxel(this, get_current_mechanics_voxel_index());}
		}
		// #pragma omp critical
		{get_container()->add_agent_to_outer_voxel(this);}
		// std::cout<<"cell out of boundary..."<< __LINE__<<" "<<ID<<std::endl;
		current_mechanics_voxel_index=-1;
		is_out_of_domain=true;
		is_active=false;
		return;
	}
	
	// temp_current_voxel_index= get_current_mechanics_voxel_index();
	// updated_current_mechanics_voxel_index=get_container()->underlying_mesh.nearest_voxel_index( position );
	
	// update mesh indices (if needed)
	if(updated_current_mechanics_voxel_index!= get_current_mechanics_voxel_index())
	{
		// #pragma omp critical
		{
			container->remove_agent_from_voxel(this, get_current_mechanics_voxel_index());
			container->add_agent_to_voxel(this, updated_current_mechanics_voxel_index);
		}
		current_mechanics_voxel_index=updated_current_mechanics_voxel_index;
	}
	
	return; 
}

void Cell::copy_data(Cell* copy_me)
{
	// phenotype=copyMe-> phenotype; //it is taken care in set_phenotype
	type = copy_me->type; 
	type_name = copy_me->type_name; 
	
	custom_data = copy_me->custom_data; 
	parameters = copy_me->parameters; 
	
	velocity = copy_me->velocity; 
	// expected_phenotype = copy_me-> expected_phenotype; //it is taken care in set_phenotype
	cell_source_sink_solver_temp1 = std::vector<double>(copy_me->cell_source_sink_solver_temp1);
	cell_source_sink_solver_temp2 = std::vector<double>(copy_me->cell_source_sink_solver_temp2);
	
	return; 
}

void Cell::copy_function_pointers(Cell* copy_me)
{
	functions = copy_me->functions; 
	return; 
}

void Cell::add_potentials(Cell* other_agent)
{
	if( this->ID == other_agent->ID )
	{ return; }

	// 12 uniform neighbors at a close packing distance, after dividing out all constants
	static double simple_pressure_scale = 0.027288820670331; // 12 * (1 - sqrt(pi/(2*sqrt(3))))^2 
	// 9.820170012151277; // 12 * ( 1 - sqrt(2*pi/sqrt(3)))^2

	double distance = 0; 
	for( int i = 0 ; i < 3 ; i++ ) 
	{ 
		displacement[i] = position[i] - (*other_agent).position[i]; 
		distance += displacement[i] * displacement[i]; 
	}
	// Make sure that the distance is not zero
	
	distance = std::max(sqrt(distance), 0.00001); 
	
	//Repulsive
	double R = phenotype.geometry.radius+ (*other_agent).phenotype.geometry.radius; 
	
	double RN = phenotype.geometry.nuclear_radius + (*other_agent).phenotype.geometry.nuclear_radius;	
	double temp_r, c;
	if( distance > R ) 
	{
		temp_r=0;
	}
	// else if( distance < RN ) 
	// {
		// double M = 1.0; 
		// c = 1.0 - RN/R; 
		// c *= c; 
		// c -= M; 
		// temp_r = ( c*distance/RN  + M  ); 
	// }
	else
	{
		// temp_r = 1 - distance/R;
		temp_r = -distance; // -d
		temp_r /= R; // -d/R
		temp_r += 1.0; // 1-d/R
		temp_r *= temp_r; // (1-d/R)^2 
		
		// add the relative pressure contribution 
		state.simple_pressure += ( temp_r / simple_pressure_scale ); // New July 2017 
	}
	
	// August 2017 - back to the original if both have same coefficient 
	double effective_repulsion = sqrt( phenotype.mechanics.cell_cell_repulsion_strength * other_agent->phenotype.mechanics.cell_cell_repulsion_strength ); 
	temp_r *= effective_repulsion; 
	
	// temp_r *= phenotype.mechanics.cell_cell_repulsion_strength; // original 
	//////////////////////////////////////////////////////////////////
	
	// Adhesive
	//double max_interactive_distance = parameters.max_interaction_distance_factor * phenotype.geometry.radius + 
	//	(*other_agent).parameters.max_interaction_distance_factor * (*other_agent).phenotype.geometry.radius;
		
	double max_interactive_distance = phenotype.mechanics.relative_maximum_adhesion_distance * phenotype.geometry.radius + 
		(*other_agent).phenotype.mechanics.relative_maximum_adhesion_distance * (*other_agent).phenotype.geometry.radius;
		
	if(distance < max_interactive_distance ) 
	{	
		// double temp_a = 1 - distance/max_interactive_distance; 
		double temp_a = -distance; // -d
		temp_a /= max_interactive_distance; // -d/S
		temp_a += 1.0; // 1 - d/S 
		temp_a *= temp_a; // (1-d/S)^2 
		// temp_a *= phenotype.mechanics.cell_cell_adhesion_strength; // original 
		
		// August 2017 - back to the original if both have same coefficient 
		double effective_adhesion = sqrt( phenotype.mechanics.cell_cell_adhesion_strength * other_agent->phenotype.mechanics.cell_cell_adhesion_strength ); 
		temp_a *= effective_adhesion; 
		
		temp_r -= temp_a;
	}
	/////////////////////////////////////////////////////////////////
	if( fabs(temp_r) < 1e-16 )
	{ return; }
	temp_r /= distance;
	// for( int i = 0 ; i < 3 ; i++ ) 
	// {
	//	velocity[i] += displacement[i] * temp_r; 
	// }
	axpy( &velocity , temp_r , displacement ); 
	
	return;
}

Cell* create_cell( void )
{
	Cell* pNew; 
	pNew = new Cell;		
	(*all_cells).push_back( pNew ); 
	pNew->index=(*all_cells).size()-1;
	
	// new usability enhancements in May 2017 
	
	if( BioFVM::get_default_microenvironment() )
	{
		pNew->register_microenvironment( BioFVM::get_default_microenvironment() );
	}

	// All the phenotype and other data structures are already set 
	// by virtue of the default Cell constructor. 
	
	return pNew; 
}

// in the future, I might swap this with create_cell(): 
// In that "create_cell()" uses "create_cell( cell_defaults )" 
Cell* create_cell( Cell_Definition& cd )
{
	Cell* pNew = create_cell(); 
	
	// use the cell defaults; 
	pNew->type = cd.type; 
	pNew->type_name = cd.name; 
	
	pNew->custom_data = cd.custom_data; 
	pNew->parameters = cd.parameters; 
	pNew->functions = cd.functions; 
	
	pNew->phenotype = cd.phenotype; 
	pNew->is_movable = true;
	pNew->is_out_of_domain = false;
	pNew->displacement.resize(3,0.0); // state? 
	
	pNew->assign_orientation();
	
	return pNew; 
}

void Cell::convert_to_cell_definition( Cell_Definition& cd )
{
	
	// use the cell defaults; 
	type = cd.type; 
	type_name = cd.name; 
	
	custom_data = cd.custom_data; 
	parameters = cd.parameters; 
	functions = cd.functions; 
	
	phenotype = cd.phenotype; 
	// is_movable = true;
	// is_out_of_domain = false;
	
	// displacement.resize(3,0.0); // state? 
	
	assign_orientation();	
	
	return; 
}

void delete_cell( int index )
{
	// released internalized substrates (as of 1.5.x releases)
	(*all_cells)[index]->release_internalized_substrates(); 
	
	// deregister agent in from the agent container
	(*all_cells)[index]->get_container()->remove_agent((*all_cells)[index]);
	// de-allocate (delete) the cell; 
	delete (*all_cells)[index]; 

	// performance goal: don't delete in the middle -- very expensive reallocation
	// alternative: copy last element to index position, then shrink vector by 1 at the end O(constant)

	// move last item to index location  
	(*all_cells)[ (*all_cells).size()-1 ]->index=index;
	(*all_cells)[index] = (*all_cells)[ (*all_cells).size()-1 ];
	// shrink the vector
	(*all_cells).pop_back();	
	return; 
}

void delete_cell( Cell* pDelete )
{
	delete_cell(pDelete->index);
	return; 
}

bool is_neighbor_voxel(Cell* pCell, std::vector<double> my_voxel_center, std::vector<double> other_voxel_center, int other_voxel_index)
{
	double max_interactive_distance = pCell->phenotype.mechanics.relative_maximum_adhesion_distance * pCell->phenotype.geometry.radius 
		+ pCell->get_container()->max_cell_interactive_distance_in_voxel[other_voxel_index];
	
	int comparing_dimension = -1, comparing_dimension2 = -1;
	if(my_voxel_center[0] == other_voxel_center[0] && my_voxel_center[1] == other_voxel_center[1])
	{
		comparing_dimension = 2;
	}
	else if(my_voxel_center[0] == other_voxel_center[0] && my_voxel_center[2] == other_voxel_center[2])
	{
		comparing_dimension = 1;
	}
	else if(my_voxel_center[1] == other_voxel_center[1] && my_voxel_center[2] == other_voxel_center[2])
	{
		comparing_dimension = 0;
	}
	
	if(comparing_dimension != -1) 
	{ //then it is an immediate neighbor (through side faces)
		double surface_coord= 0.5*(my_voxel_center[comparing_dimension] + other_voxel_center[comparing_dimension]);
		if(std::fabs(pCell->position[comparing_dimension] - surface_coord) > max_interactive_distance)
		{ return false; }
		return true;
	}
	comparing_dimension=-1;
	
	if(my_voxel_center[0] == other_voxel_center[0])
	{
		comparing_dimension = 1; comparing_dimension2 = 2;
	}
	else if(my_voxel_center[1] == other_voxel_center[1])
	{
		comparing_dimension=0; comparing_dimension2 = 2;
	}
	else if(my_voxel_center[2] == other_voxel_center[2])
	{
		comparing_dimension = 0; comparing_dimension2=1;
	}
	if(comparing_dimension != -1)
	{
		double line_coord1= 0.5*(my_voxel_center[comparing_dimension] + other_voxel_center[comparing_dimension]);
		double line_coord2= 0.5*(my_voxel_center[comparing_dimension2] + other_voxel_center[comparing_dimension2]);
		double distance_squared= std::pow( pCell->position[comparing_dimension] - line_coord1,2)+ std::pow( pCell->position[comparing_dimension2] - line_coord2,2);
		if(distance_squared > max_interactive_distance * max_interactive_distance)
		{ return false; }
		return true;
	}
	std::vector<double> corner_point= 0.5*(my_voxel_center+other_voxel_center);
	double distance_squared= (corner_point[0]-pCell->position[0])*(corner_point[0]-pCell->position[0])
		+(corner_point[1]-pCell->position[1])*(corner_point[1]-pCell->position[1]) 
		+(corner_point[2]-pCell->position[2]) * (corner_point[2]-pCell->position[2]);
	if(distance_squared > max_interactive_distance * max_interactive_distance)
	{ return false; }
	return true;
}

std::vector<Cell*>& Cell::cells_in_my_container( void )
{
	return get_container()->agent_grid[get_current_mechanics_voxel_index()];
}

void Cell::ingest_cell( Cell* pCell_to_eat )
{
	// absorb all the volume(s)

	// absorb fluid volume (all into the cytoplasm) 
	phenotype.volume.cytoplasmic_fluid += pCell_to_eat->phenotype.volume.fluid; 
	pCell_to_eat->phenotype.volume.cytoplasmic_fluid = 0.0; 
	
	// absorb nuclear and cyto solid volume (into the cytoplasm) 
	phenotype.volume.cytoplasmic_solid += pCell_to_eat->phenotype.volume.cytoplasmic_solid; 
	pCell_to_eat->phenotype.volume.cytoplasmic_solid = 0.0; 
	
	phenotype.volume.cytoplasmic_solid += pCell_to_eat->phenotype.volume.nuclear_solid; 
	pCell_to_eat->phenotype.volume.nuclear_solid = 0.0; 
	
	// consistency calculations 
	
	phenotype.volume.fluid = phenotype.volume.nuclear_fluid + 
		phenotype.volume.cytoplasmic_fluid; 
	pCell_to_eat->phenotype.volume.fluid = 0.0; 
	
	phenotype.volume.solid = phenotype.volume.cytoplasmic_solid + 
		phenotype.volume.nuclear_solid; 
	pCell_to_eat->phenotype.volume.solid = 0.0; 
	
	// no change to nuclear volume (initially) 
	pCell_to_eat->phenotype.volume.nuclear = 0.0; 
	pCell_to_eat->phenotype.volume.nuclear_fluid = 0.0; 
	
	phenotype.volume.cytoplasmic = phenotype.volume.cytoplasmic_solid + 
		phenotype.volume.cytoplasmic_fluid; 
	pCell_to_eat->phenotype.volume.cytoplasmic = 0.0; 
	
	phenotype.volume.total = phenotype.volume.nuclear + 
		phenotype.volume.cytoplasmic; 
	pCell_to_eat->phenotype.volume.total = 0.0; 

	phenotype.volume.fluid_fraction = phenotype.volume.fluid / 
		(  phenotype.volume.total ); 
	pCell_to_eat->phenotype.volume.fluid_fraction = 0.0; 

	phenotype.volume.cytoplasmic_to_nuclear_ratio = phenotype.volume.cytoplasmic_solid / 
		( phenotype.volume.nuclear_solid + 1e-16 );
		
	// update corresponding BioFVM parameters (self-consistency) 
	set_total_volume( phenotype.volume.total ); 
	pCell_to_eat->set_total_volume( 0.0 ); 
	
	// absorb the internalized substrates 
	
	// multiply by the fraction that is supposed to be ingested (for each substrate) 
	*(pCell_to_eat->internalized_substrates) *= 
		*(pCell_to_eat->fraction_transferred_when_ingested); // 
	
	*internalized_substrates += *(pCell_to_eat->internalized_substrates); 
	static int n_substrates = internalized_substrates->size(); 
	pCell_to_eat->internalized_substrates->assign( n_substrates , 0.0 ); 	
	
	// trigger removal from the simulation 
	// pCell_to_eat->die(); // I don't think this is safe if it's in an OpenMP loop 
	// flag it for removal 
	pCell_to_eat->flag_for_removal(); 
	// mark it as dead 
	pCell_to_eat->phenotype.death.dead = true; 
	// set secretion and uptake to zero 
	pCell_to_eat->phenotype.secretion.set_all_secretion_to_zero( );  
	pCell_to_eat->phenotype.secretion.set_all_uptake_to_zero( ); 

	
	// deactivate all custom function 
	pCell_to_eat->functions.custom_cell_rule = NULL; 
	pCell_to_eat->functions.update_phenotype = NULL; 
	pCell_to_eat->functions.contact_function = NULL; 
	
	// set it to zero mechanics 
	pCell_to_eat->functions.custom_cell_rule = NULL; 
	
	return; 
}

void Cell::lyse_cell( void )
{
	flag_for_removal(); 
	// mark it as dead 
	phenotype.death.dead = true; 
	// set secretion and uptake to zero 
	phenotype.secretion.set_all_secretion_to_zero( );  
	phenotype.secretion.set_all_uptake_to_zero( ); 
	
	// deactivate all custom function 
	functions.custom_cell_rule = NULL; 
	functions.update_phenotype = NULL; 
	functions.contact_function = NULL; 
	
	// set it to zero mechanics 
	functions.custom_cell_rule = NULL; 

	return; 
}

};


########## NEXT FILE ##########
PhysiCell_cell_container.cpp:::
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include "../BioFVM/BioFVM_agent_container.h"
#include "PhysiCell_constants.h"
#include "../BioFVM/BioFVM_vector.h"
#include "PhysiCell_cell.h"

using namespace BioFVM;

namespace PhysiCell{

std::vector<Cell*> *all_cells;

Cell_Container::Cell_Container()
{
	all_cells = (std::vector<Cell*> *) &all_basic_agents;	
	boundary_condition_for_pushed_out_agents= PhysiCell_constants::default_boundary_condition_for_pushed_out_agents;
	std::vector<Cell*> cells_ready_to_divide;
	std::vector<Cell*> cells_ready_to_die;
	
	return; 
}	
	
void Cell_Container::initialize(double x_start, double x_end, double y_start, double y_end, double z_start, double z_end , double voxel_size)
{
	initialize(x_start, x_end, y_start, y_end, z_start, z_end , voxel_size, voxel_size, voxel_size);
	
	return; 
}

void Cell_Container::initialize(double x_start, double x_end, double y_start, double y_end, double z_start, double z_end , double dx, double dy, double dz)
{
	all_cells = (std::vector<Cell*> *) &all_basic_agents;	
	boundary_condition_for_pushed_out_agents= PhysiCell_constants::default_boundary_condition_for_pushed_out_agents;
	std::vector<Cell*> cells_ready_to_divide;
	std::vector<Cell*> cells_ready_to_die;

	underlying_mesh.resize(x_start, x_end, y_start, y_end, z_start, z_end , dx, dy, dz);
	agent_grid.resize(underlying_mesh.voxels.size());
	max_cell_interactive_distance_in_voxel.resize(underlying_mesh.voxels.size(), 0.0);
	agents_in_outer_voxels.resize(6);
	
	return; 
}
 
void Cell_Container::update_all_cells(double t)
{
	// update_all_cells(t, dt_settings.cell_cycle_dt_default, dt_settings.mechanics_dt_default);
	
	update_all_cells(t, phenotype_dt, mechanics_dt , diffusion_dt );
	
	return; 
}

// deprecate me JULY 2017
void Cell_Container::update_all_cells(double t, double dt)
{
	std::cout << "WARNING : " << __FUNCTION__ << " in " << __FILE__ << " is deprecated." 
		<< "\tIt returns without execution." << std::endl; 
	return; 
	update_all_cells(t, dt,dt);
	
	return; 
}

// deprecate me JULY 2017 
void Cell_Container::update_all_cells(double t, double phenotype_dt_ , double mechanics_dt_ )
{
	std::cout << "WARNING : " << __FUNCTION__ << " in " << __FILE__ << " is deprecated." 
		<< "\tIt returns without execution." << std::endl; 
	return; 
	
	//if it is the time for running cell cycle, do it!
	double time_since_last_cycle= t- last_cell_cycle_time;

	static double phenotype_tolerance = 0.001 * phenotype_dt_; 
	static double mechanics_tolerance = 0.001 * mechanics_dt_; 
	
	if( fabs(time_since_last_cycle- phenotype_dt_ ) < phenotype_tolerance || !initialzed)
	{
		// Reset the max_radius in each voxel. It will be filled in set_total_volume
		// It might be better if we calculate it before mechanics each time 
		std::fill(max_cell_interactive_distance_in_voxel.begin(), max_cell_interactive_distance_in_voxel.end(), 0.0);
		
		if(!initialzed)
		{
			time_since_last_cycle = phenotype_dt_;
		}
		
		// old functions prior to 1.2.1
		/*
		#pragma omp parallel for 
		for( int i=0; i < (*all_cells).size(); i++ )
		{
			if((*all_cells)[i]->is_out_of_domain)
				continue;
			(*all_cells)[i]->update_cell_and_death_parameters((*all_cells)[i],cell_cycle_dt);
			(*all_cells)[i]->advance_cell_current_phase((*all_cells)[i],time_since_last_cycle);
			(*all_cells)[i]->update_volume((*all_cells)[i], time_since_last_cycle ); 
		}
		*/
		
		// new as of 1.2.1 -- bundles cell phenotype parameter update, volume update, geometry update, 
		// checking for death, and advancing the cell cycle. Not motility, though. (that's in mechanics)
		#pragma omp parallel for 
		for( int i=0; i < (*all_cells).size(); i++ )
		{
			if((*all_cells)[i]->is_out_of_domain)
			{ continue; }
			// (*all_cells)[i]->phenotype.advance_bundled_models( (*all_cells)[i] , time_since_last_cycle ); 
			(*all_cells)[i]->advance_bundled_phenotype_functions( time_since_last_cycle ); 
		}
		
		// process divides / removes 
		for( int i=0; i < cells_ready_to_divide.size(); i++ )
		{
			cells_ready_to_divide[i]->divide();
		}
		for( int i=0; i < cells_ready_to_die.size(); i++ )
		{	
			cells_ready_to_die[i]->die();	
		}
		num_divisions_in_current_step+=  cells_ready_to_divide.size();
		num_deaths_in_current_step+=  cells_ready_to_die.size();
		
		cells_ready_to_die.clear();
		cells_ready_to_divide.clear();
		last_cell_cycle_time= t;
	}
	
	double time_since_last_mechanics= t- last_mechanics_time;
	
	// if( time_since_last_mechanics>= mechanics_dt || !initialzed)
	if( fabs(time_since_last_mechanics - mechanics_dt_)< mechanics_tolerance || !initialzed)
	{
		if(!initialzed)
		{
			time_since_last_mechanics = mechanics_dt_;
		}
		// Compute velocities
		#pragma omp parallel for 
		for( int i=0; i < (*all_cells).size(); i++ )
		{

			if(!(*all_cells)[i]->is_out_of_domain && (*all_cells)[i]->is_movable)
			{
				// update_velocity already includes the motility update 
				//(*all_cells)[i]->phenotype.motility.update_motility_vector( (*all_cells)[i] ,(*all_cells)[i]->phenotype , time_since_last_mechanics ); 
				(*all_cells)[i]->functions.update_velocity( (*all_cells)[i], (*all_cells)[i]->phenotype, time_since_last_mechanics);
			}

			if( (*all_cells)[i]->functions.custom_cell_rule )
			{
				(*all_cells)[i]->functions.custom_cell_rule((*all_cells)[i], (*all_cells)[i]->phenotype, time_since_last_mechanics);
			}
		}
		// Calculate new positions
		#pragma omp parallel for 
		for( int i=0; i < (*all_cells).size(); i++ )
		{
			if(!(*all_cells)[i]->is_out_of_domain && (*all_cells)[i]->is_movable)
			{
				(*all_cells)[i]->update_position(time_since_last_mechanics);
			}
		}
		
		// When somebody reviews this code, let's add proper braces for clarity!!! 
		
		// Update cell indices in the container
		for( int i=0; i < (*all_cells).size(); i++ )
			if(!(*all_cells)[i]->is_out_of_domain && (*all_cells)[i]->is_movable)
				(*all_cells)[i]->update_voxel_in_container();
		last_mechanics_time=t;
	}
	initialzed=true;
	return;
}

void Cell_Container::update_all_cells(double t, double phenotype_dt_ , double mechanics_dt_ , double diffusion_dt_ )
{
	// secretions and uptakes. Syncing with BioFVM is automated. 

	#pragma omp parallel for 
	for( int i=0; i < (*all_cells).size(); i++ )
	{
		(*all_cells)[i]->phenotype.secretion.advance( (*all_cells)[i], (*all_cells)[i]->phenotype , diffusion_dt_ );
	}
	
	//if it is the time for running cell cycle, do it!
	double time_since_last_cycle= t- last_cell_cycle_time;

	static double phenotype_dt_tolerance = 0.001 * phenotype_dt_; 
	static double mechanics_dt_tolerance = 0.001 * mechanics_dt_; 
	
	if( fabs(time_since_last_cycle-phenotype_dt_ ) < phenotype_dt_tolerance || !initialzed)
	{
		// Reset the max_radius in each voxel. It will be filled in set_total_volume
		// It might be better if we calculate it before mechanics each time 
		std::fill(max_cell_interactive_distance_in_voxel.begin(), max_cell_interactive_distance_in_voxel.end(), 0.0);
		
		if(!initialzed)
		{
			time_since_last_cycle = phenotype_dt_;
		}
		
		// new as of 1.2.1 -- bundles cell phenotype parameter update, volume update, geometry update, 
		// checking for death, and advancing the cell cycle. Not motility, though. (that's in mechanics)
		#pragma omp parallel for 
		for( int i=0; i < (*all_cells).size(); i++ )
		{
			if((*all_cells)[i]->is_out_of_domain)
			{ continue; }
			// (*all_cells)[i]->phenotype.advance_bundled_models( (*all_cells)[i] , time_since_last_cycle ); 
			(*all_cells)[i]->advance_bundled_phenotype_functions( time_since_last_cycle ); 
		}
		
		// process divides / removes 
		for( int i=0; i < cells_ready_to_divide.size(); i++ )
		{
			cells_ready_to_divide[i]->divide();
		}
		for( int i=0; i < cells_ready_to_die.size(); i++ )
		{	
			cells_ready_to_die[i]->die();	
		}
		num_divisions_in_current_step+=  cells_ready_to_divide.size();
		num_deaths_in_current_step+=  cells_ready_to_die.size();
		
		cells_ready_to_die.clear();
		cells_ready_to_divide.clear();
		last_cell_cycle_time= t;
	}
		
	double time_since_last_mechanics= t- last_mechanics_time;
	
	// if( time_since_last_mechanics>= mechanics_dt || !initialzed)
	if( fabs(time_since_last_mechanics - mechanics_dt_) < mechanics_dt_tolerance || !initialzed)
	{
		if(!initialzed)
		{
			time_since_last_mechanics = mechanics_dt_;
		}
		
		// new February 2018 
		// if we need gradients, compute them
		if( default_microenvironment_options.calculate_gradients ) 
		{ microenvironment.compute_all_gradient_vectors();  }
		// end of new in Feb 2018 		
		
		// Compute velocities
		#pragma omp parallel for 
		for( int i=0; i < (*all_cells).size(); i++ )
		{

			if(!(*all_cells)[i]->is_out_of_domain && (*all_cells)[i]->is_movable && (*all_cells)[i]->functions.update_velocity )
			{
				// update_velocity already includes the motility update 
				//(*all_cells)[i]->phenotype.motility.update_motility_vector( (*all_cells)[i] ,(*all_cells)[i]->phenotype , time_since_last_mechanics ); 
				(*all_cells)[i]->functions.update_velocity( (*all_cells)[i], (*all_cells)[i]->phenotype, time_since_last_mechanics);
			}

			if( (*all_cells)[i]->functions.custom_cell_rule )
			{
				(*all_cells)[i]->functions.custom_cell_rule((*all_cells)[i], (*all_cells)[i]->phenotype, time_since_last_mechanics);
			}
		}
		// Calculate new positions
		#pragma omp parallel for 
		for( int i=0; i < (*all_cells).size(); i++ )
		{
			if(!(*all_cells)[i]->is_out_of_domain && (*all_cells)[i]->is_movable)
			{
				(*all_cells)[i]->update_position(time_since_last_mechanics);
			}
		}
		
		// When somebody reviews this code, let's add proper braces for clarity!!! 
		
		// Update cell indices in the container
		for( int i=0; i < (*all_cells).size(); i++ )
			if(!(*all_cells)[i]->is_out_of_domain && (*all_cells)[i]->is_movable)
				(*all_cells)[i]->update_voxel_in_container();
		last_mechanics_time=t;
	}
	
	initialzed=true;
	return;
}

void Cell_Container::register_agent( Cell* agent )
{
	agent_grid[agent->get_current_mechanics_voxel_index()].push_back(agent);
	return; 
}

void Cell_Container::remove_agent(Cell* agent )
{
	remove_agent_from_voxel(agent, agent->get_current_mechanics_voxel_index());
	return; 
}

void Cell_Container::add_agent_to_outer_voxel(Cell* agent)
{
	int escaping_face= find_escaping_face_index(agent);
	agents_in_outer_voxels[escaping_face].push_back(agent);
	agent->is_out_of_domain=true;
	return; 
}

void Cell_Container::remove_agent_from_voxel(Cell* agent, int voxel_index)
{
	int delete_index = 0; 
	while( agent_grid[voxel_index][ delete_index ] != agent )
	{
		delete_index++; 
	}
	// move last item to index location  
	agent_grid[agent->get_current_mechanics_voxel_index()][delete_index] = agent_grid[agent->get_current_mechanics_voxel_index()][agent_grid[agent->get_current_mechanics_voxel_index()].size()-1 ]; 
	// shrink the vector
	agent_grid[agent->get_current_mechanics_voxel_index()].pop_back(); 
	return; 
}		

void Cell_Container::add_agent_to_voxel(Cell* agent, int voxel_index)
{
	agent_grid[voxel_index].push_back(agent); 
	return; 
}	

bool Cell_Container::contain_any_cell(int voxel_index)
{
	// Let's replace this with clearer statements. 
	return agent_grid[voxel_index].size()==0?false:true;
}

int find_escaping_face_index(Cell* agent)
{
	if(agent->position[0] <= agent->get_container()->underlying_mesh.bounding_box[PhysiCell_constants::mesh_min_x_index])
	{ return PhysiCell_constants::mesh_lx_face_index; }
	if(agent->position[0] >= agent->get_container()->underlying_mesh.bounding_box[PhysiCell_constants::mesh_max_x_index])
	{ return PhysiCell_constants::mesh_ux_face_index; }
	if(agent->position[1] <= agent->get_container()->underlying_mesh.bounding_box[PhysiCell_constants::mesh_min_y_index])
	{ return PhysiCell_constants::mesh_ly_face_index; }
	if(agent->position[1] >= agent->get_container()->underlying_mesh.bounding_box[PhysiCell_constants::mesh_max_y_index])
	{ return PhysiCell_constants::mesh_uy_face_index; }
	if(agent->position[2] <= agent->get_container()->underlying_mesh.bounding_box[PhysiCell_constants::mesh_min_z_index])
	{ return PhysiCell_constants::mesh_lz_face_index; }
	if(agent->position[2] >= agent->get_container()->underlying_mesh.bounding_box[PhysiCell_constants::mesh_max_z_index])
	{ return PhysiCell_constants::mesh_uz_face_index; }
	return -1; 
}

void Cell_Container::flag_cell_for_division( Cell* pCell )
{ 
	#pragma omp critical 
	{cells_ready_to_divide.push_back( pCell );} 
	return; 
}

void Cell_Container::flag_cell_for_removal( Cell* pCell )
{ 
	#pragma omp critical 
	{cells_ready_to_die.push_back( pCell );} 
	return; 
}


Cell_Container* create_cell_container_for_microenvironment( BioFVM::Microenvironment& m , double mechanics_voxel_size )
{
	Cell_Container* cell_container = new Cell_Container;
	cell_container->initialize( m.mesh.bounding_box[0], m.mesh.bounding_box[3], 
		m.mesh.bounding_box[1], m.mesh.bounding_box[4], 
		m.mesh.bounding_box[2], m.mesh.bounding_box[5],  mechanics_voxel_size );
	m.agent_container = (Agent_Container*) cell_container; 
	
	if( BioFVM::get_default_microenvironment() == NULL )
	{ 
		BioFVM::set_default_microenvironment( &m ); 
	}
	
	return cell_container; 
}

};

########## NEXT FILE ##########
cancer_immune_3D.cpp:::
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include "./cancer_immune_3D.h"

Cell_Definition immune_cell; 

void create_immune_cell_type( void )
{
	immune_cell = cell_defaults; 
	
	immune_cell.name = "immune cell";
	immune_cell.type = 1; 

	// turn off proliferation; 
	
	int cycle_start_index = live.find_phase_index( PhysiCell_constants::live ); 
	int cycle_end_index = live.find_phase_index( PhysiCell_constants::live ); 
	
	immune_cell.phenotype.cycle.data.transition_rate(cycle_start_index,cycle_end_index) = 0.0; 	
	
	int apoptosis_index = cell_defaults.phenotype.death.find_death_model_index( PhysiCell_constants::apoptosis_death_model ); 
	
	static int oxygen_ID = microenvironment.find_density_index( "oxygen" ); // 0 
	static int immuno_ID = microenvironment.find_density_index( "immunostimulatory factor" ); // 1
	
	// reduce o2 uptake 
	
	immune_cell.phenotype.secretion.uptake_rates[oxygen_ID] *= 
		parameters.doubles("immune_o2_relative_uptake"); // 0.1; 
	
	// set apoptosis to survive 10 days (on average) 
	
	immune_cell.phenotype.death.rates[apoptosis_index] = 
		parameters.doubles("immune_apoptosis_rate"); // 1.0 / (10.0 * 24.0 * 60.0 ); 
	
	// turn on motility; 
	immune_cell.phenotype.motility.is_motile = true; 
	immune_cell.phenotype.motility.persistence_time = 
		parameters.doubles("immune_motility_persistence_time"); // 10.0; 
	immune_cell.phenotype.motility.migration_speed = 
		parameters.doubles("immune_migration_speed"); // 1;  
	immune_cell.phenotype.motility.migration_bias = 
		parameters.doubles("immune_migration_bias"); // 0.5;
	
	immune_cell.phenotype.mechanics.cell_cell_adhesion_strength *= 
		parameters.doubles("immune_relative_adhesion"); // 0.0;
	immune_cell.phenotype.mechanics.cell_cell_repulsion_strength *= 
		parameters.doubles("immune_relative_repulsion"); // 5.0;
	
	// set functions 
	
	immune_cell.functions.update_phenotype = NULL; 
	immune_cell.functions.custom_cell_rule = immune_cell_rule; 
	immune_cell.functions.update_migration_bias = immune_cell_motility;	
	
	// set custom data values 
	
	Parameter<double> paramD; 
	
	immune_cell.custom_data[ "oncoprotein" ] = 0.0; 
	immune_cell.custom_data[ "kill rate" ] = 
		parameters.doubles("immune_kill_rate"); // 1.0/15.0; // how often it tries to kill
	immune_cell.custom_data[ "attachment lifetime" ] = 
		parameters.doubles("immune_attachment_lifetime"); // 60.00; // how long it can stay attached 
	immune_cell.custom_data[ "attachment rate" ] = 
		parameters.doubles("immune_attachment_rate"); // 1.0/5.0; // how long it wants to wander before attaching	
	
	return; 
}

void create_cell_types( void )
{
	// use the same random seed so that future experiments have the 
	// same initial histogram of oncoprotein, even if threading means 
	// that future division and other events are still not identical 
	// for all runs 
	SeedRandom( parameters.ints("random_seed") ); 
	
	// housekeeping 
	
	initialize_default_cell_definition();
	cell_defaults.phenotype.secretion.sync_to_microenvironment( &microenvironment ); 
	
	// turn the default cycle model to live, 
	// so it's easier to turn off proliferation
	
	cell_defaults.phenotype.cycle.sync_to_cycle_model( live ); 
	
	// Make sure we're ready for 2D
	
	cell_defaults.functions.set_orientation = up_orientation; 
	// cell_defaults.phenotype.geometry.polarity = 1.0; 
	cell_defaults.phenotype.motility.restrict_to_2D = false; // true; 
	
	// set to no motility for cancer cells 
	cell_defaults.phenotype.motility.is_motile = false; 
	
	// use default proliferation and death 
	
	int cycle_start_index = live.find_phase_index( PhysiCell_constants::live ); 
	int cycle_end_index = live.find_phase_index( PhysiCell_constants::live ); 
	
	int apoptosis_index = cell_defaults.phenotype.death.find_death_model_index( PhysiCell_constants::apoptosis_death_model ); 
	
	cell_defaults.parameters.o2_proliferation_saturation = 38.0;  
	cell_defaults.parameters.o2_reference = 38.0; 
	
	static int oxygen_ID = microenvironment.find_density_index( "oxygen" ); // 0 
	static int immuno_ID = microenvironment.find_density_index( "immunostimulatory factor" ); // 1
	
	// set default uptake and secretion 
	// oxygen 
	cell_defaults.phenotype.secretion.secretion_rates[oxygen_ID] = 0; 
	cell_defaults.phenotype.secretion.uptake_rates[oxygen_ID] = 10; 
	cell_defaults.phenotype.secretion.saturation_densities[oxygen_ID] = 38; 

	// immunostimulatory 
	cell_defaults.phenotype.secretion.saturation_densities[immuno_ID] = 1; 

	// set the default cell type to o2-based proliferation with the effect of the 
	// on oncoprotein, and secretion of the immunostimulatory factor 
	
	cell_defaults.functions.update_phenotype = tumor_cell_phenotype_with_and_immune_stimulation; 
	
	// add the extra bit of "attachment" mechanics 
	cell_defaults.functions.custom_cell_rule = extra_elastic_attachment_mechanics; 
	
	cell_defaults.name = "cancer cell"; 
	cell_defaults.type = 0; 
	
	// add custom data 
	
	Parameter<double> paramD;
	
	cell_defaults.custom_data.add_variable( "oncoprotein" , "dimensionless", 1.0 ); 
	paramD = parameters.doubles[ "elastic_coefficient" ]; 
	cell_defaults.custom_data.add_variable( "elastic coefficient" , paramD.units, paramD.value ); 
		// "1/min" , 0.01 );  /* param */ 
	cell_defaults.custom_data.add_variable( "kill rate" , "1/min" , 0 ); // how often it tries to kill
	cell_defaults.custom_data.add_variable( "attachment lifetime" , "min" , 0 ); // how long it can stay attached 
	cell_defaults.custom_data.add_variable( "attachment rate" , "1/min" ,0 ); // how long it wants to wander before attaching
	
	// create the immune cell type 
	create_immune_cell_type(); 
	
	return; 
}

void setup_microenvironment( void )
{
	// set domain parameters
/*
	default_microenvironment_options.X_range = {-1000, 1000}; 
	default_microenvironment_options.Y_range = {-1000, 1000}; 
	default_microenvironment_options.Z_range = {-1000, 1000}; 
*/	
/*
	// now in XML 
	default_microenvironment_options.X_range = {-750, 750}; 
	default_microenvironment_options.Y_range = {-750, 750}; 
	default_microenvironment_options.Z_range = {-750, 750};
*/
	
	if( default_microenvironment_options.simulate_2D == true )
	{
		std::cout << "Warning: overriding 2D setting to return to 3D" << std::endl; 
		default_microenvironment_options.simulate_2D = false; 
	}
	
/* 
	In XML as of version 1.6.0 
	
	// gradients are needed for this example 
	
	default_microenvironment_options.calculate_gradients = true; 
	
	// add the immunostimulatory factor 
	
	// let's do these in XML later 
	
	microenvironment.add_density( "immunostimulatory factor", "dimensionless" ); 
	microenvironment.diffusion_coefficients[1] = 1e3; 
	microenvironment.decay_rates[1] = .016; 
	
	// let BioFVM use oxygen as the default 
	
	default_microenvironment_options.use_oxygen_as_first_field = true; 

	// set Dirichlet conditions 
	
	default_microenvironment_options.outer_Dirichlet_conditions = true;
	default_microenvironment_options.Dirichlet_condition_vector[0] = 38; // physioxic conditions 
	default_microenvironment_options.Dirichlet_condition_vector[1] = 0; 
	default_microenvironment_options.Dirichlet_activation_vector[1] = false;  // no Dirichlet for the immunostimulatory factor 

	// set initial conditions 
	default_microenvironment_options.initial_condition_vector = { 38.0 , 0 }; 
*/
	
	initialize_microenvironment(); 	

	return; 
}	

void introduce_immune_cells( void )
{
	double tumor_radius = -9e9; // 250.0; 
	double temp_radius = 0.0; 
	
	// for the loop, deal with the (faster) norm squared 
	for( int i=0; i < (*all_cells).size() ; i++ )
	{
		temp_radius = norm_squared( (*all_cells)[i]->position ); 
		if( temp_radius > tumor_radius )
		{ tumor_radius = temp_radius; }
	}
	// now square root to get to radius 
	tumor_radius = sqrt( tumor_radius ); 
	
	// if this goes wackadoodle, choose 250 
	if( tumor_radius < 250.0 )
	{ tumor_radius = 250.0; }
	
	std::cout << "current tumor radius: " << tumor_radius << std::endl; 
	
	
	// now seed immune cells 
	
	int number_of_immune_cells = 
		parameters.ints("number_of_immune_cells"); // 7500; // 100; // 40; 
	double radius_inner = tumor_radius + 
		parameters.doubles("initial_min_immune_distance_from_tumor"); 30.0; // 75 // 50; 
	double radius_outer = radius_inner + 
		parameters.doubles("thickness_of_immune_seeding_region"); // 75.0; // 100; // 1000 - 50.0; 
	
	double mean_radius = 0.5*(radius_inner + radius_outer); 
	double std_radius = 0.33*( radius_outer-radius_inner)/2.0; 
	
	for( int i=0 ;i < number_of_immune_cells ; i++ )
	{
		double theta = UniformRandom() * 6.283185307179586476925286766559; 
		double phi = acos( 2.0*UniformRandom() - 1.0 );  
		
		double radius = NormalRandom( mean_radius, std_radius ); 
		
		Cell* pCell = create_cell( immune_cell ); 
		pCell->assign_position( radius*cos(theta)*sin(phi), radius*sin(theta)*sin(phi), radius*cos(phi) ); 
	}
	
	return; 
}


std::vector<std::vector<double>> create_cell_sphere_positions(double cell_radius, double sphere_radius)
{
	std::vector<std::vector<double>> cells;
	int xc=0,yc=0,zc=0;
	double x_spacing= cell_radius*sqrt(3);
	double y_spacing= cell_radius*2;
	double z_spacing= cell_radius*sqrt(3);
	
	std::vector<double> tempPoint(3,0.0);
	// std::vector<double> cylinder_center(3,0.0);
	
	for(double z=-sphere_radius;z<sphere_radius;z+=z_spacing, zc++)
	{
		for(double x=-sphere_radius;x<sphere_radius;x+=x_spacing, xc++)
		{
			for(double y=-sphere_radius;y<sphere_radius;y+=y_spacing, yc++)
			{
				tempPoint[0]=x + (zc%2) * 0.5 * cell_radius;
				tempPoint[1]=y + (xc%2) * cell_radius;
				tempPoint[2]=z;
				
				if(sqrt(norm_squared(tempPoint))< sphere_radius)
				{ cells.push_back(tempPoint); }
			}
			
		}
	}
	return cells;
	
}

void setup_tissue( void )
{
	// place a cluster of tumor cells at the center 
	
	double cell_radius = cell_defaults.phenotype.geometry.radius; 
	double cell_spacing = 0.95 * 2.0 * cell_radius; 
	
	double tumor_radius = 
		parameters.doubles("tumor_radius"); // 250.0; 
	
	Cell* pCell = NULL; 
	
	
	
	std::vector<std::vector<double>> positions = create_cell_sphere_positions(cell_radius,tumor_radius); 
	std::cout << "creating " << positions.size() << " closely-packed tumor cells ... " << std::endl; 
	
	static double imm_mean = parameters.doubles("tumor_mean_immunogenicity"); 
	static double imm_sd = parameters.doubles("tumor_immunogenicity_standard_deviation"); 
		
	for( int i=0; i < positions.size(); i++ )
	{
		pCell = create_cell(); // tumor cell 
		pCell->assign_position( positions[i] );
		pCell->custom_data[0] = NormalRandom( imm_mean, imm_sd );
		if( pCell->custom_data[0] < 0.0 )
		{ pCell->custom_data[0] = 0.0; } 
	}
	
	double sum = 0.0; 
	double min = 9e9; 
	double max = -9e9; 
	for( int i=0; i < all_cells->size() ; i++ )
	{
		double r = (*all_cells)[i]->custom_data[0]; 
		sum += r;
		if( r < min )
		{ min = r; } 
		if( r > max )
		{ max = r; }
	}
	double mean = sum / ( all_cells->size() + 1e-15 ); 
	// compute standard deviation 
	sum = 0.0; 
	for( int i=0; i < all_cells->size(); i++ )
	{
		sum +=  ( (*all_cells)[i]->custom_data[0] - mean )*( (*all_cells)[i]->custom_data[0] - mean ); 
	}
	double standard_deviation = sqrt( sum / ( all_cells->size() - 1.0 + 1e-15 ) ); 
	
	std::cout << std::endl << "Oncoprotein summary: " << std::endl
			  << "===================" << std::endl; 
	std::cout << "mean: " << mean << std::endl; 
	std::cout << "standard deviation: " << standard_deviation << std::endl; 
	std::cout << "[min max]: [" << min << " " << max << "]" << std::endl << std::endl; 
	
	return; 
}

// custom cell phenotype function to scale immunostimulatory factor with hypoxia 
void tumor_cell_phenotype_with_and_immune_stimulation( Cell* pCell, Phenotype& phenotype, double dt )
{
	static int cycle_start_index = live.find_phase_index( PhysiCell_constants::live ); 
	static int cycle_end_index = live.find_phase_index( PhysiCell_constants::live ); 
	static int oncoprotein_i = pCell->custom_data.find_variable_index( "oncoprotein" ); 
	
	// update secretion rates based on hypoxia 
	
	static int o2_index = microenvironment.find_density_index( "oxygen" ); 
	static int immune_factor_index = microenvironment.find_density_index( "immunostimulatory factor" ); 
	double o2 = pCell->nearest_density_vector()[o2_index];	

/*	
	if( o2 > pCell->parameters.o2_hypoxic_response )
	{
		phenotype.secretion.secretion_rates[immune_factor_index] = 0.0; 
	}
	else
	{
		double hypoxia = ( pCell->parameters.o2_hypoxic_response - o2 ) / ( pCell->parameters.o2_hypoxic_response + 1e-13 ); 
		phenotype.secretion.secretion_rates[ immune_factor_index ] = 10.0 * hypoxia; 	
	}
*/
	// new 
	phenotype.secretion.secretion_rates[immune_factor_index] = 10.0; 
	
	update_cell_and_death_parameters_O2_based(pCell,phenotype,dt);
	
	// if cell is dead, don't bother with future phenotype changes. 
	// set it to secrete the immunostimulatory factor 
	if( phenotype.death.dead == true )
	{
		phenotype.secretion.secretion_rates[immune_factor_index] = 10; 
		pCell->functions.update_phenotype = NULL; 		
		return; 
	}

	// multiply proliferation rate by the oncoprotein 
	phenotype.cycle.data.transition_rate( cycle_start_index ,cycle_end_index ) *= pCell->custom_data[oncoprotein_i] ; 
	
	return; 
}

std::vector<std::string> cancer_immune_coloring_function( Cell* pCell )
{
	static int oncoprotein_i = pCell->custom_data.find_variable_index( "oncoprotein" ); 
	
	// immune are black
	std::vector< std::string > output( 4, "black" ); 
	
	if( pCell->type == 1 )
	{ 
		output[0] = "lime";
		output[1] = "lime";
		output[2] = "green"; 
		return output;
	} 

	// if I'm under attack, color me 
	if( pCell->state.neighbors.size() > 0 )
	{
		output[0] = "darkcyan"; // orangered // "purple"; // 128,0,128
		output[1] = "black"; // "magenta"; 
		output[2] = "cyan"; // "magenta"; //255,0,255
		return output; 
	}
	
	// live cells are green, but shaded by oncoprotein value 
	if( pCell->phenotype.death.dead == false )
	{
		int oncoprotein = (int) round( 0.5 * pCell->custom_data[oncoprotein_i] * 255.0 ); 
		char szTempString [128];
		sprintf( szTempString , "rgb(%u,%u,%u)", oncoprotein, oncoprotein, 255-oncoprotein );
		output[0].assign( szTempString );
		output[1].assign( szTempString );

		sprintf( szTempString , "rgb(%u,%u,%u)", (int)round(output[0][0]/2.0) , (int)round(output[0][1]/2.0) , (int)round(output[0][2]/2.0) );
		output[2].assign( szTempString );
		
		return output; 
	}

	// if not, dead colors 
	
	if (pCell->phenotype.cycle.current_phase().code == PhysiCell_constants::apoptotic )  // Apoptotic - Red
	{
		output[0] = "rgb(255,0,0)";
		output[2] = "rgb(125,0,0)";
	}
	
	// Necrotic - Brown
	if( pCell->phenotype.cycle.current_phase().code == PhysiCell_constants::necrotic_swelling || 
		pCell->phenotype.cycle.current_phase().code == PhysiCell_constants::necrotic_lysed || 
		pCell->phenotype.cycle.current_phase().code == PhysiCell_constants::necrotic )
	{
		output[0] = "rgb(250,138,38)";
		output[2] = "rgb(139,69,19)";
	}	
	
	return output; 
}

void add_elastic_velocity( Cell* pActingOn, Cell* pAttachedTo , double elastic_constant )
{
	std::vector<double> displacement = pAttachedTo->position - pActingOn->position; 
	axpy( &(pActingOn->velocity) , elastic_constant , displacement ); 
	
	return; 
}

void extra_elastic_attachment_mechanics( Cell* pCell, Phenotype& phenotype, double dt )
{
	for( int i=0; i < pCell->state.neighbors.size() ; i++ )
	{
		add_elastic_velocity( pCell, pCell->state.neighbors[i], pCell->custom_data["elastic coefficient"] ); 
	}

	return; 
}	

void attach_cells( Cell* pCell_1, Cell* pCell_2 )
{
	#pragma omp critical
	{
		
	bool already_attached = false; 
	for( int i=0 ; i < pCell_1->state.neighbors.size() ; i++ )
	{
		if( pCell_1->state.neighbors[i] == pCell_2 )
		{ already_attached = true; }
	}
	if( already_attached == false )
	{ pCell_1->state.neighbors.push_back( pCell_2 ); }
	
	already_attached = false; 
	for( int i=0 ; i < pCell_2->state.neighbors.size() ; i++ )
	{
		if( pCell_2->state.neighbors[i] == pCell_1 )
		{ already_attached = true; }
	}
	if( already_attached == false )
	{ pCell_2->state.neighbors.push_back( pCell_1 ); }

	}

	return; 
}

void dettach_cells( Cell* pCell_1 , Cell* pCell_2 )
{
	#pragma omp critical
	{
		bool found = false; 
		int i = 0; 
		while( !found && i < pCell_1->state.neighbors.size() )
		{
			// if cell 2 is in cell 1's list, remove it
			if( pCell_1->state.neighbors[i] == pCell_2 )
			{
				int n = pCell_1->state.neighbors.size(); 
				// copy last entry to current position 
				pCell_1->state.neighbors[i] = pCell_1->state.neighbors[n-1]; 
				// shrink by one 
				pCell_1->state.neighbors.pop_back(); 
				found = true; 
			}
			i++; 
		}
	
		found = false; 
		i = 0; 
		while( !found && i < pCell_2->state.neighbors.size() )
		{
			// if cell 1 is in cell 2's list, remove it
			if( pCell_2->state.neighbors[i] == pCell_1 )
			{
				int n = pCell_2->state.neighbors.size(); 
				// copy last entry to current position 
				pCell_2->state.neighbors[i] = pCell_2->state.neighbors[n-1]; 
				// shrink by one 
				pCell_2->state.neighbors.pop_back(); 
				found = true; 
			}
			i++; 
		}

	}
	
	return; 
}

void immune_cell_motility( Cell* pCell, Phenotype& phenotype, double dt )
{
	// if attached, biased motility towards director chemoattractant 
	// otherwise, biased motility towards cargo chemoattractant 
	
	static int immune_factor_index = microenvironment.find_density_index( "immunostimulatory factor" ); 

	// if not docked, attempt biased chemotaxis 
	if( pCell->state.neighbors.size() == 0 )
	{
		// phenotype.motility.migration_bias = 0.25; 
		phenotype.motility.is_motile = true; 
		
		phenotype.motility.migration_bias_direction = pCell->nearest_gradient(immune_factor_index);	
		normalize( &( phenotype.motility.migration_bias_direction ) );			
	}
	else
	{
		phenotype.motility.is_motile = false; 
	}
	
	return; 
}

Cell* immune_cell_check_neighbors_for_attachment( Cell* pAttacker , double dt )
{
	std::vector<Cell*> nearby = pAttacker->cells_in_my_container(); 
	int i = 0; 
	while( i < nearby.size() )
	{
		// don't try to kill yourself 
		if( nearby[i] != pAttacker )
		{
			if( immune_cell_attempt_attachment( pAttacker, nearby[i] , dt ) )
			{ return nearby[i]; }
		}
		i++; 
	}
	
	return NULL; 
}

bool immune_cell_attempt_attachment( Cell* pAttacker, Cell* pTarget , double dt )
{
	static int oncoprotein_i = pTarget->custom_data.find_variable_index( "oncoprotein" ); 
	static int attach_rate_i = pAttacker->custom_data.find_variable_index( "attachment rate" ); 

	static double oncoprotein_saturation = 
		parameters.doubles("oncoprotein_saturation"); // 2.0; 
	static double oncoprotein_threshold =  
		parameters.doubles("oncoprotein_threshold"); // 0.5; // 0.1; 
	static double oncoprotein_difference = oncoprotein_saturation - oncoprotein_threshold;
	
	static double max_attachment_distance = 
		parameters.doubles("max_attachment_distance"); // 18.0; 
	static double min_attachment_distance = 
		parameters.doubles("min_attachment_distance"); // 14.0; 
	static double attachment_difference = max_attachment_distance - min_attachment_distance; 
	
	if( pTarget->custom_data[oncoprotein_i] > oncoprotein_threshold && pTarget->phenotype.death.dead == false )
	{
		std::vector<double> displacement = pTarget->position - pAttacker->position;
		double distance_scale = norm( displacement ); 
		if( distance_scale > max_attachment_distance )
		{ return false; } 
	
		double scale = pTarget->custom_data[oncoprotein_i];
		scale -= oncoprotein_threshold; 
		scale /= oncoprotein_difference;
		if( scale > 1.0 )
		{ scale = 1.0; } 
		
		distance_scale *= -1.0; 
		distance_scale += max_attachment_distance; 
		distance_scale /= attachment_difference; 
		if( distance_scale > 1.0 )
		{ distance_scale = 1.0; } 
		
		if( UniformRandom() < pAttacker->custom_data[attach_rate_i] * scale * dt * distance_scale )
		{
			std::cout << "\t attach!" << " " << pTarget->custom_data[oncoprotein_i] << std::endl; 
			attach_cells( pAttacker, pTarget ); 
		}
		
		return true; 
	}
	
	return false; 
}

bool immune_cell_attempt_apoptosis( Cell* pAttacker, Cell* pTarget, double dt )
{
	static int oncoprotein_i = pTarget->custom_data.find_variable_index( "oncoprotein" ); 
	static int apoptosis_model_index = pTarget->phenotype.death.find_death_model_index( "apoptosis" );	
	static int kill_rate_index = pAttacker->custom_data.find_variable_index( "kill rate" ); 
	
	
	
	static double oncoprotein_saturation = 
		parameters.doubles("oncoprotein_saturation"); // 2.0; 
	static double oncoprotein_threshold =  
		parameters.doubles("oncoprotein_threshold"); // 0.5; // 0.1; 
	static double oncoprotein_difference = oncoprotein_saturation - oncoprotein_threshold;

	
	// new 
	if( pTarget->custom_data[oncoprotein_i] < oncoprotein_threshold )
	{ return false; }
	
	// new 
	double scale = pTarget->custom_data[oncoprotein_i];
	scale -= oncoprotein_threshold; 
	scale /= oncoprotein_difference;
	if( scale > 1.0 )
	{ scale = 1.0; } 
	
	
//	if( UniformRandom() < pAttacker->custom_data[kill_rate_index] * pTarget->custom_data[oncoprotein_i] * dt )
	if( UniformRandom() < pAttacker->custom_data[kill_rate_index] * scale * dt )
	{ 
		std::cout << "\t\t kill!" << " " << pTarget->custom_data[oncoprotein_i] << std::endl; 
		return true; 
	}
	return false; 
}

bool immune_cell_trigger_apoptosis( Cell* pAttacker, Cell* pTarget )
{
	static int apoptosis_model_index = pTarget->phenotype.death.find_death_model_index( "apoptosis" );	
	
	// if the Target cell is already dead, don't bother!
	if( pTarget->phenotype.death.dead == true )
	{ return false; }

	pTarget->start_death( apoptosis_model_index );
	return true; 
}

void immune_cell_rule( Cell* pCell, Phenotype& phenotype, double dt )
{
	static int attach_lifetime_i = pCell->custom_data.find_variable_index( "attachment lifetime" ); 
	
	if( phenotype.death.dead == true )
	{
		// the cell death functions don't automatically turn off custom functions, 
		// since those are part of mechanics. 
		
		// Let's just fully disable now. 
		pCell->functions.custom_cell_rule = NULL; 
		return; 
	}
	
	// if I'm docked
	if( pCell->state.neighbors.size() > 0 )
	{
		extra_elastic_attachment_mechanics( pCell, phenotype, dt );
		
		// attempt to kill my attached cell
		
		bool dettach_me = false; 
		
		if( immune_cell_attempt_apoptosis( pCell, pCell->state.neighbors[0], dt ) )
		{
			immune_cell_trigger_apoptosis( pCell, pCell->state.neighbors[0] ); 
			dettach_me = true; 
		}
		
		// decide whether ot dettach 
		
		if( UniformRandom() < dt / ( pCell->custom_data[attach_lifetime_i] + 1e-15 ) )
		{ dettach_me = true; }
		
		// if I dettach, resume motile behavior 
		
		if( dettach_me )
		{
			dettach_cells( pCell, pCell->state.neighbors[0] ); 
			phenotype.motility.is_motile = true; 
		}
		return; 
	}
	
	// I'm not docked, look for cells nearby and try to docked
	
	// if this returns non-NULL, we're now attached to a cell 
	if( immune_cell_check_neighbors_for_attachment( pCell , dt) )
	{
		// set motility off 
		phenotype.motility.is_motile = false; 
		return; 
	}
	phenotype.motility.is_motile = true; 
	
	return; 
}


########## NEXT FILE ##########
PhysiCell_test_DCIS.cpp:::
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>
#include <time.h>

#include "../core/PhysiCell.h"
#include "../modules/PhysiCell_standard_modules.h"   

using namespace BioFVM;
using namespace PhysiCell;


int omp_num_threads = 8; // set number of threads for parallel computing
// set this to # of CPU cores x 2 (for hyperthreading)

double o2_conc=7.1930;  

double duct_radius= 158.75;

std::vector<std::vector<double>> create_sphere(double cell_radius, double sphere_radius)
{
	std::vector<std::vector<double>> cells;
	int xc=0,yc=0,zc=0;
	double x_spacing= cell_radius*sqrt(3);
	double y_spacing= cell_radius*2;
	double z_spacing= cell_radius*sqrt(3);
	
	std::vector<double> tempPoint(3,0.0);
	// std::vector<double> cylinder_center(3,0.0);
	
	for(double z=-sphere_radius;z<sphere_radius;z+=z_spacing, zc++)
		for(double x=-sphere_radius;x<sphere_radius;x+=x_spacing, xc++)
			for(double y=-sphere_radius;y<sphere_radius;y+=y_spacing, yc++)
			{
				tempPoint[0]=x + (zc%2) * 0.5 * cell_radius;
				tempPoint[1]=y + (xc%2) * cell_radius;
				tempPoint[2]=z;
				
				if(sqrt(norm_squared(tempPoint))< sphere_radius)
				{
					cells.push_back(tempPoint);
				}
			}
	return cells;
	
}


double distance_to_membrane_duct(Cell* pCell, Phenotype& phenotype, double dummy)
{
	double epsillon= 1e-7;
	//Note that this function assumes that duct cap center is located at <0, 0, 0>
	if(pCell->position[0]>=0) // Cell is within the cylinder part of the duct
	{
		double distance_to_x_axis= sqrt(pCell->position[1]* pCell->position[1] + pCell->position[2]*pCell->position[2]);
		distance_to_x_axis = std::max(distance_to_x_axis, epsillon);		// prevents division by zero
		pCell->displacement[0]=0; 
		pCell->displacement[1]= -pCell->position[1]/ distance_to_x_axis; 
		pCell->displacement[2]= -pCell->position[2]/ distance_to_x_axis; 
		return fabs(duct_radius- distance_to_x_axis);
	}
	
	// Cell is inside the cap of the duct
	double distance_to_origin= dist(pCell->position, {0.0,0.0,0.0});  // distance to the origin 
	distance_to_origin = std::max(distance_to_origin, epsillon);			  // prevents division by zero
	pCell->displacement[0]= -pCell->position[0]/ distance_to_origin;
	pCell->displacement[1]= -pCell->position[1]/ distance_to_origin;
	pCell->displacement[2]= -pCell->position[2]/ distance_to_origin;
	return fabs(duct_radius- distance_to_origin);
}

int main( int argc, char* argv[] )
{
	bool DEBUG=false;
	double t = 0.0; 
	double dt = 0.01; // reaction-diffusion time-step
	double mechanics_dt= 0.1;
	double cell_cycle_dt= 6;
	
	double t_output_interval = 60.0; // 1.0; 
	double t_max = 365*24*60;
	double t_next_output_time = 0; 
	int next_output_index = 0; 
	
	double dx; 
	double dy;  
	double dz; 
	
	// openmp setup
	omp_set_num_threads(omp_num_threads);
	
	// PNRG setup 	
	SeedRandom(3); 
	
	// figure out the bounding box 
	std::vector<double> bounding_box( 6, 0.0 );
	bounding_box[PhysiCell_constants::mesh_min_x_index] = -200; bounding_box[PhysiCell_constants::mesh_max_x_index] = 1000; 
	bounding_box[PhysiCell_constants::mesh_min_y_index] = -200; bounding_box[PhysiCell_constants::mesh_max_y_index] = 200; 
	bounding_box[PhysiCell_constants::mesh_min_z_index] = -200; bounding_box[PhysiCell_constants::mesh_max_z_index] = 200; 
	dx=20; dy=20; dz=20;
	
	
	// create a microenvironment
	BioFVM::Microenvironment microenvironment;
	microenvironment.name="substrate scale";
	// add a microenvironment for simulating substrates 	
	// microenvironment.create_microenvironment( "substrate scale"); 
	microenvironment.set_density(0, "oxygen" , "mmHg" );
	// microenvironment.add_density( "glucose" , "dimensionless" );
	
	std::cout << bounding_box << std::endl; 
	
	microenvironment.resize_space( bounding_box[0] , bounding_box[3] , bounding_box[1], bounding_box[4] , bounding_box[2] , bounding_box[5] ,dx,dy,dz );
	microenvironment.spatial_units = "microns";
	microenvironment.time_units = "minutes";
	microenvironment.mesh.units = "microns";
	
	// Cell_Container 
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	for( int n=0; n < microenvironment.number_of_voxels() ; n++ )
	{
		microenvironment.density_vector(n)[0] = o2_conc; 	
	}
	
	// register the diffusion solver 
	microenvironment.diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_3D; 
	
	// register substrates properties 
	microenvironment.diffusion_coefficients[0] = 1.0e5; // microns^2 / min 
	microenvironment.decay_rates[0] = 0.1;

	microenvironment.display_information( std::cout );

	
	initialize_default_cell_definition(); 	
	cell_defaults.type = 0; 
	cell_defaults.name = "tumor cell"; 
	// set default cell cycle model 
	cell_defaults.functions.cycle_model = Ki67_advanced; 	
	// set default_cell_functions; 
	cell_defaults.functions.update_phenotype = update_cell_and_death_parameters_O2_based; 
	cell_defaults.phenotype.secretion.sync_to_microenvironment( &microenvironment );
	cell_defaults.phenotype.sync_to_functions( cell_defaults.functions );
	
	int Q_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_negative );
	int oxygen_substrate_index = microenvironment.find_density_index( "oxygen" ); 
	int K1_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_positive_premitotic );
	int K2_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_positive_postmitotic );
	int apoptosis_model_index = cell_defaults.phenotype.death.find_death_model_index( "apoptosis" );
	int necrosis_model_index = cell_defaults.phenotype.death.find_death_model_index( "necrosis" );
	// cells apoptose after about 7 days 
	cell_defaults.phenotype.death.rates[apoptosis_model_index] = 1.0 / (7.0 * 24.0 * 60.0); 
	// initially no necrosis 
	cell_defaults.phenotype.death.rates[necrosis_model_index] = 0.0; 

	// make sure the cells uptake oxygen at the right rate 
	cell_defaults.phenotype.secretion.uptake_rates[oxygen_substrate_index] = 10; 

	// update transition times 
	cell_defaults.phenotype.cycle.data.transition_rate(Q_index,K1_index) = 1.0 / ( 8.5 * 60.0 ); 
	cell_defaults.phenotype.cycle.data.transition_rate(K1_index,K2_index) = 1.0 / ( 13.0 * 60.0 ); 
	cell_defaults.phenotype.cycle.data.transition_rate(K2_index,Q_index) = 1.0 / ( 2.5 * 60.0 ); 
	
	// let's make necrotic cells survive 6 hours in minimal oxygen conditions  
	cell_defaults.parameters.max_necrosis_rate = 1.0 / (6.0 * 60.0); 
	

	cell_defaults. functions.calculate_distance_to_membrane= distance_to_membrane_duct;
	double cell_radius=10;
	double sphere_radius = duct_radius - 10;;
	// std::cout << __FILE__ << " custom " << __LINE__ << std::endl; 
	std::vector<std::vector<double>> cell_positions;
	cell_positions= create_sphere(cell_radius, sphere_radius);

	//add Dirichlet node for all the voxels located outside of the duct
	std::vector<double> dirichlet_o2( 1 , o2_conc );
	
	for( int i=0; i < microenvironment.number_of_voxels() ; i++ )
	{
		if(microenvironment.voxels(i).center[0]>=0)
		{
			if(sqrt(microenvironment.voxels(i).center[1]* microenvironment.voxels(i).center[1] + microenvironment.voxels(i).center[2]*microenvironment.voxels(i).center[2])>duct_radius)
				microenvironment.add_dirichlet_node( i , dirichlet_o2 );
		}
		else
		{
			if(dist(microenvironment.voxels(i).center, {0.0,0.0,0.0})>duct_radius)
				microenvironment.add_dirichlet_node( i , dirichlet_o2 );
		}
	}
	
	Cell* pCell;

	for(int i=0;i<cell_positions.size();i++)
	// for(int i=0;i<2;i++)
	{
		if(cell_positions[i][0]>0)
			continue;
		pCell = create_cell();
		pCell->register_microenvironment(&microenvironment);
		pCell->assign_position(cell_positions[i]);
		pCell->phenotype.cycle.data.current_phase_index = Q_index; 
		if( pCell->phenotype.cycle.current_phase().entry_function )                      
			pCell->phenotype.cycle.current_phase().entry_function( pCell, pCell->phenotype, dt);
		// pCell->parameters.necrosis_type= PhysiCell_constants::deterministic_necrosis;
	}
	for(int i=0;i<all_basic_agents.size();i++){
		all_basic_agents[i]->set_internal_uptake_constants(dt); 
	}
	
	
	std::cout << (*all_cells).size() <<" agents created successfully." <<std::endl;
	
	std::vector<double> position (3, 0.0);
	position[0]=0;
	position[1]=0;
	position[2]=0;
	
	int output_index =0; 
	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	std::cout << "CLOCKS_PER_SEC = " << CLOCKS_PER_SEC << "\n";
	
/*	clock_t begin = clock();
	double sum=0;
  for(int i=0;i<1000000000;i++)
  {
	  sum+= sqrt((double)i);
  }
	std::cout<<"sum: "<<sum<<std::endl;
  clock_t end = clock();
  double elapsed_secs = double(end - begin) / CLOCKS_PER_SEC;
 */
  
	std::ofstream report_file ("report.txt");
	report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	try 
	{		
		while( t < t_max )
		{
			if(  fabs( t - t_next_output_time ) < 0.0001 )
			{
				log_output(t, output_index, microenvironment, report_file);
				t_next_output_time += t_output_interval;						
			}
			// std::cout<<__LINE__<<std::endl;			
			microenvironment.simulate_cell_sources_and_sinks( dt );
			microenvironment.simulate_diffusion_decay( dt );
			((Cell_Container *)microenvironment.agent_container)->update_all_cells(t, cell_cycle_dt, mechanics_dt, dt);		
			t += dt; 
			output_index++;
		}
		log_output(t, output_index, microenvironment, report_file);
		report_file.close();
	}
	catch( const std::exception& e ) { // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	return 0; 
}

########## NEXT FILE ##########
PhysiCell_test_HDS.cpp:::
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>


#include "../core/PhysiCell.h"
#include "../modules/PhysiCell_standard_modules.h"   

using namespace BioFVM;
using namespace PhysiCell;


int omp_num_threads = 8; // set number of threads for parallel computing
// set this to # of CPU cores x 2 (for hyperthreading)

double o2_conc=38.0;   //check this value to make sure it has support from literature

std::vector<std::vector<double>> create_sphere(double cell_radius, double sphere_radius)
{
	std::vector<std::vector<double>> cells;
	int xc=0,yc=0,zc=0;
	double x_spacing= cell_radius*sqrt(3);
	double y_spacing= cell_radius*2;
	double z_spacing= cell_radius*sqrt(3);
	
	std::vector<double> tempPoint(3,0.0);
	// std::vector<double> cylinder_center(3,0.0);
	
	for(double z=-sphere_radius;z<sphere_radius;z+=z_spacing, zc++)
		for(double x=-sphere_radius;x<sphere_radius;x+=x_spacing, xc++)
			for(double y=-sphere_radius;y<sphere_radius;y+=y_spacing, yc++)
			{
				tempPoint[0]=x + (zc%2) * 0.5 * cell_radius;
				tempPoint[1]=y + (xc%2) * cell_radius;
				tempPoint[2]=z;
				
				if(sqrt(norm_squared(tempPoint))< sphere_radius)
				{
					cells.push_back(tempPoint);
				}
			}
	return cells;
	
}

int main( int argc, char* argv[] )
{
	bool DEBUG=false;
	double t = 0.0; 
	double dt = 0.01; // reaction-diffusion time-step
	double mechanics_dt= 0.1;
	double cell_cycle_dt= 6;
	
	double t_output_interval = 600.0; // 1.0; 
	double t_max = 365*24*60;
	double t_next_output_time = 0; 
	int next_output_index = 0; 
	
	double dx; 
	double dy;  
	double dz; 
	
	// openmp setup
	omp_set_num_threads(omp_num_threads);
	
	// PNRG setup 	
	SeedRandom(3); 
	
	// figure out the bounding box 
	std::vector<double> bounding_box( 6, 0.0 );
	bounding_box[PhysiCell_constants::mesh_min_x_index] = -1000; bounding_box[PhysiCell_constants::mesh_max_x_index] = 1000; 
	bounding_box[PhysiCell_constants::mesh_min_y_index] = -1000; bounding_box[PhysiCell_constants::mesh_max_y_index] = 1000; 
	bounding_box[PhysiCell_constants::mesh_min_z_index] = -1000; bounding_box[PhysiCell_constants::mesh_max_z_index] = 1000; 
	dx=20; dy=20; dz=20;
	

	// create a microenvironment
	BioFVM::Microenvironment microenvironment;
	microenvironment.name="substrate scale";
	// add a microenvironment for simulating substrates 	
	// microenvironment.create_microenvironment( "substrate scale"); 
	microenvironment.set_density(0, "oxygen" , "mmHg" );
	// microenvironment.add_density( "glucose" , "dimensionless" );
	
	std::cout << bounding_box << std::endl; 
	
	microenvironment.resize_space( bounding_box[0] , bounding_box[3] , bounding_box[1], bounding_box[4] , bounding_box[2] , bounding_box[5] ,dx,dy,dz );
	microenvironment.spatial_units = "microns";
	microenvironment.time_units = "minutes";
	microenvironment.mesh.units = "microns";
	
	// Cell_Container 
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	for( int n=0; n < microenvironment.number_of_voxels() ; n++ )
	{
		microenvironment.density_vector(n)[0] = o2_conc; 	
	}
	
	// register the diffusion solver 
	microenvironment.diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_3D; 
	
	// register substrates properties 
	microenvironment.diffusion_coefficients[0] = 1.0e5; // microns^2 / min 
	microenvironment.decay_rates[0] = 0.1;

	microenvironment.display_information( std::cout );

	
	initialize_default_cell_definition(); 	
	cell_defaults.type = 0; 
	cell_defaults.name = "tumor cell"; 
	// set default cell cycle model 
	cell_defaults.functions.cycle_model = Ki67_advanced; 	
	// set default_cell_functions; 
	cell_defaults.functions.update_phenotype = update_cell_and_death_parameters_O2_based; 
	cell_defaults.phenotype.secretion.sync_to_microenvironment( &microenvironment );
	cell_defaults.phenotype.sync_to_functions( cell_defaults.functions );
	
	int Q_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_negative );
	int oxygen_substrate_index = microenvironment.find_density_index( "oxygen" ); 
	int K1_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_positive_premitotic );
	int K2_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_positive_postmitotic );
	int apoptosis_model_index = cell_defaults.phenotype.death.find_death_model_index( "apoptosis" );
	int necrosis_model_index = cell_defaults.phenotype.death.find_death_model_index( "necrosis" );
	// cells apoptose after about 7 days 
	cell_defaults.phenotype.death.rates[apoptosis_model_index] = 1.0 / (7.0 * 24.0 * 60.0); 
	// initially no necrosis 
	cell_defaults.phenotype.death.rates[necrosis_model_index] = 0.0; 

	// make sure the cells uptake oxygen at the right rate 
	cell_defaults.phenotype.secretion.uptake_rates[oxygen_substrate_index] = 10; 

	// update transition times 
	cell_defaults.phenotype.cycle.data.transition_rate(Q_index,K1_index) = 1.0 / ( 8.5 * 60.0 ); 
	cell_defaults.phenotype.cycle.data.transition_rate(K1_index,K2_index) = 1.0 / ( 13.0 * 60.0 ); 
	cell_defaults.phenotype.cycle.data.transition_rate(K2_index,Q_index) = 1.0 / ( 2.5 * 60.0 ); 
	
	// let's make necrotic cells survive 6 hours in minimal oxygen conditions  
	cell_defaults.parameters.max_necrosis_rate = 1.0 / (6.0 * 60.0); 
	
	double cell_radius=10;
	double sphere_radius = 150;
	// std::cout << __FILE__ << " custom " << __LINE__ << std::endl; 
	std::vector<std::vector<double>> cell_positions;
	cell_positions= create_sphere(cell_radius, sphere_radius);

	//add Dirichlet node for all the voxels located outside of the duct
	std::vector<double> dirichlet_o2( 1 , o2_conc );
	
	double min_x=microenvironment.mesh.bounding_box[0];
	double max_x=microenvironment.mesh.bounding_box[3];
	double min_y=microenvironment.mesh.bounding_box[1];
	double max_y=microenvironment.mesh.bounding_box[4];
	double min_z=microenvironment.mesh.bounding_box[2];
	double max_z=microenvironment.mesh.bounding_box[5];
	double strip_width=40;	

	for( int i=0; i < microenvironment.number_of_voxels() ; i++ )
	{
		if( abs(max_x-microenvironment.voxels(i).center[0]) < strip_width || abs(microenvironment.voxels(i).center[0]- min_x)< strip_width  
			|| abs(max_y-microenvironment.voxels(i).center[1]) < strip_width || abs(microenvironment.voxels(i).center[1]- min_y)< strip_width  
				|| abs(max_z-microenvironment.voxels(i).center[2]) < strip_width || abs(microenvironment.voxels(i).center[2]- min_z)< strip_width )
				{
					microenvironment.add_dirichlet_node( i , dirichlet_o2 );
				}		
	}

	
	Cell* pCell;

for(int i=0;i<cell_positions.size();i++)
	// for(int i=0;i<2;i++)
	{
		if(cell_positions[i][0]>0)
			continue;
		pCell = create_cell();
		pCell->register_microenvironment(&microenvironment);
		pCell->assign_position(cell_positions[i]);
		pCell->phenotype.cycle.data.current_phase_index = Q_index; 
		if( pCell->phenotype.cycle.current_phase().entry_function )                      
			pCell->phenotype.cycle.current_phase().entry_function( pCell, pCell->phenotype, dt);
		// pCell->parameters.necrosis_type= PhysiCell_constants::deterministic_necrosis;
	}

	for(int i=0;i<all_basic_agents.size();i++){
		all_basic_agents[i]->set_internal_uptake_constants(dt); 
	}
	
	std::cout << (*all_cells).size() <<" agents created successfully." <<std::endl;
	
	std::vector<double> position (3, 0.0);
	position[0]=0;
	position[1]=0;
	position[2]=0;
	
	int output_index =0; 
	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file ("report_spheroid.txt");
	report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	try 
	{		
		while( t < t_max )
		{
			if(  fabs( t - t_next_output_time ) < 0.0001 )
			{
				log_output(t, output_index, microenvironment, report_file);
				t_next_output_time += t_output_interval;						
			}
			microenvironment.simulate_cell_sources_and_sinks( dt );
			microenvironment.simulate_diffusion_decay( dt );
			((Cell_Container *)microenvironment.agent_container)->update_all_cells(t, cell_cycle_dt, mechanics_dt, dt);		
			t += dt; 
			output_index++;
		}
		log_output(t, output_index, microenvironment, report_file);
		report_file.close();
	}
	catch( const std::exception& e ) { // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	return 0; 
}

########## NEXT FILE ##########
PhysiCell_test_cell_cycle.cpp:::
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "../core/PhysiCell.h"
#include "../modules/PhysiCell_standard_modules.h" 

using namespace BioFVM;
using namespace PhysiCell;


int omp_num_threads = 8; // set number of threads for parallel computing
// set this to # of CPU cores x 2 (for hyperthreading)
double pi=3.1415926535897932384626433832795;

double o2_conc=6.06;
double min_voxel_size=30;

int write_test_report(std::vector<Cell*> all_cells, double timepoint)
{
    std::string filename; 
    filename.resize( 1024 ); 
    sprintf( (char*) filename.c_str() , "test_cycle\\cells_%08i.txt" , (int)round(timepoint) ); 
    std::ofstream outputFile (filename.c_str(), std::ofstream::out);
    //outputFile<<"\tID\tx\ty\tz\tradius\tphenotype\telapsed_time\n";
    int phenotype_code;
    for(int i=0;i<all_cells.size();i++)
    {
        phenotype_code=all_cells[i]->phenotype.cycle.current_phase().code;
        outputFile<<i<<"\t"<<all_cells[i]->ID<<"\t"<<all_cells[i]->position[0]<<"\t" << all_cells[i]->position[1] <<"\t"<< all_cells[i]->position[2]<<"\t";
        outputFile<<all_cells[i]->phenotype.geometry.radius<<"\t"<<phenotype_code<< "\t"<< all_cells[i]->
        phenotype.cycle.data.elapsed_time_in_phase <<std::endl;
         
        // std::cout<<"Cell ID #"<<all_cells[i]->ID<<" position: "<< all_cells[i]->position<<std::endl;
    }
    outputFile.close();
    return 0;
}

int main( int argc, char* argv[] )
{
	if(argc<=1)
	{
		std::cout<<"you need to provide dt as an argument"<<std::endl;
		return 0;
	}
	double t = 0.0; 
	double dt = strtod(argv[1], NULL);
	std::cout<<dt<<std::endl;
	
	double t_output_interval = std::max(60.0,dt); // 1.0; 
	double t_max = 60*24*6;
	double t_next_output_time = 0; 
	int next_output_index = 0; 
	
	double dx; 
	double dy;  
	double dz; 
	
	// openmp setup
	omp_set_num_threads(omp_num_threads);
	
	// PNRG setup 	
	SeedRandom(); 
	
	// figure out the bounding box 
	double side_length= 2000;
	std::vector<double> bounding_box( 6, 0.0 );
	bounding_box[PhysiCell_constants::mesh_min_x_index] = 0; bounding_box[PhysiCell_constants::mesh_max_x_index] = side_length; 
	bounding_box[PhysiCell_constants::mesh_min_y_index] = 0; bounding_box[PhysiCell_constants::mesh_max_y_index] = side_length; 
	bounding_box[PhysiCell_constants::mesh_min_z_index] = 0; bounding_box[PhysiCell_constants::mesh_max_z_index] = side_length; 
	dx=20; dy=20; dz=20;
		
	// create a microenvironment; 
	BioFVM::Microenvironment microenvironment;
	microenvironment.name="substrate scale";
	// add a microenvironment for simulating substrates 	
	microenvironment.set_density(0, "oxygen" , "mmHg" );
	
	std::cout << bounding_box << std::endl; 
	
	microenvironment.resize_space( bounding_box[0] , bounding_box[3] , bounding_box[1], bounding_box[4] , bounding_box[2] , bounding_box[5] ,dx,dy,dz );
	microenvironment.spatial_units = "microns";
	microenvironment.time_units = "minutes";
	microenvironment.mesh.units = "microns";
	// Cell_Container 
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	for( int n=0; n < microenvironment.number_of_voxels() ; n++ )
	{
		microenvironment.density_vector(n)[0] = o2_conc; 	
	}
	
	// register the diffusion solver 
	microenvironment.diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_3D; 
	
	initialize_default_cell_definition(); 	
	cell_defaults.type = 0; 
	cell_defaults.name = "tumor cell"; 
	// set default cell cycle model 
	cell_defaults.functions.cycle_model = Ki67_advanced; 	
	// set default_cell_functions; 
	cell_defaults.functions.update_phenotype = update_cell_and_death_parameters_O2_based; 
	
	// disable cell's movement
	cell_defaults.functions.update_velocity=empty_function;
	cell_defaults.phenotype.secretion.sync_to_microenvironment( &microenvironment );
	cell_defaults.phenotype.sync_to_functions( cell_defaults.functions ); 
	// first find index for a few key variables. 
	int apoptosis_model_index = cell_defaults.phenotype.death.find_death_model_index( "Apoptosis" );
	int necrosis_model_index = cell_defaults.phenotype.death.find_death_model_index( "Necrosis" );
	int oxygen_substrate_index = microenvironment.find_density_index( "oxygen" ); 

	int K1_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_positive_premitotic );
	int K2_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_positive_postmitotic );
	int Q_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_negative );
	int A_index = Ki67_advanced.find_phase_index( PhysiCell_constants::apoptotic );
	int N_index = Ki67_advanced.find_phase_index( PhysiCell_constants::necrotic_swelling );
	
		// cells apoptose after about 7 days 
	cell_defaults.phenotype.death.rates[apoptosis_model_index] = 1.0 / (7.0 * 24.0 * 60.0); 
	// initially no necrosis 
	cell_defaults.phenotype.death.rates[necrosis_model_index] = 0.0; 

	// make sure the cells uptake oxygen at the right rate 
	cell_defaults.phenotype.secretion.uptake_rates[oxygen_substrate_index] = 0; 

	// cells leave the Q phase and enter the K1 phase after 5 hours 
	cell_defaults.phenotype.cycle.data.transition_rate(Q_index,K1_index) = 1.0 / ( 5.0 * 60.0 ); 
	
	// let's make necrotic cells survive 6 hours in minimal oxygen conditions  
	cell_defaults.parameters.max_necrosis_rate = 1.0 / (6.0 * 60.0); 
	

	microenvironment.display_information( std::cout );

	std::vector<double> temp_position(3);
	
	int num_ki67_positive_pre= 0;
	int num_ki67_positive_post= 0;
	int num_ki67_q=1000;//;
	int num_apoptotic= 0;
	int total= num_ki67_positive_pre + num_ki67_positive_post + num_ki67_q + num_apoptotic;
	double T1= 13 * 60;
	double T2= 2.5 * 60;
	double TQ= 74.35 * 60;
	double TA= 8.6 * 60;
	double T;
	int phase_index;
	for(int i=0;i<total;i++)
	{
		
		for(int j=0;j<3;j++)
			temp_position[j]= uniform_random()*1000+500;
		Cell* pCell = create_cell();
		pCell->register_microenvironment(&microenvironment);
		pCell->assign_position(temp_position);
		//pCell->advance_cell_current_phase=ki67_advanced_cycle_model_stochastic;
		if(i<num_ki67_positive_pre)
		{
			phase_index=K1_index;
			T = T1;
		}
		else if(i< num_ki67_positive_pre+ num_ki67_positive_post)
		{
			phase_index = K2_index;	
			T = T2;			
		}
		else if(i< num_ki67_positive_pre+ num_ki67_positive_post+ num_apoptotic)
		{
			phase_index = A_index;	
			T = TA;	
			pCell->phenotype.death.trigger_death( apoptosis_model_index );
			pCell->phenotype.cycle.sync_to_cycle_model( pCell->phenotype.death.current_model() );
		}
		else
		{
			phase_index = Q_index;	
			T = TQ;			
		}
		pCell->phenotype.cycle.data.current_phase_index = phase_index; 
		if( pCell->phenotype.cycle.current_phase().entry_function )                      
			pCell->phenotype.cycle.current_phase().entry_function( pCell, pCell->phenotype, dt);
		// std::cout<<__FILE__<<","<<__LINE__<<std::endl;

	}
	for(int i=0;i<all_basic_agents.size();i++){
		all_basic_agents[i]->set_internal_uptake_constants(dt); 
	}
		
	std::cout << (*all_cells).size() <<" agents created successfully." <<std::endl;
	
	int output_index =0; 
	// std::ofstream report_file ("report.txt");
	// report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();

	try 
	{		
		while( t < t_max )
		{
			if(  fabs( t - t_next_output_time ) < 0.0001 )
			{
				write_test_report(*all_cells,t);
				t_next_output_time += t_output_interval;	
				std::cout << "t: "<<t<<", cell count: "<<(*all_cells).size()<<std::endl;
			}
	
			((Cell_Container *)microenvironment.agent_container)->update_all_cells(t, dt, dt, dt);
			t += dt; 
			output_index++;
		}
		write_test_report(*all_cells,t);
		// report_file.close();
	}
	catch( const std::exception& e ) { // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	return 0; 
}

########## NEXT FILE ##########
PhysiCell_test_mechanics_1.cpp:::
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "../core/PhysiCell.h"
#include "../modules/PhysiCell_standard_modules.h" 
using namespace BioFVM;
using namespace PhysiCell;

int omp_num_threads = 8; // set number of threads for parallel computing
// set this to # of CPU cores x 2 (for hyperthreading)


void do_nothing(Cell* pCell, Phenotype& phenotype, double dt){}

int main( int argc, char* argv[] )
{
	if(argc<=1)
	{
		std::cout<<"you need to provide dt as an argument"<<std::endl;
		return 0;
	}

	double t = 0.0; 
	double dt = strtod(argv[1],NULL);
	double t_output_interval = 1; // 1.0; 
	double t_max = 60;
	double t_next_output_time = 0; 
	int next_output_index = 0; 
	
	double dx; 
	double dy;  
	double dz; 
	
	// openmp setup
	omp_set_num_threads(omp_num_threads);
	
	// PNRG setup 	
	SeedRandom(3); 
	
	// figure out the bounding box 
	std::vector<double> bounding_box( 6, 0.0 );
	bounding_box[PhysiCell_constants::mesh_min_x_index] = 0; bounding_box[PhysiCell_constants::mesh_max_x_index] = 2000; 
	bounding_box[PhysiCell_constants::mesh_min_y_index] = 0; bounding_box[PhysiCell_constants::mesh_max_y_index] = 2000; 
	bounding_box[PhysiCell_constants::mesh_min_z_index] = 0; bounding_box[PhysiCell_constants::mesh_max_z_index] = 2000; 
	dx=20; dy=20; dz=20;
	
	// create a microenvironment;
	BioFVM::Microenvironment microenvironment;
	microenvironment.name="substrate scale";
	// add a microenvironment for simulating substrates 	
	microenvironment.set_density(0, "oxygen" , "mmHg" );
	microenvironment.resize_space( bounding_box[0] , bounding_box[3] , bounding_box[1], bounding_box[4] , bounding_box[2] , bounding_box[5] ,dx,dy,dz );
	microenvironment.spatial_units = "microns";
	microenvironment.time_units = "minutes";
	microenvironment.mesh.units = "microns";
	// Since this is just a test for mechanics, the following density initialization are not needed
	/* for( int n=0; n < microenvironment.number_of_voxels() ; n++ )
	{
		microenvironment.density_vector(n)[0] = o2_conc; 	
	}*/
	
	// Cell_Container
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	//microenvironment.agent_container= (Agent_Container *) cell_container; // cell_container;
	
	initialize_default_cell_definition(); 	
	cell_defaults.type = 0; 
	cell_defaults.name = "tumor cell"; 
	cell_defaults.functions.cycle_model = Ki67_advanced; 
	cell_defaults.functions.update_phenotype = empty_function;
	cell_defaults.functions.volume_update_function = empty_function;
	
	
	int Q_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_negative );
	// register the diffusion solver 
	microenvironment.diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_3D; 
		
	microenvironment.display_information( std::cout );

	
	// std::cout << __FILE__ << " custom " << __LINE__ << std::endl; 
	std::vector<double> point1(3), point2(3);

	double num1, num2;
	num1=100;
	num2= 105.73;
	double volume=4188.790204786391;
	point1[0]= num1; point1[1]= num1; point1[2]= num1; 
	point2[0]= num2; point2[1]= num2; point2[2]= num2; 
	
	Cell* pCell1 = create_cell();
	pCell1->register_microenvironment(&microenvironment);
	pCell1->assign_position(point1);
	pCell1->phenotype.cycle.data.current_phase_index = Q_index; 
	/* NOTE: for this experiment, you need to disable volume update function 
	 to make sure that volume change are not affecting the distance we measure for the cells.*/
	//pCell1->functions.volume_update_function=do_nothing;
	pCell1->set_total_volume(volume);
	
	Cell* pCell2 = create_cell();
	 pCell2->register_microenvironment(&microenvironment);
	pCell2->assign_position(point2);
	pCell2->phenotype.cycle.data.current_phase_index = Q_index; 
	//pCell2->functions.volume_update_function=do_nothing;
	pCell2->set_total_volume(volume);
	
	std::cout << pCell1->phenotype.geometry.radius<<std::endl;
	
	std::cout << (*all_cells).size() <<" agents created successfully." <<std::endl;
	
	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::string filename; 
	filename.resize( 1024 ); 
	sprintf( (char*) filename.c_str() , "mechanics_test1_result_dt=%f.txt" , dt ); 
	std::ofstream report_file (filename.c_str(), std::ofstream::out);
	
	pCell1->functions.update_velocity(pCell1,pCell1->phenotype, dt);
	pCell2->functions.update_velocity(pCell2,pCell2->phenotype, dt);
	
	pCell1->set_previous_velocity(pCell1->velocity[0],pCell1->velocity[1],pCell1->velocity[2]);
	pCell2->set_previous_velocity(pCell2->velocity[0],pCell2->velocity[1],pCell2->velocity[2]);
		
	for(int i=0;i<10;i++)
	{
		pCell1->position += (dt/10.0)*pCell1->velocity; 
		pCell2->position += (dt/10.0)*pCell2->velocity;
		t+=dt/10.0;
	}
	std::cout<<"time: "<< t<<std::endl;
	t_next_output_time=t_output_interval;
	std::cout<<pCell1->get_total_volume()<<std::endl;
	try 
	{		
		while( t < t_max )
		{
			
			if(  fabs( t - t_next_output_time ) < dt/10.0 )
			{
				report_file<<t<<"\t"<<dist(pCell1->position,pCell2->position)<<"\n";
				t_next_output_time += t_output_interval; 
			}
			
			((Cell_Container *)microenvironment.agent_container)->update_all_cells(t, dt, dt, dt);
			t += dt; 
		}
		report_file.close();
		std::cout<<pCell1->position<<"  "<< pCell2->position<< ", distance: " <<dist(pCell1->position,pCell2->position)<<  std::endl;
		
		std::cout<<pCell1->get_total_volume()<<std::endl;
		std::cout << "total number of agents: " << (*all_cells).size()<<std::endl << std::endl;
		BioFVM::RUNTIME_TOC();
		BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() );
	}
	catch( const std::exception& e ) { // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	return 0; 
}

########## NEXT FILE ##########
PhysiCell_test_mechanics_2.cpp:::
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "../core/PhysiCell.h"
#include "../modules/PhysiCell_standard_modules.h" 

using namespace BioFVM;
using namespace PhysiCell;

int omp_num_threads = 8; // set number of threads for parallel computing
// set this to # of CPU cores x 2 (for hyperthreading)
double pi=3.1415926535897932384626433832795;

double min_voxel_size=30;

void do_nothing(Cell* pCell, Phenotype& phenotype, double dt){}

std::vector<std::vector<double>> create_sphere(double cell_radius, double sphere_radius)
{
	std::vector<std::vector<double>> cells;
	int xc=0,yc=0,zc=0;
	double x_spacing= cell_radius*sqrt(3);
	double y_spacing= cell_radius*2;
	double z_spacing= cell_radius*sqrt(3);
	
	std::vector<double> tempPoint(3,0.0);
	// std::vector<double> cylinder_center(3,0.0);
	
	for(double z=-sphere_radius;z<sphere_radius;z+=z_spacing, zc++)
		for(double x=-sphere_radius;x<sphere_radius;x+=x_spacing, xc++)
			for(double y=-sphere_radius;y<sphere_radius;y+=y_spacing, yc++)
			{
				tempPoint[0]=x + (zc%2) * 0.5 * cell_radius;
				tempPoint[1]=y + (xc%2) * cell_radius;
				tempPoint[2]=z;
				
				if(sqrt(norm_squared(tempPoint))< sphere_radius)
				{
					cells.push_back(tempPoint);
				}
			}
	return cells;
	
}

int main( int argc, char* argv[] )
{
	if(argc<=1)
	{
		std::cout<<"you need to provide dt as an argument"<<std::endl;
		return 0;
	}

	double t = 0.0; 
	double dt = strtod(argv[1],NULL);
	double t_output_interval = 5.0; // 1.0; 
	double t_max = 60;
	double t_next_output_time = 0; 
	int next_output_index = 0; 
	
	double dx; 
	double dy;  
	double dz; 
	
	// openmp setup
	omp_set_num_threads(omp_num_threads);
	
	// PNRG setup 	
	SeedRandom(3); 
	
	// figure out the bounding box 
	std::vector<double> bounding_box( 6, 0.0 );
	bounding_box[PhysiCell_constants::mesh_min_x_index] = 0; bounding_box[PhysiCell_constants::mesh_max_x_index] = 2000; 
	bounding_box[PhysiCell_constants::mesh_min_y_index] = 0; bounding_box[PhysiCell_constants::mesh_max_y_index] = 2000; 
	bounding_box[PhysiCell_constants::mesh_min_z_index] = 0; bounding_box[PhysiCell_constants::mesh_max_z_index] = 2000; 
	dx=20; dy=20; dz=20;
	
	
	// create a microenvironment
	BioFVM::Microenvironment microenvironment;
	microenvironment.name="substrate scale";
	// add a microenvironment for simulating substrates 	
	microenvironment.set_density(0, "oxygen" , "mmHg" );
	
	std::cout << bounding_box << std::endl; 
	
	microenvironment.resize_space( bounding_box[0] , bounding_box[3] , bounding_box[1], bounding_box[4] , bounding_box[2] , bounding_box[5] ,dx,dy,dz );
	microenvironment.spatial_units = "microns";
	microenvironment.time_units = "minutes";
	microenvironment.mesh.units = "microns";
	// Cell_Container * 
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	microenvironment.display_information( std::cout );

	initialize_default_cell_definition(); 	
	cell_defaults.type = 0; 
	cell_defaults.name = "tumor cell"; 
	cell_defaults.functions.cycle_model = Ki67_advanced; 
	cell_defaults.functions.update_phenotype = empty_function;
	cell_defaults.functions.volume_update_function = empty_function;
	
	int Q_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_negative );
	

	double sample_cell_radius=10;
	double volume=2.4943e+03;
	double sphere_radius = 80;
	// std::cout << __FILE__ << " custom " << __LINE__ << std::endl; 
	std::vector<std::vector<double>> cell_positions;
	cell_positions= create_sphere(sample_cell_radius/5, sphere_radius);
	
	std::vector<double> tumor_center(3);
		tumor_center[0]=1000;
		tumor_center[1]=1000;
		tumor_center[2]=1000;
	
	for(int i=0;i<cell_positions.size();i++)
	{
		Cell* pCell = create_cell();
		pCell->register_microenvironment(&microenvironment);
		pCell->assign_position(tumor_center+ cell_positions[i]);
		// pCell->functions.volume_update_function=empty_function;
		// pCell->functions.update_phenotype=do_nothing;
		pCell->phenotype.cycle.data.current_phase_index = Q_index; 
		pCell->set_total_volume(volume);	
	}
	
	std::cout << (*all_cells)[0]->phenotype.geometry.radius<<std::endl;	
	std::cout << (*all_cells).size() <<" agents created successfully." <<std::endl;
	
	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	try 
	{		
		while( t < t_max )
		{
			// std::cout<<"time: "<<t<<" diff:"<<fabs( t - t_next_output_time )<<" next output time:"<<t_next_output_time<<std::endl;
			if(  fabs( t - t_next_output_time ) < 0.001 )
			{
				std::cout<<"time: "<<t<<std::endl;
				writeCellReport(*all_cells, t);
				t_next_output_time += t_output_interval;
			}
				
			((Cell_Container *)microenvironment.agent_container)->update_all_cells(t, dt, dt, dt);
			t += dt; 
		}
		double scale=1000;
		writeCellReport(*all_cells, t_max);
		std::cout << "total number of agents: " << (*all_cells).size()<<std::endl << std::endl;
		BioFVM::RUNTIME_TOC();
		BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() );
	}
	catch( const std::exception& e ) { // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	return 0; 
}

########## NEXT FILE ##########
PhysiCell_test_volume.cpp:::
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "../core/PhysiCell.h"
#include "../modules/PhysiCell_standard_modules.h" 

using namespace BioFVM;
using namespace PhysiCell;

int omp_num_threads = 1; // set number of threads for parallel computing
// set this to # of CPU cores x 2 (for hyperthreading)

double o2_conc=5.01;

int main( int argc, char* argv[] )
{
	double t = 0.0; 
	double dt;
	char test_type[3];
	// -A or -a for apoptotic, -N of -n for necrotic, and -c for live cells; the command should be like "program_name dt -x" where x is from (c,n,a)
	if(argc>=2)
	{
		dt = strtod(argv[1], NULL);
		if(argc==3)
			strcpy(test_type, argv[2]);
		else
			strcpy(test_type, "-c");
	}
	else
	{
		dt=0.1;
		strcpy(test_type, "-c");
	}
	std::cout<<test_type<<", "<<dt<<std::endl;
	double t_output_interval = 60.0;
	
	// set t_max to a larger value if you want to check volume change in necrotic phase
	double t_max = 1201;
	double t_next_output_time = 0; 
	int next_output_index = 0; 
	
	double dx; 
	double dy;  
	double dz; 
	
	// openmp setup
	omp_set_num_threads(omp_num_threads);
	
	// PNRG setup 	
	SeedRandom(-35); 
	
	// figure out the bounding box 
	std::vector<double> bounding_box( 6, 0.0 );
	bounding_box[PhysiCell_constants::mesh_min_x_index] = 0; bounding_box[PhysiCell_constants::mesh_max_x_index] = 2000; 
	bounding_box[PhysiCell_constants::mesh_min_y_index] = 0; bounding_box[PhysiCell_constants::mesh_max_y_index] = 2000; 
	bounding_box[PhysiCell_constants::mesh_min_z_index] = 0; bounding_box[PhysiCell_constants::mesh_max_z_index] = 2000; 
	dx=20; dy=20; dz=20;
	
	// create a microenvironment
	BioFVM::Microenvironment microenvironment;
	microenvironment.name="substrate scale";
	// add a microenvironment for simulating substrates 	
	microenvironment.set_density(0, "oxygen" , "mmHg" );
	
	std::cout << bounding_box << std::endl; 
	
	microenvironment.resize_space( bounding_box[0] , bounding_box[3] , bounding_box[1], bounding_box[4] , bounding_box[2] , bounding_box[5] ,dx,dy,dz );
	microenvironment.spatial_units = "microns";
	microenvironment.time_units = "minutes";
	microenvironment.mesh.units = "microns";
	// Cell_Container * 
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	for( int n=0; n < microenvironment.number_of_voxels() ; n++ )
	{
		microenvironment.density_vector(n)[0] = o2_conc; 	
	}

	// register the diffusion solver 
	microenvironment.diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_3D; 
	
	initialize_default_cell_definition(); 	
	cell_defaults.type = 0; 
	cell_defaults.name = "tumor cell"; 
	// set default cell cycle model 
	cell_defaults.functions.cycle_model = Ki67_advanced; 	
	// set default_cell_functions; 
	cell_defaults.functions.update_phenotype = update_cell_and_death_parameters_O2_based; 
	//cell_defaults.functions.volume_update_function = standard_volume_update_function;
	cell_defaults.phenotype.secretion.sync_to_microenvironment( &microenvironment );
	cell_defaults.phenotype.sync_to_functions( cell_defaults.functions ); 
	// first find index for a few key variables. 
	int apoptosis_model_index = cell_defaults.phenotype.death.find_death_model_index( "Apoptosis" );
	int necrosis_model_index = cell_defaults.phenotype.death.find_death_model_index( "Necrosis" );
	int oxygen_substrate_index = microenvironment.find_density_index( "oxygen" ); 

	int K1_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_positive_premitotic );
	int K2_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_positive_postmitotic );
	int Q_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_negative );
	int A_index = Ki67_advanced.find_phase_index( PhysiCell_constants::apoptotic );
	int N_index = Ki67_advanced.find_phase_index( PhysiCell_constants::necrotic_swelling );
	
	microenvironment.display_information( std::cout );
	std::vector<double> point1(3);
	
	double a1=500;
	point1[0]= a1; point1[1]= a1; point1[2]= a1; 
	
	Cell* pCell1 = create_cell();
	pCell1->register_microenvironment(&microenvironment);
	pCell1->assign_position(point1);
	if(test_type[1]=='A' || test_type[1]=='a')
	{
		pCell1->phenotype.cycle.data.current_phase_index = A_index; 
		pCell1->phenotype.death.trigger_death( apoptosis_model_index );
		pCell1->phenotype.cycle.sync_to_cycle_model( pCell1->phenotype.death.current_model() );
	}
	else if(test_type[1]=='N' || test_type[1]=='n')
	{
		pCell1->phenotype.cycle.data.current_phase_index = N_index; 
		pCell1->phenotype.death.trigger_death( necrosis_model_index );
		pCell1->phenotype.cycle.sync_to_cycle_model( pCell1->phenotype.death.current_model() );
	}
	else if(test_type[1]=='C' || test_type[1]=='c')
	{
		pCell1->phenotype.cycle.data.current_phase_index = K1_index; 
		// disable apoptosis
		cell_defaults.phenotype.death.rates[apoptosis_model_index] =0;
		// set Q duration to a large value
		cell_defaults.phenotype.cycle.data.transition_rate(Q_index,K1_index) = 1e9;
		
	}

	pCell1->phenotype.cycle.current_phase().entry_function( pCell1, pCell1->phenotype, dt);

	
	
	
	for(int i=0;i<all_basic_agents.size();i++){
		all_basic_agents[i]->set_internal_uptake_constants(dt); 
	}
		
	std::cout << (*all_cells).size() <<" agent(s) created successfully." <<std::endl;
	
	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	std::ofstream vol_report ("vol_report.txt", std::ofstream::out);
	try 
	{		
		while( t < t_max )
		{
			if(  fabs( t - t_next_output_time ) < 0.001 )
			{
				vol_report<<t<<"\t"<<pCell1->get_total_volume()<<"\t"<<pCell1->phenotype.volume.fluid<<"\t"<<pCell1->phenotype.volume.nuclear_solid<<"\t"<<pCell1->phenotype.volume.cytoplasmic_solid<<"\n";
				t_next_output_time += t_output_interval;
			}
			if((*all_cells).size()>1)
			{
				delete_cell((Cell*)all_basic_agents[1]);
				std::cout << "cell deleted " << std::endl;
			}
			((Cell_Container *)microenvironment.agent_container)->update_all_cells(t, dt, dt, dt);
			t += dt; 
		}

		std::cout << "total number of agents: " << (*all_cells).size()<<std::endl << std::endl;
		BioFVM::RUNTIME_TOC();
		BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() );
		vol_report.close();
		std::cout<<"\nTotal volume: " << pCell1->get_total_volume()<<std::endl;
	}
	
	catch( const std::exception& e ) { // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	return 0; 
}

########## NEXT FILE ##########
main-beta.cpp:::
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>
#include <string> 

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// custom user modules 

#include "./custom_modules/heterogeneity.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }

	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// PNRG setup 
	SeedRandom(); 
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); 

	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	create_cell_types();
	setup_tissue();
	
	/* Users typically start modifying here. START USERMODS */ 
	
	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );
	
	// save a simulation snapshot 
	
	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = heterogeneity_coloring_function;
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	display_citations(); 
	
	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}
	
	// main loop 
	
	try 
	{	
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
			}
			
			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			
			// run PhysiCell 
			((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			PhysiCell_globals.current_time += diffusion_dt;
		}
		
		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	// timer 
	
	std::cout << std::endl << "Total simulation runtime: " << std::endl; 
	BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() ); 

	return 0; 
}

########## NEXT FILE ##########
main-biorobots.cpp:::
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// custom user modules 

#include "./custom_modules/biorobots.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }
	
	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// PNRG setup 
	SeedRandom(); 
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); 

	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	create_cell_types();
	setup_tissue();
	
	/* Users typically start modifying here. START USERMODS */ 
	
	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );
	
	// save a simulation snapshot 

	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = robot_coloring_function;
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	display_citations(); 
	
	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}
	
	// main loop 
	
	try 
	{	
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
			}
			
			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			
			// run PhysiCell 
			((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			PhysiCell_globals.current_time += diffusion_dt;
		}
		
		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	// timer 
	
	std::cout << std::endl << "Total simulation runtime: " << std::endl; 
	BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() ); 

	return 0; 
}

########## NEXT FILE ##########
main-cancer_biorobots.cpp:::
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// custom user modules 

#include "./custom_modules/cancer_biorobots.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }
	
	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// PNRG setup 
	SeedRandom(); 
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); 

	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	create_cell_types();
	setup_tissue();
	
	/* Users typically start modifying here. START USERMODS */ 

	double therapy_activation_time = parameters.doubles("therapy_activation_time"); // 60 * 24 * 7; // inject therapy at 7 days 

	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );
	
	// save a simulation snapshot 

	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = cancer_biorobots_coloring_function;
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	display_citations(); 
	
	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}	
	
	// main loop 
	
	try 
	{	
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			static bool therapy_introduced = false; 
			if( PhysiCell_globals.current_time > therapy_activation_time - 0.01*diffusion_dt && therapy_introduced == false )
			{
				std::cout << "Therapy started!" << std::endl; 
				therapy_introduced = true; 
				PhysiCell_settings.full_save_interval = parameters.doubles("save_interval_after_therapy_start"); // 3.0; 
				PhysiCell_settings.SVG_save_interval = parameters.doubles("save_interval_after_therapy_start"); // 3.0; 
				
				PhysiCell_globals.next_full_save_time = PhysiCell_globals.current_time; 
				PhysiCell_globals.next_SVG_save_time = PhysiCell_globals.current_time; 
				
				introduce_biorobots();
			} 	

			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
			}

			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			
			// run PhysiCell 
			((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			PhysiCell_globals.current_time += diffusion_dt;
		}
		
		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	// timer 
	
	std::cout << std::endl << "Total simulation runtime: " << std::endl; 
	BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() ); 

	return 0; 
}

########## NEXT FILE ##########
main-cancer_immune_3D.cpp:::
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// custom user modules 

#include "./custom_modules/cancer_immune_3D.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }
	
	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// PNRG setup 
	SeedRandom(); 
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); 

	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	create_cell_types();
	setup_tissue();
	
	/* Users typically start modifying here. START USERMODS */ 

	double immune_activation_time = 
		parameters.doubles("immune_activation_time"); // 60 * 24 * 14; // activate immune response at 14 days 
	
	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );
	
	// save a simulation snapshot 

	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = cancer_immune_coloring_function;
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	display_citations(); 
	
	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}

	//set the diffusion solver to GPU
	microenvironment.diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_3D_GPU;
	
	// main loop 
	
	try 
	{	
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			static bool immune_cells_introduced = false; 
			if( PhysiCell_globals.current_time > immune_activation_time - 0.01*diffusion_dt && immune_cells_introduced == false )
			{
				std::cout << "Therapy activated!" << std::endl << std::endl; 
				immune_cells_introduced = true; 
				
				PhysiCell_settings.full_save_interval = 
					parameters.doubles("save_interval_after_therapy_start"); // 3.0; 
				PhysiCell_settings.SVG_save_interval = 
					parameters.doubles("save_interval_after_therapy_start"); // 3.0; 
				
				PhysiCell_globals.next_full_save_time = PhysiCell_globals.current_time; 
				PhysiCell_globals.next_SVG_save_time = PhysiCell_globals.current_time; 
				
				introduce_immune_cells();
			} 

			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				std::cout << "1" << std::endl;
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				std::cout << "2" << std::endl;
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
			}
			
			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			// if( default_microenvironment_options.calculate_gradients )
			// { microenvironment.compute_all_gradient_vectors(); }
			
			// run PhysiCell 
			// ((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			
			// manually call the code for cell sources and sinks, 
			// since these are ordinarily automatically done as part of phenotype.secretion in the 
			// PhysiCell update that we commented out above. Remove this when we go 
			// back to main code 

			#pragma omp parallel for 
			for( int i=0; i < (*all_cells).size(); i++ )
			{
				(*all_cells)[i]->phenotype.secretion.advance( (*all_cells)[i], (*all_cells)[i]->phenotype , diffusion_dt );
			}			
			
			PhysiCell_globals.current_time += diffusion_dt;
		}
		
		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );

	return 0; 
}

########## NEXT FILE ##########
main-heterogeneity.cpp:::
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>
#include <string> 

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// custom user modules 

#include "./custom_modules/heterogeneity.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }

	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// PNRG setup 
	SeedRandom(); 
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); 

	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	create_cell_types();
	setup_tissue();
	
	/* Users typically start modifying here. START USERMODS */ 
	
	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );
	
	// save a simulation snapshot 
	
	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = heterogeneity_coloring_function;
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	display_citations(); 
	
	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}
	
	// main loop 
	
	try 
	{	
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
			}
			
			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			
			// run PhysiCell 
			((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			PhysiCell_globals.current_time += diffusion_dt;
		}
		
		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	// timer 
	
	std::cout << std::endl << "Total simulation runtime: " << std::endl; 
	BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() ); 

	return 0; 
}

########## NEXT FILE ##########
main-2D.cpp:::
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// put custom code modules here! 

#include "./custom_modules/custom.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }
	
	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); // modify this in the custom code 
	
	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	/* Users typically start modifying here. START USERMODS */ 
	
	create_cell_types();
	
	setup_tissue();

	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );
	
	// save a simulation snapshot 
	
	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = my_coloring_function; 
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	display_citations(); 
	
	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}
	
	// main loop 
	
	try 
	{		
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
			}

			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			
			// run PhysiCell 
			((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			/*
			  Custom add-ons could potentially go here. 
			*/
			
			PhysiCell_globals.current_time += diffusion_dt;
		}
		
		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	// timer 
	
	std::cout << std::endl << "Total simulation runtime: " << std::endl; 
	BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() ); 

	return 0; 
}

########## NEXT FILE ##########
main-3D.cpp:::
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// put custom code modules here! 

#include "./custom_modules/custom.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }
	
	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// PNRG setup 
	SeedRandom(); 
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); // modify this in the custom code 
	
	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	/* Users typically start modifying here. START USERMODS */ 
	
	create_cell_types();
	
	setup_tissue();

	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );
	
	// save a simulation snapshot 
	
	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = my_coloring_function;
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	display_citations(); 
	
	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}
	
	// main loop 
	
	try 
	{		
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
			}

			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			
			// run PhysiCell 
			((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			/*
			  Custom add-ons could potentially go here. 
			*/			
			
			PhysiCell_globals.current_time += diffusion_dt;
		}

		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );

	
	// timer 
	
	std::cout << std::endl << "Total simulation runtime: " << std::endl; 
	BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() ); 

	return 0; 
}

########## NEXT FILE ##########
main-virus_macrophage.cpp:::
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// put custom code modules here! 

#include "./custom_modules/custom.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }

	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); // modify this in the custom code 

	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );

	/* Users typically start modifying here. START USERMODS */ 
	
	create_cell_types();

	setup_tissue();

	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );

	// save a simulation snapshot 
	
	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = viral_coloring_function; 
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );

	display_citations(); 

	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}
	
	// main loop 
	
	try 
	{		
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
				
				std::cout << "Total substrates " << integrate_total_substrates() << std::endl; 
			}

			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			
			// run PhysiCell 
			((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			/*
			  Custom add-ons could potentially go here. 
			*/
			
			PhysiCell_globals.current_time += diffusion_dt;
		}
		
		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	// timer 
	
	std::cout << std::endl << "Total simulation runtime: " << std::endl; 
	BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() ); 

	return 0; 
}

########## NEXT FILE ##########
unit_test_conservation.cpp:::
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// put custom code modules here! 

#include "./custom_modules/custom.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }
	
	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); // modify this in the custom code 
	
	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	/* Users typically start modifying here. START USERMODS */ 
	
	create_cell_types();
	
	setup_tissue();

	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );
	
	// save a simulation snapshot 
	
	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = my_coloring_function; 
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	display_citations(); 
	
	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}
	
	// main loop 
	
	std::cout << "Unit test: conservation with individual agent substrate internalization " << std::endl 
		<< "If this works, the total amount of each substrate should stay fixed at each output " << std::endl << std::endl ; 
	
	try 
	{		
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
				
				std::cout << "Total substrates " << integrate_total_substrates() << std::endl; 
			}

			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			
			// run PhysiCell 
			((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			/*
			  Custom add-ons could potentially go here. 
			*/
			
			PhysiCell_globals.current_time += diffusion_dt;
		}
		
		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	// timer 
	
	std::cout << std::endl << "Total simulation runtime: " << std::endl; 
	BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() ); 

	return 0; 
}

########## NEXT FILE ##########
biorobots.cpp:::
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include "./biorobots.h"

void setup_microenvironment( void )
{
	// set domain parameters
	
	initialize_microenvironment(); 	
	
	// these will ***overwrite*** values specified in the 
	// microenvironment_setup part of the XML,
	// based on what's in the user_parameters section 
	
	microenvironment.name = "synthetic tissue"; 
	
	int cargo_ID = microenvironment.find_density_index( "cargo signal" ); 
	int director_ID = microenvironment.find_density_index( "director signal" ); 
	
	microenvironment.diffusion_coefficients[cargo_ID] = 
		parameters.doubles("cargo_signal_D");  
	microenvironment.decay_rates[cargo_ID] = 
		parameters.doubles("cargo_signal_decay");  
	
	microenvironment.diffusion_coefficients[director_ID] = 
		parameters.doubles("director_signal_D");  
	microenvironment.decay_rates[director_ID] = 
		parameters.doubles("director_signal_decay"); 
	
	// display the microenvironment again 
	
	microenvironment.display_information( std::cout ); 
	
	return; 
}

void create_cell_types( void )
{
	SeedRandom( parameters.ints("random_seed") ); 
	// housekeeping 
	
	initialize_default_cell_definition();
	cell_defaults.phenotype.secretion.sync_to_microenvironment( &microenvironment ); 
	
	// turn the default cycle model to live, 
	// so it's easier to turn off proliferation
	
	cell_defaults.phenotype.cycle.sync_to_cycle_model( live ); 
	
	// Make sure we're ready for 2D
	
	cell_defaults.functions.set_orientation = up_orientation; 
	cell_defaults.phenotype.geometry.polarity = 1.0; 
	cell_defaults.phenotype.motility.restrict_to_2D = true; 
	
	// turn off proliferation and death 
	
	int cycle_start_index = live.find_phase_index( PhysiCell_constants::live ); 
	int cycle_end_index = live.find_phase_index( PhysiCell_constants::live ); 
	
	int apoptosis_index = cell_defaults.phenotype.death.find_death_model_index( PhysiCell_constants::apoptosis_death_model ); 
	
	cell_defaults.phenotype.cycle.data.transition_rate( cycle_start_index , cycle_end_index ) = 0.0; 
	cell_defaults.phenotype.death.rates[apoptosis_index] = 0.0; 
	
	int cargo_ID = microenvironment.find_density_index( "cargo signal" ); // 1 
	int director_ID = microenvironment.find_density_index( "director signal" ); // 0 
	
	// set uptake and secretion to zero 
	cell_defaults.phenotype.secretion.secretion_rates[director_ID] = 0; 
	cell_defaults.phenotype.secretion.uptake_rates[director_ID] = 0; 
	cell_defaults.phenotype.secretion.saturation_densities[director_ID] = 1; 
	
	cell_defaults.phenotype.secretion.secretion_rates[cargo_ID] = 0; 
	cell_defaults.phenotype.secretion.uptake_rates[cargo_ID] = 0; 
	cell_defaults.phenotype.secretion.saturation_densities[cargo_ID] = 1; 

	// set the default cell type to no phenotype updates 
	
	cell_defaults.functions.update_phenotype = NULL; 
	
	// add custom data 
	
	cell_defaults.custom_data.add_variable( "receptor" , "dimensionless", 0.0 ); 
	/*
	cell_defaults.custom_data.add_variable( "elastic coefficient" , "1/min" , 0.05 );  // 0.1; 
	*/
	Parameter<double> paramD = parameters.doubles[ "elastic_coefficient" ]; 
	cell_defaults.custom_data.add_variable( "elastic coefficient" , paramD.units , paramD.value );  // 0.1; 
	
	//
	// Define "seed" cells 
	
	director_cell = cell_defaults; 
	director_cell.type = director_ID; 
	director_cell.name = "director cell"; 
	
	// seed cell secrete the signal 
	
	director_cell.phenotype.secretion.secretion_rates[director_ID] = 9.9; 
	
	// seed cell rule 
	
	director_cell.functions.update_phenotype = director_cell_rule; 
	
	// define "cargo" cells 
	
	cargo_cell = cell_defaults; 
	cargo_cell.type = cargo_ID; 
	cargo_cell.name = "cargo cell";
	
	cargo_cell.functions.update_phenotype = cargo_cell_rule; 
	cargo_cell.functions.custom_cell_rule = extra_elastic_attachment_mechanics; 
	
	cargo_cell.custom_data["receptor"] = 1.0; 

	cargo_cell.phenotype.secretion.secretion_rates[cargo_ID] = 9.9; 
	cargo_cell.phenotype.cycle.data.transition_rate( cycle_start_index , cycle_end_index ) = 0.0; // 7e-4
	
	//
	// Define "worker" cells 
	
	worker_cell = cell_defaults; 
	worker_cell.type = worker_ID; 
	worker_cell.name = "worker cell";
	
	// make them motile, and unadhesive  
	
	worker_cell.phenotype.motility.is_motile = true; 
	worker_cell.phenotype.motility.persistence_time = 
		parameters.doubles("worker_motility_persistence_time"); // 5.0; 
	worker_cell.phenotype.motility.migration_speed = 
		parameters.doubles("worker_migration_speed"); // 5; 
	worker_cell.phenotype.motility.migration_bias = 
		parameters.doubles("unattached_worker_migration_bias"); // 0.0; 
	

	worker_cell.phenotype.mechanics.cell_cell_adhesion_strength = 0.0; 
	
	worker_cell.functions.update_phenotype = worker_cell_rule; 
	worker_cell.functions.custom_cell_rule = extra_elastic_attachment_mechanics; 
	worker_cell.functions.update_migration_bias = worker_cell_motility;
	
	return; 
}

void director_cell_rule( Cell* pCell , Phenotype& phenotype , double dt )
{
	return; 
	std::vector<Cell*> nearby = pCell->cells_in_my_container(); 
	
	// if at least 2 neighbors, turn off secretion 
		// if size >= 3, then we have "self" and at least two more 
	if( nearby.size() > 2 )
	{
		pCell->phenotype.secretion.set_all_secretion_to_zero(); 
		pCell->custom_data[ "secreting" ] = 0.0; 
		
		pCell->functions.update_phenotype = NULL; 
	}
	
	return; 
}

std::vector<std::string> robot_coloring_function( Cell* pCell )
{
	std::string color = "black"; 
	std::vector< std::string > output( 4 , color ); 
	
	// black cells if necrotic 
	if( pCell->phenotype.death.dead == true )
	{ return output; }

	output[3] = "none"; // no nuclear outline color 
	
	static std::string worker_color = parameters.strings( "worker_color" ); 
	static std::string cargo_color = parameters.strings( "cargo_color" ); 
	static std::string director_color = parameters.strings( "director_color" ); 

	if( pCell->type == worker_ID )
	{ color = worker_color; }
	if( pCell->type == cargo_ID )
	{ color = cargo_color; }
	if( pCell->type == linker_ID )
	{ color = "aquamarine"; }

	if( pCell->type == director_ID )
	{ color = director_color; }

	output[0] = color; 
	output[2] = color; 
	
	return output; 
}

void create_cargo_cluster_6( std::vector<double>& center )
{
	// create a hollow cluster at position, with random orientation 
	
	static double spacing = 0.95 * cargo_cell.phenotype.geometry.radius * 2.0; 
	static double d_Theta = 1.047197551196598 ; // 2*pi / 6.0 
	
	double theta = 6.283185307179586 * UniformRandom(); 
	
	static std::vector<double> position(3,0.0); 
	
	Cell* pC; 
	for( int i=0; i < 6; i++ )
	{
		pC = create_cell( cargo_cell ); 
		
		position[0] = center[0] + spacing*cos( theta ); 
		position[1] = center[1] + spacing*sin( theta ); 
		
		pC->assign_position( position ); 
		
		theta += d_Theta; 
	}
	
	return; 
}

void create_cargo_cluster_7( std::vector<double>& center )
{
	// create a filled cluster at position, with random orientation 

	create_cargo_cluster_6( center );
	Cell* pC = create_cell( cargo_cell ); 
	pC->assign_position( center ); 
	
	return; 
}


void create_cargo_cluster_3( std::vector<double>& center )
{
	// create a small cluster at position, with random orientation 
	
	static double spacing = 0.95 * cargo_cell.phenotype.geometry.radius * 1.0; 
	static double d_Theta = 2.094395102393195 ; // 2*pi / 3.0 
	
	double theta = 6.283185307179586 * UniformRandom(); 
	
	static std::vector<double> position(3,0.0); 
	
	Cell* pC; 
	for( int i=0; i < 3; i++ )
	{
		pC = create_cell( cargo_cell ); 
		
		position[0] = center[0] + spacing*cos( theta ); 
		position[1] = center[1] + spacing*sin( theta ); 
		
		pC->assign_position( position ); 
		
		theta += d_Theta; 
	}
	
	return; 
}


void setup_tissue( void )
{
	int number_of_directors = parameters.ints("number_of_directors"); // 15;  
	int number_of_cargo_clusters = parameters.ints("number_of_cargo_clusters"); // 100;  
	int number_of_workers = parameters.ints("number_of_workers"); // 50;  

	std::cout << "Placing cells ... " << std::endl; 
	
	// randomly place seed cells 
	
	std::vector<double> position(3,0.0); 
	
	double x_range = default_microenvironment_options.X_range[1] - default_microenvironment_options.X_range[0]; 
	double y_range = default_microenvironment_options.Y_range[1] - default_microenvironment_options.Y_range[0]; 

	double relative_margin = 0.2;  
	double relative_outer_margin = 0.02; 
	
	std::cout << "\tPlacing director cells ... " << std::endl; 
	for( int i=0; i < number_of_directors ; i++ )
	{
		// pick a random location 
		
		position[0] = default_microenvironment_options.X_range[0] + x_range*( relative_margin + (1.0-2*relative_margin)*UniformRandom() ); 
		
		position[1] = default_microenvironment_options.Y_range[0] + y_range*( relative_outer_margin + (1.0-2*relative_outer_margin)*UniformRandom() ); 
		
		// place the cell
		Cell* pC;

		pC = create_cell( director_cell ); 
		pC->assign_position( position );
		pC->is_movable = false; 
	}
	
	// place cargo clusters on the fringes 
	
	std::cout << "\tPlacing cargo cells ... " << std::endl; 
	for( int i=0; i < number_of_cargo_clusters ; i++ )
	{
		// pick a random location 
		
		position[0] = default_microenvironment_options.X_range[0] + 
				x_range*( relative_outer_margin + (1-2.0*relative_outer_margin)*UniformRandom() ); 
		
		position[1] = default_microenvironment_options.Y_range[0] + 
				y_range*( relative_outer_margin + (1-2.0*relative_outer_margin)*UniformRandom() ); 
		
		if( UniformRandom() < 0.5 )
		{
			Cell* pCell = create_cell( cargo_cell ); 
			pCell->assign_position( position ); 
		}
		else
		{
			create_cargo_cluster_7( position ); 
		}
	}
	
	// place "workersworkers"

	std::cout << "\tPlacing worker cells ... " << std::endl; 
	for( int i=0; i < number_of_workers ; i++ )
	{
		// pick a random location 
		
		position[0] = default_microenvironment_options.X_range[0] + x_range*( relative_margin + (1.0-2*relative_margin)*UniformRandom() ); 
		
		position[1] = default_microenvironment_options.Y_range[0] + y_range*( relative_outer_margin + (1.0-2*relative_outer_margin)*UniformRandom() ); 
		
		// place the cell
		Cell* pC;

		pC = create_cell( worker_cell ); 
		pC->assign_position( position );
	}	
	

	std::cout << "done!" << std::endl; 
	// make a plot 
	
	PhysiCell_SVG_options.length_bar = 200; 
	SVG_plot( "initial.svg" , microenvironment, 0.0 , 0.0 , robot_coloring_function );	
	
	return; 
}


void cargo_cell_rule( Cell* pCell , Phenotype& phenotype , double dt )
{
	
	return; 
}


void attach_cells( Cell* pCell_1, Cell* pCell_2 )
{
	#pragma omp critical
	{
		
	bool already_attached = false; 
	for( int i=0 ; i < pCell_1->state.neighbors.size() ; i++ )
	{
		if( pCell_1->state.neighbors[i] == pCell_2 )
		{ already_attached = true; }
	}
	if( already_attached == false )
	{ pCell_1->state.neighbors.push_back( pCell_2 ); }
	
	already_attached = false; 
	for( int i=0 ; i < pCell_2->state.neighbors.size() ; i++ )
	{
		if( pCell_2->state.neighbors[i] == pCell_1 )
		{ already_attached = true; }
	}
	if( already_attached == false )
	{ pCell_2->state.neighbors.push_back( pCell_1 ); }

	}

	return; 
}

void dettach_cells( Cell* pCell_1 , Cell* pCell_2 )
{
	#pragma omp critical
	{
		bool found = false; 
		int i = 0; 
		while( !found && i < pCell_1->state.neighbors.size() )
		{
			// if cell 2 is in cell 1's list, remove it
			if( pCell_1->state.neighbors[i] == pCell_2 )
			{
				int n = pCell_1->state.neighbors.size(); 
				// copy last entry to current position 
				pCell_1->state.neighbors[i] = pCell_1->state.neighbors[n-1]; 
				// shrink by one 
				pCell_1->state.neighbors.pop_back(); 
				found = true; 
			}
			i++; 
		}
	
		found = false; 
		i = 0; 
		while( !found && i < pCell_2->state.neighbors.size() )
		{
			// if cell 1 is in cell 2's list, remove it
			if( pCell_2->state.neighbors[i] == pCell_1 )
			{
				int n = pCell_2->state.neighbors.size(); 
				// copy last entry to current position 
				pCell_2->state.neighbors[i] = pCell_2->state.neighbors[n-1]; 
				// shrink by one 
				pCell_2->state.neighbors.pop_back(); 
				found = true; 
			}
			i++; 
		}

	}
	
	return; 
}

void add_elastic_velocity( Cell* pActingOn, Cell* pAttachedTo , double elastic_constant )
{
	std::vector<double> displacement = pAttachedTo->position - pActingOn->position; 
	axpy( &(pActingOn->velocity) , elastic_constant , displacement ); 
	
	return; 
}

void extra_elastic_attachment_mechanics( Cell* pCell, Phenotype& phenotype, double dt )
{
	// if I am 
	std::vector<double> velocity(3,0.0); 
	
	for( int i=0; i < pCell->state.neighbors.size() ; i++ )
	{
		add_elastic_velocity( pCell, pCell->state.neighbors[i], pCell->custom_data["elastic coefficient"] ); 
	}

	return; 
}	


void worker_cell_rule( Cell* pCell, Phenotype& phenotype, double dt )
{
	static double threshold = parameters.doubles("drop_threshold"); // 0.4; 
	
	static int cargo_ID = microenvironment.find_density_index( "cargo signal" ); // 1 
	static int director_ID = microenvironment.find_density_index( "director signal" ); // 0 
	
	// have I arrived? If so, release my cargo 
	if( pCell->nearest_density_vector()[director_ID] > threshold )
	{
		for( int i=0; i < pCell->state.neighbors.size(); i++ )
		{
			Cell* pTemp = pCell->state.neighbors[i]; 
			dettach_cells( pCell, pTemp ); 
			
			pTemp->custom_data[ "receptor" ] = 0.0; 
			pTemp->phenotype.cycle.data.transition_rate( 0,0 ) = 0; 
		}
	}
	
	// am I searching for cargo? if so, see if I've found it
	if( pCell->state.neighbors.size() == 0 )
	{
		std::vector<Cell*> nearby = pCell->cells_in_my_container(); 
		for( int i=0; i < nearby.size(); i++ )
		{
			// if it is expressing the receptor, dock with it 
			if( nearby[i]->custom_data["receptor"] > 0.5 )
			{
				attach_cells( pCell, nearby[i] ); 
				nearby[i]->custom_data["receptor"] = 0.0; 
				nearby[i]->phenotype.secretion.set_all_secretion_to_zero(); 
			}
		}
		
	}
	
	return; 
}

void worker_cell_motility( Cell* pCell, Phenotype& phenotype, double dt )
{
	// if attached, biased motility towards director chemoattractant 
	// otherwise, biased motility towards cargo chemoattractant 
	
	static double attached_worker_migration_bias = 
		parameters.doubles("attached_worker_migration_bias"); 
	static double unattached_worker_migration_bias = 
		parameters.doubles("unattached_worker_migration_bias"); 
		
	static int cargo_ID = microenvironment.find_density_index( "cargo signal" ); // 1 
	static int director_ID = microenvironment.find_density_index( "director signal" ); // 0 
	
	if( pCell->state.neighbors.size() > 0 )
	{
		phenotype.motility.migration_bias = attached_worker_migration_bias; 

		phenotype.motility.migration_bias_direction = pCell->nearest_gradient(director_ID);	
		normalize( &( phenotype.motility.migration_bias_direction ) );			
	}
	else
	{
		phenotype.motility.migration_bias = unattached_worker_migration_bias; 
		
		phenotype.motility.migration_bias_direction = pCell->nearest_gradient(cargo_ID);	
		normalize( &( phenotype.motility.migration_bias_direction ) );			
	}
	
	return; 
}

########## NEXT FILE ##########
cancer_biorobots.cpp:::
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include "./cancer_biorobots.h"

Cell_Definition cargo_cell; 
Cell_Definition worker_cell; 

void create_cargo_cell_type( void ) 
{
	cargo_cell = cell_defaults; 
	
	cargo_cell.name = "cargo cell";
	cargo_cell.type = 1; 

	// turn off proliferation; 
	
	int cycle_start_index = live.find_phase_index( PhysiCell_constants::live ); 
	int cycle_end_index = live.find_phase_index( PhysiCell_constants::live ); 
	
	cargo_cell.phenotype.cycle.data.transition_rate(cycle_start_index,cycle_end_index) = 0.0; 	
	
	int apoptosis_index = cell_defaults.phenotype.death.find_death_model_index( PhysiCell_constants::apoptosis_death_model ); 
	
	int oxygen_ID = microenvironment.find_density_index( "oxygen" ); // 0 
	int attract_ID = microenvironment.find_density_index( "chemoattractant" ); // 1
	int therapy_ID = microenvironment.find_density_index( "therapeutic" ); // 2
	
	// reduce o2 uptake 
	
	cargo_cell.phenotype.secretion.uptake_rates[oxygen_ID] *= 
		parameters.doubles("cargo_o2_relative_uptake"); // 0.1; 
	
	// set secretion of the chemoattractant
	cargo_cell.phenotype.secretion.secretion_rates[attract_ID] = 10; 
	
	// set apoptosis to survive 10 days (on average) 
	
	cargo_cell.phenotype.death.rates[apoptosis_index] = 
		parameters.doubles("cargo_apoptosis_rate"); // 1.0 / (10.0 * 24.0 * 60.0 ); 
	
	// turn of motility; 
	cargo_cell.phenotype.motility.is_motile = false; 
	
	cargo_cell.phenotype.mechanics.cell_cell_adhesion_strength *= 
		parameters.doubles("cargo_relative_adhesion"); // 0.0;
	cargo_cell.phenotype.mechanics.cell_cell_repulsion_strength *= 
		parameters.doubles("cargo_relative_repulsion"); // 5.0;
	
	// set functions 
	
	cargo_cell.functions.update_phenotype = cargo_cell_phenotype_rule; 
	cargo_cell.functions.custom_cell_rule = cargo_cell_rule; 
	cargo_cell.functions.update_migration_bias = NULL;	
	
	// set custom data values 
	
	cargo_cell.custom_data[ "receptor" ] = 1.0; 
	
	cargo_cell.custom_data[ "damage rate" ] = 0.00;  
	cargo_cell.custom_data[ "repair rate" ] = 0.0;  
	cargo_cell.custom_data[ "drug death rate" ] = 0.0;  

	return;
}	

void create_worker_cell_type( void )
{
	worker_cell = cell_defaults; 
	
	worker_cell.name = "worker cell";
	worker_cell.type = 2; 

	// turn off proliferation; 
	
	int cycle_start_index = live.find_phase_index( PhysiCell_constants::live ); 
	int cycle_end_index = live.find_phase_index( PhysiCell_constants::live ); 
	
	worker_cell.phenotype.cycle.data.transition_rate(cycle_start_index,cycle_end_index) = 0.0; 	
	
	int apoptosis_index = cell_defaults.phenotype.death.find_death_model_index( PhysiCell_constants::apoptosis_death_model ); 
	
	int oxygen_ID = microenvironment.find_density_index( "oxygen" ); // 0 
	int attract_ID = microenvironment.find_density_index( "chemoattractant" ); // 1
	int therapy_ID = microenvironment.find_density_index( "therapeutic" ); // 2	
	
	// reduce o2 uptake 
	
	worker_cell.phenotype.secretion.uptake_rates[oxygen_ID] *= 
		parameters.doubles("worker_o2_relative_uptake"); // 0.1; 
	
	// set apoptosis zero
	
	worker_cell.phenotype.death.rates[apoptosis_index] = 
		parameters.doubles("worker_apoptosis_rate"); // 0.0; // 1.0 / (10.0 * 24.0 * 60.0 ); 
	
	// turn on motility; 
	worker_cell.phenotype.motility.is_motile = true; 
	worker_cell.phenotype.motility.persistence_time = 
		parameters.doubles("worker_motility_persistence_time"); // 5.0; 
	worker_cell.phenotype.motility.migration_speed = 
		parameters.doubles("worker_migration_speed"); // 2;  
	worker_cell.phenotype.motility.migration_bias = 
		parameters.doubles("unattached_worker_migration_bias"); // 1;
	
	worker_cell.phenotype.mechanics.cell_cell_adhesion_strength *= 
		parameters.doubles("worker_relative_adhesion"); // 0.0;
	worker_cell.phenotype.mechanics.cell_cell_repulsion_strength *= 
		parameters.doubles("worker_relative_repulsion"); // 5.0;
	
	// set functions 
	
	worker_cell.functions.update_phenotype = worker_cell_rule; 
	worker_cell.functions.custom_cell_rule = extra_elastic_attachment_mechanics;  
	worker_cell.functions.update_migration_bias = worker_cell_motility;	
	
	// set custom data values 
	
	worker_cell.custom_data[ "receptor" ] = 0.0; 
	worker_cell.custom_data[ "damage rate" ] = 0.00;  
	worker_cell.custom_data[ "repair rate" ] = 0.0;  
	worker_cell.custom_data[ "drug death rate" ] = 0.0;  
	
	return; 
}

void create_cell_types( void )
{
	// use the same random seed so that future experiments have the 
	// same initial histogram of oncoprotein, even if threading means 
	// that future division and other events are still not identical 
	// for all runs 
	SeedRandom( parameters.ints("random_seed") ); 
	
	// housekeeping 
	
	initialize_default_cell_definition();
	cell_defaults.phenotype.secretion.sync_to_microenvironment( &microenvironment ); 
	
	// turn the default cycle model to live, 
	// so it's easier to turn off proliferation
	
	cell_defaults.phenotype.cycle.sync_to_cycle_model( live ); 
	
	// Make sure we're ready for 2D
	
	cell_defaults.functions.set_orientation = up_orientation; 
	cell_defaults.phenotype.geometry.polarity = 1.0; 
	cell_defaults.phenotype.motility.restrict_to_2D = true; // true; 
	
	// set to no motility for cancer cells 
	cell_defaults.phenotype.motility.is_motile = false; 
	
	// use default proliferation and death 
	
	int cycle_start_index = live.find_phase_index( PhysiCell_constants::live ); 
	int cycle_end_index = live.find_phase_index( PhysiCell_constants::live ); 
	
	int apoptosis_index = cell_defaults.phenotype.death.find_death_model_index( PhysiCell_constants::apoptosis_death_model ); 
	
	cell_defaults.parameters.o2_proliferation_saturation = 38.0;  
	cell_defaults.parameters.o2_reference = 38.0; 
	
	int oxygen_ID = microenvironment.find_density_index( "oxygen" ); // 0 
	int attract_ID = microenvironment.find_density_index( "chemoattractant" ); // 1
	int therapy_ID = microenvironment.find_density_index( "therapeutic" ); // 2	
	
	// set default uptake and secretion 
	// oxygen 
	cell_defaults.phenotype.secretion.secretion_rates[oxygen_ID] = 0; 
	cell_defaults.phenotype.secretion.uptake_rates[oxygen_ID] = 10; 
	cell_defaults.phenotype.secretion.saturation_densities[oxygen_ID] = 38; 

	// chemoattractant 
	cell_defaults.phenotype.secretion.saturation_densities[attract_ID] = 1; 
	// therapeutic  
	cell_defaults.phenotype.secretion.saturation_densities[therapy_ID] = 1; 
	
	// set the default cell type to o2-based proliferation with the effect of the 
	// on oncoprotein, and secretion of the immunostimulatory factor 
	
	cell_defaults.functions.update_phenotype = tumor_cell_phenotype_with_therapy; 
	
	// add the extra bit of "attachment" mechanics 
	cell_defaults.functions.custom_cell_rule = extra_elastic_attachment_mechanics; 
	
	// change the max cell-cell adhesion distance 
	cell_defaults.phenotype.mechanics.set_relative_maximum_adhesion_distance(parameters.doubles("max_relative_cell_adhesion_distance") );
	
	cell_defaults.name = "cancer cell"; 
	cell_defaults.type = 0; 
	
	// add custom data 
		
	Parameter<double> paramD; 
	
	// for cargo-worker 
	paramD = parameters.doubles["elastic_coefficient"]; 
	cell_defaults.custom_data.add_variable( "elastic coefficient" , paramD.units, paramD.value ); 
	
	paramD = parameters.doubles["receptor"]; 
	cell_defaults.custom_data.add_variable( "receptor" , paramD.units, paramD.value ); 
	
	paramD = parameters.doubles["cargo_release_o2_threshold"]; 
	cell_defaults.custom_data.add_variable( "cargo release oxygen threshold" , paramD.units, paramD.value ); 
	
	// for therapy 
	
	paramD = parameters.doubles["damage_rate"]; 
	cell_defaults.custom_data.add_variable( "damage rate" , paramD.units, paramD.value ); 
	paramD = parameters.doubles["repair_rate"]; 
	cell_defaults.custom_data.add_variable( "repair rate" , paramD.units, paramD.value ); 
	paramD = parameters.doubles["drug_death_rate"]; 	
	cell_defaults.custom_data.add_variable( "drug death rate" , paramD.units, paramD.value ); 
	cell_defaults.custom_data.add_variable( "damage" , "dimensionless", 0.0 ); 
	
	// create the biorobot types 
	create_cargo_cell_type(); 
	create_worker_cell_type(); 
	
	return; 
}

void setup_microenvironment( void )
{
	// set domain parameters
	
/*
	// in the XML now 
	default_microenvironment_options.X_range = {-750, 750}; 
	default_microenvironment_options.Y_range = {-750, 750}; 
	// default_microenvironment_options.Z_range = {-750, 750}; 
*/
	if( default_microenvironment_options.simulate_2D == false )
	{
		std::cout << "WARNING: overriding from 3-D to 2-D" << std::endl; 
		default_microenvironment_options.simulate_2D = true; 
	}
	
	int oxygen_ID = microenvironment.find_density_index( "oxygen" ); // 0 
	int attract_ID = microenvironment.find_density_index( "chemoattractant" ); // 1
	int therapy_ID = microenvironment.find_density_index( "therapeutic" ); // 2
	
/*
	all this is in XML now 
	// gradients are needed for this example 
	
	default_microenvironment_options.calculate_gradients = true; 
	
	// add cargo cell chemokine

	// Earlier: A future release of PhysiCell will handle setup of chemical factors 
	// more elegantly. So, let's skip XML specification for now.
	// August 2019: but now it's in XML in 1.6.0! Yay! 
	
	// add therapeutic 
	
	microenvironment.add_density( "chemoattractant", "dimensionless" ); 
	microenvironment.diffusion_coefficients[1] = 1e3; 
	microenvironment.decay_rates[1] = .1; 	
	
	// add the immunostimulatory factor 
	
	microenvironment.add_density( "therapeutic", "dimensionless" ); 
	microenvironment.diffusion_coefficients[2] = 1e3; 
	microenvironment.decay_rates[2] = 0.15625; 	
	
	// let BioFVM use oxygen as the default 
	
	default_microenvironment_options.use_oxygen_as_first_field = true; 

	// set Dirichlet conditions 
	
	default_microenvironment_options.outer_Dirichlet_conditions = true;
	default_microenvironment_options.Dirichlet_condition_vector[0] = 38; // physioxic conditions 
	default_microenvironment_options.Dirichlet_condition_vector[1] = 0; 
	default_microenvironment_options.Dirichlet_condition_vector[2] = 0; 
	
	default_microenvironment_options.Dirichlet_activation_vector[1] = false;  // no Dirichlet for the chemoattractant 
	default_microenvironment_options.Dirichlet_activation_vector[2] = false;  // no Dirichlet for the therapeutic  
	
	// set initial conditions 
	default_microenvironment_options.initial_condition_vector = { 38.0 , 0.0, 0.0 }; 
*/	
			
	initialize_microenvironment(); 	

	return; 
}	

//keep 
void introduce_biorobots( void )
{
	// idea: we'll "inject" them in a little column
		
	static double worker_fraction = 
		parameters.doubles("worker_fraction"); // 0.10; /* param */ 
	static int number_of_injected_cells = 
		parameters.ints("number_of_injected_cells"); // 500; /* param */ 
	
	// make these vary with domain size 
	double left_coordinate = default_microenvironment_options.X_range[1] - 150.0; // 600.0; 
	double right_cooridnate = default_microenvironment_options.X_range[1] - 50.0; // 700.0;

	double bottom_coordinate = default_microenvironment_options.Y_range[0] + 50.0; // -700; 
	double top_coordinate = default_microenvironment_options.Y_range[1] - 50.0; // 700; 
		
	for( int i=0 ;i < number_of_injected_cells ; i++ )
	{
		std::vector<double> position = {0,0,0}; 
		position[0] = left_coordinate + (right_cooridnate-left_coordinate)*UniformRandom(); 
		position[1] = bottom_coordinate + (top_coordinate-bottom_coordinate)*UniformRandom(); 
		
		Cell* pCell;  
		if( UniformRandom() <= worker_fraction )
		{ pCell = create_cell( worker_cell ); }
		else
		{ pCell = create_cell( cargo_cell ); }
		pCell->assign_position( position ); 
	}
	
	return; 
}

void setup_tissue( void )
{
	// place a cluster of tumor cells at the center 
	
	double cell_radius = cell_defaults.phenotype.geometry.radius; 
	double cell_spacing = 0.95 * 2.0 * cell_radius; 
	
	double tumor_radius = parameters.doubles("tumor_radius"); // 200.0; 
	
	Cell* pCell = NULL; 
	
	double x = 0.0; 
	double x_outer = tumor_radius; 
	double y = 0.0; 
	
	int n = 0; 
	while( y < tumor_radius )
	{
		x = 0.0; 
		if( n % 2 == 1 )
		{ x = 0.5*cell_spacing; }
		x_outer = sqrt( tumor_radius*tumor_radius - y*y ); 
		
		while( x < x_outer )
		{
			pCell = create_cell(); // tumor cell 
			pCell->assign_position( x , y , 0.0 );
			
			if( fabs( y ) > 0.01 )
			{
				pCell = create_cell(); // tumor cell 
				pCell->assign_position( x , -y , 0.0 );				
			}
			
			if( fabs( x ) > 0.01 )
			{ 
				pCell = create_cell(); // tumor cell 
				pCell->assign_position( -x , y , 0.0 );
				
				if( fabs( y ) > 0.01 )
				{
					pCell = create_cell(); // tumor cell 
					pCell->assign_position( -x , -y , 0.0 );
				}
			}
			x += cell_spacing; 
			
		}
		
		y += cell_spacing * sqrt(3.0)/2.0; 
		n++; 
	}
	
	return; 
}

// done 
std::vector<std::string> cancer_biorobots_coloring_function( Cell* pCell )
{
	std::vector< std::string > output( 4, "black" ); 
	
	static int damage_i = pCell->custom_data.find_variable_index( "damage" ); 
	static double max_damage = 1.0 * cell_defaults.custom_data["damage rate"] / (1e-16 + cell_defaults.custom_data[ "repair rate" ] );
	
	// cargo cell 
	if( pCell->type == 1 )
	{
		output[0] = "blue";
		output[1] = "blue";
		output[2] = "blue"; 
		output[3] = "none"; // no nuclear outline color 
		return output;
	}
	
	// worker cell 
	if( pCell->type == 2 )
	{
		output[0] = "red";
		output[1] = "red";
		output[2] = "red"; 
		output[3] = "none"; // no nuclear outline color 
		return output;
	}
	
	// apoptotic tumor - cyan 
	if (pCell->phenotype.cycle.current_phase().code == PhysiCell_constants::apoptotic )  // Apoptotic - cyan
	{
		output[0] = "cyan";
		output[2] = "darkcyan"; 
		return output; 
	}	
	
	// Necrotic tumor - Brown
	if( pCell->phenotype.cycle.current_phase().code == PhysiCell_constants::necrotic_swelling || 
		pCell->phenotype.cycle.current_phase().code == PhysiCell_constants::necrotic_lysed || 
		pCell->phenotype.cycle.current_phase().code == PhysiCell_constants::necrotic )
	{
		output[0] = "rgb(250,138,38)";
		output[2] = "rgb(139,69,19)";
		return output; 
	}		
	
	// live tumor -- shade by level of damage 
	
	
	// if live: color by damage 
	if( pCell->phenotype.death.dead == false )
	{
		int damage = (int) round( pCell->custom_data[damage_i] * 255.0 / max_damage ); 
		
		char szTempString [128];
		sprintf( szTempString , "rgb(%u,%u,%u)" , damage , 255-damage , damage );
		output[0].assign( szTempString );
		output[1].assign( szTempString );
		sprintf( szTempString , "rgb(%u,%u,%u)" , damage/4 , (255-damage)/4 , damage/4 );
		output[2].assign( szTempString );
	}
	return output; 
}


// keep 
void add_elastic_velocity( Cell* pActingOn, Cell* pAttachedTo , double elastic_constant )
{
	std::vector<double> displacement = pAttachedTo->position - pActingOn->position; 
	
	// dettach cells if too far apart 
	static double max_elastic_displacement = parameters.doubles("max_elastic_displacement");
	static double max_displacement_squared = max_elastic_displacement*max_elastic_displacement; 
	
	if( norm_squared( displacement ) > max_displacement_squared )
	{
		dettach_cells( pActingOn , pAttachedTo );
		std::cout << "\t\tDETACH!!!!!" << std::endl; 
		return; 
	}
	
	axpy( &(pActingOn->velocity) , elastic_constant , displacement ); 
	
	return; 
}

// keep 
void extra_elastic_attachment_mechanics( Cell* pCell, Phenotype& phenotype, double dt )
{
	for( int i=0; i < pCell->state.neighbors.size() ; i++ )
	{
		add_elastic_velocity( pCell, pCell->state.neighbors[i], pCell->custom_data["elastic coefficient"] ); 
	}

	return; 
}	

// keep 
void attach_cells( Cell* pCell_1, Cell* pCell_2 )
{
	#pragma omp critical
	{
		
	bool already_attached = false; 
	for( int i=0 ; i < pCell_1->state.neighbors.size() ; i++ )
	{
		if( pCell_1->state.neighbors[i] == pCell_2 )
		{ already_attached = true; }
	}
	if( already_attached == false )
	{ pCell_1->state.neighbors.push_back( pCell_2 ); }
	
	already_attached = false; 
	for( int i=0 ; i < pCell_2->state.neighbors.size() ; i++ )
	{
		if( pCell_2->state.neighbors[i] == pCell_1 )
		{ already_attached = true; }
	}
	if( already_attached == false )
	{ pCell_2->state.neighbors.push_back( pCell_1 ); }

	}

	return; 
}

// keep 
void dettach_cells( Cell* pCell_1 , Cell* pCell_2 )
{
	#pragma omp critical
	{
		bool found = false; 
		int i = 0; 
		while( !found && i < pCell_1->state.neighbors.size() )
		{
			// if cell 2 is in cell 1's list, remove it
			if( pCell_1->state.neighbors[i] == pCell_2 )
			{
				int n = pCell_1->state.neighbors.size(); 
				// copy last entry to current position 
				pCell_1->state.neighbors[i] = pCell_1->state.neighbors[n-1]; 
				// shrink by one 
				pCell_1->state.neighbors.pop_back(); 
				found = true; 
			}
			i++; 
		}
	
		found = false; 
		i = 0; 
		while( !found && i < pCell_2->state.neighbors.size() )
		{
			// if cell 1 is in cell 2's list, remove it
			if( pCell_2->state.neighbors[i] == pCell_1 )
			{
				int n = pCell_2->state.neighbors.size(); 
				// copy last entry to current position 
				pCell_2->state.neighbors[i] = pCell_2->state.neighbors[n-1]; 
				// shrink by one 
				pCell_2->state.neighbors.pop_back(); 
				found = true; 
			}
			i++; 
		}

	}
	
	return; 
}


// keep! 
Cell* worker_cell_check_neighbors_for_attachment( Cell* pWorker , double dt )
{
	std::vector<Cell*> nearby = pWorker->cells_in_my_container(); 
	int i = 0; 
	while( i < nearby.size() )
	{
		// don't try to attach to yourself 
		if( nearby[i] != pWorker )
		{
			if( worker_cell_attempt_attachment( pWorker, nearby[i] , dt ) )
			{ return nearby[i]; }
		}
		i++; 
	}
	
	return NULL; 
}

// keep! 
bool worker_cell_attempt_attachment( Cell* pWorker, Cell* pCargo , double dt )
{
	static int receptor_i = pCargo->custom_data.find_variable_index( "receptor" ); 

	static double receptor_threshold = 
		parameters.doubles("attachment_receptor_threshold"); // 0.1; 
	
	static double max_attachment_distance = 
		parameters.doubles("max_attachment_distance"); // 18.0; 
	static double min_attachment_distance = 
		parameters.doubles("min_attachment_distance"); // 14.0; 
	static double attachment_difference = max_attachment_distance - min_attachment_distance; 
	
	if( pCargo->custom_data[receptor_i] > receptor_threshold )
	{
		std::vector<double> displacement = pCargo->position - pWorker->position;
		double distance = norm( displacement ); 
		if( distance > max_attachment_distance )
		{ return false; } 
	
		if( distance < min_attachment_distance )
		{ 
			attach_cells( pWorker, pCargo );
			return true; 
		}
		
		return true; 
	}
	
	return false; 
}



void worker_cell_rule( Cell* pCell, Phenotype& phenotype, double dt )
{
	// if I am dead, don't bother

	if( phenotype.death.dead == true )
	{
		// the cell death functions don't automatically turn off custom functions, 
		// since those are part of mechanics. 
		
		// Let's just fully disable now. 
		pCell->functions.custom_cell_rule = NULL; 
		return; 
	}
	
	// am I searching for cargo? if so, see if I've found it
	if( pCell->state.neighbors.size() == 0 )
	{
		std::vector<Cell*> nearby = pCell->cells_in_my_container(); 
		bool attached = false; // want to limit to one attachment 
		for( int i=0; i < nearby.size(); i++ )
		{
			// if it is expressing the receptor, dock with it 
			if( nearby[i]->custom_data["receptor"] > 0.5 && attached == false )
			{
				attach_cells( pCell, nearby[i] ); 
				// nearby[i]->custom_data["receptor"] = 0.0; // put into cargo cell rule instead? 
				// nearby[i]->phenotype.secretion.set_all_secretion_to_zero(); // put into cargo rule instead? 
				attached = true; 
			}
		}
		
	}
	
	return; 
}

void worker_cell_motility( Cell* pCell, Phenotype& phenotype, double dt )
{
	static int o2_index = microenvironment.find_density_index( "oxygen" ); 
	static int signal_index = microenvironment.find_density_index( "chemoattractant" ); 

	static double detection_threshold = 
		parameters.doubles("motility_shutdown_detection_threshold"); // 0.001; 
	
	// if attached, biased motility towards director chemoattractant 
	// otherwise, biased motility towards cargo chemoattractant 
	
	static double attached_worker_migration_bias = 
		parameters.doubles("attached_worker_migration_bias"); 
	static double unattached_worker_migration_bias = 
		parameters.doubles("unattached_worker_migration_bias"); 
	
	if( pCell->state.neighbors.size() > 0 )
	{
		phenotype.motility.migration_bias = attached_worker_migration_bias; 

		phenotype.motility.migration_bias_direction = pCell->nearest_gradient(o2_index);	
		phenotype.motility.migration_bias_direction *= -1.0; 
		normalize( &( phenotype.motility.migration_bias_direction ) );			
	}
	else
	{
		// if there is no detectable signal, shut down motility (permanently)
		if( pCell->nearest_density_vector()[signal_index] < detection_threshold )
		{
			phenotype.motility.is_motile = false; 
			pCell->functions.update_migration_bias = NULL; 
		}
		
		phenotype.motility.migration_bias = unattached_worker_migration_bias; 
		
		phenotype.motility.migration_bias_direction = pCell->nearest_gradient(signal_index);	
		normalize( &( phenotype.motility.migration_bias_direction ) );			
	}
	
	return; 
}

/*  CARGO CELL RULES */ 

void cargo_cell_rule( Cell* pCell, Phenotype& phenotype, double dt )
{
	static int attach_lifetime_i = pCell->custom_data.find_variable_index( "attachment lifetime" ); 
	
	if( phenotype.death.dead == true )
	{
		// the cell death functions don't automatically turn off custom functions, 
		// since those are part of mechanics. 
		
		// Let's just fully disable now. 
		pCell->functions.custom_cell_rule = NULL; 
		return; 
	}
	
	// if I'm docked
	if( pCell->state.neighbors.size() > 0 )
	{
		extra_elastic_attachment_mechanics( pCell, phenotype, dt );
		phenotype.motility.is_motile = false; 
		return; 
	}
	
	
	return; 
}



// phenotype rule 
void old_cargo_cell_phenotype_rule( Cell* pCell, Phenotype& phenotype, double dt )
{
	static int o2_index = microenvironment.find_density_index( "oxygen" ); 
	static int signal_index = microenvironment.find_density_index( "chemoattractant" ); 
	static int drug_index = microenvironment.find_density_index( "oxygen" ); 
	
	static int death_index = pCell->custom_data.find_variable_index( "cargo apoptosis oxygen threshold" ); 
	static int receptor_index = pCell->custom_data.find_variable_index( "receptor" ); 
	
	static int apoptosis_model_index = phenotype.death.find_death_model_index( "apoptosis" );	
	
	// if I am attached, do not secrete chemoattractant. do not express receptor 
	
	if( pCell->state.neighbors.size() > 0 )
	{
		phenotype.secretion.secretion_rates[signal_index] = 0.0; 
		pCell->custom_data[receptor_index] = 0.0; 
	}
	
	// am I dead? 
	
	if( phenotype.death.dead == true )
	{
		// if attached to anything, release
		
		for( int i=0; i < pCell->state.neighbors.size() ; i++ )
		{
			dettach_cells( pCell , pCell->state.neighbors[i] ); 
		}
		
		// set drug release rate
		
		phenotype.secretion.secretion_rates[drug_index] = 10.0; 
	
		// get rid of all extra functions 
		
		pCell->functions.update_phenotype = NULL; 
		pCell->functions.custom_cell_rule = NULL; 
	
		return; 
	}
	
	// should I die? 
	
	if( pCell->nearest_density_vector()[o2_index] <= pCell->custom_data[death_index] )
	{
		std::cout<< "arrrhhh!!!!!! " << std::endl; 
		// if ready dead, don't bother!
		if( phenotype.death.dead == true )
		{ return; }

		// trigger death 
		pCell->start_death( apoptosis_model_index );
		
		// if attached to anything, release
		
		for( int i=0; i < pCell->state.neighbors.size() ; i++ )
		{
			dettach_cells( pCell , pCell->state.neighbors[i] ); 
		}
		
		// set drug release rate
		
		phenotype.secretion.secretion_rates[drug_index] = 10.0; 
	
		// get rid of all extra functions 
		
		pCell->functions.update_phenotype = NULL; 
		pCell->functions.custom_cell_rule = NULL; 		
		
		return; 
	}

	
	return; 
}

// phenotype rule 
void cargo_cell_phenotype_rule( Cell* pCell, Phenotype& phenotype, double dt )
{
	static int o2_index = microenvironment.find_density_index( "oxygen" ); 
	static int signal_index = microenvironment.find_density_index( "chemoattractant" ); 
	static int drug_index = microenvironment.find_density_index( "therapeutic" ); 
	
	static int drop_index = pCell->custom_data.find_variable_index( "cargo release oxygen threshold" ); 
	static int receptor_index = pCell->custom_data.find_variable_index( "receptor" ); 
	
	static int apoptosis_model_index = phenotype.death.find_death_model_index( "apoptosis" );
	
	// if dettached and receptor on, secrete signal 
	
	// if dettached and receptor off, secrete chemo
	
	if( pCell->state.neighbors.size() == 0 )
	{
		if( pCell->custom_data[receptor_index] > 0.1 )
		{
			phenotype.secretion.secretion_rates[signal_index] = 10.0; 
			phenotype.secretion.secretion_rates[drug_index] = 0.0; 
		}
		else
		{
			phenotype.secretion.secretion_rates[signal_index] = 0.0; 
			phenotype.secretion.secretion_rates[drug_index] = 10.0; 
		}
		return; 
	}
	
	// if you reach this point of the code, the cell is attached 
	

	// if attached and oxygen high, secrete nothing, receptor off 
	
	// if attached and oxygen low, dettach, start secreting chemo, receptor off   
	
	if( pCell->nearest_density_vector()[o2_index] > pCell->custom_data[drop_index] )
	{
		phenotype.secretion.secretion_rates[signal_index] = 0.0; 
		phenotype.secretion.secretion_rates[drug_index] = 0.0; 
		pCell->custom_data[receptor_index] = 0.0; 

	}
	else
	{
		phenotype.secretion.secretion_rates[signal_index] = 0.0; 
		phenotype.secretion.secretion_rates[drug_index] = 10.0; 
		pCell->custom_data[receptor_index] = 0.0; 		
		
		for( int i=0; i < pCell->state.neighbors.size() ; i++ )
		{
			dettach_cells( pCell , pCell->state.neighbors[i] ); 
		}		
		
	}
	
	return; 
}



/* TUMOR CELL RULES */ 

void tumor_cell_phenotype_with_therapy( Cell* pCell, Phenotype& phenotype, double dt )
{
	static int cycle_start_index = live.find_phase_index( PhysiCell_constants::live ); 
	static int cycle_end_index = live.find_phase_index( PhysiCell_constants::live ); 
	static int damage_i = pCell->custom_data.find_variable_index( "damage" ); 

	static int damage_rate_i = pCell->custom_data.find_variable_index( "damage rate" ); 
	static int repair_rate_i = pCell->custom_data.find_variable_index( "repair rate" ); 
	static int death_rate_i = pCell->custom_data.find_variable_index( "drug death rate" ); 
	
	static int chemo_i = microenvironment.find_density_index( "therapeutic" ); 
	
	static int apoptosis_model_index = phenotype.death.find_death_model_index( "apoptosis" );	
	
	static double max_damage = 1.0 * cell_defaults.custom_data["damage rate"] / (1e-16 + cell_defaults.custom_data[ "repair rate" ] );
	
	// if I'm dead, don't bother. disable my phenotype rule
	if( phenotype.death.dead == true )
	{
		pCell->functions.update_phenotype = NULL; 
		return; 
	}
	
	// first, vary the cell birth and death rates with oxygenation
	
	update_cell_and_death_parameters_O2_based(pCell,phenotype,dt);
	
	// the update the cell damage 
	
	// dD/dt = alpha*c - beta-D by implicit scheme 
	
	double temp = pCell->nearest_density_vector()[chemo_i];
	
	// reuse temp as much as possible to reduce memory allocations etc. 
	temp *= dt; 
	temp *= pCell->custom_data[damage_rate_i]; 
	
	pCell->custom_data[damage_i] += temp; // d_prev + dt*chemo*damage_rate 
	
	temp = pCell->custom_data[repair_rate_i];
	temp *= dt; 
	temp += 1.0; 
	pCell->custom_data[damage_i] /= temp;  // (d_prev + dt*chemo*damage_rate)/(1 + dt*repair_rate)
	
	// then, see if the cell undergoes death from the therapy 
	
	temp = dt; 
	temp *= pCell->custom_data[damage_i]; 
	temp *= pCell->custom_data[death_rate_i]; 
	temp /= max_damage; // dt*(damage/max_damage)*death_rate 

	if( UniformRandom() <= temp )
	{
		pCell->start_death( apoptosis_model_index );
		pCell->functions.update_phenotype = NULL; 		
		pCell->functions.custom_cell_rule = NULL; 
	}

	return; 
}



########## NEXT FILE ##########
cancer_immune_3D.cpp:::
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include "./cancer_immune_3D.h"

Cell_Definition immune_cell; 

void create_immune_cell_type( void )
{
	immune_cell = cell_defaults; 
	
	immune_cell.name = "immune cell";
	immune_cell.type = 1; 

	// turn off proliferation; 
	
	int cycle_start_index = live.find_phase_index( PhysiCell_constants::live ); 
	int cycle_end_index = live.find_phase_index( PhysiCell_constants::live ); 
	
	immune_cell.phenotype.cycle.data.transition_rate(cycle_start_index,cycle_end_index) = 0.0; 	
	
	int apoptosis_index = cell_defaults.phenotype.death.find_death_model_index( PhysiCell_constants::apoptosis_death_model ); 
	
	static int oxygen_ID = microenvironment.find_density_index( "oxygen" ); // 0 
	static int immuno_ID = microenvironment.find_density_index( "immunostimulatory factor" ); // 1
	
	// reduce o2 uptake 
	
	immune_cell.phenotype.secretion.uptake_rates[oxygen_ID] *= 
		parameters.doubles("immune_o2_relative_uptake"); // 0.1; 
	
	// set apoptosis to survive 10 days (on average) 
	
	immune_cell.phenotype.death.rates[apoptosis_index] = 
		parameters.doubles("immune_apoptosis_rate"); // 1.0 / (10.0 * 24.0 * 60.0 ); 
	
	// turn on motility; 
	immune_cell.phenotype.motility.is_motile = true; 
	immune_cell.phenotype.motility.persistence_time = 
		parameters.doubles("immune_motility_persistence_time"); // 10.0; 
	immune_cell.phenotype.motility.migration_speed = 
		parameters.doubles("immune_migration_speed"); // 1;  
	immune_cell.phenotype.motility.migration_bias = 
		parameters.doubles("immune_migration_bias"); // 0.5;
	
	immune_cell.phenotype.mechanics.cell_cell_adhesion_strength *= 
		parameters.doubles("immune_relative_adhesion"); // 0.0;
	immune_cell.phenotype.mechanics.cell_cell_repulsion_strength *= 
		parameters.doubles("immune_relative_repulsion"); // 5.0;
	
	// set functions 
	
	immune_cell.functions.update_phenotype = NULL; 
	immune_cell.functions.custom_cell_rule = immune_cell_rule; 
	immune_cell.functions.update_migration_bias = immune_cell_motility;	
	
	// set custom data values 
	
	Parameter<double> paramD; 
	
	immune_cell.custom_data[ "oncoprotein" ] = 0.0; 
	immune_cell.custom_data[ "kill rate" ] = 
		parameters.doubles("immune_kill_rate"); // 1.0/15.0; // how often it tries to kill
	immune_cell.custom_data[ "attachment lifetime" ] = 
		parameters.doubles("immune_attachment_lifetime"); // 60.00; // how long it can stay attached 
	immune_cell.custom_data[ "attachment rate" ] = 
		parameters.doubles("immune_attachment_rate"); // 1.0/5.0; // how long it wants to wander before attaching	
	
	return; 
}

void create_cell_types( void )
{
	// use the same random seed so that future experiments have the 
	// same initial histogram of oncoprotein, even if threading means 
	// that future division and other events are still not identical 
	// for all runs 
	SeedRandom( parameters.ints("random_seed") ); 
	
	// housekeeping 
	
	initialize_default_cell_definition();
	cell_defaults.phenotype.secretion.sync_to_microenvironment( &microenvironment ); 
	
	// turn the default cycle model to live, 
	// so it's easier to turn off proliferation
	
	cell_defaults.phenotype.cycle.sync_to_cycle_model( live ); 
	
	// Make sure we're ready for 2D
	
	cell_defaults.functions.set_orientation = up_orientation; 
	// cell_defaults.phenotype.geometry.polarity = 1.0; 
	cell_defaults.phenotype.motility.restrict_to_2D = false; // true; 
	
	// set to no motility for cancer cells 
	cell_defaults.phenotype.motility.is_motile = false; 
	
	// use default proliferation and death 
	
	int cycle_start_index = live.find_phase_index( PhysiCell_constants::live ); 
	int cycle_end_index = live.find_phase_index( PhysiCell_constants::live ); 
	
	int apoptosis_index = cell_defaults.phenotype.death.find_death_model_index( PhysiCell_constants::apoptosis_death_model ); 
	
	cell_defaults.parameters.o2_proliferation_saturation = 38.0;  
	cell_defaults.parameters.o2_reference = 38.0; 
	
	static int oxygen_ID = microenvironment.find_density_index( "oxygen" ); // 0 
	static int immuno_ID = microenvironment.find_density_index( "immunostimulatory factor" ); // 1
	
	// set default uptake and secretion 
	// oxygen 
	cell_defaults.phenotype.secretion.secretion_rates[oxygen_ID] = 0; 
	cell_defaults.phenotype.secretion.uptake_rates[oxygen_ID] = 10; 
	cell_defaults.phenotype.secretion.saturation_densities[oxygen_ID] = 38; 

	// immunostimulatory 
	cell_defaults.phenotype.secretion.saturation_densities[immuno_ID] = 1; 

	// set the default cell type to o2-based proliferation with the effect of the 
	// on oncoprotein, and secretion of the immunostimulatory factor 
	
	cell_defaults.functions.update_phenotype = tumor_cell_phenotype_with_and_immune_stimulation; 
	
	// add the extra bit of "attachment" mechanics 
	cell_defaults.functions.custom_cell_rule = extra_elastic_attachment_mechanics; 
	
	cell_defaults.name = "cancer cell"; 
	cell_defaults.type = 0; 
	
	// add custom data 
	
	Parameter<double> paramD;
	
	cell_defaults.custom_data.add_variable( "oncoprotein" , "dimensionless", 1.0 ); 
	paramD = parameters.doubles[ "elastic_coefficient" ]; 
	cell_defaults.custom_data.add_variable( "elastic coefficient" , paramD.units, paramD.value ); 
		// "1/min" , 0.01 );  /* param */ 
	cell_defaults.custom_data.add_variable( "kill rate" , "1/min" , 0 ); // how often it tries to kill
	cell_defaults.custom_data.add_variable( "attachment lifetime" , "min" , 0 ); // how long it can stay attached 
	cell_defaults.custom_data.add_variable( "attachment rate" , "1/min" ,0 ); // how long it wants to wander before attaching
	
	// create the immune cell type 
	create_immune_cell_type(); 
	
	return; 
}

void setup_microenvironment( void )
{
	// set domain parameters
/*
	default_microenvironment_options.X_range = {-1000, 1000}; 
	default_microenvironment_options.Y_range = {-1000, 1000}; 
	default_microenvironment_options.Z_range = {-1000, 1000}; 
*/	
/*
	// now in XML 
	default_microenvironment_options.X_range = {-750, 750}; 
	default_microenvironment_options.Y_range = {-750, 750}; 
	default_microenvironment_options.Z_range = {-750, 750};
*/
	
	if( default_microenvironment_options.simulate_2D == true )
	{
		std::cout << "Warning: overriding 2D setting to return to 3D" << std::endl; 
		default_microenvironment_options.simulate_2D = false; 
	}
	
/* 
	In XML as of version 1.6.0 
	
	// gradients are needed for this example 
	
	default_microenvironment_options.calculate_gradients = true; 
	
	// add the immunostimulatory factor 
	
	// let's do these in XML later 
	
	microenvironment.add_density( "immunostimulatory factor", "dimensionless" ); 
	microenvironment.diffusion_coefficients[1] = 1e3; 
	microenvironment.decay_rates[1] = .016; 
	
	// let BioFVM use oxygen as the default 
	
	default_microenvironment_options.use_oxygen_as_first_field = true; 

	// set Dirichlet conditions 
	
	default_microenvironment_options.outer_Dirichlet_conditions = true;
	default_microenvironment_options.Dirichlet_condition_vector[0] = 38; // physioxic conditions 
	default_microenvironment_options.Dirichlet_condition_vector[1] = 0; 
	default_microenvironment_options.Dirichlet_activation_vector[1] = false;  // no Dirichlet for the immunostimulatory factor 

	// set initial conditions 
	default_microenvironment_options.initial_condition_vector = { 38.0 , 0 }; 
*/
	
	initialize_microenvironment(); 	

	return; 
}	

void introduce_immune_cells( void )
{
	double tumor_radius = -9e9; // 250.0; 
	double temp_radius = 0.0; 
	
	// for the loop, deal with the (faster) norm squared 
	for( int i=0; i < (*all_cells).size() ; i++ )
	{
		temp_radius = norm_squared( (*all_cells)[i]->position ); 
		if( temp_radius > tumor_radius )
		{ tumor_radius = temp_radius; }
	}
	// now square root to get to radius 
	tumor_radius = sqrt( tumor_radius ); 
	
	// if this goes wackadoodle, choose 250 
	if( tumor_radius < 250.0 )
	{ tumor_radius = 250.0; }
	
	std::cout << "current tumor radius: " << tumor_radius << std::endl; 
	
	
	// now seed immune cells 
	
	int number_of_immune_cells = 
		parameters.ints("number_of_immune_cells"); // 7500; // 100; // 40; 
	double radius_inner = tumor_radius + 
		parameters.doubles("initial_min_immune_distance_from_tumor"); 30.0; // 75 // 50; 
	double radius_outer = radius_inner + 
		parameters.doubles("thickness_of_immune_seeding_region"); // 75.0; // 100; // 1000 - 50.0; 
	
	double mean_radius = 0.5*(radius_inner + radius_outer); 
	double std_radius = 0.33*( radius_outer-radius_inner)/2.0; 
	
	for( int i=0 ;i < number_of_immune_cells ; i++ )
	{
		double theta = UniformRandom() * 6.283185307179586476925286766559; 
		double phi = acos( 2.0*UniformRandom() - 1.0 );  
		
		double radius = NormalRandom( mean_radius, std_radius ); 
		
		Cell* pCell = create_cell( immune_cell ); 
		pCell->assign_position( radius*cos(theta)*sin(phi), radius*sin(theta)*sin(phi), radius*cos(phi) ); 
	}
	
	return; 
}


std::vector<std::vector<double>> create_cell_sphere_positions(double cell_radius, double sphere_radius)
{
	std::vector<std::vector<double>> cells;
	int xc=0,yc=0,zc=0;
	double x_spacing= cell_radius*sqrt(3);
	double y_spacing= cell_radius*2;
	double z_spacing= cell_radius*sqrt(3);
	
	std::vector<double> tempPoint(3,0.0);
	// std::vector<double> cylinder_center(3,0.0);
	
	for(double z=-sphere_radius;z<sphere_radius;z+=z_spacing, zc++)
	{
		for(double x=-sphere_radius;x<sphere_radius;x+=x_spacing, xc++)
		{
			for(double y=-sphere_radius;y<sphere_radius;y+=y_spacing, yc++)
			{
				tempPoint[0]=x + (zc%2) * 0.5 * cell_radius;
				tempPoint[1]=y + (xc%2) * cell_radius;
				tempPoint[2]=z;
				
				if(sqrt(norm_squared(tempPoint))< sphere_radius)
				{ cells.push_back(tempPoint); }
			}
			
		}
	}
	return cells;
	
}

void setup_tissue( void )
{
	// place a cluster of tumor cells at the center 
	
	double cell_radius = cell_defaults.phenotype.geometry.radius; 
	double cell_spacing = 0.95 * 2.0 * cell_radius; 
	
	double tumor_radius = 
		parameters.doubles("tumor_radius"); // 250.0; 
	
	Cell* pCell = NULL; 
	
	
	
	std::vector<std::vector<double>> positions = create_cell_sphere_positions(cell_radius,tumor_radius); 
	std::cout << "creating " << positions.size() << " closely-packed tumor cells ... " << std::endl; 
	
	static double imm_mean = parameters.doubles("tumor_mean_immunogenicity"); 
	static double imm_sd = parameters.doubles("tumor_immunogenicity_standard_deviation"); 
		
	for( int i=0; i < positions.size(); i++ )
	{
		pCell = create_cell(); // tumor cell 
		pCell->assign_position( positions[i] );
		pCell->custom_data[0] = NormalRandom( imm_mean, imm_sd );
		if( pCell->custom_data[0] < 0.0 )
		{ pCell->custom_data[0] = 0.0; } 
	}
	
	double sum = 0.0; 
	double min = 9e9; 
	double max = -9e9; 
	for( int i=0; i < all_cells->size() ; i++ )
	{
		double r = (*all_cells)[i]->custom_data[0]; 
		sum += r;
		if( r < min )
		{ min = r; } 
		if( r > max )
		{ max = r; }
	}
	double mean = sum / ( all_cells->size() + 1e-15 ); 
	// compute standard deviation 
	sum = 0.0; 
	for( int i=0; i < all_cells->size(); i++ )
	{
		sum +=  ( (*all_cells)[i]->custom_data[0] - mean )*( (*all_cells)[i]->custom_data[0] - mean ); 
	}
	double standard_deviation = sqrt( sum / ( all_cells->size() - 1.0 + 1e-15 ) ); 
	
	std::cout << std::endl << "Oncoprotein summary: " << std::endl
			  << "===================" << std::endl; 
	std::cout << "mean: " << mean << std::endl; 
	std::cout << "standard deviation: " << standard_deviation << std::endl; 
	std::cout << "[min max]: [" << min << " " << max << "]" << std::endl << std::endl; 
	
	return; 
}

// custom cell phenotype function to scale immunostimulatory factor with hypoxia 
void tumor_cell_phenotype_with_and_immune_stimulation( Cell* pCell, Phenotype& phenotype, double dt )
{
	static int cycle_start_index = live.find_phase_index( PhysiCell_constants::live ); 
	static int cycle_end_index = live.find_phase_index( PhysiCell_constants::live ); 
	static int oncoprotein_i = pCell->custom_data.find_variable_index( "oncoprotein" ); 
	
	// update secretion rates based on hypoxia 
	
	static int o2_index = microenvironment.find_density_index( "oxygen" ); 
	static int immune_factor_index = microenvironment.find_density_index( "immunostimulatory factor" ); 
	double o2 = pCell->nearest_density_vector()[o2_index];	

/*	
	if( o2 > pCell->parameters.o2_hypoxic_response )
	{
		phenotype.secretion.secretion_rates[immune_factor_index] = 0.0; 
	}
	else
	{
		double hypoxia = ( pCell->parameters.o2_hypoxic_response - o2 ) / ( pCell->parameters.o2_hypoxic_response + 1e-13 ); 
		phenotype.secretion.secretion_rates[ immune_factor_index ] = 10.0 * hypoxia; 	
	}
*/
	// new 
	phenotype.secretion.secretion_rates[immune_factor_index] = 10.0; 
	
	update_cell_and_death_parameters_O2_based(pCell,phenotype,dt);
	
	// if cell is dead, don't bother with future phenotype changes. 
	// set it to secrete the immunostimulatory factor 
	if( phenotype.death.dead == true )
	{
		phenotype.secretion.secretion_rates[immune_factor_index] = 10; 
		pCell->functions.update_phenotype = NULL; 		
		return; 
	}

	// multiply proliferation rate by the oncoprotein 
	phenotype.cycle.data.transition_rate( cycle_start_index ,cycle_end_index ) *= pCell->custom_data[oncoprotein_i] ; 
	
	return; 
}

std::vector<std::string> cancer_immune_coloring_function( Cell* pCell )
{
	static int oncoprotein_i = pCell->custom_data.find_variable_index( "oncoprotein" ); 
	
	// immune are black
	std::vector< std::string > output( 4, "black" ); 
	
	if( pCell->type == 1 )
	{ 
		output[0] = "lime";
		output[1] = "lime";
		output[2] = "green"; 
		return output;
	} 

	// if I'm under attack, color me 
	if( pCell->state.neighbors.size() > 0 )
	{
		output[0] = "darkcyan"; // orangered // "purple"; // 128,0,128
		output[1] = "black"; // "magenta"; 
		output[2] = "cyan"; // "magenta"; //255,0,255
		return output; 
	}
	
	// live cells are green, but shaded by oncoprotein value 
	if( pCell->phenotype.death.dead == false )
	{
		int oncoprotein = (int) round( 0.5 * pCell->custom_data[oncoprotein_i] * 255.0 ); 
		char szTempString [128];
		sprintf( szTempString , "rgb(%u,%u,%u)", oncoprotein, oncoprotein, 255-oncoprotein );
		output[0].assign( szTempString );
		output[1].assign( szTempString );

		sprintf( szTempString , "rgb(%u,%u,%u)", (int)round(output[0][0]/2.0) , (int)round(output[0][1]/2.0) , (int)round(output[0][2]/2.0) );
		output[2].assign( szTempString );
		
		return output; 
	}

	// if not, dead colors 
	
	if (pCell->phenotype.cycle.current_phase().code == PhysiCell_constants::apoptotic )  // Apoptotic - Red
	{
		output[0] = "rgb(255,0,0)";
		output[2] = "rgb(125,0,0)";
	}
	
	// Necrotic - Brown
	if( pCell->phenotype.cycle.current_phase().code == PhysiCell_constants::necrotic_swelling || 
		pCell->phenotype.cycle.current_phase().code == PhysiCell_constants::necrotic_lysed || 
		pCell->phenotype.cycle.current_phase().code == PhysiCell_constants::necrotic )
	{
		output[0] = "rgb(250,138,38)";
		output[2] = "rgb(139,69,19)";
	}	
	
	return output; 
}

void add_elastic_velocity( Cell* pActingOn, Cell* pAttachedTo , double elastic_constant )
{
	std::vector<double> displacement = pAttachedTo->position - pActingOn->position; 
	axpy( &(pActingOn->velocity) , elastic_constant , displacement ); 
	
	return; 
}

void extra_elastic_attachment_mechanics( Cell* pCell, Phenotype& phenotype, double dt )
{
	for( int i=0; i < pCell->state.neighbors.size() ; i++ )
	{
		add_elastic_velocity( pCell, pCell->state.neighbors[i], pCell->custom_data["elastic coefficient"] ); 
	}

	return; 
}	

void attach_cells( Cell* pCell_1, Cell* pCell_2 )
{
	#pragma omp critical
	{
		
	bool already_attached = false; 
	for( int i=0 ; i < pCell_1->state.neighbors.size() ; i++ )
	{
		if( pCell_1->state.neighbors[i] == pCell_2 )
		{ already_attached = true; }
	}
	if( already_attached == false )
	{ pCell_1->state.neighbors.push_back( pCell_2 ); }
	
	already_attached = false; 
	for( int i=0 ; i < pCell_2->state.neighbors.size() ; i++ )
	{
		if( pCell_2->state.neighbors[i] == pCell_1 )
		{ already_attached = true; }
	}
	if( already_attached == false )
	{ pCell_2->state.neighbors.push_back( pCell_1 ); }

	}

	return; 
}

void dettach_cells( Cell* pCell_1 , Cell* pCell_2 )
{
	#pragma omp critical
	{
		bool found = false; 
		int i = 0; 
		while( !found && i < pCell_1->state.neighbors.size() )
		{
			// if cell 2 is in cell 1's list, remove it
			if( pCell_1->state.neighbors[i] == pCell_2 )
			{
				int n = pCell_1->state.neighbors.size(); 
				// copy last entry to current position 
				pCell_1->state.neighbors[i] = pCell_1->state.neighbors[n-1]; 
				// shrink by one 
				pCell_1->state.neighbors.pop_back(); 
				found = true; 
			}
			i++; 
		}
	
		found = false; 
		i = 0; 
		while( !found && i < pCell_2->state.neighbors.size() )
		{
			// if cell 1 is in cell 2's list, remove it
			if( pCell_2->state.neighbors[i] == pCell_1 )
			{
				int n = pCell_2->state.neighbors.size(); 
				// copy last entry to current position 
				pCell_2->state.neighbors[i] = pCell_2->state.neighbors[n-1]; 
				// shrink by one 
				pCell_2->state.neighbors.pop_back(); 
				found = true; 
			}
			i++; 
		}

	}
	
	return; 
}

void immune_cell_motility( Cell* pCell, Phenotype& phenotype, double dt )
{
	// if attached, biased motility towards director chemoattractant 
	// otherwise, biased motility towards cargo chemoattractant 
	
	static int immune_factor_index = microenvironment.find_density_index( "immunostimulatory factor" ); 

	// if not docked, attempt biased chemotaxis 
	if( pCell->state.neighbors.size() == 0 )
	{
		// phenotype.motility.migration_bias = 0.25; 
		phenotype.motility.is_motile = true; 
		
		phenotype.motility.migration_bias_direction = pCell->nearest_gradient(immune_factor_index);	
		normalize( &( phenotype.motility.migration_bias_direction ) );			
	}
	else
	{
		phenotype.motility.is_motile = false; 
	}
	
	return; 
}

Cell* immune_cell_check_neighbors_for_attachment( Cell* pAttacker , double dt )
{
	std::vector<Cell*> nearby = pAttacker->cells_in_my_container(); 
	int i = 0; 
	while( i < nearby.size() )
	{
		// don't try to kill yourself 
		if( nearby[i] != pAttacker )
		{
			if( immune_cell_attempt_attachment( pAttacker, nearby[i] , dt ) )
			{ return nearby[i]; }
		}
		i++; 
	}
	
	return NULL; 
}

bool immune_cell_attempt_attachment( Cell* pAttacker, Cell* pTarget , double dt )
{
	static int oncoprotein_i = pTarget->custom_data.find_variable_index( "oncoprotein" ); 
	static int attach_rate_i = pAttacker->custom_data.find_variable_index( "attachment rate" ); 

	static double oncoprotein_saturation = 
		parameters.doubles("oncoprotein_saturation"); // 2.0; 
	static double oncoprotein_threshold =  
		parameters.doubles("oncoprotein_threshold"); // 0.5; // 0.1; 
	static double oncoprotein_difference = oncoprotein_saturation - oncoprotein_threshold;
	
	static double max_attachment_distance = 
		parameters.doubles("max_attachment_distance"); // 18.0; 
	static double min_attachment_distance = 
		parameters.doubles("min_attachment_distance"); // 14.0; 
	static double attachment_difference = max_attachment_distance - min_attachment_distance; 
	
	if( pTarget->custom_data[oncoprotein_i] > oncoprotein_threshold && pTarget->phenotype.death.dead == false )
	{
		std::vector<double> displacement = pTarget->position - pAttacker->position;
		double distance_scale = norm( displacement ); 
		if( distance_scale > max_attachment_distance )
		{ return false; } 
	
		double scale = pTarget->custom_data[oncoprotein_i];
		scale -= oncoprotein_threshold; 
		scale /= oncoprotein_difference;
		if( scale > 1.0 )
		{ scale = 1.0; } 
		
		distance_scale *= -1.0; 
		distance_scale += max_attachment_distance; 
		distance_scale /= attachment_difference; 
		if( distance_scale > 1.0 )
		{ distance_scale = 1.0; } 
		
		if( UniformRandom() < pAttacker->custom_data[attach_rate_i] * scale * dt * distance_scale )
		{
			std::cout << "\t attach!" << " " << pTarget->custom_data[oncoprotein_i] << std::endl; 
			attach_cells( pAttacker, pTarget ); 
		}
		
		return true; 
	}
	
	return false; 
}

bool immune_cell_attempt_apoptosis( Cell* pAttacker, Cell* pTarget, double dt )
{
	static int oncoprotein_i = pTarget->custom_data.find_variable_index( "oncoprotein" ); 
	static int apoptosis_model_index = pTarget->phenotype.death.find_death_model_index( "apoptosis" );	
	static int kill_rate_index = pAttacker->custom_data.find_variable_index( "kill rate" ); 
	
	
	
	static double oncoprotein_saturation = 
		parameters.doubles("oncoprotein_saturation"); // 2.0; 
	static double oncoprotein_threshold =  
		parameters.doubles("oncoprotein_threshold"); // 0.5; // 0.1; 
	static double oncoprotein_difference = oncoprotein_saturation - oncoprotein_threshold;

	
	// new 
	if( pTarget->custom_data[oncoprotein_i] < oncoprotein_threshold )
	{ return false; }
	
	// new 
	double scale = pTarget->custom_data[oncoprotein_i];
	scale -= oncoprotein_threshold; 
	scale /= oncoprotein_difference;
	if( scale > 1.0 )
	{ scale = 1.0; } 
	
	
//	if( UniformRandom() < pAttacker->custom_data[kill_rate_index] * pTarget->custom_data[oncoprotein_i] * dt )
	if( UniformRandom() < pAttacker->custom_data[kill_rate_index] * scale * dt )
	{ 
		std::cout << "\t\t kill!" << " " << pTarget->custom_data[oncoprotein_i] << std::endl; 
		return true; 
	}
	return false; 
}

bool immune_cell_trigger_apoptosis( Cell* pAttacker, Cell* pTarget )
{
	static int apoptosis_model_index = pTarget->phenotype.death.find_death_model_index( "apoptosis" );	
	
	// if the Target cell is already dead, don't bother!
	if( pTarget->phenotype.death.dead == true )
	{ return false; }

	pTarget->start_death( apoptosis_model_index );
	return true; 
}

void immune_cell_rule( Cell* pCell, Phenotype& phenotype, double dt )
{
	static int attach_lifetime_i = pCell->custom_data.find_variable_index( "attachment lifetime" ); 
	
	if( phenotype.death.dead == true )
	{
		// the cell death functions don't automatically turn off custom functions, 
		// since those are part of mechanics. 
		
		// Let's just fully disable now. 
		pCell->functions.custom_cell_rule = NULL; 
		return; 
	}
	
	// if I'm docked
	if( pCell->state.neighbors.size() > 0 )
	{
		extra_elastic_attachment_mechanics( pCell, phenotype, dt );
		
		// attempt to kill my attached cell
		
		bool dettach_me = false; 
		
		if( immune_cell_attempt_apoptosis( pCell, pCell->state.neighbors[0], dt ) )
		{
			immune_cell_trigger_apoptosis( pCell, pCell->state.neighbors[0] ); 
			dettach_me = true; 
		}
		
		// decide whether ot dettach 
		
		if( UniformRandom() < dt / ( pCell->custom_data[attach_lifetime_i] + 1e-15 ) )
		{ dettach_me = true; }
		
		// if I dettach, resume motile behavior 
		
		if( dettach_me )
		{
			dettach_cells( pCell, pCell->state.neighbors[0] ); 
			phenotype.motility.is_motile = true; 
		}
		return; 
	}
	
	// I'm not docked, look for cells nearby and try to docked
	
	// if this returns non-NULL, we're now attached to a cell 
	if( immune_cell_check_neighbors_for_attachment( pCell , dt) )
	{
		// set motility off 
		phenotype.motility.is_motile = false; 
		return; 
	}
	phenotype.motility.is_motile = true; 
	
	return; 
}


########## NEXT FILE ##########
CI_script.cpp:::
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

// set number of threads for OpenMP (parallel computing)
int omp_num_threads = 8; // set this to # of CPU cores x 2 (for hyperthreading)

int main( int argc, char* argv[] )
{
	// OpenMP setup
	omp_set_num_threads(omp_num_threads);

	#pragma omp parallel for 
	for( int i= atoi( argv[1] ) ; i <= atoi( argv[2] ); i++ )
	{
		char str [1024]; 
		sprintf( str , "CI_vis %i", i ); 
		system( str ); 
		
		std::cout << i << " " << str << std::endl; 
		
		
	}
	

	
	return 0; 
}
########## NEXT FILE ##########
add.c:::
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB BT code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS BT code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

#include "header.h"
//#include "timers.h"

//---------------------------------------------------------------------
// addition of update to the vector u//---------------------------------------------------------------------
void add()
{
  int i, j, k, m;
  int gp22, gp12, gp02;

  gp22 = grid_points[2]-2;
  gp12 = grid_points[1]-2;
  gp02 = grid_points[0]-2;

#pragma acc parallel loop gang present(u,rhs) num_gangs(gp22) num_workers(4) vector_length(32)
  for (k = 1; k <= gp22; k++) {
    #pragma acc loop worker
    for (j = 1; j <= gp12; j++) {
	  #pragma acc loop vector
      for (i = 1; i <= gp02; i++) {
	  /*
        for (m = 0; m < 5; m++) {
          u[m][k][j][i] = u[m][k][j][i] + rhs[m][k][j][i];
        }
	  */
          u[0][k][j][i] = u[0][k][j][i] + rhs[0][k][j][i];
          u[1][k][j][i] = u[1][k][j][i] + rhs[1][k][j][i];
          u[2][k][j][i] = u[2][k][j][i] + rhs[2][k][j][i];
          u[3][k][j][i] = u[3][k][j][i] + rhs[3][k][j][i];
          u[4][k][j][i] = u[4][k][j][i] + rhs[4][k][j][i];
      }
    }
  }
}

########## NEXT FILE ##########
bt.c:::
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB BT code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//OpenACC version author: Rengan Xu(renganxu@gmail.com)				   //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS BT code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

//---------------------------------------------------------------------
// program BT
//---------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>

#include "header.h"
#include "timers.h"
#include "print_results.h"
#include<openacc.h>

/* common /global/ */
double elapsed_time;
int grid_points[3];
logical timeron;

/* common /constants/ */
double tx1, tx2, tx3, ty1, ty2, ty3, tz1, tz2, tz3, 
       dx1, dx2, dx3, dx4, dx5, dy1, dy2, dy3, dy4, 
       dy5, dz1, dz2, dz3, dz4, dz5, dssp, dt, 
       ce[5][13], dxmax, dymax, dzmax, xxcon1, xxcon2, 
       xxcon3, xxcon4, xxcon5, dx1tx1, dx2tx1, dx3tx1,
       dx4tx1, dx5tx1, yycon1, yycon2, yycon3, yycon4,
       yycon5, dy1ty1, dy2ty1, dy3ty1, dy4ty1, dy5ty1,
       zzcon1, zzcon2, zzcon3, zzcon4, zzcon5, dz1tz1, 
       dz2tz1, dz3tz1, dz4tz1, dz5tz1, dnxm1, dnym1, 
       dnzm1, c1c2, c1c5, c3c4, c1345, conz1, c1, c2, 
       c3, c4, c5, c4dssp, c5dssp, dtdssp, dttx1,
       dttx2, dtty1, dtty2, dttz1, dttz2, c2dttx1, 
       c2dtty1, c2dttz1, comz1, comz4, comz5, comz6, 
       c3c4tx3, c3c4ty3, c3c4tz3, c2iv, con43, con16;

// to improve cache performance, grid dimensions padded by 1 
// for even number sizes only.
/* common /fields/ */
double us     [KMAX][JMAXP+1][IMAXP+1];
double vs     [KMAX][JMAXP+1][IMAXP+1];
double ws     [KMAX][JMAXP+1][IMAXP+1];
double qs     [KMAX][JMAXP+1][IMAXP+1];
double rho_i  [KMAX][JMAXP+1][IMAXP+1];
double square [KMAX][JMAXP+1][IMAXP+1];
double forcing[5][KMAX][JMAXP+1][IMAXP+1];
double u[5][KMAX][JMAXP+1][IMAXP+1];
double rhs[5][KMAX][JMAXP+1][IMAXP+1];

/* common /work_1d/ */
double cuf[PROBLEM_SIZE+1];
double q  [PROBLEM_SIZE+1];
double ue [PROBLEM_SIZE+1][5];
double buf[PROBLEM_SIZE+1][5];

/* common /work_lhs/ */
double fjac[PROBLEM_SIZE+1][5][5];
double njac[PROBLEM_SIZE+1][5][5];
double lhs [PROBLEM_SIZE+1][3][5][5];
double tmp1, tmp2, tmp3;
/*  
double fjacX[5][5][PROBLEM_SIZE+1][JMAXP-1][KMAX-1];
double njacX[5][5][PROBLEM_SIZE+1][JMAXP-1][KMAX-1];
double lhsX[5][5][3][PROBLEM_SIZE][JMAXP-1][KMAX-1];
  
double fjacY[5][5][PROBLEM_SIZE+1][IMAXP-1][KMAX-1];
double njacY[5][5][PROBLEM_SIZE+1][IMAXP-1][KMAX-1];
double lhsY[5][5][3][PROBLEM_SIZE][IMAXP-1][KMAX-1];

double fjacZ[5][5][PROBLEM_SIZE+1][IMAXP-1][JMAXP-1];
double njacZ[5][5][PROBLEM_SIZE+1][IMAXP-1][JMAXP-1];
double lhsZ[5][5][3][PROBLEM_SIZE][IMAXP-1][JMAXP-1];
*/
int main(int argc, char *argv[])
{
  int i, niter, step;
  double navg, mflops, n3;

  double tmax, t, trecs[t_last+1];
  logical verified;
  char Class;
  char *t_names[t_last+1];

  //---------------------------------------------------------------------
  // Root node reads input file (if it exists) else takes
  // defaults from parameters
  //---------------------------------------------------------------------
  FILE *fp;
  if ((fp = fopen("timer.flag", "r")) != NULL) {
    timeron = true;
    t_names[t_total] = "total";
    t_names[t_rhsx] = "rhsx";
    t_names[t_rhsy] = "rhsy";
    t_names[t_rhsz] = "rhsz";
    t_names[t_rhs] = "rhs";
    t_names[t_xsolve] = "xsolve";
    t_names[t_ysolve] = "ysolve";
    t_names[t_zsolve] = "zsolve";
    t_names[t_rdis1] = "redist1";
    t_names[t_rdis2] = "redist2";
    t_names[t_add] = "add";
    fclose(fp);
  } else {
    timeron = false;
  }

  printf("\n\n NAS Parallel Benchmarks (NPB3.3-ACC-C) - BT Benchmark\n\n");

  if ((fp = fopen("inputbt.data", "r")) != NULL) {
    int result;
    printf(" Reading from input file inputbt.data\n");
    result = fscanf(fp, "%d", &niter);
    while (fgetc(fp) != '\n');
    result = fscanf(fp, "%lf", &dt);
    while (fgetc(fp) != '\n');
    result = fscanf(fp, "%d%d%d\n", 
        &grid_points[0], &grid_points[1], &grid_points[2]);
    fclose(fp);
  } else {
    printf(" No input file inputbt.data. Using compiled defaults\n");
    niter = NITER_DEFAULT;
    dt    = DT_DEFAULT;
    grid_points[0] = PROBLEM_SIZE;
    grid_points[1] = PROBLEM_SIZE;
    grid_points[2] = PROBLEM_SIZE;
  }

  printf(" Size: %4dx%4dx%4d\n",
      grid_points[0], grid_points[1], grid_points[2]);
  printf(" Iterations: %4d    dt: %10.6f\n", niter, dt);
  printf("\n");
  
  //PROBLEM_SIZE=grid_points[0];

  if ( (grid_points[0] > IMAX) ||
       (grid_points[1] > JMAX) ||
       (grid_points[2] > KMAX) ) {
    printf(" %d, %d, %d\n", grid_points[0], grid_points[1], grid_points[2]);
    printf(" Problem size too big for compiled array sizes\n");
    return 0;
  }
  
//printf("PROBLEM_SIZE: %d, IMAX: %d, JMAX: %d, KMAX: %d, IMAXP: %d, JMAXP: %d\n",
//  		  PROBLEM_SIZE, IMAX, JMAX, KMAX, IMAXP, JMAXP);

    acc_init(acc_device_default);
  set_constants();

  for (i = 1; i <= t_last; i++) {
    timer_clear(i);
  }

#pragma acc data create(forcing,rho_i,u,us,vs,ws,square,qs,rhs) //fjacX,njacX,lhsX,fjacY,njacY,lhsY,fjacZ,njacZ,lhsZ)
{
  initialize();

  exact_rhs();

  //---------------------------------------------------------------------
  // do one time step to touch all code, and reinitialize
  //---------------------------------------------------------------------
  adi();
  initialize();
  
  for (i = 1; i <= t_last; i++) {
    timer_clear(i);
  }
  timer_start(1);

  for (step = 1; step <= niter; step++) {
    if ((step % 20) == 0 || step == 1) {
      printf(" Time step %4d\n", step);
    }

    adi();
  }

  timer_stop(1);
  tmax = timer_read(1);

  #pragma acc update host(u)
  verify(niter, &Class, &verified);

  n3 = 1.0*grid_points[0]*grid_points[1]*grid_points[2];
  navg = (grid_points[0]+grid_points[1]+grid_points[2])/3.0;
  if(tmax != 0.0) {
    mflops = 1.0e-6 * (double)niter *
      (3478.8 * n3 - 17655.7 * (navg*navg) + 28023.7 * navg)
      / tmax;
  } else {
    mflops = 0.0;
  }

}/*end acc data*/
  print_results("BT", Class, grid_points[0], 
                grid_points[1], grid_points[2], niter,
                tmax, mflops, "          floating point", 
                verified, NPBVERSION,COMPILETIME, CS1, CS2, CS3, CS4, CS5, 
                CS6, "(none)");

    acc_shutdown(acc_device_default);
  return 0;
}


########## NEXT FILE ##########
error.c:::
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB BT code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS BT code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

#include <math.h>
#include "header.h"

//---------------------------------------------------------------------
// this function computes the norm of the difference between the
// computed solution and the exact solution
//---------------------------------------------------------------------
void error_norm(double rms[5])
{
  int i, j, k, m, d;
  double xi, eta, zeta, u_exact[5], add;

  for (m = 0; m < 5; m++) {
    rms[m] = 0.0;
  }

  for (k = 0; k <= grid_points[2]-1; k++) {
    zeta = (double)(k) * dnzm1;
    for (j = 0; j <= grid_points[1]-1; j++) {
      eta = (double)(j) * dnym1;
      for (i = 0; i <= grid_points[0]-1; i++) {
        xi = (double)(i) * dnxm1;
        exact_solution(xi, eta, zeta, u_exact);

        for (m = 0; m < 5; m++) {
          add = u[m][k][j][i]-u_exact[m];
          rms[m] = rms[m] + add*add;
        }
      }
    }
  }

  for (m = 0; m < 5; m++) {
    for (d = 0; d < 3; d++) {
      rms[m] = rms[m] / (double)(grid_points[d]-2);
    }
    rms[m] = sqrt(rms[m]);
  }
}


void rhs_norm(double rms[5])
{
  int i, j, k, d, m;
  double add;

  for (m = 0; m < 5; m++) {
    rms[m] = 0.0;
  } 

  #pragma acc update host(rhs)

  for (k = 1; k <= grid_points[2]-2; k++) {
    for (j = 1; j <= grid_points[1]-2; j++) {
      for (i = 1; i <= grid_points[0]-2; i++) {
        for (m = 0; m < 5; m++) {
          add = rhs[m][k][j][i];
          rms[m] = rms[m] + add*add;
        } 
      } 
    } 
  } 

  for (m = 0; m < 5; m++) {
    for (d = 0; d < 3; d++) {
      rms[m] = rms[m] / (double)(grid_points[d]-2);
    } 
    rms[m] = sqrt(rms[m]);
  } 
}

########## NEXT FILE ##########
exact_rhs.c:::
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB BT code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS BT code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

#include "header.h"

//---------------------------------------------------------------------
// compute the right hand side based on exact solution
//---------------------------------------------------------------------
void exact_rhs()
{
  double dtemp[5], xi, eta, zeta, dtpp;
  int m, i, j, k, ip1, im1, jp1, jm1, km1, kp1;

  //---------------------------------------------------------------------
  // initialize                                  
  //---------------------------------------------------------------------
  for (k = 0; k <= grid_points[2]-1; k++) {
    for (j = 0; j <= grid_points[1]-1; j++) {
      for (i = 0; i <= grid_points[0]-1; i++) {
        for (m = 0; m < 5; m++) {
          forcing[m][k][j][i] = 0.0;
        }
      }
    }
  }

  //---------------------------------------------------------------------
  // xi-direction flux differences                      
  //---------------------------------------------------------------------
  for (k = 1; k <= grid_points[2]-2; k++) {
    zeta = (double)(k) * dnzm1;
    for (j = 1; j <= grid_points[1]-2; j++) {
      eta = (double)(j) * dnym1;

      for (i = 0; i <= grid_points[0]-1; i++) {
        xi = (double)(i) * dnxm1;

        exact_solution(xi, eta, zeta, dtemp);
        for (m = 0; m < 5; m++) {
          ue[i][m] = dtemp[m];
        }

        dtpp = 1.0 / dtemp[0];

        for (m = 1; m < 5; m++) {
          buf[i][m] = dtpp * dtemp[m];
        }

        cuf[i]    = buf[i][1] * buf[i][1];
        buf[i][0] = cuf[i] + buf[i][2] * buf[i][2] + buf[i][3] * buf[i][3];
        q[i] = 0.5*(buf[i][1]*ue[i][1] + buf[i][2]*ue[i][2] +
                    buf[i][3]*ue[i][3]);
      }

      for (i = 1; i <= grid_points[0]-2; i++) {
        im1 = i-1;
        ip1 = i+1;

        forcing[0][k][j][i] = forcing[0][k][j][i] -
          tx2*( ue[ip1][1]-ue[im1][1] )+
          dx1tx1*(ue[ip1][0]-2.0*ue[i][0]+ue[im1][0]);

        forcing[1][k][j][i] = forcing[1][k][j][i] - tx2 * (
            (ue[ip1][1]*buf[ip1][1]+c2*(ue[ip1][4]-q[ip1]))-
            (ue[im1][1]*buf[im1][1]+c2*(ue[im1][4]-q[im1])))+
          xxcon1*(buf[ip1][1]-2.0*buf[i][1]+buf[im1][1])+
          dx2tx1*( ue[ip1][1]-2.0* ue[i][1]+ue[im1][1]);

        forcing[2][k][j][i] = forcing[2][k][j][i] - tx2 * (
            ue[ip1][2]*buf[ip1][1]-ue[im1][2]*buf[im1][1])+
          xxcon2*(buf[ip1][2]-2.0*buf[i][2]+buf[im1][2])+
          dx3tx1*( ue[ip1][2]-2.0*ue[i][2] +ue[im1][2]);

        forcing[3][k][j][i] = forcing[3][k][j][i] - tx2*(
            ue[ip1][3]*buf[ip1][1]-ue[im1][3]*buf[im1][1])+
          xxcon2*(buf[ip1][3]-2.0*buf[i][3]+buf[im1][3])+
          dx4tx1*( ue[ip1][3]-2.0* ue[i][3]+ ue[im1][3]);

        forcing[4][k][j][i] = forcing[4][k][j][i] - tx2*(
            buf[ip1][1]*(c1*ue[ip1][4]-c2*q[ip1])-
            buf[im1][1]*(c1*ue[im1][4]-c2*q[im1]))+
          0.5*xxcon3*(buf[ip1][0]-2.0*buf[i][0]+
              buf[im1][0])+
          xxcon4*(cuf[ip1]-2.0*cuf[i]+cuf[im1])+
          xxcon5*(buf[ip1][4]-2.0*buf[i][4]+buf[im1][4])+
          dx5tx1*( ue[ip1][4]-2.0* ue[i][4]+ ue[im1][4]);
      }

      //---------------------------------------------------------------------
      // Fourth-order dissipation                         
      //---------------------------------------------------------------------
      for (m = 0; m < 5; m++) {
        i = 1;
        forcing[m][k][j][i] = forcing[m][k][j][i] - dssp *
          (5.0*ue[i][m] - 4.0*ue[i+1][m] +ue[i+2][m]);
        i = 2;
        forcing[m][k][j][i] = forcing[m][k][j][i] - dssp *
          (-4.0*ue[i-1][m] + 6.0*ue[i][m] -
            4.0*ue[i+1][m] +     ue[i+2][m]);
      }

      for (i = 3; i <= grid_points[0]-4; i++) {
        for (m = 0; m < 5; m++) {
          forcing[m][k][j][i] = forcing[m][k][j][i] - dssp*
            (ue[i-2][m] - 4.0*ue[i-1][m] +
             6.0*ue[i][m] - 4.0*ue[i+1][m] + ue[i+2][m]);
        }
      }

      for (m = 0; m < 5; m++) {
        i = grid_points[0]-3;
        forcing[m][k][j][i] = forcing[m][k][j][i] - dssp *
          (ue[i-2][m] - 4.0*ue[i-1][m] +
           6.0*ue[i][m] - 4.0*ue[i+1][m]);
        i = grid_points[0]-2;
        forcing[m][k][j][i] = forcing[m][k][j][i] - dssp *
          (ue[i-2][m] - 4.0*ue[i-1][m] + 5.0*ue[i][m]);
      }
    }
  }

  //---------------------------------------------------------------------
  // eta-direction flux differences             
  //---------------------------------------------------------------------
  for (k = 1; k <= grid_points[2]-2; k++) {
    zeta = (double)(k) * dnzm1;
    for (i = 1; i <= grid_points[0]-2; i++) {
      xi = (double)(i) * dnxm1;

      for (j = 0; j <= grid_points[1]-1; j++) {
        eta = (double)(j) * dnym1;

        exact_solution(xi, eta, zeta, dtemp);
        for (m = 0; m < 5; m++) {
          ue[j][m] = dtemp[m];
        }

        dtpp = 1.0/dtemp[0];

        for (m = 1; m < 5; m++) {
          buf[j][m] = dtpp * dtemp[m];
        }

        cuf[j]    = buf[j][2] * buf[j][2];
        buf[j][0] = cuf[j] + buf[j][1] * buf[j][1] + buf[j][3] * buf[j][3];
        q[j] = 0.5*(buf[j][1]*ue[j][1] + buf[j][2]*ue[j][2] +
                    buf[j][3]*ue[j][3]);
      }

      for (j = 1; j <= grid_points[1]-2; j++) {
        jm1 = j-1;
        jp1 = j+1;

        forcing[0][k][j][i] = forcing[0][k][j][i] -
          ty2*( ue[jp1][2]-ue[jm1][2] )+
          dy1ty1*(ue[jp1][0]-2.0*ue[j][0]+ue[jm1][0]);

        forcing[1][k][j][i] = forcing[1][k][j][i] - ty2*(
            ue[jp1][1]*buf[jp1][2]-ue[jm1][1]*buf[jm1][2])+
          yycon2*(buf[jp1][1]-2.0*buf[j][1]+buf[jm1][1])+
          dy2ty1*( ue[jp1][1]-2.0* ue[j][1]+ ue[jm1][1]);

        forcing[2][k][j][i] = forcing[2][k][j][i] - ty2*(
            (ue[jp1][2]*buf[jp1][2]+c2*(ue[jp1][4]-q[jp1]))-
            (ue[jm1][2]*buf[jm1][2]+c2*(ue[jm1][4]-q[jm1])))+
          yycon1*(buf[jp1][2]-2.0*buf[j][2]+buf[jm1][2])+
          dy3ty1*( ue[jp1][2]-2.0*ue[j][2] +ue[jm1][2]);

        forcing[3][k][j][i] = forcing[3][k][j][i] - ty2*(
            ue[jp1][3]*buf[jp1][2]-ue[jm1][3]*buf[jm1][2])+
          yycon2*(buf[jp1][3]-2.0*buf[j][3]+buf[jm1][3])+
          dy4ty1*( ue[jp1][3]-2.0*ue[j][3]+ ue[jm1][3]);

        forcing[4][k][j][i] = forcing[4][k][j][i] - ty2*(
            buf[jp1][2]*(c1*ue[jp1][4]-c2*q[jp1])-
            buf[jm1][2]*(c1*ue[jm1][4]-c2*q[jm1]))+
          0.5*yycon3*(buf[jp1][0]-2.0*buf[j][0]+
              buf[jm1][0])+
          yycon4*(cuf[jp1]-2.0*cuf[j]+cuf[jm1])+
          yycon5*(buf[jp1][4]-2.0*buf[j][4]+buf[jm1][4])+
          dy5ty1*(ue[jp1][4]-2.0*ue[j][4]+ue[jm1][4]);
      }

      //---------------------------------------------------------------------
      // Fourth-order dissipation                      
      //---------------------------------------------------------------------
      for (m = 0; m < 5; m++) {
        j = 1;
        forcing[m][k][j][i] = forcing[m][k][j][i] - dssp *
          (5.0*ue[j][m] - 4.0*ue[j+1][m] +ue[j+2][m]);
        j = 2;
        forcing[m][k][j][i] = forcing[m][k][j][i] - dssp *
          (-4.0*ue[j-1][m] + 6.0*ue[j][m] -
           4.0*ue[j+1][m] +       ue[j+2][m]);
      }

      for (j = 3; j <= grid_points[1]-4; j++) {
        for (m = 0; m < 5; m++) {
          forcing[m][k][j][i] = forcing[m][k][j][i] - dssp*
            (ue[j-2][m] - 4.0*ue[j-1][m] +
             6.0*ue[j][m] - 4.0*ue[j+1][m] + ue[j+2][m]);
        }
      }

      for (m = 0; m < 5; m++) {
        j = grid_points[1]-3;
        forcing[m][k][j][i] = forcing[m][k][j][i] - dssp *
          (ue[j-2][m] - 4.0*ue[j-1][m] +
           6.0*ue[j][m] - 4.0*ue[j+1][m]);
        j = grid_points[1]-2;
        forcing[m][k][j][i] = forcing[m][k][j][i] - dssp *
          (ue[j-2][m] - 4.0*ue[j-1][m] + 5.0*ue[j][m]);
      }
    }
  }

  //---------------------------------------------------------------------
  // zeta-direction flux differences                      
  //---------------------------------------------------------------------
  for (j = 1; j <= grid_points[1]-2; j++) {
    eta = (double)(j) * dnym1;
    for (i = 1; i <= grid_points[0]-2; i++) {
      xi = (double)(i) * dnxm1;

      for (k = 0; k <= grid_points[2]-1; k++) {
        zeta = (double)(k) * dnzm1;

        exact_solution(xi, eta, zeta, dtemp);
        for (m = 0; m < 5; m++) {
          ue[k][m] = dtemp[m];
        }

        dtpp = 1.0/dtemp[0];

        for (m = 1; m < 5; m++) {
          buf[k][m] = dtpp * dtemp[m];
        }

        cuf[k]    = buf[k][3] * buf[k][3];
        buf[k][0] = cuf[k] + buf[k][1] * buf[k][1] + buf[k][2] * buf[k][2];
        q[k] = 0.5*(buf[k][1]*ue[k][1] + buf[k][2]*ue[k][2] +
                    buf[k][3]*ue[k][3]);
      }

      for (k = 1; k <= grid_points[2]-2; k++) {
        km1 = k-1;
        kp1 = k+1;

        forcing[0][k][j][i] = forcing[0][k][j][i] -
          tz2*( ue[kp1][3]-ue[km1][3] )+
          dz1tz1*(ue[kp1][0]-2.0*ue[k][0]+ue[km1][0]);

        forcing[1][k][j][i] = forcing[1][k][j][i] - tz2 * (
            ue[kp1][1]*buf[kp1][3]-ue[km1][1]*buf[km1][3])+
          zzcon2*(buf[kp1][1]-2.0*buf[k][1]+buf[km1][1])+
          dz2tz1*( ue[kp1][1]-2.0* ue[k][1]+ ue[km1][1]);

        forcing[2][k][j][i] = forcing[2][k][j][i] - tz2 * (
            ue[kp1][2]*buf[kp1][3]-ue[km1][2]*buf[km1][3])+
          zzcon2*(buf[kp1][2]-2.0*buf[k][2]+buf[km1][2])+
          dz3tz1*(ue[kp1][2]-2.0*ue[k][2]+ue[km1][2]);

        forcing[3][k][j][i] = forcing[3][k][j][i] - tz2 * (
            (ue[kp1][3]*buf[kp1][3]+c2*(ue[kp1][4]-q[kp1]))-
            (ue[km1][3]*buf[km1][3]+c2*(ue[km1][4]-q[km1])))+
          zzcon1*(buf[kp1][3]-2.0*buf[k][3]+buf[km1][3])+
          dz4tz1*( ue[kp1][3]-2.0*ue[k][3] +ue[km1][3]);

        forcing[4][k][j][i] = forcing[4][k][j][i] - tz2 * (
            buf[kp1][3]*(c1*ue[kp1][4]-c2*q[kp1])-
            buf[km1][3]*(c1*ue[km1][4]-c2*q[km1]))+
          0.5*zzcon3*(buf[kp1][0]-2.0*buf[k][0]
              +buf[km1][0])+
          zzcon4*(cuf[kp1]-2.0*cuf[k]+cuf[km1])+
          zzcon5*(buf[kp1][4]-2.0*buf[k][4]+buf[km1][4])+
          dz5tz1*( ue[kp1][4]-2.0*ue[k][4]+ ue[km1][4]);
      }

      //---------------------------------------------------------------------
      // Fourth-order dissipation                        
      //---------------------------------------------------------------------
      for (m = 0; m < 5; m++) {
        k = 1;
        forcing[m][k][j][i] = forcing[m][k][j][i] - dssp *
          (5.0*ue[k][m] - 4.0*ue[k+1][m] +ue[k+2][m]);
        k = 2;
        forcing[m][k][j][i] = forcing[m][k][j][i] - dssp *
          (-4.0*ue[k-1][m] + 6.0*ue[k][m] -
           4.0*ue[k+1][m] +       ue[k+2][m]);
      }

      for (k = 3; k <= grid_points[2]-4; k++) {
        for (m = 0; m < 5; m++) {
          forcing[m][k][j][i] = forcing[m][k][j][i] - dssp*
            (ue[k-2][m] - 4.0*ue[k-1][m] +
             6.0*ue[k][m] - 4.0*ue[k+1][m] + ue[k+2][m]);
        }
      }

      for (m = 0; m < 5; m++) {
        k = grid_points[2]-3;
        forcing[m][k][j][i] = forcing[m][k][j][i] - dssp *
          (ue[k-2][m] - 4.0*ue[k-1][m] +
           6.0*ue[k][m] - 4.0*ue[k+1][m]);
        k = grid_points[2]-2;
        forcing[m][k][j][i] = forcing[m][k][j][i] - dssp *
          (ue[k-2][m] - 4.0*ue[k-1][m] + 5.0*ue[k][m]);
      }

    }
  }

  //---------------------------------------------------------------------
  // now change the sign of the forcingfunction, 
  //---------------------------------------------------------------------
  for (k = 1; k <= grid_points[2]-2; k++) {
    for (j = 1; j <= grid_points[1]-2; j++) {
      for (i = 1; i <= grid_points[0]-2; i++) {
        for (m = 0; m < 5; m++) {
          forcing[m][k][j][i] = -1.0 * forcing[m][k][j][i];
        }
      }
    }
  }

  #pragma acc update device(forcing)
}

########## NEXT FILE ##########
initialize.c:::
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB BT code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS BT code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

#include "header.h"

//---------------------------------------------------------------------
// This subroutine initializes the field variable uusing 
// tri-linear transfinite interpolation of the boundary values     
//---------------------------------------------------------------------
void initialize()
{
  int i, j, k, m, ix, iy, iz;
  double xi, eta, zeta, Pface[2][3][5], Pxi, Peta, Pzeta, temp[5];

  //---------------------------------------------------------------------
  // Later (in compute_rhs) we compute 1/ufor every element. A few of 
  // the corner elements are not used, but it convenient (and faster) 
  // to compute the whole thing with a simple loop. Make sure those 
  // values are nonzero by initializing the whole thing here. 
  //---------------------------------------------------------------------
  for (k = 0; k <= grid_points[2]-1; k++) {
    for (j = 0; j <= grid_points[1]-1; j++) {
      for (i = 0; i <= grid_points[0]-1; i++) {
        for (m = 0; m < 5; m++) {
          u[m][k][j][i] = 1.0;
        }
      }
    }
  }

  //---------------------------------------------------------------------
  // first store the "interpolated" values everywhere on the grid    
  //---------------------------------------------------------------------
  for (k = 0; k <= grid_points[2]-1; k++) {
    zeta = (double)(k) * dnzm1;
    for (j = 0; j <= grid_points[1]-1; j++) {
      eta = (double)(j) * dnym1;
      for (i = 0; i <= grid_points[0]-1; i++) {
        xi = (double)(i) * dnxm1;

        for (ix = 0; ix < 2; ix++) {
          exact_solution((double)ix, eta, zeta, &Pface[ix][0][0]);
        }

        for (iy = 0; iy < 2; iy++) {
          exact_solution(xi, (double)iy , zeta, &Pface[iy][1][0]);
        }

        for (iz = 0; iz < 2; iz++) {
          exact_solution(xi, eta, (double)iz, &Pface[iz][2][0]);
        }

        for (m = 0; m < 5; m++) {
          Pxi   = xi   * Pface[1][0][m] + (1.0-xi)   * Pface[0][0][m];
          Peta  = eta  * Pface[1][1][m] + (1.0-eta)  * Pface[0][1][m];
          Pzeta = zeta * Pface[1][2][m] + (1.0-zeta) * Pface[0][2][m];

          u[m][k][j][i] = Pxi + Peta + Pzeta - 
                          Pxi*Peta - Pxi*Pzeta - Peta*Pzeta + 
                          Pxi*Peta*Pzeta;
        }
      }
    }
  }

  //---------------------------------------------------------------------
  // now store the exact values on the boundaries        
  //---------------------------------------------------------------------

  //---------------------------------------------------------------------
  // west face                                                  
  //---------------------------------------------------------------------
  i = 0;
  xi = 0.0;
  for (k = 0; k <= grid_points[2]-1; k++) {
    zeta = (double)(k) * dnzm1;
    for (j = 0; j <= grid_points[1]-1; j++) {
      eta = (double)(j) * dnym1;
      exact_solution(xi, eta, zeta, temp);
      for (m = 0; m < 5; m++) {
        u[m][k][j][i] = temp[m];
      }
    }
  }

  //---------------------------------------------------------------------
  // east face                                                      
  //---------------------------------------------------------------------
  i = grid_points[0]-1;
  xi = 1.0;
  for (k = 0; k <= grid_points[2]-1; k++) {
    zeta = (double)(k) * dnzm1;
    for (j = 0; j <= grid_points[1]-1; j++) {
      eta = (double)(j) * dnym1;
      exact_solution(xi, eta, zeta, temp);
      for (m = 0; m < 5; m++) {
        u[m][k][j][i] = temp[m];
      }
    }
  }

  //---------------------------------------------------------------------
  // south face                                                 
  //---------------------------------------------------------------------
  j = 0;
  eta = 0.0;
  for (k = 0; k <= grid_points[2]-1; k++) {
    zeta = (double)(k) * dnzm1;
    for (i = 0; i <= grid_points[0]-1; i++) {
      xi = (double)(i) * dnxm1;
      exact_solution(xi, eta, zeta, temp);
      for (m = 0; m < 5; m++) {
        u[m][k][j][i] = temp[m];
      }
    }
  }

  //---------------------------------------------------------------------
  // north face                                    
  //---------------------------------------------------------------------
  j = grid_points[1]-1;
  eta = 1.0;
  for (k = 0; k <= grid_points[2]-1; k++) {
    zeta = (double)(k) * dnzm1;
    for (i = 0; i <= grid_points[0]-1; i++) {
      xi = (double)(i) * dnxm1;
      exact_solution(xi, eta, zeta, temp);
      for (m = 0; m < 5; m++) {
        u[m][k][j][i] = temp[m];
      }
    }
  }

  //---------------------------------------------------------------------
  // bottom face                                       
  //---------------------------------------------------------------------
  k = 0;
  zeta = 0.0;
  for (j = 0; j <= grid_points[1]-1; j++) {
    eta = (double)(j) * dnym1;
    for (i =0; i <= grid_points[0]-1; i++) {
      xi = (double)(i) *dnxm1;
      exact_solution(xi, eta, zeta, temp);
      for (m = 0; m < 5; m++) {
        u[m][k][j][i] = temp[m];
      }
    }
  }

  //---------------------------------------------------------------------
  // top face     
  //---------------------------------------------------------------------
  k = grid_points[2]-1;
  zeta = 1.0;
  for (j = 0; j <= grid_points[1]-1; j++) {
    eta = (double)(j) * dnym1;
    for (i = 0; i <= grid_points[0]-1; i++) {
      xi = (double)(i) * dnxm1;
      exact_solution(xi, eta, zeta, temp);
      for (m = 0; m < 5; m++) {
        u[m][k][j][i] = temp[m];
      }
    }
  }

  #pragma acc update device(u)
}


########## NEXT FILE ##########
rhs.c:::
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB BT code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS BT code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

#include "header.h"
//#include "timers.h"
#include<stdio.h>

void compute_rhs()
{
  int i, j, k, m;
  double rho_inv, uijk, up1, um1, vijk, vp1, vm1, wijk, wp1, wm1;
  int gp0, gp1, gp2;
  int gp01,gp11,gp21;
  int gp02,gp12,gp22;

  gp0 = grid_points[0];
  gp1 = grid_points[1];
  gp2 = grid_points[2];
  gp01 = grid_points[0]-1;
  gp11 = grid_points[1]-1;
  gp21 = grid_points[2]-1;
  gp02 = grid_points[0]-2;
  gp12 = grid_points[1]-2;
  gp22 = grid_points[2]-2;

  //  printf("gp01=%d, gp11=%d\n", gp01, gp11);
  //  printf("gp21=%d, gp02=%d\n", gp21, gp02);
  //  printf("gp12=%d, gp22=%d\n", gp12, gp22);

  //---------------------------------------------------------------------
  // compute the reciprocal of density, and the kinetic energy, 
  // and the speed of sound.
  //---------------------------------------------------------------------
#pragma acc data present(forcing,rho_i,u,us,vs,ws,square,qs,rhs) 
{
 #pragma acc parallel loop gang num_gangs(192) num_workers(16) vector_length(32)
  for (k = 0; k <= gp21; k++) {
    #pragma acc loop worker
    for (j = 0; j <= gp11; j++) {
	  #pragma acc loop vector
      for (i = 0; i <= gp01; i++) {
        rho_inv = 1.0/u[0][k][j][i];
        rho_i[k][j][i] = rho_inv;
        us[k][j][i] = u[1][k][j][i] * rho_inv;
        vs[k][j][i] = u[2][k][j][i] * rho_inv;
        ws[k][j][i] = u[3][k][j][i] * rho_inv;
        square[k][j][i] = 0.5* (
            u[1][k][j][i]*u[1][k][j][i] + 
            u[2][k][j][i]*u[2][k][j][i] +
            u[3][k][j][i]*u[3][k][j][i] ) * rho_inv;
        qs[k][j][i] = square[k][j][i] * rho_inv;
      }
    }
  }

  //---------------------------------------------------------------------
  // copy the exact forcingterm to the right hand side;  because 
  // this forcingterm is known, we can store it on the whole grid
  // including the boundary                   
  //---------------------------------------------------------------------
  #pragma acc  parallel loop gang num_gangs(192) num_workers(16) vector_length(32)
  for (k = 0; k <= gp21; k++) {
    #pragma acc loop worker
    for (j = 0; j <= gp11; j++) {
	  #pragma acc loop vector
      for (i = 0; i <= gp01; i++) {
          rhs[0][k][j][i] = forcing[0][k][j][i];
          rhs[1][k][j][i] = forcing[1][k][j][i];
          rhs[2][k][j][i] = forcing[2][k][j][i];
          rhs[3][k][j][i] = forcing[3][k][j][i];
          rhs[4][k][j][i] = forcing[4][k][j][i];
      }
    }
  }

  //---------------------------------------------------------------------
  // compute xi-direction fluxes 
  //---------------------------------------------------------------------
  #pragma acc  parallel loop gang num_gangs(192) num_workers(16) vector_length(32)
  for (k = 1; k <= gp22; k++) {
    #pragma acc loop worker
    for (j = 1; j <= gp12; j++) {
	  #pragma acc loop vector
      for (i = 1; i <= gp02; i++) {
        uijk = us[k][j][i];
        up1  = us[k][j][i+1];
        um1  = us[k][j][i-1];

        rhs[0][k][j][i] = rhs[0][k][j][i] + dx1tx1 * 
          (u[0][k][j][i+1] - 2.0*u[0][k][j][i] + 
           u[0][k][j][i-1]) -
          tx2 * (u[1][k][j][i+1] - u[1][k][j][i-1]);

        rhs[1][k][j][i] = rhs[1][k][j][i] + dx2tx1 * 
          (u[1][k][j][i+1] - 2.0*u[1][k][j][i] + 
           u[1][k][j][i-1]) +
          xxcon2*con43 * (up1 - 2.0*uijk + um1) -
          tx2 * (u[1][k][j][i+1]*up1 - 
              u[1][k][j][i-1]*um1 +
              (u[4][k][j][i+1]- square[k][j][i+1]-
               u[4][k][j][i-1]+ square[k][j][i-1])*
              c2);

        rhs[2][k][j][i] = rhs[2][k][j][i] + dx3tx1 * 
          (u[2][k][j][i+1] - 2.0*u[2][k][j][i] +
           u[2][k][j][i-1]) +
          xxcon2 * (vs[k][j][i+1] - 2.0*vs[k][j][i] +
              vs[k][j][i-1]) -
          tx2 * (u[2][k][j][i+1]*up1 - 
              u[2][k][j][i-1]*um1);

        rhs[3][k][j][i] = rhs[3][k][j][i] + dx4tx1 * 
          (u[3][k][j][i+1] - 2.0*u[3][k][j][i] +
           u[3][k][j][i-1]) +
          xxcon2 * (ws[k][j][i+1] - 2.0*ws[k][j][i] +
              ws[k][j][i-1]) -
          tx2 * (u[3][k][j][i+1]*up1 - 
              u[3][k][j][i-1]*um1);

        rhs[4][k][j][i] = rhs[4][k][j][i] + dx5tx1 * 
          (u[4][k][j][i+1] - 2.0*u[4][k][j][i] +
           u[4][k][j][i-1]) +
          xxcon3 * (qs[k][j][i+1] - 2.0*qs[k][j][i] +
              qs[k][j][i-1]) +
          xxcon4 * (up1*up1 -       2.0*uijk*uijk + 
              um1*um1) +
          xxcon5 * (u[4][k][j][i+1]*rho_i[k][j][i+1] - 
              2.0*u[4][k][j][i]*rho_i[k][j][i] +
              u[4][k][j][i-1]*rho_i[k][j][i-1]) -
          tx2 * ( (c1*u[4][k][j][i+1] - 
                c2*square[k][j][i+1])*up1 -
              (c1*u[4][k][j][i-1] - 
               c2*square[k][j][i-1])*um1 );
      }
    }
  }
    //---------------------------------------------------------------------
    // add fourth order xi-direction dissipation               
    //---------------------------------------------------------------------
  #pragma acc  parallel loop gang num_gangs(192) num_workers(16) vector_length(32)
  for (k = 1; k <= gp22; k++) {
    #pragma acc loop worker vector
    for (j = 1; j <= gp12; j++) {
      	i = 1;
        rhs[0][k][j][i] = rhs[0][k][j][i]- dssp * 
          ( 5.0*u[0][k][j][i] - 4.0*u[0][k][j][i+1] +
            u[0][k][j][i+2]);
        rhs[1][k][j][i] = rhs[1][k][j][i]- dssp * 
          ( 5.0*u[1][k][j][i] - 4.0*u[1][k][j][i+1] +
            u[1][k][j][i+2]);
        rhs[2][k][j][i] = rhs[2][k][j][i]- dssp * 
          ( 5.0*u[2][k][j][i] - 4.0*u[2][k][j][i+1] +
            u[2][k][j][i+2]);
        rhs[3][k][j][i] = rhs[3][k][j][i]- dssp * 
          ( 5.0*u[3][k][j][i] - 4.0*u[3][k][j][i+1] +
            u[3][k][j][i+2]);
        rhs[4][k][j][i] = rhs[4][k][j][i]- dssp * 
          ( 5.0*u[4][k][j][i] - 4.0*u[4][k][j][i+1] +
            u[4][k][j][i+2]);

      	i = 2;
        rhs[0][k][j][i] = rhs[0][k][j][i] - dssp * 
          (-4.0*u[0][k][j][i-1] + 6.0*u[0][k][j][i] -
           4.0*u[0][k][j][i+1] + u[0][k][j][i+2]);
        rhs[1][k][j][i] = rhs[1][k][j][i] - dssp * 
          (-4.0*u[1][k][j][i-1] + 6.0*u[1][k][j][i] -
           4.0*u[1][k][j][i+1] + u[1][k][j][i+2]);
        rhs[2][k][j][i] = rhs[2][k][j][i] - dssp * 
          (-4.0*u[2][k][j][i-1] + 6.0*u[2][k][j][i] -
           4.0*u[2][k][j][i+1] + u[2][k][j][i+2]);
        rhs[3][k][j][i] = rhs[3][k][j][i] - dssp * 
          (-4.0*u[3][k][j][i-1] + 6.0*u[3][k][j][i] -
           4.0*u[3][k][j][i+1] + u[3][k][j][i+2]);
        rhs[4][k][j][i] = rhs[4][k][j][i] - dssp * 
          (-4.0*u[4][k][j][i-1] + 6.0*u[4][k][j][i] -
           4.0*u[4][k][j][i+1] + u[4][k][j][i+2]);
    }
  }
  
  #pragma acc parallel loop gang num_gangs(192) num_workers(16) vector_length(32)
  for (k = 1; k <= gp22; k++) {
    #pragma acc loop worker
    for (j = 1; j <= gp12; j++) {
	  #pragma acc loop vector
      for (i = 3; i <= gp02-2; i++) {
          rhs[0][k][j][i] = rhs[0][k][j][i] - dssp*
		    (  u[0][k][j][i-2] - 4.0*u[0][k][j][i-1] + 
               6.0*u[0][k][j][i] - 4.0*u[0][k][j][i+1] + 
               u[0][k][j][i+2] );
          rhs[1][k][j][i] = rhs[1][k][j][i] - dssp*
		    (  u[1][k][j][i-2] - 4.0*u[1][k][j][i-1] + 
               6.0*u[1][k][j][i] - 4.0*u[1][k][j][i+1] + 
               u[1][k][j][i+2] );
          rhs[2][k][j][i] = rhs[2][k][j][i] - dssp*
		    (  u[2][k][j][i-2] - 4.0*u[2][k][j][i-1] + 
               6.0*u[2][k][j][i] - 4.0*u[2][k][j][i+1] + 
               u[2][k][j][i+2] );
          rhs[3][k][j][i] = rhs[3][k][j][i] - dssp*
		    (  u[3][k][j][i-2] - 4.0*u[3][k][j][i-1] + 
               6.0*u[3][k][j][i] - 4.0*u[3][k][j][i+1] + 
               u[3][k][j][i+2] );
          rhs[4][k][j][i] = rhs[4][k][j][i] - dssp*
		    (  u[4][k][j][i-2] - 4.0*u[4][k][j][i-1] + 
               6.0*u[4][k][j][i] - 4.0*u[4][k][j][i+1] + 
               u[4][k][j][i+2] );
      }
    }
  }
  
  #pragma acc parallel loop gang num_gangs(192) num_workers(16) vector_length(32) 
  for (k = 1; k <= gp22; k++) {
    #pragma acc loop worker vector
    for (j = 1; j <= gp12; j++) {
      	i = gp0-3;
        rhs[0][k][j][i] = rhs[0][k][j][i] - dssp *
          ( u[0][k][j][i-2] - 4.0*u[0][k][j][i-1] + 
            6.0*u[0][k][j][i] - 4.0*u[0][k][j][i+1] );
        rhs[1][k][j][i] = rhs[1][k][j][i] - dssp *
          ( u[1][k][j][i-2] - 4.0*u[1][k][j][i-1] + 
            6.0*u[1][k][j][i] - 4.0*u[1][k][j][i+1] );
        rhs[2][k][j][i] = rhs[2][k][j][i] - dssp *
          ( u[2][k][j][i-2] - 4.0*u[2][k][j][i-1] + 
            6.0*u[2][k][j][i] - 4.0*u[2][k][j][i+1] );
        rhs[3][k][j][i] = rhs[3][k][j][i] - dssp *
          ( u[3][k][j][i-2] - 4.0*u[3][k][j][i-1] + 
            6.0*u[3][k][j][i] - 4.0*u[3][k][j][i+1] );
        rhs[4][k][j][i] = rhs[4][k][j][i] - dssp *
          ( u[4][k][j][i-2] - 4.0*u[4][k][j][i-1] + 
            6.0*u[4][k][j][i] - 4.0*u[4][k][j][i+1] );

      	i = gp02;
        rhs[0][k][j][i] = rhs[0][k][j][i] - dssp *
          ( u[0][k][j][i-2] - 4.*u[0][k][j][i-1] +
            5.*u[0][k][j][i] );
        rhs[1][k][j][i] = rhs[1][k][j][i] - dssp *
          ( u[1][k][j][i-2] - 4.*u[1][k][j][i-1] +
            5.*u[1][k][j][i] );
        rhs[2][k][j][i] = rhs[2][k][j][i] - dssp *
          ( u[2][k][j][i-2] - 4.*u[2][k][j][i-1] +
            5.*u[2][k][j][i] );
        rhs[3][k][j][i] = rhs[3][k][j][i] - dssp *
          ( u[3][k][j][i-2] - 4.*u[3][k][j][i-1] +
            5.*u[3][k][j][i] );
        rhs[4][k][j][i] = rhs[4][k][j][i] - dssp *
          ( u[4][k][j][i-2] - 4.*u[4][k][j][i-1] +
            5.*u[4][k][j][i] );
    }
  }

  //---------------------------------------------------------------------
  // compute eta-direction fluxes 
  //---------------------------------------------------------------------
  #pragma acc parallel loop gang num_gangs(192) num_workers(16) vector_length(32)
  for (k = 1; k <= gp22; k++) {
    #pragma acc loop worker
    for (j = 1; j <= gp12; j++) {
	  #pragma acc loop vector
      for (i = 1; i <= gp02; i++) {
        vijk = vs[k][j][i];
        vp1  = vs[k][j+1][i];
        vm1  = vs[k][j-1][i];
        rhs[0][k][j][i] = rhs[0][k][j][i] + dy1ty1 * 
          (u[0][k][j+1][i] - 2.0*u[0][k][j][i] + 
           u[0][k][j-1][i]) -
          ty2 * (u[2][k][j+1][i] - u[2][k][j-1][i]);
        rhs[1][k][j][i] = rhs[1][k][j][i] + dy2ty1 * 
          (u[1][k][j+1][i] - 2.0*u[1][k][j][i] + 
           u[1][k][j-1][i]) +
          yycon2 * (us[k][j+1][i] - 2.0*us[k][j][i] + 
              us[k][j-1][i]) -
          ty2 * (u[1][k][j+1][i]*vp1 - 
              u[1][k][j-1][i]*vm1);
        rhs[2][k][j][i] = rhs[2][k][j][i] + dy3ty1 * 
          (u[2][k][j+1][i] - 2.0*u[2][k][j][i] + 
           u[2][k][j-1][i]) +
          yycon2*con43 * (vp1 - 2.0*vijk + vm1) -
          ty2 * (u[2][k][j+1][i]*vp1 - 
              u[2][k][j-1][i]*vm1 +
              (u[4][k][j+1][i] - square[k][j+1][i] - 
               u[4][k][j-1][i] + square[k][j-1][i])
              *c2);
        rhs[3][k][j][i] = rhs[3][k][j][i] + dy4ty1 * 
          (u[3][k][j+1][i] - 2.0*u[3][k][j][i] + 
           u[3][k][j-1][i]) +
          yycon2 * (ws[k][j+1][i] - 2.0*ws[k][j][i] + 
              ws[k][j-1][i]) -
          ty2 * (u[3][k][j+1][i]*vp1 - 
              u[3][k][j-1][i]*vm1);
        rhs[4][k][j][i] = rhs[4][k][j][i] + dy5ty1 * 
          (u[4][k][j+1][i] - 2.0*u[4][k][j][i] + 
           u[4][k][j-1][i]) +
          yycon3 * (qs[k][j+1][i] - 2.0*qs[k][j][i] + 
              qs[k][j-1][i]) +
          yycon4 * (vp1*vp1       - 2.0*vijk*vijk + 
              vm1*vm1) +
          yycon5 * (u[4][k][j+1][i]*rho_i[k][j+1][i] - 
              2.0*u[4][k][j][i]*rho_i[k][j][i] +
              u[4][k][j-1][i]*rho_i[k][j-1][i]) -
          ty2 * ((c1*u[4][k][j+1][i] - 
                c2*square[k][j+1][i]) * vp1 -
              (c1*u[4][k][j-1][i] - 
               c2*square[k][j-1][i]) * vm1);
      }
    }
  }
    //---------------------------------------------------------------------
    // add fourth order eta-direction dissipation         
    //---------------------------------------------------------------------
  #pragma acc parallel loop gang num_gangs(192) num_workers(16) vector_length(32)
  for (k = 1; k <= gp22; k++) {
    #pragma acc loop worker vector
    for (i = 1; i <= gp02; i++) {
    	j = 1;
        
		rhs[0][k][j][i] = rhs[0][k][j][i]- dssp * 
          ( 5.0*u[0][k][j][i] - 4.0*u[0][k][j+1][i] +
            u[0][k][j+2][i]);
        rhs[1][k][j][i] = rhs[1][k][j][i]- dssp * 
          ( 5.0*u[1][k][j][i] - 4.0*u[1][k][j+1][i] +
            u[1][k][j+2][i]);
        rhs[2][k][j][i] = rhs[2][k][j][i]- dssp * 
          ( 5.0*u[2][k][j][i] - 4.0*u[2][k][j+1][i] +
            u[2][k][j+2][i]);
        rhs[3][k][j][i] = rhs[3][k][j][i]- dssp * 
          ( 5.0*u[3][k][j][i] - 4.0*u[3][k][j+1][i] +
            u[3][k][j+2][i]);
        rhs[4][k][j][i] = rhs[4][k][j][i]- dssp * 
          ( 5.0*u[4][k][j][i] - 4.0*u[4][k][j+1][i] +
            u[4][k][j+2][i]);

    	j = 2;
        rhs[0][k][j][i] = rhs[0][k][j][i] - dssp * 
          (-4.0*u[0][k][j-1][i] + 6.0*u[0][k][j][i] -
           4.0*u[0][k][j+1][i] + u[0][k][j+2][i]);
        rhs[1][k][j][i] = rhs[1][k][j][i] - dssp * 
          (-4.0*u[1][k][j-1][i] + 6.0*u[1][k][j][i] -
           4.0*u[1][k][j+1][i] + u[1][k][j+2][i]);
        rhs[2][k][j][i] = rhs[2][k][j][i] - dssp * 
          (-4.0*u[2][k][j-1][i] + 6.0*u[2][k][j][i] -
           4.0*u[2][k][j+1][i] + u[2][k][j+2][i]);
        rhs[3][k][j][i] = rhs[3][k][j][i] - dssp * 
          (-4.0*u[3][k][j-1][i] + 6.0*u[3][k][j][i] -
           4.0*u[3][k][j+1][i] + u[3][k][j+2][i]);
        rhs[4][k][j][i] = rhs[4][k][j][i] - dssp * 
          (-4.0*u[4][k][j-1][i] + 6.0*u[4][k][j][i] -
           4.0*u[4][k][j+1][i] + u[4][k][j+2][i]);
    }
  }
  
  #pragma acc parallel loop gang num_gangs(192) num_workers(16) vector_length(32)
  for (k = 1; k <= gp22; k++) {
    #pragma acc loop worker
    for (j = 3; j <= gp1-4; j++) {
	  #pragma acc loop vector
      for (i = 1; i <= gp02; i++) {
          rhs[0][k][j][i] = rhs[0][k][j][i] - dssp * 
            (  u[0][k][j-2][i] - 4.0*u[0][k][j-1][i] + 
               6.0*u[0][k][j][i] - 4.0*u[0][k][j+1][i] + 
               u[0][k][j+2][i] );
          rhs[1][k][j][i] = rhs[1][k][j][i] - dssp * 
            (  u[1][k][j-2][i] - 4.0*u[1][k][j-1][i] + 
               6.0*u[1][k][j][i] - 4.0*u[1][k][j+1][i] + 
               u[1][k][j+2][i] );
          rhs[2][k][j][i] = rhs[2][k][j][i] - dssp * 
            (  u[2][k][j-2][i] - 4.0*u[2][k][j-1][i] + 
               6.0*u[2][k][j][i] - 4.0*u[2][k][j+1][i] + 
               u[2][k][j+2][i] );
          rhs[3][k][j][i] = rhs[3][k][j][i] - dssp * 
            (  u[3][k][j-2][i] - 4.0*u[3][k][j-1][i] + 
               6.0*u[3][k][j][i] - 4.0*u[3][k][j+1][i] + 
               u[3][k][j+2][i] );
          rhs[4][k][j][i] = rhs[4][k][j][i] - dssp * 
            (  u[4][k][j-2][i] - 4.0*u[4][k][j-1][i] + 
               6.0*u[4][k][j][i] - 4.0*u[4][k][j+1][i] + 
               u[4][k][j+2][i] );
      }
    }
  }

  #pragma acc parallel loop gang num_gangs(192) num_workers(16) vector_length(32)
  for (k = 1; k <= gp22; k++) {
    #pragma acc loop worker vector
    for (i = 1; i <= gp02; i++) {
		j = gp1-3;
        rhs[0][k][j][i] = rhs[0][k][j][i] - dssp *
          ( u[0][k][j-2][i] - 4.0*u[0][k][j-1][i] + 
            6.0*u[0][k][j][i] - 4.0*u[0][k][j+1][i] );
        rhs[1][k][j][i] = rhs[1][k][j][i] - dssp *
          ( u[1][k][j-2][i] - 4.0*u[1][k][j-1][i] + 
            6.0*u[1][k][j][i] - 4.0*u[1][k][j+1][i] );
        rhs[2][k][j][i] = rhs[2][k][j][i] - dssp *
          ( u[2][k][j-2][i] - 4.0*u[2][k][j-1][i] + 
            6.0*u[2][k][j][i] - 4.0*u[2][k][j+1][i] );
        rhs[3][k][j][i] = rhs[3][k][j][i] - dssp *
          ( u[3][k][j-2][i] - 4.0*u[3][k][j-1][i] + 
            6.0*u[3][k][j][i] - 4.0*u[3][k][j+1][i] );
        rhs[4][k][j][i] = rhs[4][k][j][i] - dssp *
          ( u[4][k][j-2][i] - 4.0*u[4][k][j-1][i] + 
            6.0*u[4][k][j][i] - 4.0*u[4][k][j+1][i] );
    
		j = gp12;
        rhs[0][k][j][i] = rhs[0][k][j][i] - dssp *
          ( u[0][k][j-2][i] - 4.*u[0][k][j-1][i] +
            5.*u[0][k][j][i] );
        rhs[1][k][j][i] = rhs[1][k][j][i] - dssp *
          ( u[1][k][j-2][i] - 4.*u[1][k][j-1][i] +
            5.*u[1][k][j][i] );
        rhs[2][k][j][i] = rhs[2][k][j][i] - dssp *
          ( u[2][k][j-2][i] - 4.*u[2][k][j-1][i] +
            5.*u[2][k][j][i] );
        rhs[3][k][j][i] = rhs[3][k][j][i] - dssp *
          ( u[3][k][j-2][i] - 4.*u[3][k][j-1][i] +
            5.*u[3][k][j][i] );
        rhs[4][k][j][i] = rhs[4][k][j][i] - dssp *
          ( u[4][k][j-2][i] - 4.*u[4][k][j-1][i] +
            5.*u[4][k][j][i] );
    }
  }
  
  //---------------------------------------------------------------------
  // compute zeta-direction fluxes 
  //---------------------------------------------------------------------
  #pragma acc parallel loop gang num_gangs(192) num_workers(16) vector_length(32)
  for (k = 1; k <= gp22; k++) {
   #pragma acc loop worker
    for (j = 1; j <= gp12; j++) {
	  #pragma acc loop vector
      for (i = 1; i <= gp02; i++) {
        wijk = ws[k][j][i];
        wp1  = ws[k+1][j][i];
        wm1  = ws[k-1][j][i];

        rhs[0][k][j][i] = rhs[0][k][j][i] + dz1tz1 * 
          (u[0][k+1][j][i] - 2.0*u[0][k][j][i] + 
           u[0][k-1][j][i]) -
          tz2 * (u[3][k+1][j][i] - u[3][k-1][j][i]);
        rhs[1][k][j][i] = rhs[1][k][j][i] + dz2tz1 * 
          (u[1][k+1][j][i] - 2.0*u[1][k][j][i] + 
           u[1][k-1][j][i]) +
          zzcon2 * (us[k+1][j][i] - 2.0*us[k][j][i] + 
              us[k-1][j][i]) -
          tz2 * (u[1][k+1][j][i]*wp1 - 
              u[1][k-1][j][i]*wm1);
        rhs[2][k][j][i] = rhs[2][k][j][i] + dz3tz1 * 
          (u[2][k+1][j][i] - 2.0*u[2][k][j][i] + 
           u[2][k-1][j][i]) +
          zzcon2 * (vs[k+1][j][i] - 2.0*vs[k][j][i] + 
              vs[k-1][j][i]) -
          tz2 * (u[2][k+1][j][i]*wp1 - 
              u[2][k-1][j][i]*wm1);
        rhs[3][k][j][i] = rhs[3][k][j][i] + dz4tz1 * 
          (u[3][k+1][j][i] - 2.0*u[3][k][j][i] + 
           u[3][k-1][j][i]) +
          zzcon2*con43 * (wp1 - 2.0*wijk + wm1) -
          tz2 * (u[3][k+1][j][i]*wp1 - 
              u[3][k-1][j][i]*wm1 +
              (u[4][k+1][j][i] - square[k+1][j][i] - 
               u[4][k-1][j][i] + square[k-1][j][i])
              *c2);
        rhs[4][k][j][i] = rhs[4][k][j][i] + dz5tz1 * 
          (u[4][k+1][j][i] - 2.0*u[4][k][j][i] + 
           u[4][k-1][j][i]) +
          zzcon3 * (qs[k+1][j][i] - 2.0*qs[k][j][i] + 
              qs[k-1][j][i]) +
          zzcon4 * (wp1*wp1 - 2.0*wijk*wijk + 
              wm1*wm1) +
          zzcon5 * (u[4][k+1][j][i]*rho_i[k+1][j][i] - 
              2.0*u[4][k][j][i]*rho_i[k][j][i] +
              u[4][k-1][j][i]*rho_i[k-1][j][i]) -
          tz2 * ( (c1*u[4][k+1][j][i] - 
                c2*square[k+1][j][i])*wp1 -
              (c1*u[4][k-1][j][i] - 
               c2*square[k-1][j][i])*wm1);
      }
    }
  }
  //---------------------------------------------------------------------
  // add fourth order zeta-direction dissipation                
  //---------------------------------------------------------------------
  #pragma acc parallel loop gang num_gangs(192) num_workers(16) vector_length(32)
  for (j = 1; j <= gp12; j++) {
    #pragma acc loop worker vector
    for (i = 1; i <= gp02; i++) {
  		k = 1;
        rhs[0][k][j][i] = rhs[0][k][j][i]- dssp * 
          ( 5.0*u[0][k][j][i] - 4.0*u[0][k+1][j][i] +
            u[0][k+2][j][i]);
        rhs[1][k][j][i] = rhs[1][k][j][i]- dssp * 
          ( 5.0*u[1][k][j][i] - 4.0*u[1][k+1][j][i] +
            u[1][k+2][j][i]);
        rhs[2][k][j][i] = rhs[2][k][j][i]- dssp * 
          ( 5.0*u[2][k][j][i] - 4.0*u[2][k+1][j][i] +
            u[2][k+2][j][i]);
        rhs[3][k][j][i] = rhs[3][k][j][i]- dssp * 
          ( 5.0*u[3][k][j][i] - 4.0*u[3][k+1][j][i] +
            u[3][k+2][j][i]);
        rhs[4][k][j][i] = rhs[4][k][j][i]- dssp * 
          ( 5.0*u[4][k][j][i] - 4.0*u[4][k+1][j][i] +
            u[4][k+2][j][i]);
  		
		k = 2;
        rhs[0][k][j][i] = rhs[0][k][j][i] - dssp * 
          (-4.0*u[0][k-1][j][i] + 6.0*u[0][k][j][i] -
           4.0*u[0][k+1][j][i] + u[0][k+2][j][i]);
        rhs[1][k][j][i] = rhs[1][k][j][i] - dssp * 
          (-4.0*u[1][k-1][j][i] + 6.0*u[1][k][j][i] -
           4.0*u[1][k+1][j][i] + u[1][k+2][j][i]);
        rhs[2][k][j][i] = rhs[2][k][j][i] - dssp * 
          (-4.0*u[2][k-1][j][i] + 6.0*u[2][k][j][i] -
           4.0*u[2][k+1][j][i] + u[2][k+2][j][i]);
        rhs[3][k][j][i] = rhs[3][k][j][i] - dssp * 
          (-4.0*u[3][k-1][j][i] + 6.0*u[3][k][j][i] -
           4.0*u[3][k+1][j][i] + u[3][k+2][j][i]);
        rhs[4][k][j][i] = rhs[4][k][j][i] - dssp * 
          (-4.0*u[4][k-1][j][i] + 6.0*u[4][k][j][i] -
           4.0*u[4][k+1][j][i] + u[4][k+2][j][i]);
    }
  }

  #pragma acc parallel loop gang num_gangs(192) num_workers(16) vector_length(32)
  for (k = 3; k <= gp2-4; k++) {
    #pragma acc loop worker
    for (j = 1; j <= gp12; j++) {
	  #pragma acc loop vector
      for (i = 1; i <= gp02; i++) {
          rhs[0][k][j][i] = rhs[0][k][j][i] - dssp * 
            (  u[0][k-2][j][i] - 4.0*u[0][k-1][j][i] + 
               6.0*u[0][k][j][i] - 4.0*u[0][k+1][j][i] + 
               u[0][k+2][j][i] );
          rhs[1][k][j][i] = rhs[1][k][j][i] - dssp * 
            (  u[1][k-2][j][i] - 4.0*u[1][k-1][j][i] + 
               6.0*u[1][k][j][i] - 4.0*u[1][k+1][j][i] + 
               u[1][k+2][j][i] );
          rhs[2][k][j][i] = rhs[2][k][j][i] - dssp * 
            (  u[2][k-2][j][i] - 4.0*u[2][k-1][j][i] + 
               6.0*u[2][k][j][i] - 4.0*u[2][k+1][j][i] + 
               u[2][k+2][j][i] );
          rhs[3][k][j][i] = rhs[3][k][j][i] - dssp * 
            (  u[3][k-2][j][i] - 4.0*u[3][k-1][j][i] + 
               6.0*u[3][k][j][i] - 4.0*u[3][k+1][j][i] + 
               u[3][k+2][j][i] );
          rhs[4][k][j][i] = rhs[4][k][j][i] - dssp * 
            (  u[4][k-2][j][i] - 4.0*u[4][k-1][j][i] + 
               6.0*u[4][k][j][i] - 4.0*u[4][k+1][j][i] + 
               u[4][k+2][j][i] );
      }
    }
  }

  #pragma acc parallel loop gang num_gangs(192) num_workers(16) vector_length(32)
  for (j = 1; j <= gp12; j++) {
    #pragma acc loop worker vector
    for (i = 1; i <= gp02; i++) {
		k = gp2-3;
        rhs[0][k][j][i] = rhs[0][k][j][i] - dssp *
          ( u[0][k-2][j][i] - 4.0*u[0][k-1][j][i] + 
            6.0*u[0][k][j][i] - 4.0*u[0][k+1][j][i] );
        rhs[1][k][j][i] = rhs[1][k][j][i] - dssp *
          ( u[1][k-2][j][i] - 4.0*u[1][k-1][j][i] + 
            6.0*u[1][k][j][i] - 4.0*u[1][k+1][j][i] );
        rhs[2][k][j][i] = rhs[2][k][j][i] - dssp *
          ( u[2][k-2][j][i] - 4.0*u[2][k-1][j][i] + 
            6.0*u[2][k][j][i] - 4.0*u[2][k+1][j][i] );
        rhs[3][k][j][i] = rhs[3][k][j][i] - dssp *
          ( u[3][k-2][j][i] - 4.0*u[3][k-1][j][i] + 
            6.0*u[3][k][j][i] - 4.0*u[3][k+1][j][i] );
        rhs[4][k][j][i] = rhs[4][k][j][i] - dssp *
          ( u[4][k-2][j][i] - 4.0*u[4][k-1][j][i] + 
            6.0*u[4][k][j][i] - 4.0*u[4][k+1][j][i] );
  
  		k = gp22;
        rhs[0][k][j][i] = rhs[0][k][j][i] - dssp *
          ( u[0][k-2][j][i] - 4.*u[0][k-1][j][i] +
            5.*u[0][k][j][i] );
        rhs[1][k][j][i] = rhs[1][k][j][i] - dssp *
          ( u[1][k-2][j][i] - 4.*u[1][k-1][j][i] +
            5.*u[1][k][j][i] );
        rhs[2][k][j][i] = rhs[2][k][j][i] - dssp *
          ( u[2][k-2][j][i] - 4.*u[2][k-1][j][i] +
            5.*u[2][k][j][i] );
        rhs[3][k][j][i] = rhs[3][k][j][i] - dssp *
          ( u[3][k-2][j][i] - 4.*u[3][k-1][j][i] +
            5.*u[3][k][j][i] );
        rhs[4][k][j][i] = rhs[4][k][j][i] - dssp *
          ( u[4][k-2][j][i] - 4.*u[4][k-1][j][i] +
            5.*u[4][k][j][i] );
    }
  }


  #pragma acc parallel loop gang num_gangs(192) num_workers(16) vector_length(32)
  for (k = 1; k <= gp22; k++) {
    #pragma acc loop worker
    for (j = 1; j <= gp12; j++) {
	  #pragma acc loop vector
      for (i = 1; i <= gp02; i++) {
          rhs[0][k][j][i] = rhs[0][k][j][i] * dt;
          rhs[1][k][j][i] = rhs[1][k][j][i] * dt;
          rhs[2][k][j][i] = rhs[2][k][j][i] * dt;
          rhs[3][k][j][i] = rhs[3][k][j][i] * dt;
          rhs[4][k][j][i] = rhs[4][k][j][i] * dt;
      }
    }
  }

}/*end acc data*/
}

########## NEXT FILE ##########
x_solve.c:::
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB BT code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS BT code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

#include "header.h"
//#include "timers.h"
#include <stdio.h>

//---------------------------------------------------------------------
// 
// Performs line solves in X direction by first factoring
// the block-tridiagonal matrix into an upper triangular matrix, 
// and then performing back substitution to solve for the unknow
// vectors of each line.  
// 
// Make sure we treat elements zero to cell_size in the direction
// of the sweep.
// 
//---------------------------------------------------------------------
void x_solve()
{
  int i, j, k, m, n, isize, z;
//  double pivot, coeff;
  int gp22, gp12;
//  double temp1, temp2, temp3;

  double fjacX[5][5][PROBLEM_SIZE+1][JMAXP-1][KMAX-1];
  double njacX[5][5][PROBLEM_SIZE+1][JMAXP-1][KMAX-1];
  double lhsX[5][5][3][PROBLEM_SIZE][JMAXP-1][KMAX-1];
  
  double temp1,temp2,temp3,pivot,coeff;
  
  gp22 = grid_points[2]-2;
  gp12 = grid_points[1]-2;

    //printf("gp22=%d, gp12=%d\n", gp22, gp12);
  //---------------------------------------------------------------------
  // This function computes the left hand side in the xi-direction
  //---------------------------------------------------------------------

  isize = grid_points[0]-1;

  //---------------------------------------------------------------------
  // determine a (labeled f) and n jacobians
  //---------------------------------------------------------------------
//#pragma acc data present(rho_i,u,qs,rhs,square,lhsX,fjacX,njacX) 
#pragma acc data present(rho_i,u,qs,rhs,square) create(lhsX,fjacX,njacX) 
{
	  #pragma acc parallel loop gang num_gangs(isize+1) num_workers(8) vector_length(32)
      for (i = 0; i <= isize; i++) {
    #pragma acc loop worker
    for (j = 1; j <= gp12; j++) {
 #pragma acc loop vector
  for (k = 1; k <= gp22; k++) {
        temp1 = rho_i[k][j][i];
        temp2 = temp1 * temp1;
        temp3 = temp1 * temp2;
        //-------------------------------------------------------------------
        // 
        //-------------------------------------------------------------------
        fjacX[0][0][i][j][k] = 0.0;
        fjacX[0][1][i][j][k] = 1.0;
        fjacX[0][2][i][j][k] = 0.0;
        fjacX[0][3][i][j][k] = 0.0;
        fjacX[0][4][i][j][k] = 0.0;

        fjacX[1][0][i][j][k] = -(u[1][k][j][i] * temp2 * u[1][k][j][i])
          + c2 * qs[k][j][i];
        fjacX[1][1][i][j][k] = ( 2.0 - c2 ) * ( u[1][k][j][i] / u[0][k][j][i] );
        fjacX[1][2][i][j][k] = - c2 * ( u[2][k][j][i] * temp1 );
        fjacX[1][3][i][j][k] = - c2 * ( u[3][k][j][i] * temp1 );
        fjacX[1][4][i][j][k] = c2;

        fjacX[2][0][i][j][k] = - ( u[1][k][j][i]*u[2][k][j][i] ) * temp2;
        fjacX[2][1][i][j][k] = u[2][k][j][i] * temp1;
        fjacX[2][2][i][j][k] = u[1][k][j][i] * temp1;
        fjacX[2][3][i][j][k] = 0.0;
        fjacX[2][4][i][j][k] = 0.0;

        fjacX[3][0][i][j][k] = - ( u[1][k][j][i]*u[3][k][j][i] ) * temp2;
        fjacX[3][1][i][j][k] = u[3][k][j][i] * temp1;
        fjacX[3][2][i][j][k] = 0.0;
        fjacX[3][3][i][j][k] = u[1][k][j][i] * temp1;
        fjacX[3][4][i][j][k] = 0.0;

        fjacX[4][0][i][j][k] = ( c2 * 2.0 * square[k][j][i] - c1 * u[4][k][j][i] )
          * ( u[1][k][j][i] * temp2 );
        fjacX[4][1][i][j][k] = c1 *  u[4][k][j][i] * temp1 
          - c2 * ( u[1][k][j][i]*u[1][k][j][i] * temp2 + qs[k][j][i] );
        fjacX[4][2][i][j][k] = - c2 * ( u[2][k][j][i]*u[1][k][j][i] ) * temp2;
        fjacX[4][3][i][j][k] = - c2 * ( u[3][k][j][i]*u[1][k][j][i] ) * temp2;
        fjacX[4][4][i][j][k] = c1 * ( u[1][k][j][i] * temp1 );

        njacX[0][0][i][j][k] = 0.0;
        njacX[0][1][i][j][k] = 0.0;
        njacX[0][2][i][j][k] = 0.0;
        njacX[0][3][i][j][k] = 0.0;
        njacX[0][4][i][j][k] = 0.0;

        njacX[1][0][i][j][k] = - con43 * c3c4 * temp2 * u[1][k][j][i];
        njacX[1][1][i][j][k] =   con43 * c3c4 * temp1;
        njacX[1][2][i][j][k] =   0.0;
        njacX[1][3][i][j][k] =   0.0;
        njacX[1][4][i][j][k] =   0.0;

        njacX[2][0][i][j][k] = - c3c4 * temp2 * u[2][k][j][i];
        njacX[2][1][i][j][k] =   0.0;
        njacX[2][2][i][j][k] =   c3c4 * temp1;
        njacX[2][3][i][j][k] =   0.0;
        njacX[2][4][i][j][k] =   0.0;

        njacX[3][0][i][j][k] = - c3c4 * temp2 * u[3][k][j][i];
        njacX[3][1][i][j][k] =   0.0;
        njacX[3][2][i][j][k] =   0.0;
        njacX[3][3][i][j][k] =   c3c4 * temp1;
        njacX[3][4][i][j][k] =   0.0;

        njacX[4][0][i][j][k] = - ( con43 * c3c4
            - c1345 ) * temp3 * (u[1][k][j][i]*u[1][k][j][i])
          - ( c3c4 - c1345 ) * temp3 * (u[2][k][j][i]*u[2][k][j][i])
          - ( c3c4 - c1345 ) * temp3 * (u[3][k][j][i]*u[3][k][j][i])
          - c1345 * temp2 * u[4][k][j][i];

        njacX[4][1][i][j][k] = ( con43 * c3c4
            - c1345 ) * temp2 * u[1][k][j][i];
        njacX[4][2][i][j][k] = ( c3c4 - c1345 ) * temp2 * u[2][k][j][i];
        njacX[4][3][i][j][k] = ( c3c4 - c1345 ) * temp2 * u[3][k][j][i];
        njacX[4][4][i][j][k] = ( c1345 ) * temp1;
      }
	}
  }

      //---------------------------------------------------------------------
      // now jacobians set, so form left hand side in x direction
      //---------------------------------------------------------------------
  //    lhsX[k][j]init(lhsX[k][j], isize);
  // zero the whole left hand side for starters
    #pragma acc parallel loop gang num_gangs(gp12) num_workers(8) vector_length(32)
    for (j = 1; j <= gp12; j++) {
  #pragma acc loop worker vector
  for (k = 1; k <= gp22; k++) {
  		for (n = 0; n < 5; n++) {
		   for (m = 0; m < 5; m++){
      			lhsX[m][n][0][0][j][k] = 0.0;
      			lhsX[m][n][1][0][j][k] = 0.0;
      			lhsX[m][n][2][0][j][k] = 0.0;
      			lhsX[m][n][0][isize][j][k] = 0.0;
      			lhsX[m][n][1][isize][j][k] = 0.0;
      			lhsX[m][n][2][isize][j][k] = 0.0;
      		}
  		}
	}
  }

  // next, set all diagonal values to 1. This is overkill, but convenient
    #pragma acc parallel loop gang num_gangs(gp12) num_workers(8) vector_length(32) 
    for (j = 1; j <= gp12; j++) {
  #pragma acc loop worker vector
  for (k = 1; k <= gp22; k++) {
    		lhsX[0][0][1][0][j][k] = 1.0;
    		lhsX[0][0][1][isize][j][k] = 1.0;
    		lhsX[1][1][1][0][j][k] = 1.0;
    		lhsX[1][1][1][isize][j][k] = 1.0;
    		lhsX[2][2][1][0][j][k] = 1.0;
    		lhsX[2][2][1][isize][j][k] = 1.0;
    		lhsX[3][3][1][0][j][k] = 1.0;
    		lhsX[3][3][1][isize][j][k] = 1.0;
    		lhsX[4][4][1][0][j][k] = 1.0;
    		lhsX[4][4][1][isize][j][k] = 1.0;
	}
  }
  
	   #pragma acc parallel loop gang num_gangs(isize-1) num_workers(8) vector_length(32)
 	   for (i = 1; i <= isize-1; i++) {
    #pragma acc loop worker
    for (j = 1; j <= gp12; j++) {
  #pragma acc loop vector
  for (k = 1; k <= gp22; k++) {
        temp1 = dt * tx1;
        temp2 = dt * tx2;

        lhsX[0][0][AA][i][j][k] = - temp2 * fjacX[0][0][i-1][j][k]
          - temp1 * njacX[0][0][i-1][j][k]
          - temp1 * dx1; 
        lhsX[0][1][AA][i][j][k] = - temp2 * fjacX[0][1][i-1][j][k]
          - temp1 * njacX[0][1][i-1][j][k];
        lhsX[0][2][AA][i][j][k] = - temp2 * fjacX[0][2][i-1][j][k]
          - temp1 * njacX[0][2][i-1][j][k];
        lhsX[0][3][AA][i][j][k] = - temp2 * fjacX[0][3][i-1][j][k]
          - temp1 * njacX[0][3][i-1][j][k];
        lhsX[0][4][AA][i][j][k] = - temp2 * fjacX[0][4][i-1][j][k]
          - temp1 * njacX[0][4][i-1][j][k];

        lhsX[1][0][AA][i][j][k] = - temp2 * fjacX[1][0][i-1][j][k]
          - temp1 * njacX[1][0][i-1][j][k];
        lhsX[1][1][AA][i][j][k] = - temp2 * fjacX[1][1][i-1][j][k]
          - temp1 * njacX[1][1][i-1][j][k]
          - temp1 * dx2;
        lhsX[1][2][AA][i][j][k] = - temp2 * fjacX[1][2][i-1][j][k]
          - temp1 * njacX[1][2][i-1][j][k];
        lhsX[1][3][AA][i][j][k] = - temp2 * fjacX[1][3][i-1][j][k]
          - temp1 * njacX[1][3][i-1][j][k];
        lhsX[1][4][AA][i][j][k] = - temp2 * fjacX[1][4][i-1][j][k]
          - temp1 * njacX[1][4][i-1][j][k];

        lhsX[2][0][AA][i][j][k] = - temp2 * fjacX[2][0][i-1][j][k]
          - temp1 * njacX[2][0][i-1][j][k];
        lhsX[2][1][AA][i][j][k] = - temp2 * fjacX[2][1][i-1][j][k]
          - temp1 * njacX[2][1][i-1][j][k];
        lhsX[2][2][AA][i][j][k] = - temp2 * fjacX[2][2][i-1][j][k]
          - temp1 * njacX[2][2][i-1][j][k]
          - temp1 * dx3;
        lhsX[2][3][AA][i][j][k] = - temp2 * fjacX[2][3][i-1][j][k]
          - temp1 * njacX[2][3][i-1][j][k];
        lhsX[2][4][AA][i][j][k] = - temp2 * fjacX[2][4][i-1][j][k]
          - temp1 * njacX[2][4][i-1][j][k];

        lhsX[3][0][AA][i][j][k] = - temp2 * fjacX[3][0][i-1][j][k]
          - temp1 * njacX[3][0][i-1][j][k];
        lhsX[3][1][AA][i][j][k] = - temp2 * fjacX[3][1][i-1][j][k]
          - temp1 * njacX[3][1][i-1][j][k];
        lhsX[3][2][AA][i][j][k] = - temp2 * fjacX[3][2][i-1][j][k]
          - temp1 * njacX[3][2][i-1][j][k];
        lhsX[3][3][AA][i][j][k] = - temp2 * fjacX[3][3][i-1][j][k]
          - temp1 * njacX[3][3][i-1][j][k]
          - temp1 * dx4;
        lhsX[3][4][AA][i][j][k] = - temp2 * fjacX[3][4][i-1][j][k]
          - temp1 * njacX[3][4][i-1][j][k];

        lhsX[4][0][AA][i][j][k] = - temp2 * fjacX[4][0][i-1][j][k]
          - temp1 * njacX[4][0][i-1][j][k];
        lhsX[4][1][AA][i][j][k] = - temp2 * fjacX[4][1][i-1][j][k]
          - temp1 * njacX[4][1][i-1][j][k];
        lhsX[4][2][AA][i][j][k] = - temp2 * fjacX[4][2][i-1][j][k]
          - temp1 * njacX[4][2][i-1][j][k];
        lhsX[4][3][AA][i][j][k] = - temp2 * fjacX[4][3][i-1][j][k]
          - temp1 * njacX[4][3][i-1][j][k];
        lhsX[4][4][AA][i][j][k] = - temp2 * fjacX[4][4][i-1][j][k]
          - temp1 * njacX[4][4][i-1][j][k]
          - temp1 * dx5;

        lhsX[0][0][BB][i][j][k] = 1.0
          + temp1 * 2.0 * njacX[0][0][i][j][k]
          + temp1 * 2.0 * dx1;
        lhsX[0][1][BB][i][j][k] = temp1 * 2.0 * njacX[0][1][i][j][k];
        lhsX[0][2][BB][i][j][k] = temp1 * 2.0 * njacX[0][2][i][j][k];
        lhsX[0][3][BB][i][j][k] = temp1 * 2.0 * njacX[0][3][i][j][k];
        lhsX[0][4][BB][i][j][k] = temp1 * 2.0 * njacX[0][4][i][j][k];

        lhsX[1][0][BB][i][j][k] = temp1 * 2.0 * njacX[1][0][i][j][k];
        lhsX[1][1][BB][i][j][k] = 1.0
          + temp1 * 2.0 * njacX[1][1][i][j][k]
          + temp1 * 2.0 * dx2;
        lhsX[1][2][BB][i][j][k] = temp1 * 2.0 * njacX[1][2][i][j][k];
        lhsX[1][3][BB][i][j][k] = temp1 * 2.0 * njacX[1][3][i][j][k];
        lhsX[1][4][BB][i][j][k] = temp1 * 2.0 * njacX[1][4][i][j][k];

        lhsX[2][0][BB][i][j][k] = temp1 * 2.0 * njacX[2][0][i][j][k];
        lhsX[2][1][BB][i][j][k] = temp1 * 2.0 * njacX[2][1][i][j][k];
        lhsX[2][2][BB][i][j][k] = 1.0
          + temp1 * 2.0 * njacX[2][2][i][j][k]
          + temp1 * 2.0 * dx3;
        lhsX[2][3][BB][i][j][k] = temp1 * 2.0 * njacX[2][3][i][j][k];
        lhsX[2][4][BB][i][j][k] = temp1 * 2.0 * njacX[2][4][i][j][k];

        lhsX[3][0][BB][i][j][k] = temp1 * 2.0 * njacX[3][0][i][j][k];
        lhsX[3][1][BB][i][j][k] = temp1 * 2.0 * njacX[3][1][i][j][k];
        lhsX[3][2][BB][i][j][k] = temp1 * 2.0 * njacX[3][2][i][j][k];
        lhsX[3][3][BB][i][j][k] = 1.0
          + temp1 * 2.0 * njacX[3][3][i][j][k]
          + temp1 * 2.0 * dx4;
        lhsX[3][4][BB][i][j][k] = temp1 * 2.0 * njacX[3][4][i][j][k];

        lhsX[4][0][BB][i][j][k] = temp1 * 2.0 * njacX[4][0][i][j][k];
        lhsX[4][1][BB][i][j][k] = temp1 * 2.0 * njacX[4][1][i][j][k];
        lhsX[4][2][BB][i][j][k] = temp1 * 2.0 * njacX[4][2][i][j][k];
        lhsX[4][3][BB][i][j][k] = temp1 * 2.0 * njacX[4][3][i][j][k];
        lhsX[4][4][BB][i][j][k] = 1.0
          + temp1 * 2.0 * njacX[4][4][i][j][k]
          + temp1 * 2.0 * dx5;

        lhsX[0][0][CC][i][j][k] =  temp2 * fjacX[0][0][i+1][j][k]
          - temp1 * njacX[0][0][i+1][j][k]
          - temp1 * dx1;
        lhsX[0][1][CC][i][j][k] =  temp2 * fjacX[0][1][i+1][j][k]
          - temp1 * njacX[0][1][i+1][j][k];
        lhsX[0][2][CC][i][j][k] =  temp2 * fjacX[0][2][i+1][j][k]
          - temp1 * njacX[0][2][i+1][j][k];
        lhsX[0][3][CC][i][j][k] =  temp2 * fjacX[0][3][i+1][j][k]
          - temp1 * njacX[0][3][i+1][j][k];
        lhsX[0][4][CC][i][j][k] =  temp2 * fjacX[0][4][i+1][j][k]
          - temp1 * njacX[0][4][i+1][j][k];

        lhsX[1][0][CC][i][j][k] =  temp2 * fjacX[1][0][i+1][j][k]
          - temp1 * njacX[1][0][i+1][j][k];
        lhsX[1][1][CC][i][j][k] =  temp2 * fjacX[1][1][i+1][j][k]
          - temp1 * njacX[1][1][i+1][j][k]
          - temp1 * dx2;
        lhsX[1][2][CC][i][j][k] =  temp2 * fjacX[1][2][i+1][j][k]
          - temp1 * njacX[1][2][i+1][j][k];
        lhsX[1][3][CC][i][j][k] =  temp2 * fjacX[1][3][i+1][j][k]
          - temp1 * njacX[1][3][i+1][j][k];
        lhsX[1][4][CC][i][j][k] =  temp2 * fjacX[1][4][i+1][j][k]
          - temp1 * njacX[1][4][i+1][j][k];

        lhsX[2][0][CC][i][j][k] =  temp2 * fjacX[2][0][i+1][j][k]
          - temp1 * njacX[2][0][i+1][j][k];
        lhsX[2][1][CC][i][j][k] =  temp2 * fjacX[2][1][i+1][j][k]
          - temp1 * njacX[2][1][i+1][j][k];
        lhsX[2][2][CC][i][j][k] =  temp2 * fjacX[2][2][i+1][j][k]
          - temp1 * njacX[2][2][i+1][j][k]
          - temp1 * dx3;
        lhsX[2][3][CC][i][j][k] =  temp2 * fjacX[2][3][i+1][j][k]
          - temp1 * njacX[2][3][i+1][j][k];
        lhsX[2][4][CC][i][j][k] =  temp2 * fjacX[2][4][i+1][j][k]
          - temp1 * njacX[2][4][i+1][j][k];

        lhsX[3][0][CC][i][j][k] =  temp2 * fjacX[3][0][i+1][j][k]
          - temp1 * njacX[3][0][i+1][j][k];
        lhsX[3][1][CC][i][j][k] =  temp2 * fjacX[3][1][i+1][j][k]
          - temp1 * njacX[3][1][i+1][j][k];
        lhsX[3][2][CC][i][j][k] =  temp2 * fjacX[3][2][i+1][j][k]
          - temp1 * njacX[3][2][i+1][j][k];
        lhsX[3][3][CC][i][j][k] =  temp2 * fjacX[3][3][i+1][j][k]
          - temp1 * njacX[3][3][i+1][j][k]
          - temp1 * dx4;
        lhsX[3][4][CC][i][j][k] =  temp2 * fjacX[3][4][i+1][j][k]
          - temp1 * njacX[3][4][i+1][j][k];

        lhsX[4][0][CC][i][j][k] =  temp2 * fjacX[4][0][i+1][j][k]
          - temp1 * njacX[4][0][i+1][j][k];
        lhsX[4][1][CC][i][j][k] =  temp2 * fjacX[4][1][i+1][j][k]
          - temp1 * njacX[4][1][i+1][j][k];
        lhsX[4][2][CC][i][j][k] =  temp2 * fjacX[4][2][i+1][j][k]
          - temp1 * njacX[4][2][i+1][j][k];
        lhsX[4][3][CC][i][j][k] =  temp2 * fjacX[4][3][i+1][j][k]
          - temp1 * njacX[4][3][i+1][j][k];
        lhsX[4][4][CC][i][j][k] =  temp2 * fjacX[4][4][i+1][j][k]
          - temp1 * njacX[4][4][i+1][j][k]
          - temp1 * dx5;
      }
    }
  }

      //---------------------------------------------------------------------
      //---------------------------------------------------------------------

      //---------------------------------------------------------------------
      // performs guaussian elimination on this cell.
      // 
      // assumes that unpacking routines for non-first cells 
      // preload C' and rhs' from previous cell.
      // 
      // assumed send happens outside this routine, but that
      // c'(IMAX) and rhs'(IMAX) will be sent to next cell
      //---------------------------------------------------------------------

      //---------------------------------------------------------------------
      // outer most do loops - sweeping in i direction
      //---------------------------------------------------------------------

      //---------------------------------------------------------------------
      // multiply c[k][j][0] by b_inverse and copy back to c
      // multiply rhs(0) by b_inverse(0) and copy to rhs      //---------------------------------------------------------------------
      //binvcrhs( lhsX[0][j][BB], lhsX[k][0][j][k][CC], rhs[k][j][0] );
    #pragma acc parallel loop gang num_gangs(gp12) num_workers(4) vector_length(32)
    for (j = 1; j <= gp12; j++) {
  #pragma acc loop worker vector
  for (k = 1; k <= gp22; k++) {
/*
	  for(m = 0; m < 5; m++){
	  	pivot = 1.00/lhsX[m][m][BB][0][j][k];
		for(n = m+1; n < 5; n++){
			lhsX[m][n][BB][0][j][k] = lhsX[m][n][BB][0][j][k]*pivot;
		}
		lhsX[m][0][CC][0][j][k] = lhsX[m][0][CC][0][j][k]*pivot;
		lhsX[m][1][CC][0][j][k] = lhsX[m][1][CC][0][j][k]*pivot;
		lhsX[m][2][CC][0][j][k] = lhsX[m][2][CC][0][j][k]*pivot;
		lhsX[m][3][CC][0][j][k] = lhsX[m][3][CC][0][j][k]*pivot;
		lhsX[m][4][CC][0][j][k] = lhsX[m][4][CC][0][j][k]*pivot;
		rhs[m][k][j][0] = rhs[m][k][j][0]*pivot;
		for(n = 0; n < 5; n++){
			if(n != m){
				coeff = lhsX[n][m][BB][0][j][k];
				for(z = m+1; z < 5; z++){
					lhsX[n][z][BB][0][j][k] = lhsX[n][z][BB][0][j][k] - coeff*lhsX[m][z][BB][0][j][k];
				}
				lhsX[n][0][CC][0][j][k] = lhsX[n][0][CC][0][j][k] - coeff*lhsX[m][0][CC][0][j][k];
				lhsX[n][1][CC][0][j][k] = lhsX[n][1][CC][0][j][k] - coeff*lhsX[m][1][CC][0][j][k];
				lhsX[n][2][CC][0][j][k] = lhsX[n][2][CC][0][j][k] - coeff*lhsX[m][2][CC][0][j][k];
				lhsX[n][3][CC][0][j][k] = lhsX[n][3][CC][0][j][k] - coeff*lhsX[m][3][CC][0][j][k];
				lhsX[n][4][CC][0][j][k] = lhsX[n][4][CC][0][j][k] - coeff*lhsX[m][4][CC][0][j][k];
				rhs[n][k][j][0] = rhs[n][k][j][0] - coeff*rhs[m][k][j][0];
			}
		}
	  }
*/
  pivot = 1.00/lhsX[0][0][BB][0][j][k];
  lhsX[0][1][BB][0][j][k] = lhsX[0][1][BB][0][j][k]*pivot;
  lhsX[0][2][BB][0][j][k] = lhsX[0][2][BB][0][j][k]*pivot;
  lhsX[0][3][BB][0][j][k] = lhsX[0][3][BB][0][j][k]*pivot;
  lhsX[0][4][BB][0][j][k] = lhsX[0][4][BB][0][j][k]*pivot;
  lhsX[0][0][CC][0][j][k] = lhsX[0][0][CC][0][j][k]*pivot;
  lhsX[0][1][CC][0][j][k] = lhsX[0][1][CC][0][j][k]*pivot;
  lhsX[0][2][CC][0][j][k] = lhsX[0][2][CC][0][j][k]*pivot;
  lhsX[0][3][CC][0][j][k] = lhsX[0][3][CC][0][j][k]*pivot;
  lhsX[0][4][CC][0][j][k] = lhsX[0][4][CC][0][j][k]*pivot;
  rhs[0][k][j][0]   = rhs[0][k][j][0]  *pivot;

  coeff = lhsX[1][0][BB][0][j][k];
  lhsX[1][1][BB][0][j][k]= lhsX[1][1][BB][0][j][k] - coeff*lhsX[0][1][BB][0][j][k];
  lhsX[1][2][BB][0][j][k]= lhsX[1][2][BB][0][j][k] - coeff*lhsX[0][2][BB][0][j][k];
  lhsX[1][3][BB][0][j][k]= lhsX[1][3][BB][0][j][k] - coeff*lhsX[0][3][BB][0][j][k];
  lhsX[1][4][BB][0][j][k]= lhsX[1][4][BB][0][j][k] - coeff*lhsX[0][4][BB][0][j][k];
  lhsX[1][0][CC][0][j][k] = lhsX[1][0][CC][0][j][k] - coeff*lhsX[0][0][CC][0][j][k];
  lhsX[1][1][CC][0][j][k] = lhsX[1][1][CC][0][j][k] - coeff*lhsX[0][1][CC][0][j][k];
  lhsX[1][2][CC][0][j][k] = lhsX[1][2][CC][0][j][k] - coeff*lhsX[0][2][CC][0][j][k];
  lhsX[1][3][CC][0][j][k] = lhsX[1][3][CC][0][j][k] - coeff*lhsX[0][3][CC][0][j][k];
  lhsX[1][4][CC][0][j][k] = lhsX[1][4][CC][0][j][k] - coeff*lhsX[0][4][CC][0][j][k];
  rhs[1][k][j][0]   = rhs[1][k][j][0]   - coeff*rhs[0][k][j][0];

  coeff = lhsX[2][0][BB][0][j][k];
  lhsX[2][1][BB][0][j][k]= lhsX[2][1][BB][0][j][k] - coeff*lhsX[0][1][BB][0][j][k];
  lhsX[2][2][BB][0][j][k]= lhsX[2][2][BB][0][j][k] - coeff*lhsX[0][2][BB][0][j][k];
  lhsX[2][3][BB][0][j][k]= lhsX[2][3][BB][0][j][k] - coeff*lhsX[0][3][BB][0][j][k];
  lhsX[2][4][BB][0][j][k]= lhsX[2][4][BB][0][j][k] - coeff*lhsX[0][4][BB][0][j][k];
  lhsX[2][0][CC][0][j][k] = lhsX[2][0][CC][0][j][k] - coeff*lhsX[0][0][CC][0][j][k];
  lhsX[2][1][CC][0][j][k] = lhsX[2][1][CC][0][j][k] - coeff*lhsX[0][1][CC][0][j][k];
  lhsX[2][2][CC][0][j][k] = lhsX[2][2][CC][0][j][k] - coeff*lhsX[0][2][CC][0][j][k];
  lhsX[2][3][CC][0][j][k] = lhsX[2][3][CC][0][j][k] - coeff*lhsX[0][3][CC][0][j][k];
  lhsX[2][4][CC][0][j][k] = lhsX[2][4][CC][0][j][k] - coeff*lhsX[0][4][CC][0][j][k];
  rhs[2][k][j][0]   = rhs[2][k][j][0]   - coeff*rhs[0][k][j][0];

  coeff = lhsX[3][0][BB][0][j][k];
  lhsX[3][1][BB][0][j][k]= lhsX[3][1][BB][0][j][k] - coeff*lhsX[0][1][BB][0][j][k];
  lhsX[3][2][BB][0][j][k]= lhsX[3][2][BB][0][j][k] - coeff*lhsX[0][2][BB][0][j][k];
  lhsX[3][3][BB][0][j][k]= lhsX[3][3][BB][0][j][k] - coeff*lhsX[0][3][BB][0][j][k];
  lhsX[3][4][BB][0][j][k]= lhsX[3][4][BB][0][j][k] - coeff*lhsX[0][4][BB][0][j][k];
  lhsX[3][0][CC][0][j][k] = lhsX[3][0][CC][0][j][k] - coeff*lhsX[0][0][CC][0][j][k];
  lhsX[3][1][CC][0][j][k] = lhsX[3][1][CC][0][j][k] - coeff*lhsX[0][1][CC][0][j][k];
  lhsX[3][2][CC][0][j][k] = lhsX[3][2][CC][0][j][k] - coeff*lhsX[0][2][CC][0][j][k];
  lhsX[3][3][CC][0][j][k] = lhsX[3][3][CC][0][j][k] - coeff*lhsX[0][3][CC][0][j][k];
  lhsX[3][4][CC][0][j][k] = lhsX[3][4][CC][0][j][k] - coeff*lhsX[0][4][CC][0][j][k];
  rhs[3][k][j][0]   = rhs[3][k][j][0]   - coeff*rhs[0][k][j][0];

  coeff = lhsX[4][0][BB][0][j][k];
  lhsX[4][1][BB][0][j][k]= lhsX[4][1][BB][0][j][k] - coeff*lhsX[0][1][BB][0][j][k];
  lhsX[4][2][BB][0][j][k]= lhsX[4][2][BB][0][j][k] - coeff*lhsX[0][2][BB][0][j][k];
  lhsX[4][3][BB][0][j][k]= lhsX[4][3][BB][0][j][k] - coeff*lhsX[0][3][BB][0][j][k];
  lhsX[4][4][BB][0][j][k]= lhsX[4][4][BB][0][j][k] - coeff*lhsX[0][4][BB][0][j][k];
  lhsX[4][0][CC][0][j][k] = lhsX[4][0][CC][0][j][k] - coeff*lhsX[0][0][CC][0][j][k];
  lhsX[4][1][CC][0][j][k] = lhsX[4][1][CC][0][j][k] - coeff*lhsX[0][1][CC][0][j][k];
  lhsX[4][2][CC][0][j][k] = lhsX[4][2][CC][0][j][k] - coeff*lhsX[0][2][CC][0][j][k];
  lhsX[4][3][CC][0][j][k] = lhsX[4][3][CC][0][j][k] - coeff*lhsX[0][3][CC][0][j][k];
  lhsX[4][4][CC][0][j][k] = lhsX[4][4][CC][0][j][k] - coeff*lhsX[0][4][CC][0][j][k];
  rhs[4][k][j][0]   = rhs[4][k][j][0]   - coeff*rhs[0][k][j][0];


  pivot = 1.00/lhsX[1][1][BB][0][j][k];
  lhsX[1][2][BB][0][j][k] = lhsX[1][2][BB][0][j][k]*pivot;
  lhsX[1][3][BB][0][j][k] = lhsX[1][3][BB][0][j][k]*pivot;
  lhsX[1][4][BB][0][j][k] = lhsX[1][4][BB][0][j][k]*pivot;
  lhsX[1][0][CC][0][j][k] = lhsX[1][0][CC][0][j][k]*pivot;
  lhsX[1][1][CC][0][j][k] = lhsX[1][1][CC][0][j][k]*pivot;
  lhsX[1][2][CC][0][j][k] = lhsX[1][2][CC][0][j][k]*pivot;
  lhsX[1][3][CC][0][j][k] = lhsX[1][3][CC][0][j][k]*pivot;
  lhsX[1][4][CC][0][j][k] = lhsX[1][4][CC][0][j][k]*pivot;
  rhs[1][k][j][0]   = rhs[1][k][j][0]  *pivot;

  coeff = lhsX[0][1][BB][0][j][k];
  lhsX[0][2][BB][0][j][k]= lhsX[0][2][BB][0][j][k] - coeff*lhsX[1][2][BB][0][j][k];
  lhsX[0][3][BB][0][j][k]= lhsX[0][3][BB][0][j][k] - coeff*lhsX[1][3][BB][0][j][k];
  lhsX[0][4][BB][0][j][k]= lhsX[0][4][BB][0][j][k] - coeff*lhsX[1][4][BB][0][j][k];
  lhsX[0][0][CC][0][j][k] = lhsX[0][0][CC][0][j][k] - coeff*lhsX[1][0][CC][0][j][k];
  lhsX[0][1][CC][0][j][k] = lhsX[0][1][CC][0][j][k] - coeff*lhsX[1][1][CC][0][j][k];
  lhsX[0][2][CC][0][j][k] = lhsX[0][2][CC][0][j][k] - coeff*lhsX[1][2][CC][0][j][k];
  lhsX[0][3][CC][0][j][k] = lhsX[0][3][CC][0][j][k] - coeff*lhsX[1][3][CC][0][j][k];
  lhsX[0][4][CC][0][j][k] = lhsX[0][4][CC][0][j][k] - coeff*lhsX[1][4][CC][0][j][k];
  rhs[0][k][j][0]   = rhs[0][k][j][0]   - coeff*rhs[1][k][j][0];

  coeff = lhsX[2][1][BB][0][j][k];
  lhsX[2][2][BB][0][j][k]= lhsX[2][2][BB][0][j][k] - coeff*lhsX[1][2][BB][0][j][k];
  lhsX[2][3][BB][0][j][k]= lhsX[2][3][BB][0][j][k] - coeff*lhsX[1][3][BB][0][j][k];
  lhsX[2][4][BB][0][j][k]= lhsX[2][4][BB][0][j][k] - coeff*lhsX[1][4][BB][0][j][k];
  lhsX[2][0][CC][0][j][k] = lhsX[2][0][CC][0][j][k] - coeff*lhsX[1][0][CC][0][j][k];
  lhsX[2][1][CC][0][j][k] = lhsX[2][1][CC][0][j][k] - coeff*lhsX[1][1][CC][0][j][k];
  lhsX[2][2][CC][0][j][k] = lhsX[2][2][CC][0][j][k] - coeff*lhsX[1][2][CC][0][j][k];
  lhsX[2][3][CC][0][j][k] = lhsX[2][3][CC][0][j][k] - coeff*lhsX[1][3][CC][0][j][k];
  lhsX[2][4][CC][0][j][k] = lhsX[2][4][CC][0][j][k] - coeff*lhsX[1][4][CC][0][j][k];
  rhs[2][k][j][0]   = rhs[2][k][j][0]   - coeff*rhs[1][k][j][0];

  coeff = lhsX[3][1][BB][0][j][k];
  lhsX[3][2][BB][0][j][k]= lhsX[3][2][BB][0][j][k] - coeff*lhsX[1][2][BB][0][j][k];
  lhsX[3][3][BB][0][j][k]= lhsX[3][3][BB][0][j][k] - coeff*lhsX[1][3][BB][0][j][k];
  lhsX[3][4][BB][0][j][k]= lhsX[3][4][BB][0][j][k] - coeff*lhsX[1][4][BB][0][j][k];
  lhsX[3][0][CC][0][j][k] = lhsX[3][0][CC][0][j][k] - coeff*lhsX[1][0][CC][0][j][k];
  lhsX[3][1][CC][0][j][k] = lhsX[3][1][CC][0][j][k] - coeff*lhsX[1][1][CC][0][j][k];
  lhsX[3][2][CC][0][j][k] = lhsX[3][2][CC][0][j][k] - coeff*lhsX[1][2][CC][0][j][k];
  lhsX[3][3][CC][0][j][k] = lhsX[3][3][CC][0][j][k] - coeff*lhsX[1][3][CC][0][j][k];
  lhsX[3][4][CC][0][j][k] = lhsX[3][4][CC][0][j][k] - coeff*lhsX[1][4][CC][0][j][k];
  rhs[3][k][j][0]   = rhs[3][k][j][0]   - coeff*rhs[1][k][j][0];

  coeff = lhsX[4][1][BB][0][j][k];
  lhsX[4][2][BB][0][j][k]= lhsX[4][2][BB][0][j][k] - coeff*lhsX[1][2][BB][0][j][k];
  lhsX[4][3][BB][0][j][k]= lhsX[4][3][BB][0][j][k] - coeff*lhsX[1][3][BB][0][j][k];
  lhsX[4][4][BB][0][j][k]= lhsX[4][4][BB][0][j][k] - coeff*lhsX[1][4][BB][0][j][k];
  lhsX[4][0][CC][0][j][k] = lhsX[4][0][CC][0][j][k] - coeff*lhsX[1][0][CC][0][j][k];
  lhsX[4][1][CC][0][j][k] = lhsX[4][1][CC][0][j][k] - coeff*lhsX[1][1][CC][0][j][k];
  lhsX[4][2][CC][0][j][k] = lhsX[4][2][CC][0][j][k] - coeff*lhsX[1][2][CC][0][j][k];
  lhsX[4][3][CC][0][j][k] = lhsX[4][3][CC][0][j][k] - coeff*lhsX[1][3][CC][0][j][k];
  lhsX[4][4][CC][0][j][k] = lhsX[4][4][CC][0][j][k] - coeff*lhsX[1][4][CC][0][j][k];
  rhs[4][k][j][0]   = rhs[4][k][j][0]   - coeff*rhs[1][k][j][0];


  pivot = 1.00/lhsX[2][2][BB][0][j][k];
  lhsX[2][3][BB][0][j][k] = lhsX[2][3][BB][0][j][k]*pivot;
  lhsX[2][4][BB][0][j][k] = lhsX[2][4][BB][0][j][k]*pivot;
  lhsX[2][0][CC][0][j][k] = lhsX[2][0][CC][0][j][k]*pivot;
  lhsX[2][1][CC][0][j][k] = lhsX[2][1][CC][0][j][k]*pivot;
  lhsX[2][2][CC][0][j][k] = lhsX[2][2][CC][0][j][k]*pivot;
  lhsX[2][3][CC][0][j][k] = lhsX[2][3][CC][0][j][k]*pivot;
  lhsX[2][4][CC][0][j][k] = lhsX[2][4][CC][0][j][k]*pivot;
  rhs[2][k][j][0]   = rhs[2][k][j][0]  *pivot;

  coeff = lhsX[0][2][BB][0][j][k];
  lhsX[0][3][BB][0][j][k]= lhsX[0][3][BB][0][j][k] - coeff*lhsX[2][3][BB][0][j][k];
  lhsX[0][4][BB][0][j][k]= lhsX[0][4][BB][0][j][k] - coeff*lhsX[2][4][BB][0][j][k];
  lhsX[0][0][CC][0][j][k] = lhsX[0][0][CC][0][j][k] - coeff*lhsX[2][0][CC][0][j][k];
  lhsX[0][1][CC][0][j][k] = lhsX[0][1][CC][0][j][k] - coeff*lhsX[2][1][CC][0][j][k];
  lhsX[0][2][CC][0][j][k] = lhsX[0][2][CC][0][j][k] - coeff*lhsX[2][2][CC][0][j][k];
  lhsX[0][3][CC][0][j][k] = lhsX[0][3][CC][0][j][k] - coeff*lhsX[2][3][CC][0][j][k];
  lhsX[0][4][CC][0][j][k] = lhsX[0][4][CC][0][j][k] - coeff*lhsX[2][4][CC][0][j][k];
  rhs[0][k][j][0]   = rhs[0][k][j][0]   - coeff*rhs[2][k][j][0];

  coeff = lhsX[1][2][BB][0][j][k];
  lhsX[1][3][BB][0][j][k]= lhsX[1][3][BB][0][j][k] - coeff*lhsX[2][3][BB][0][j][k];
  lhsX[1][4][BB][0][j][k]= lhsX[1][4][BB][0][j][k] - coeff*lhsX[2][4][BB][0][j][k];
  lhsX[1][0][CC][0][j][k] = lhsX[1][0][CC][0][j][k] - coeff*lhsX[2][0][CC][0][j][k];
  lhsX[1][1][CC][0][j][k] = lhsX[1][1][CC][0][j][k] - coeff*lhsX[2][1][CC][0][j][k];
  lhsX[1][2][CC][0][j][k] = lhsX[1][2][CC][0][j][k] - coeff*lhsX[2][2][CC][0][j][k];
  lhsX[1][3][CC][0][j][k] = lhsX[1][3][CC][0][j][k] - coeff*lhsX[2][3][CC][0][j][k];
  lhsX[1][4][CC][0][j][k] = lhsX[1][4][CC][0][j][k] - coeff*lhsX[2][4][CC][0][j][k];
  rhs[1][k][j][0]   = rhs[1][k][j][0]   - coeff*rhs[2][k][j][0];

  coeff = lhsX[3][2][BB][0][j][k];
  lhsX[3][3][BB][0][j][k]= lhsX[3][3][BB][0][j][k] - coeff*lhsX[2][3][BB][0][j][k];
  lhsX[3][4][BB][0][j][k]= lhsX[3][4][BB][0][j][k] - coeff*lhsX[2][4][BB][0][j][k];
  lhsX[3][0][CC][0][j][k] = lhsX[3][0][CC][0][j][k] - coeff*lhsX[2][0][CC][0][j][k];
  lhsX[3][1][CC][0][j][k] = lhsX[3][1][CC][0][j][k] - coeff*lhsX[2][1][CC][0][j][k];
  lhsX[3][2][CC][0][j][k] = lhsX[3][2][CC][0][j][k] - coeff*lhsX[2][2][CC][0][j][k];
  lhsX[3][3][CC][0][j][k] = lhsX[3][3][CC][0][j][k] - coeff*lhsX[2][3][CC][0][j][k];
  lhsX[3][4][CC][0][j][k] = lhsX[3][4][CC][0][j][k] - coeff*lhsX[2][4][CC][0][j][k];
  rhs[3][k][j][0]   = rhs[3][k][j][0]   - coeff*rhs[2][k][j][0];

  coeff = lhsX[4][2][BB][0][j][k];
  lhsX[4][3][BB][0][j][k]= lhsX[4][3][BB][0][j][k] - coeff*lhsX[2][3][BB][0][j][k];
  lhsX[4][4][BB][0][j][k]= lhsX[4][4][BB][0][j][k] - coeff*lhsX[2][4][BB][0][j][k];
  lhsX[4][0][CC][0][j][k] = lhsX[4][0][CC][0][j][k] - coeff*lhsX[2][0][CC][0][j][k];
  lhsX[4][1][CC][0][j][k] = lhsX[4][1][CC][0][j][k] - coeff*lhsX[2][1][CC][0][j][k];
  lhsX[4][2][CC][0][j][k] = lhsX[4][2][CC][0][j][k] - coeff*lhsX[2][2][CC][0][j][k];
  lhsX[4][3][CC][0][j][k] = lhsX[4][3][CC][0][j][k] - coeff*lhsX[2][3][CC][0][j][k];
  lhsX[4][4][CC][0][j][k] = lhsX[4][4][CC][0][j][k] - coeff*lhsX[2][4][CC][0][j][k];
  rhs[4][k][j][0]   = rhs[4][k][j][0]   - coeff*rhs[2][k][j][0];


  pivot = 1.00/lhsX[3][3][BB][0][j][k];
  lhsX[3][4][BB][0][j][k] = lhsX[3][4][BB][0][j][k]*pivot;
  lhsX[3][0][CC][0][j][k] = lhsX[3][0][CC][0][j][k]*pivot;
  lhsX[3][1][CC][0][j][k] = lhsX[3][1][CC][0][j][k]*pivot;
  lhsX[3][2][CC][0][j][k] = lhsX[3][2][CC][0][j][k]*pivot;
  lhsX[3][3][CC][0][j][k] = lhsX[3][3][CC][0][j][k]*pivot;
  lhsX[3][4][CC][0][j][k] = lhsX[3][4][CC][0][j][k]*pivot;
  rhs[3][k][j][0]   = rhs[3][k][j][0]  *pivot;

  coeff = lhsX[0][3][BB][0][j][k];
  lhsX[0][4][BB][0][j][k]= lhsX[0][4][BB][0][j][k] - coeff*lhsX[3][4][BB][0][j][k];
  lhsX[0][0][CC][0][j][k] = lhsX[0][0][CC][0][j][k] - coeff*lhsX[3][0][CC][0][j][k];
  lhsX[0][1][CC][0][j][k] = lhsX[0][1][CC][0][j][k] - coeff*lhsX[3][1][CC][0][j][k];
  lhsX[0][2][CC][0][j][k] = lhsX[0][2][CC][0][j][k] - coeff*lhsX[3][2][CC][0][j][k];
  lhsX[0][3][CC][0][j][k] = lhsX[0][3][CC][0][j][k] - coeff*lhsX[3][3][CC][0][j][k];
  lhsX[0][4][CC][0][j][k] = lhsX[0][4][CC][0][j][k] - coeff*lhsX[3][4][CC][0][j][k];
  rhs[0][k][j][0]   = rhs[0][k][j][0]   - coeff*rhs[3][k][j][0];

  coeff = lhsX[1][3][BB][0][j][k];
  lhsX[1][4][BB][0][j][k]= lhsX[1][4][BB][0][j][k] - coeff*lhsX[3][4][BB][0][j][k];
  lhsX[1][0][CC][0][j][k] = lhsX[1][0][CC][0][j][k] - coeff*lhsX[3][0][CC][0][j][k];
  lhsX[1][1][CC][0][j][k] = lhsX[1][1][CC][0][j][k] - coeff*lhsX[3][1][CC][0][j][k];
  lhsX[1][2][CC][0][j][k] = lhsX[1][2][CC][0][j][k] - coeff*lhsX[3][2][CC][0][j][k];
  lhsX[1][3][CC][0][j][k] = lhsX[1][3][CC][0][j][k] - coeff*lhsX[3][3][CC][0][j][k];
  lhsX[1][4][CC][0][j][k] = lhsX[1][4][CC][0][j][k] - coeff*lhsX[3][4][CC][0][j][k];
  rhs[1][k][j][0]   = rhs[1][k][j][0]   - coeff*rhs[3][k][j][0];

  coeff = lhsX[2][3][BB][0][j][k];
  lhsX[2][4][BB][0][j][k]= lhsX[2][4][BB][0][j][k] - coeff*lhsX[3][4][BB][0][j][k];
  lhsX[2][0][CC][0][j][k] = lhsX[2][0][CC][0][j][k] - coeff*lhsX[3][0][CC][0][j][k];
  lhsX[2][1][CC][0][j][k] = lhsX[2][1][CC][0][j][k] - coeff*lhsX[3][1][CC][0][j][k];
  lhsX[2][2][CC][0][j][k] = lhsX[2][2][CC][0][j][k] - coeff*lhsX[3][2][CC][0][j][k];
  lhsX[2][3][CC][0][j][k] = lhsX[2][3][CC][0][j][k] - coeff*lhsX[3][3][CC][0][j][k];
  lhsX[2][4][CC][0][j][k] = lhsX[2][4][CC][0][j][k] - coeff*lhsX[3][4][CC][0][j][k];
  rhs[2][k][j][0]   = rhs[2][k][j][0]   - coeff*rhs[3][k][j][0];

  coeff = lhsX[4][3][BB][0][j][k];
  lhsX[4][4][BB][0][j][k]= lhsX[4][4][BB][0][j][k] - coeff*lhsX[3][4][BB][0][j][k];
  lhsX[4][0][CC][0][j][k] = lhsX[4][0][CC][0][j][k] - coeff*lhsX[3][0][CC][0][j][k];
  lhsX[4][1][CC][0][j][k] = lhsX[4][1][CC][0][j][k] - coeff*lhsX[3][1][CC][0][j][k];
  lhsX[4][2][CC][0][j][k] = lhsX[4][2][CC][0][j][k] - coeff*lhsX[3][2][CC][0][j][k];
  lhsX[4][3][CC][0][j][k] = lhsX[4][3][CC][0][j][k] - coeff*lhsX[3][3][CC][0][j][k];
  lhsX[4][4][CC][0][j][k] = lhsX[4][4][CC][0][j][k] - coeff*lhsX[3][4][CC][0][j][k];
  rhs[4][k][j][0]   = rhs[4][k][j][0]   - coeff*rhs[3][k][j][0];


  pivot = 1.00/lhsX[4][4][BB][0][j][k];
  lhsX[4][0][CC][0][j][k] = lhsX[4][0][CC][0][j][k]*pivot;
  lhsX[4][1][CC][0][j][k] = lhsX[4][1][CC][0][j][k]*pivot;
  lhsX[4][2][CC][0][j][k] = lhsX[4][2][CC][0][j][k]*pivot;
  lhsX[4][3][CC][0][j][k] = lhsX[4][3][CC][0][j][k]*pivot;
  lhsX[4][4][CC][0][j][k] = lhsX[4][4][CC][0][j][k]*pivot;
  rhs[4][k][j][0]   = rhs[4][k][j][0]  *pivot;

  coeff = lhsX[0][4][BB][0][j][k];
  lhsX[0][0][CC][0][j][k] = lhsX[0][0][CC][0][j][k] - coeff*lhsX[4][0][CC][0][j][k];
  lhsX[0][1][CC][0][j][k] = lhsX[0][1][CC][0][j][k] - coeff*lhsX[4][1][CC][0][j][k];
  lhsX[0][2][CC][0][j][k] = lhsX[0][2][CC][0][j][k] - coeff*lhsX[4][2][CC][0][j][k];
  lhsX[0][3][CC][0][j][k] = lhsX[0][3][CC][0][j][k] - coeff*lhsX[4][3][CC][0][j][k];
  lhsX[0][4][CC][0][j][k] = lhsX[0][4][CC][0][j][k] - coeff*lhsX[4][4][CC][0][j][k];
  rhs[0][k][j][0]   = rhs[0][k][j][0]   - coeff*rhs[4][k][j][0];

  coeff = lhsX[1][4][BB][0][j][k];
  lhsX[1][0][CC][0][j][k] = lhsX[1][0][CC][0][j][k] - coeff*lhsX[4][0][CC][0][j][k];
  lhsX[1][1][CC][0][j][k] = lhsX[1][1][CC][0][j][k] - coeff*lhsX[4][1][CC][0][j][k];
  lhsX[1][2][CC][0][j][k] = lhsX[1][2][CC][0][j][k] - coeff*lhsX[4][2][CC][0][j][k];
  lhsX[1][3][CC][0][j][k] = lhsX[1][3][CC][0][j][k] - coeff*lhsX[4][3][CC][0][j][k];
  lhsX[1][4][CC][0][j][k] = lhsX[1][4][CC][0][j][k] - coeff*lhsX[4][4][CC][0][j][k];
  rhs[1][k][j][0]   = rhs[1][k][j][0]   - coeff*rhs[4][k][j][0];

  coeff = lhsX[2][4][BB][0][j][k];
  lhsX[2][0][CC][0][j][k] = lhsX[2][0][CC][0][j][k] - coeff*lhsX[4][0][CC][0][j][k];
  lhsX[2][1][CC][0][j][k] = lhsX[2][1][CC][0][j][k] - coeff*lhsX[4][1][CC][0][j][k];
  lhsX[2][2][CC][0][j][k] = lhsX[2][2][CC][0][j][k] - coeff*lhsX[4][2][CC][0][j][k];
  lhsX[2][3][CC][0][j][k] = lhsX[2][3][CC][0][j][k] - coeff*lhsX[4][3][CC][0][j][k];
  lhsX[2][4][CC][0][j][k] = lhsX[2][4][CC][0][j][k] - coeff*lhsX[4][4][CC][0][j][k];
  rhs[2][k][j][0]   = rhs[2][k][j][0]   - coeff*rhs[4][k][j][0];

  coeff = lhsX[3][4][BB][0][j][k];
  lhsX[3][0][CC][0][j][k] = lhsX[3][0][CC][0][j][k] - coeff*lhsX[4][0][CC][0][j][k];
  lhsX[3][1][CC][0][j][k] = lhsX[3][1][CC][0][j][k] - coeff*lhsX[4][1][CC][0][j][k];
  lhsX[3][2][CC][0][j][k] = lhsX[3][2][CC][0][j][k] - coeff*lhsX[4][2][CC][0][j][k];
  lhsX[3][3][CC][0][j][k] = lhsX[3][3][CC][0][j][k] - coeff*lhsX[4][3][CC][0][j][k];
  lhsX[3][4][CC][0][j][k] = lhsX[3][4][CC][0][j][k] - coeff*lhsX[4][4][CC][0][j][k];
  rhs[3][k][j][0]   = rhs[3][k][j][0]   - coeff*rhs[4][k][j][0];
	

	}/*end j*/
  }/*end k*/

      //---------------------------------------------------------------------
      // begin inner most do loop
      // do all the elements of the cell unless last 
      //---------------------------------------------------------------------
    //#pragma acc kernels loop gang(gp12) 
    #pragma acc parallel loop gang num_gangs(gp12) num_workers(4) vector_length(32)
    for (j = 1; j <= gp12; j++) {
  //#pragma acc loop gang(gp22/128) vector(128)
  #pragma acc loop worker vector
  for (k = 1; k <= gp22; k++) {
      for (i = 1; i <= isize-1; i++) {
        //-------------------------------------------------------------------
        // rhs(i) = rhs(i) - A*rhs(i-1)
        //-------------------------------------------------------------------
        //matvec_sub(lhsX[i-1][j][AA], rhs[k][k][i][j], rhs[k][j][i]);
		/*
		for(m = 0; m < 5; m++){
			rhs[m][k][j][i] = rhs[m][k][j][i] - lhsX[m][0][AA][i][j][k]*rhs[0][k][j][i-1]
											  - lhsX[m][1][AA][i][j][k]*rhs[1][k][j][i-1]
											  - lhsX[m][2][AA][i][j][k]*rhs[2][k][j][i-1]
											  - lhsX[m][3][AA][i][j][k]*rhs[3][k][j][i-1]
											  - lhsX[m][4][AA][i][j][k]*rhs[4][k][j][i-1];
		}
		*/
  rhs[0][k][j][i] = rhs[0][k][j][i] - lhsX[0][0][AA][i][j][k]*rhs[0][k][j][i-1]
                    - lhsX[0][1][AA][i][j][k]*rhs[1][k][j][i-1]
                    - lhsX[0][2][AA][i][j][k]*rhs[2][k][j][i-1]
                    - lhsX[0][3][AA][i][j][k]*rhs[3][k][j][i-1]
                    - lhsX[0][4][AA][i][j][k]*rhs[4][k][j][i-1];
  rhs[1][k][j][i] = rhs[1][k][j][i] - lhsX[1][0][AA][i][j][k]*rhs[0][k][j][i-1]
                    - lhsX[1][1][AA][i][j][k]*rhs[1][k][j][i-1]
                    - lhsX[1][2][AA][i][j][k]*rhs[2][k][j][i-1]
                    - lhsX[1][3][AA][i][j][k]*rhs[3][k][j][i-1]
                    - lhsX[1][4][AA][i][j][k]*rhs[4][k][j][i-1];
  rhs[2][k][j][i] = rhs[2][k][j][i] - lhsX[2][0][AA][i][j][k]*rhs[0][k][j][i-1]
                    - lhsX[2][1][AA][i][j][k]*rhs[1][k][j][i-1]
                    - lhsX[2][2][AA][i][j][k]*rhs[2][k][j][i-1]
                    - lhsX[2][3][AA][i][j][k]*rhs[3][k][j][i-1]
                    - lhsX[2][4][AA][i][j][k]*rhs[4][k][j][i-1];
  rhs[3][k][j][i] = rhs[3][k][j][i] - lhsX[3][0][AA][i][j][k]*rhs[0][k][j][i-1]
                    - lhsX[3][1][AA][i][j][k]*rhs[1][k][j][i-1]
                    - lhsX[3][2][AA][i][j][k]*rhs[2][k][j][i-1]
                    - lhsX[3][3][AA][i][j][k]*rhs[3][k][j][i-1]
                    - lhsX[3][4][AA][i][j][k]*rhs[4][k][j][i-1];
  rhs[4][k][j][i] = rhs[4][k][j][i] - lhsX[4][0][AA][i][j][k]*rhs[0][k][j][i-1]
                    - lhsX[4][1][AA][i][j][k]*rhs[1][k][j][i-1]
                    - lhsX[4][2][AA][i][j][k]*rhs[2][k][j][i-1]
                    - lhsX[4][3][AA][i][j][k]*rhs[3][k][j][i-1]
                    - lhsX[4][4][AA][i][j][k]*rhs[4][k][j][i-1];
		

        //-------------------------------------------------------------------
        // B(i) = B(i) - C(i-1)*A(i)
        //-------------------------------------------------------------------
      //  matmul_sub(lhsX[i-1][j][AA], lhsX[k][i][j][k][CC], lhsX[k][j][i][BB]);
	  /*
	  	for(m = 0; m < 5; m++){
	  		for(n = 0; n < 5; n++){
			lhsX[n][m][BB][i][j][k] = lhsX[n][m][BB][i][j][k] - lhsX[n][0][AA][i][j][k]*lhsX[0][m][CC][i-1][j][k]
												- lhsX[n][1][AA][i][j][k]*lhsX[1][m][CC][i-1][j][k]
												- lhsX[n][2][AA][i][j][k]*lhsX[2][m][CC][i-1][j][k]
												- lhsX[n][3][AA][i][j][k]*lhsX[3][m][CC][i-1][j][k]
												- lhsX[n][4][AA][i][j][k]*lhsX[4][m][CC][i-1][j][k];
		}
	  }
		*/
  lhsX[0][0][BB][i][j][k] = lhsX[0][0][BB][i][j][k] - lhsX[0][0][AA][i][j][k]*lhsX[0][0][CC][i-1][j][k]
                              - lhsX[0][1][AA][i][j][k]*lhsX[1][0][CC][i-1][j][k]
                              - lhsX[0][2][AA][i][j][k]*lhsX[2][0][CC][i-1][j][k]
                              - lhsX[0][3][AA][i][j][k]*lhsX[3][0][CC][i-1][j][k]
                              - lhsX[0][4][AA][i][j][k]*lhsX[4][0][CC][i-1][j][k];
  lhsX[1][0][BB][i][j][k] = lhsX[1][0][BB][i][j][k] - lhsX[1][0][AA][i][j][k]*lhsX[0][0][CC][i-1][j][k]
                              - lhsX[1][1][AA][i][j][k]*lhsX[1][0][CC][i-1][j][k]
                              - lhsX[1][2][AA][i][j][k]*lhsX[2][0][CC][i-1][j][k]
                              - lhsX[1][3][AA][i][j][k]*lhsX[3][0][CC][i-1][j][k]
                              - lhsX[1][4][AA][i][j][k]*lhsX[4][0][CC][i-1][j][k];
  lhsX[2][0][BB][i][j][k] = lhsX[2][0][BB][i][j][k] - lhsX[2][0][AA][i][j][k]*lhsX[0][0][CC][i-1][j][k]
                              - lhsX[2][1][AA][i][j][k]*lhsX[1][0][CC][i-1][j][k]
                              - lhsX[2][2][AA][i][j][k]*lhsX[2][0][CC][i-1][j][k]
                              - lhsX[2][3][AA][i][j][k]*lhsX[3][0][CC][i-1][j][k]
                              - lhsX[2][4][AA][i][j][k]*lhsX[4][0][CC][i-1][j][k];
  lhsX[3][0][BB][i][j][k] = lhsX[3][0][BB][i][j][k] - lhsX[3][0][AA][i][j][k]*lhsX[0][0][CC][i-1][j][k]
                              - lhsX[3][1][AA][i][j][k]*lhsX[1][0][CC][i-1][j][k]
                              - lhsX[3][2][AA][i][j][k]*lhsX[2][0][CC][i-1][j][k]
                              - lhsX[3][3][AA][i][j][k]*lhsX[3][0][CC][i-1][j][k]
                              - lhsX[3][4][AA][i][j][k]*lhsX[4][0][CC][i-1][j][k];
  lhsX[4][0][BB][i][j][k] = lhsX[4][0][BB][i][j][k] - lhsX[4][0][AA][i][j][k]*lhsX[0][0][CC][i-1][j][k]
                              - lhsX[4][1][AA][i][j][k]*lhsX[1][0][CC][i-1][j][k]
                              - lhsX[4][2][AA][i][j][k]*lhsX[2][0][CC][i-1][j][k]
                              - lhsX[4][3][AA][i][j][k]*lhsX[3][0][CC][i-1][j][k]
                              - lhsX[4][4][AA][i][j][k]*lhsX[4][0][CC][i-1][j][k];
  lhsX[0][1][BB][i][j][k] = lhsX[0][1][BB][i][j][k] - lhsX[0][0][AA][i][j][k]*lhsX[0][1][CC][i-1][j][k]
                              - lhsX[0][1][AA][i][j][k]*lhsX[1][1][CC][i-1][j][k]
                              - lhsX[0][2][AA][i][j][k]*lhsX[2][1][CC][i-1][j][k]
                              - lhsX[0][3][AA][i][j][k]*lhsX[3][1][CC][i-1][j][k]
                              - lhsX[0][4][AA][i][j][k]*lhsX[4][1][CC][i-1][j][k];
  lhsX[1][1][BB][i][j][k] = lhsX[1][1][BB][i][j][k] - lhsX[1][0][AA][i][j][k]*lhsX[0][1][CC][i-1][j][k]
                              - lhsX[1][1][AA][i][j][k]*lhsX[1][1][CC][i-1][j][k]
                              - lhsX[1][2][AA][i][j][k]*lhsX[2][1][CC][i-1][j][k]
                              - lhsX[1][3][AA][i][j][k]*lhsX[3][1][CC][i-1][j][k]
                              - lhsX[1][4][AA][i][j][k]*lhsX[4][1][CC][i-1][j][k];
  lhsX[2][1][BB][i][j][k] = lhsX[2][1][BB][i][j][k] - lhsX[2][0][AA][i][j][k]*lhsX[0][1][CC][i-1][j][k]
                              - lhsX[2][1][AA][i][j][k]*lhsX[1][1][CC][i-1][j][k]
                              - lhsX[2][2][AA][i][j][k]*lhsX[2][1][CC][i-1][j][k]
                              - lhsX[2][3][AA][i][j][k]*lhsX[3][1][CC][i-1][j][k]
                              - lhsX[2][4][AA][i][j][k]*lhsX[4][1][CC][i-1][j][k];
  lhsX[3][1][BB][i][j][k] = lhsX[3][1][BB][i][j][k] - lhsX[3][0][AA][i][j][k]*lhsX[0][1][CC][i-1][j][k]
                              - lhsX[3][1][AA][i][j][k]*lhsX[1][1][CC][i-1][j][k]
                              - lhsX[3][2][AA][i][j][k]*lhsX[2][1][CC][i-1][j][k]
                              - lhsX[3][3][AA][i][j][k]*lhsX[3][1][CC][i-1][j][k]
                              - lhsX[3][4][AA][i][j][k]*lhsX[4][1][CC][i-1][j][k];
  lhsX[4][1][BB][i][j][k] = lhsX[4][1][BB][i][j][k] - lhsX[4][0][AA][i][j][k]*lhsX[0][1][CC][i-1][j][k]
                              - lhsX[4][1][AA][i][j][k]*lhsX[1][1][CC][i-1][j][k]
                              - lhsX[4][2][AA][i][j][k]*lhsX[2][1][CC][i-1][j][k]
                              - lhsX[4][3][AA][i][j][k]*lhsX[3][1][CC][i-1][j][k]
                              - lhsX[4][4][AA][i][j][k]*lhsX[4][1][CC][i-1][j][k];
  lhsX[0][2][BB][i][j][k] = lhsX[0][2][BB][i][j][k] - lhsX[0][0][AA][i][j][k]*lhsX[0][2][CC][i-1][j][k]
                              - lhsX[0][1][AA][i][j][k]*lhsX[1][2][CC][i-1][j][k]
                              - lhsX[0][2][AA][i][j][k]*lhsX[2][2][CC][i-1][j][k]
                              - lhsX[0][3][AA][i][j][k]*lhsX[3][2][CC][i-1][j][k]
                              - lhsX[0][4][AA][i][j][k]*lhsX[4][2][CC][i-1][j][k];
  lhsX[1][2][BB][i][j][k] = lhsX[1][2][BB][i][j][k] - lhsX[1][0][AA][i][j][k]*lhsX[0][2][CC][i-1][j][k]
                              - lhsX[1][1][AA][i][j][k]*lhsX[1][2][CC][i-1][j][k]
                              - lhsX[1][2][AA][i][j][k]*lhsX[2][2][CC][i-1][j][k]
                              - lhsX[1][3][AA][i][j][k]*lhsX[3][2][CC][i-1][j][k]
                              - lhsX[1][4][AA][i][j][k]*lhsX[4][2][CC][i-1][j][k];
  lhsX[2][2][BB][i][j][k] = lhsX[2][2][BB][i][j][k] - lhsX[2][0][AA][i][j][k]*lhsX[0][2][CC][i-1][j][k]
                              - lhsX[2][1][AA][i][j][k]*lhsX[1][2][CC][i-1][j][k]
                              - lhsX[2][2][AA][i][j][k]*lhsX[2][2][CC][i-1][j][k]
                              - lhsX[2][3][AA][i][j][k]*lhsX[3][2][CC][i-1][j][k]
                              - lhsX[2][4][AA][i][j][k]*lhsX[4][2][CC][i-1][j][k];
  lhsX[3][2][BB][i][j][k] = lhsX[3][2][BB][i][j][k] - lhsX[3][0][AA][i][j][k]*lhsX[0][2][CC][i-1][j][k]
                              - lhsX[3][1][AA][i][j][k]*lhsX[1][2][CC][i-1][j][k]
                              - lhsX[3][2][AA][i][j][k]*lhsX[2][2][CC][i-1][j][k]
                              - lhsX[3][3][AA][i][j][k]*lhsX[3][2][CC][i-1][j][k]
                              - lhsX[3][4][AA][i][j][k]*lhsX[4][2][CC][i-1][j][k];
  lhsX[4][2][BB][i][j][k] = lhsX[4][2][BB][i][j][k] - lhsX[4][0][AA][i][j][k]*lhsX[0][2][CC][i-1][j][k]
                              - lhsX[4][1][AA][i][j][k]*lhsX[1][2][CC][i-1][j][k]
                              - lhsX[4][2][AA][i][j][k]*lhsX[2][2][CC][i-1][j][k]
                              - lhsX[4][3][AA][i][j][k]*lhsX[3][2][CC][i-1][j][k]
                              - lhsX[4][4][AA][i][j][k]*lhsX[4][2][CC][i-1][j][k];
  lhsX[0][3][BB][i][j][k] = lhsX[0][3][BB][i][j][k] - lhsX[0][0][AA][i][j][k]*lhsX[0][3][CC][i-1][j][k]
                              - lhsX[0][1][AA][i][j][k]*lhsX[1][3][CC][i-1][j][k]
                              - lhsX[0][2][AA][i][j][k]*lhsX[2][3][CC][i-1][j][k]
                              - lhsX[0][3][AA][i][j][k]*lhsX[3][3][CC][i-1][j][k]
                              - lhsX[0][4][AA][i][j][k]*lhsX[4][3][CC][i-1][j][k];
  lhsX[1][3][BB][i][j][k] = lhsX[1][3][BB][i][j][k] - lhsX[1][0][AA][i][j][k]*lhsX[0][3][CC][i-1][j][k]
                              - lhsX[1][1][AA][i][j][k]*lhsX[1][3][CC][i-1][j][k]
                              - lhsX[1][2][AA][i][j][k]*lhsX[2][3][CC][i-1][j][k]
                              - lhsX[1][3][AA][i][j][k]*lhsX[3][3][CC][i-1][j][k]
                              - lhsX[1][4][AA][i][j][k]*lhsX[4][3][CC][i-1][j][k];
  lhsX[2][3][BB][i][j][k] = lhsX[2][3][BB][i][j][k] - lhsX[2][0][AA][i][j][k]*lhsX[0][3][CC][i-1][j][k]
                              - lhsX[2][1][AA][i][j][k]*lhsX[1][3][CC][i-1][j][k]
                              - lhsX[2][2][AA][i][j][k]*lhsX[2][3][CC][i-1][j][k]
                              - lhsX[2][3][AA][i][j][k]*lhsX[3][3][CC][i-1][j][k]
                              - lhsX[2][4][AA][i][j][k]*lhsX[4][3][CC][i-1][j][k];
  lhsX[3][3][BB][i][j][k] = lhsX[3][3][BB][i][j][k] - lhsX[3][0][AA][i][j][k]*lhsX[0][3][CC][i-1][j][k]
                              - lhsX[3][1][AA][i][j][k]*lhsX[1][3][CC][i-1][j][k]
                              - lhsX[3][2][AA][i][j][k]*lhsX[2][3][CC][i-1][j][k]
                              - lhsX[3][3][AA][i][j][k]*lhsX[3][3][CC][i-1][j][k]
                              - lhsX[3][4][AA][i][j][k]*lhsX[4][3][CC][i-1][j][k];
  lhsX[4][3][BB][i][j][k] = lhsX[4][3][BB][i][j][k] - lhsX[4][0][AA][i][j][k]*lhsX[0][3][CC][i-1][j][k]
                              - lhsX[4][1][AA][i][j][k]*lhsX[1][3][CC][i-1][j][k]
                              - lhsX[4][2][AA][i][j][k]*lhsX[2][3][CC][i-1][j][k]
                              - lhsX[4][3][AA][i][j][k]*lhsX[3][3][CC][i-1][j][k]
                              - lhsX[4][4][AA][i][j][k]*lhsX[4][3][CC][i-1][j][k];
  lhsX[0][4][BB][i][j][k] = lhsX[0][4][BB][i][j][k] - lhsX[0][0][AA][i][j][k]*lhsX[0][4][CC][i-1][j][k]
                              - lhsX[0][1][AA][i][j][k]*lhsX[1][4][CC][i-1][j][k]
                              - lhsX[0][2][AA][i][j][k]*lhsX[2][4][CC][i-1][j][k]
                              - lhsX[0][3][AA][i][j][k]*lhsX[3][4][CC][i-1][j][k]
                              - lhsX[0][4][AA][i][j][k]*lhsX[4][4][CC][i-1][j][k];
  lhsX[1][4][BB][i][j][k] = lhsX[1][4][BB][i][j][k] - lhsX[1][0][AA][i][j][k]*lhsX[0][4][CC][i-1][j][k]
                              - lhsX[1][1][AA][i][j][k]*lhsX[1][4][CC][i-1][j][k]
                              - lhsX[1][2][AA][i][j][k]*lhsX[2][4][CC][i-1][j][k]
                              - lhsX[1][3][AA][i][j][k]*lhsX[3][4][CC][i-1][j][k]
                              - lhsX[1][4][AA][i][j][k]*lhsX[4][4][CC][i-1][j][k];
  lhsX[2][4][BB][i][j][k] = lhsX[2][4][BB][i][j][k] - lhsX[2][0][AA][i][j][k]*lhsX[0][4][CC][i-1][j][k]
                              - lhsX[2][1][AA][i][j][k]*lhsX[1][4][CC][i-1][j][k]
                              - lhsX[2][2][AA][i][j][k]*lhsX[2][4][CC][i-1][j][k]
                              - lhsX[2][3][AA][i][j][k]*lhsX[3][4][CC][i-1][j][k]
                              - lhsX[2][4][AA][i][j][k]*lhsX[4][4][CC][i-1][j][k];
  lhsX[3][4][BB][i][j][k] = lhsX[3][4][BB][i][j][k] - lhsX[3][0][AA][i][j][k]*lhsX[0][4][CC][i-1][j][k]
                              - lhsX[3][1][AA][i][j][k]*lhsX[1][4][CC][i-1][j][k]
                              - lhsX[3][2][AA][i][j][k]*lhsX[2][4][CC][i-1][j][k]
                              - lhsX[3][3][AA][i][j][k]*lhsX[3][4][CC][i-1][j][k]
                              - lhsX[3][4][AA][i][j][k]*lhsX[4][4][CC][i-1][j][k];
  lhsX[4][4][BB][i][j][k] = lhsX[4][4][BB][i][j][k] - lhsX[4][0][AA][i][j][k]*lhsX[0][4][CC][i-1][j][k]
                              - lhsX[4][1][AA][i][j][k]*lhsX[1][4][CC][i-1][j][k]
                              - lhsX[4][2][AA][i][j][k]*lhsX[2][4][CC][i-1][j][k]
                              - lhsX[4][3][AA][i][j][k]*lhsX[3][4][CC][i-1][j][k]
                              - lhsX[4][4][AA][i][j][k]*lhsX[4][4][CC][i-1][j][k];

        //-------------------------------------------------------------------
        // multiply c[k][j][i] by b_inverse and copy back to c
        // multiply rhs[j][k][j][0] by b_inverse[k][0] and copy to rhs        //-------------------------------------------------------------------
        //binvcrhs( lhsX[i][j][BB], lhsX[k][i][j][k][CC], rhs[k][j][i] );
		/*
	  	for(m = 0; m < 5; m++){
	  		pivot = 1.00/lhsX[m][m][BB][i][j][k];
			for(n = m+1; n < 5; n++){
				lhsX[m][n][BB][i][j][k] = lhsX[m][n][BB][i][j][k]*pivot;
			}
			lhsX[m][0][CC][i][j][k] = lhsX[m][0][CC][i][j][k]*pivot;
			lhsX[m][1][CC][i][j][k] = lhsX[m][1][CC][i][j][k]*pivot;
			lhsX[m][2][CC][i][j][k] = lhsX[m][2][CC][i][j][k]*pivot;
			lhsX[m][3][CC][i][j][k] = lhsX[m][3][CC][i][j][k]*pivot;
			lhsX[m][4][CC][i][j][k] = lhsX[m][4][CC][i][j][k]*pivot;
			rhs[m][k][j][i] = rhs[m][k][j][i]*pivot;

			for(n = 0; n < 5; n++){
			   if(n != m){
					coeff = lhsX[n][m][BB][i][j][k];
					for(z = m+1; z < 5; z++){
						lhsX[n][z][BB][i][j][k] = lhsX[n][z][BB][i][j][k] - coeff*lhsX[m][z][BB][i][j][k];
					}
					lhsX[n][0][CC][i][j][k] = lhsX[n][0][CC][i][j][k] - coeff*lhsX[m][0][CC][i][j][k];
					lhsX[n][1][CC][i][j][k] = lhsX[n][1][CC][i][j][k] - coeff*lhsX[m][1][CC][i][j][k];
					lhsX[n][2][CC][i][j][k] = lhsX[n][2][CC][i][j][k] - coeff*lhsX[m][2][CC][i][j][k];
					lhsX[n][3][CC][i][j][k] = lhsX[n][3][CC][i][j][k] - coeff*lhsX[m][3][CC][i][j][k];
					lhsX[n][4][CC][i][j][k] = lhsX[n][4][CC][i][j][k] - coeff*lhsX[m][4][CC][i][j][k];
					rhs[n][k][j][i] = rhs[n][k][j][i] - coeff*rhs[m][k][j][i];
				}
			}
	  	}
		*/
  pivot = 1.00/lhsX[0][0][BB][i][j][k];
  lhsX[0][1][BB][i][j][k] = lhsX[0][1][BB][i][j][k]*pivot;
  lhsX[0][2][BB][i][j][k] = lhsX[0][2][BB][i][j][k]*pivot;
  lhsX[0][3][BB][i][j][k] = lhsX[0][3][BB][i][j][k]*pivot;
  lhsX[0][4][BB][i][j][k] = lhsX[0][4][BB][i][j][k]*pivot;
  lhsX[0][0][CC][i][j][k] = lhsX[0][0][CC][i][j][k]*pivot;
  lhsX[0][1][CC][i][j][k] = lhsX[0][1][CC][i][j][k]*pivot;
  lhsX[0][2][CC][i][j][k] = lhsX[0][2][CC][i][j][k]*pivot;
  lhsX[0][3][CC][i][j][k] = lhsX[0][3][CC][i][j][k]*pivot;
  lhsX[0][4][CC][i][j][k] = lhsX[0][4][CC][i][j][k]*pivot;
  rhs[0][k][j][i]   = rhs[0][k][j][i]  *pivot;

  coeff = lhsX[1][0][BB][i][j][k];
  lhsX[1][1][BB][i][j][k]= lhsX[1][1][BB][i][j][k] - coeff*lhsX[0][1][BB][i][j][k];
  lhsX[1][2][BB][i][j][k]= lhsX[1][2][BB][i][j][k] - coeff*lhsX[0][2][BB][i][j][k];
  lhsX[1][3][BB][i][j][k]= lhsX[1][3][BB][i][j][k] - coeff*lhsX[0][3][BB][i][j][k];
  lhsX[1][4][BB][i][j][k]= lhsX[1][4][BB][i][j][k] - coeff*lhsX[0][4][BB][i][j][k];
  lhsX[1][0][CC][i][j][k] = lhsX[1][0][CC][i][j][k] - coeff*lhsX[0][0][CC][i][j][k];
  lhsX[1][1][CC][i][j][k] = lhsX[1][1][CC][i][j][k] - coeff*lhsX[0][1][CC][i][j][k];
  lhsX[1][2][CC][i][j][k] = lhsX[1][2][CC][i][j][k] - coeff*lhsX[0][2][CC][i][j][k];
  lhsX[1][3][CC][i][j][k] = lhsX[1][3][CC][i][j][k] - coeff*lhsX[0][3][CC][i][j][k];
  lhsX[1][4][CC][i][j][k] = lhsX[1][4][CC][i][j][k] - coeff*lhsX[0][4][CC][i][j][k];
  rhs[1][k][j][i]   = rhs[1][k][j][i]   - coeff*rhs[0][k][j][i];

  coeff = lhsX[2][0][BB][i][j][k];
  lhsX[2][1][BB][i][j][k]= lhsX[2][1][BB][i][j][k] - coeff*lhsX[0][1][BB][i][j][k];
  lhsX[2][2][BB][i][j][k]= lhsX[2][2][BB][i][j][k] - coeff*lhsX[0][2][BB][i][j][k];
  lhsX[2][3][BB][i][j][k]= lhsX[2][3][BB][i][j][k] - coeff*lhsX[0][3][BB][i][j][k];
  lhsX[2][4][BB][i][j][k]= lhsX[2][4][BB][i][j][k] - coeff*lhsX[0][4][BB][i][j][k];
  lhsX[2][0][CC][i][j][k] = lhsX[2][0][CC][i][j][k] - coeff*lhsX[0][0][CC][i][j][k];
  lhsX[2][1][CC][i][j][k] = lhsX[2][1][CC][i][j][k] - coeff*lhsX[0][1][CC][i][j][k];
  lhsX[2][2][CC][i][j][k] = lhsX[2][2][CC][i][j][k] - coeff*lhsX[0][2][CC][i][j][k];
  lhsX[2][3][CC][i][j][k] = lhsX[2][3][CC][i][j][k] - coeff*lhsX[0][3][CC][i][j][k];
  lhsX[2][4][CC][i][j][k] = lhsX[2][4][CC][i][j][k] - coeff*lhsX[0][4][CC][i][j][k];
  rhs[2][k][j][i]   = rhs[2][k][j][i]   - coeff*rhs[0][k][j][i];

  coeff = lhsX[3][0][BB][i][j][k];
  lhsX[3][1][BB][i][j][k]= lhsX[3][1][BB][i][j][k] - coeff*lhsX[0][1][BB][i][j][k];
  lhsX[3][2][BB][i][j][k]= lhsX[3][2][BB][i][j][k] - coeff*lhsX[0][2][BB][i][j][k];
  lhsX[3][3][BB][i][j][k]= lhsX[3][3][BB][i][j][k] - coeff*lhsX[0][3][BB][i][j][k];
  lhsX[3][4][BB][i][j][k]= lhsX[3][4][BB][i][j][k] - coeff*lhsX[0][4][BB][i][j][k];
  lhsX[3][0][CC][i][j][k] = lhsX[3][0][CC][i][j][k] - coeff*lhsX[0][0][CC][i][j][k];
  lhsX[3][1][CC][i][j][k] = lhsX[3][1][CC][i][j][k] - coeff*lhsX[0][1][CC][i][j][k];
  lhsX[3][2][CC][i][j][k] = lhsX[3][2][CC][i][j][k] - coeff*lhsX[0][2][CC][i][j][k];
  lhsX[3][3][CC][i][j][k] = lhsX[3][3][CC][i][j][k] - coeff*lhsX[0][3][CC][i][j][k];
  lhsX[3][4][CC][i][j][k] = lhsX[3][4][CC][i][j][k] - coeff*lhsX[0][4][CC][i][j][k];
  rhs[3][k][j][i]   = rhs[3][k][j][i]   - coeff*rhs[0][k][j][i];

  coeff = lhsX[4][0][BB][i][j][k];
  lhsX[4][1][BB][i][j][k]= lhsX[4][1][BB][i][j][k] - coeff*lhsX[0][1][BB][i][j][k];
  lhsX[4][2][BB][i][j][k]= lhsX[4][2][BB][i][j][k] - coeff*lhsX[0][2][BB][i][j][k];
  lhsX[4][3][BB][i][j][k]= lhsX[4][3][BB][i][j][k] - coeff*lhsX[0][3][BB][i][j][k];
  lhsX[4][4][BB][i][j][k]= lhsX[4][4][BB][i][j][k] - coeff*lhsX[0][4][BB][i][j][k];
  lhsX[4][0][CC][i][j][k] = lhsX[4][0][CC][i][j][k] - coeff*lhsX[0][0][CC][i][j][k];
  lhsX[4][1][CC][i][j][k] = lhsX[4][1][CC][i][j][k] - coeff*lhsX[0][1][CC][i][j][k];
  lhsX[4][2][CC][i][j][k] = lhsX[4][2][CC][i][j][k] - coeff*lhsX[0][2][CC][i][j][k];
  lhsX[4][3][CC][i][j][k] = lhsX[4][3][CC][i][j][k] - coeff*lhsX[0][3][CC][i][j][k];
  lhsX[4][4][CC][i][j][k] = lhsX[4][4][CC][i][j][k] - coeff*lhsX[0][4][CC][i][j][k];
  rhs[4][k][j][i]   = rhs[4][k][j][i]   - coeff*rhs[0][k][j][i];


  pivot = 1.00/lhsX[1][1][BB][i][j][k];
  lhsX[1][2][BB][i][j][k] = lhsX[1][2][BB][i][j][k]*pivot;
  lhsX[1][3][BB][i][j][k] = lhsX[1][3][BB][i][j][k]*pivot;
  lhsX[1][4][BB][i][j][k] = lhsX[1][4][BB][i][j][k]*pivot;
  lhsX[1][0][CC][i][j][k] = lhsX[1][0][CC][i][j][k]*pivot;
  lhsX[1][1][CC][i][j][k] = lhsX[1][1][CC][i][j][k]*pivot;
  lhsX[1][2][CC][i][j][k] = lhsX[1][2][CC][i][j][k]*pivot;
  lhsX[1][3][CC][i][j][k] = lhsX[1][3][CC][i][j][k]*pivot;
  lhsX[1][4][CC][i][j][k] = lhsX[1][4][CC][i][j][k]*pivot;
  rhs[1][k][j][i]   = rhs[1][k][j][i]  *pivot;

  coeff = lhsX[0][1][BB][i][j][k];
  lhsX[0][2][BB][i][j][k]= lhsX[0][2][BB][i][j][k] - coeff*lhsX[1][2][BB][i][j][k];
  lhsX[0][3][BB][i][j][k]= lhsX[0][3][BB][i][j][k] - coeff*lhsX[1][3][BB][i][j][k];
  lhsX[0][4][BB][i][j][k]= lhsX[0][4][BB][i][j][k] - coeff*lhsX[1][4][BB][i][j][k];
  lhsX[0][0][CC][i][j][k] = lhsX[0][0][CC][i][j][k] - coeff*lhsX[1][0][CC][i][j][k];
  lhsX[0][1][CC][i][j][k] = lhsX[0][1][CC][i][j][k] - coeff*lhsX[1][1][CC][i][j][k];
  lhsX[0][2][CC][i][j][k] = lhsX[0][2][CC][i][j][k] - coeff*lhsX[1][2][CC][i][j][k];
  lhsX[0][3][CC][i][j][k] = lhsX[0][3][CC][i][j][k] - coeff*lhsX[1][3][CC][i][j][k];
  lhsX[0][4][CC][i][j][k] = lhsX[0][4][CC][i][j][k] - coeff*lhsX[1][4][CC][i][j][k];
  rhs[0][k][j][i]   = rhs[0][k][j][i]   - coeff*rhs[1][k][j][i];

  coeff = lhsX[2][1][BB][i][j][k];
  lhsX[2][2][BB][i][j][k]= lhsX[2][2][BB][i][j][k] - coeff*lhsX[1][2][BB][i][j][k];
  lhsX[2][3][BB][i][j][k]= lhsX[2][3][BB][i][j][k] - coeff*lhsX[1][3][BB][i][j][k];
  lhsX[2][4][BB][i][j][k]= lhsX[2][4][BB][i][j][k] - coeff*lhsX[1][4][BB][i][j][k];
  lhsX[2][0][CC][i][j][k] = lhsX[2][0][CC][i][j][k] - coeff*lhsX[1][0][CC][i][j][k];
  lhsX[2][1][CC][i][j][k] = lhsX[2][1][CC][i][j][k] - coeff*lhsX[1][1][CC][i][j][k];
  lhsX[2][2][CC][i][j][k] = lhsX[2][2][CC][i][j][k] - coeff*lhsX[1][2][CC][i][j][k];
  lhsX[2][3][CC][i][j][k] = lhsX[2][3][CC][i][j][k] - coeff*lhsX[1][3][CC][i][j][k];
  lhsX[2][4][CC][i][j][k] = lhsX[2][4][CC][i][j][k] - coeff*lhsX[1][4][CC][i][j][k];
  rhs[2][k][j][i]   = rhs[2][k][j][i]   - coeff*rhs[1][k][j][i];

  coeff = lhsX[3][1][BB][i][j][k];
  lhsX[3][2][BB][i][j][k]= lhsX[3][2][BB][i][j][k] - coeff*lhsX[1][2][BB][i][j][k];
  lhsX[3][3][BB][i][j][k]= lhsX[3][3][BB][i][j][k] - coeff*lhsX[1][3][BB][i][j][k];
  lhsX[3][4][BB][i][j][k]= lhsX[3][4][BB][i][j][k] - coeff*lhsX[1][4][BB][i][j][k];
  lhsX[3][0][CC][i][j][k] = lhsX[3][0][CC][i][j][k] - coeff*lhsX[1][0][CC][i][j][k];
  lhsX[3][1][CC][i][j][k] = lhsX[3][1][CC][i][j][k] - coeff*lhsX[1][1][CC][i][j][k];
  lhsX[3][2][CC][i][j][k] = lhsX[3][2][CC][i][j][k] - coeff*lhsX[1][2][CC][i][j][k];
  lhsX[3][3][CC][i][j][k] = lhsX[3][3][CC][i][j][k] - coeff*lhsX[1][3][CC][i][j][k];
  lhsX[3][4][CC][i][j][k] = lhsX[3][4][CC][i][j][k] - coeff*lhsX[1][4][CC][i][j][k];
  rhs[3][k][j][i]   = rhs[3][k][j][i]   - coeff*rhs[1][k][j][i];

  coeff = lhsX[4][1][BB][i][j][k];
  lhsX[4][2][BB][i][j][k]= lhsX[4][2][BB][i][j][k] - coeff*lhsX[1][2][BB][i][j][k];
  lhsX[4][3][BB][i][j][k]= lhsX[4][3][BB][i][j][k] - coeff*lhsX[1][3][BB][i][j][k];
  lhsX[4][4][BB][i][j][k]= lhsX[4][4][BB][i][j][k] - coeff*lhsX[1][4][BB][i][j][k];
  lhsX[4][0][CC][i][j][k] = lhsX[4][0][CC][i][j][k] - coeff*lhsX[1][0][CC][i][j][k];
  lhsX[4][1][CC][i][j][k] = lhsX[4][1][CC][i][j][k] - coeff*lhsX[1][1][CC][i][j][k];
  lhsX[4][2][CC][i][j][k] = lhsX[4][2][CC][i][j][k] - coeff*lhsX[1][2][CC][i][j][k];
  lhsX[4][3][CC][i][j][k] = lhsX[4][3][CC][i][j][k] - coeff*lhsX[1][3][CC][i][j][k];
  lhsX[4][4][CC][i][j][k] = lhsX[4][4][CC][i][j][k] - coeff*lhsX[1][4][CC][i][j][k];
  rhs[4][k][j][i]   = rhs[4][k][j][i]   - coeff*rhs[1][k][j][i];


  pivot = 1.00/lhsX[2][2][BB][i][j][k];
  lhsX[2][3][BB][i][j][k] = lhsX[2][3][BB][i][j][k]*pivot;
  lhsX[2][4][BB][i][j][k] = lhsX[2][4][BB][i][j][k]*pivot;
  lhsX[2][0][CC][i][j][k] = lhsX[2][0][CC][i][j][k]*pivot;
  lhsX[2][1][CC][i][j][k] = lhsX[2][1][CC][i][j][k]*pivot;
  lhsX[2][2][CC][i][j][k] = lhsX[2][2][CC][i][j][k]*pivot;
  lhsX[2][3][CC][i][j][k] = lhsX[2][3][CC][i][j][k]*pivot;
  lhsX[2][4][CC][i][j][k] = lhsX[2][4][CC][i][j][k]*pivot;
  rhs[2][k][j][i]   = rhs[2][k][j][i]  *pivot;

  coeff = lhsX[0][2][BB][i][j][k];
  lhsX[0][3][BB][i][j][k]= lhsX[0][3][BB][i][j][k] - coeff*lhsX[2][3][BB][i][j][k];
  lhsX[0][4][BB][i][j][k]= lhsX[0][4][BB][i][j][k] - coeff*lhsX[2][4][BB][i][j][k];
  lhsX[0][0][CC][i][j][k] = lhsX[0][0][CC][i][j][k] - coeff*lhsX[2][0][CC][i][j][k];
  lhsX[0][1][CC][i][j][k] = lhsX[0][1][CC][i][j][k] - coeff*lhsX[2][1][CC][i][j][k];
  lhsX[0][2][CC][i][j][k] = lhsX[0][2][CC][i][j][k] - coeff*lhsX[2][2][CC][i][j][k];
  lhsX[0][3][CC][i][j][k] = lhsX[0][3][CC][i][j][k] - coeff*lhsX[2][3][CC][i][j][k];
  lhsX[0][4][CC][i][j][k] = lhsX[0][4][CC][i][j][k] - coeff*lhsX[2][4][CC][i][j][k];
  rhs[0][k][j][i]   = rhs[0][k][j][i]   - coeff*rhs[2][k][j][i];

  coeff = lhsX[1][2][BB][i][j][k];
  lhsX[1][3][BB][i][j][k]= lhsX[1][3][BB][i][j][k] - coeff*lhsX[2][3][BB][i][j][k];
  lhsX[1][4][BB][i][j][k]= lhsX[1][4][BB][i][j][k] - coeff*lhsX[2][4][BB][i][j][k];
  lhsX[1][0][CC][i][j][k] = lhsX[1][0][CC][i][j][k] - coeff*lhsX[2][0][CC][i][j][k];
  lhsX[1][1][CC][i][j][k] = lhsX[1][1][CC][i][j][k] - coeff*lhsX[2][1][CC][i][j][k];
  lhsX[1][2][CC][i][j][k] = lhsX[1][2][CC][i][j][k] - coeff*lhsX[2][2][CC][i][j][k];
  lhsX[1][3][CC][i][j][k] = lhsX[1][3][CC][i][j][k] - coeff*lhsX[2][3][CC][i][j][k];
  lhsX[1][4][CC][i][j][k] = lhsX[1][4][CC][i][j][k] - coeff*lhsX[2][4][CC][i][j][k];
  rhs[1][k][j][i]   = rhs[1][k][j][i]   - coeff*rhs[2][k][j][i];

  coeff = lhsX[3][2][BB][i][j][k];
  lhsX[3][3][BB][i][j][k]= lhsX[3][3][BB][i][j][k] - coeff*lhsX[2][3][BB][i][j][k];
  lhsX[3][4][BB][i][j][k]= lhsX[3][4][BB][i][j][k] - coeff*lhsX[2][4][BB][i][j][k];
  lhsX[3][0][CC][i][j][k] = lhsX[3][0][CC][i][j][k] - coeff*lhsX[2][0][CC][i][j][k];
  lhsX[3][1][CC][i][j][k] = lhsX[3][1][CC][i][j][k] - coeff*lhsX[2][1][CC][i][j][k];
  lhsX[3][2][CC][i][j][k] = lhsX[3][2][CC][i][j][k] - coeff*lhsX[2][2][CC][i][j][k];
  lhsX[3][3][CC][i][j][k] = lhsX[3][3][CC][i][j][k] - coeff*lhsX[2][3][CC][i][j][k];
  lhsX[3][4][CC][i][j][k] = lhsX[3][4][CC][i][j][k] - coeff*lhsX[2][4][CC][i][j][k];
  rhs[3][k][j][i]   = rhs[3][k][j][i]   - coeff*rhs[2][k][j][i];

  coeff = lhsX[4][2][BB][i][j][k];
  lhsX[4][3][BB][i][j][k]= lhsX[4][3][BB][i][j][k] - coeff*lhsX[2][3][BB][i][j][k];
  lhsX[4][4][BB][i][j][k]= lhsX[4][4][BB][i][j][k] - coeff*lhsX[2][4][BB][i][j][k];
  lhsX[4][0][CC][i][j][k] = lhsX[4][0][CC][i][j][k] - coeff*lhsX[2][0][CC][i][j][k];
  lhsX[4][1][CC][i][j][k] = lhsX[4][1][CC][i][j][k] - coeff*lhsX[2][1][CC][i][j][k];
  lhsX[4][2][CC][i][j][k] = lhsX[4][2][CC][i][j][k] - coeff*lhsX[2][2][CC][i][j][k];
  lhsX[4][3][CC][i][j][k] = lhsX[4][3][CC][i][j][k] - coeff*lhsX[2][3][CC][i][j][k];
  lhsX[4][4][CC][i][j][k] = lhsX[4][4][CC][i][j][k] - coeff*lhsX[2][4][CC][i][j][k];
  rhs[4][k][j][i]   = rhs[4][k][j][i]   - coeff*rhs[2][k][j][i];


  pivot = 1.00/lhsX[3][3][BB][i][j][k];
  lhsX[3][4][BB][i][j][k] = lhsX[3][4][BB][i][j][k]*pivot;
  lhsX[3][0][CC][i][j][k] = lhsX[3][0][CC][i][j][k]*pivot;
  lhsX[3][1][CC][i][j][k] = lhsX[3][1][CC][i][j][k]*pivot;
  lhsX[3][2][CC][i][j][k] = lhsX[3][2][CC][i][j][k]*pivot;
  lhsX[3][3][CC][i][j][k] = lhsX[3][3][CC][i][j][k]*pivot;
  lhsX[3][4][CC][i][j][k] = lhsX[3][4][CC][i][j][k]*pivot;
  rhs[3][k][j][i]   = rhs[3][k][j][i]  *pivot;

  coeff = lhsX[0][3][BB][i][j][k];
  lhsX[0][4][BB][i][j][k]= lhsX[0][4][BB][i][j][k] - coeff*lhsX[3][4][BB][i][j][k];
  lhsX[0][0][CC][i][j][k] = lhsX[0][0][CC][i][j][k] - coeff*lhsX[3][0][CC][i][j][k];
  lhsX[0][1][CC][i][j][k] = lhsX[0][1][CC][i][j][k] - coeff*lhsX[3][1][CC][i][j][k];
  lhsX[0][2][CC][i][j][k] = lhsX[0][2][CC][i][j][k] - coeff*lhsX[3][2][CC][i][j][k];
  lhsX[0][3][CC][i][j][k] = lhsX[0][3][CC][i][j][k] - coeff*lhsX[3][3][CC][i][j][k];
  lhsX[0][4][CC][i][j][k] = lhsX[0][4][CC][i][j][k] - coeff*lhsX[3][4][CC][i][j][k];
  rhs[0][k][j][i]   = rhs[0][k][j][i]   - coeff*rhs[3][k][j][i];

  coeff = lhsX[1][3][BB][i][j][k];
  lhsX[1][4][BB][i][j][k]= lhsX[1][4][BB][i][j][k] - coeff*lhsX[3][4][BB][i][j][k];
  lhsX[1][0][CC][i][j][k] = lhsX[1][0][CC][i][j][k] - coeff*lhsX[3][0][CC][i][j][k];
  lhsX[1][1][CC][i][j][k] = lhsX[1][1][CC][i][j][k] - coeff*lhsX[3][1][CC][i][j][k];
  lhsX[1][2][CC][i][j][k] = lhsX[1][2][CC][i][j][k] - coeff*lhsX[3][2][CC][i][j][k];
  lhsX[1][3][CC][i][j][k] = lhsX[1][3][CC][i][j][k] - coeff*lhsX[3][3][CC][i][j][k];
  lhsX[1][4][CC][i][j][k] = lhsX[1][4][CC][i][j][k] - coeff*lhsX[3][4][CC][i][j][k];
  rhs[1][k][j][i]   = rhs[1][k][j][i]   - coeff*rhs[3][k][j][i];

  coeff = lhsX[2][3][BB][i][j][k];
  lhsX[2][4][BB][i][j][k]= lhsX[2][4][BB][i][j][k] - coeff*lhsX[3][4][BB][i][j][k];
  lhsX[2][0][CC][i][j][k] = lhsX[2][0][CC][i][j][k] - coeff*lhsX[3][0][CC][i][j][k];
  lhsX[2][1][CC][i][j][k] = lhsX[2][1][CC][i][j][k] - coeff*lhsX[3][1][CC][i][j][k];
  lhsX[2][2][CC][i][j][k] = lhsX[2][2][CC][i][j][k] - coeff*lhsX[3][2][CC][i][j][k];
  lhsX[2][3][CC][i][j][k] = lhsX[2][3][CC][i][j][k] - coeff*lhsX[3][3][CC][i][j][k];
  lhsX[2][4][CC][i][j][k] = lhsX[2][4][CC][i][j][k] - coeff*lhsX[3][4][CC][i][j][k];
  rhs[2][k][j][i]   = rhs[2][k][j][i]   - coeff*rhs[3][k][j][i];

  coeff = lhsX[4][3][BB][i][j][k];
  lhsX[4][4][BB][i][j][k]= lhsX[4][4][BB][i][j][k] - coeff*lhsX[3][4][BB][i][j][k];
  lhsX[4][0][CC][i][j][k] = lhsX[4][0][CC][i][j][k] - coeff*lhsX[3][0][CC][i][j][k];
  lhsX[4][1][CC][i][j][k] = lhsX[4][1][CC][i][j][k] - coeff*lhsX[3][1][CC][i][j][k];
  lhsX[4][2][CC][i][j][k] = lhsX[4][2][CC][i][j][k] - coeff*lhsX[3][2][CC][i][j][k];
  lhsX[4][3][CC][i][j][k] = lhsX[4][3][CC][i][j][k] - coeff*lhsX[3][3][CC][i][j][k];
  lhsX[4][4][CC][i][j][k] = lhsX[4][4][CC][i][j][k] - coeff*lhsX[3][4][CC][i][j][k];
  rhs[4][k][j][i]   = rhs[4][k][j][i]   - coeff*rhs[3][k][j][i];


  pivot = 1.00/lhsX[4][4][BB][i][j][k];
  lhsX[4][0][CC][i][j][k] = lhsX[4][0][CC][i][j][k]*pivot;
  lhsX[4][1][CC][i][j][k] = lhsX[4][1][CC][i][j][k]*pivot;
  lhsX[4][2][CC][i][j][k] = lhsX[4][2][CC][i][j][k]*pivot;
  lhsX[4][3][CC][i][j][k] = lhsX[4][3][CC][i][j][k]*pivot;
  lhsX[4][4][CC][i][j][k] = lhsX[4][4][CC][i][j][k]*pivot;
  rhs[4][k][j][i]   = rhs[4][k][j][i]  *pivot;

  coeff = lhsX[0][4][BB][i][j][k];
  lhsX[0][0][CC][i][j][k] = lhsX[0][0][CC][i][j][k] - coeff*lhsX[4][0][CC][i][j][k];
  lhsX[0][1][CC][i][j][k] = lhsX[0][1][CC][i][j][k] - coeff*lhsX[4][1][CC][i][j][k];
  lhsX[0][2][CC][i][j][k] = lhsX[0][2][CC][i][j][k] - coeff*lhsX[4][2][CC][i][j][k];
  lhsX[0][3][CC][i][j][k] = lhsX[0][3][CC][i][j][k] - coeff*lhsX[4][3][CC][i][j][k];
  lhsX[0][4][CC][i][j][k] = lhsX[0][4][CC][i][j][k] - coeff*lhsX[4][4][CC][i][j][k];
  rhs[0][k][j][i]   = rhs[0][k][j][i]   - coeff*rhs[4][k][j][i];

  coeff = lhsX[1][4][BB][i][j][k];
  lhsX[1][0][CC][i][j][k] = lhsX[1][0][CC][i][j][k] - coeff*lhsX[4][0][CC][i][j][k];
  lhsX[1][1][CC][i][j][k] = lhsX[1][1][CC][i][j][k] - coeff*lhsX[4][1][CC][i][j][k];
  lhsX[1][2][CC][i][j][k] = lhsX[1][2][CC][i][j][k] - coeff*lhsX[4][2][CC][i][j][k];
  lhsX[1][3][CC][i][j][k] = lhsX[1][3][CC][i][j][k] - coeff*lhsX[4][3][CC][i][j][k];
  lhsX[1][4][CC][i][j][k] = lhsX[1][4][CC][i][j][k] - coeff*lhsX[4][4][CC][i][j][k];
  rhs[1][k][j][i]   = rhs[1][k][j][i]   - coeff*rhs[4][k][j][i];

  coeff = lhsX[2][4][BB][i][j][k];
  lhsX[2][0][CC][i][j][k] = lhsX[2][0][CC][i][j][k] - coeff*lhsX[4][0][CC][i][j][k];
  lhsX[2][1][CC][i][j][k] = lhsX[2][1][CC][i][j][k] - coeff*lhsX[4][1][CC][i][j][k];
  lhsX[2][2][CC][i][j][k] = lhsX[2][2][CC][i][j][k] - coeff*lhsX[4][2][CC][i][j][k];
  lhsX[2][3][CC][i][j][k] = lhsX[2][3][CC][i][j][k] - coeff*lhsX[4][3][CC][i][j][k];
  lhsX[2][4][CC][i][j][k] = lhsX[2][4][CC][i][j][k] - coeff*lhsX[4][4][CC][i][j][k];
  rhs[2][k][j][i]   = rhs[2][k][j][i]   - coeff*rhs[4][k][j][i];

  coeff = lhsX[3][4][BB][i][j][k];
  lhsX[3][0][CC][i][j][k] = lhsX[3][0][CC][i][j][k] - coeff*lhsX[4][0][CC][i][j][k];
  lhsX[3][1][CC][i][j][k] = lhsX[3][1][CC][i][j][k] - coeff*lhsX[4][1][CC][i][j][k];
  lhsX[3][2][CC][i][j][k] = lhsX[3][2][CC][i][j][k] - coeff*lhsX[4][2][CC][i][j][k];
  lhsX[3][3][CC][i][j][k] = lhsX[3][3][CC][i][j][k] - coeff*lhsX[4][3][CC][i][j][k];
  lhsX[3][4][CC][i][j][k] = lhsX[3][4][CC][i][j][k] - coeff*lhsX[4][4][CC][i][j][k];
  rhs[3][k][j][i]   = rhs[3][k][j][i]   - coeff*rhs[4][k][j][i];


      }/*end i*/
    }
  }
      //---------------------------------------------------------------------
      // rhs(isize) = rhs(isize) - A*rhs(isize-1)
      //---------------------------------------------------------------------
      //matvec_sub(lhsX[isize-1][j][AA], rhs[k][k][isize][j], rhs[k][j][isize]);
    #pragma acc parallel loop gang num_gangs(gp12) num_workers(4) vector_length(32)
    for (j = 1; j <= gp12; j++) {
  #pragma acc loop worker vector
  for (k = 1; k <= gp22; k++) {
	/*
		for(m = 0; m < 5; m++){
			rhs[m][k][j][isize] = rhs[m][k][j][isize] - lhsX[m][0][AA][isize][j][k]*rhs[0][k][j][isize-1]
											          - lhsX[m][1][AA][isize][j][k]*rhs[1][k][j][isize-1]
											          - lhsX[m][2][AA][isize][j][k]*rhs[2][k][j][isize-1]
											          - lhsX[m][3][AA][isize][j][k]*rhs[3][k][j][isize-1]
											          - lhsX[m][4][AA][isize][j][k]*rhs[4][k][j][isize-1];
		}
	*/
  rhs[0][k][j][isize] = rhs[0][k][j][isize] - lhsX[0][0][AA][isize][j][k]*rhs[0][k][j][isize-1]
                    - lhsX[0][1][AA][isize][j][k]*rhs[1][k][j][isize-1]
                    - lhsX[0][2][AA][isize][j][k]*rhs[2][k][j][isize-1]
                    - lhsX[0][3][AA][isize][j][k]*rhs[3][k][j][isize-1]
                    - lhsX[0][4][AA][isize][j][k]*rhs[4][k][j][isize-1];
  rhs[1][k][j][isize] = rhs[1][k][j][isize] - lhsX[1][0][AA][isize][j][k]*rhs[0][k][j][isize-1]
                    - lhsX[1][1][AA][isize][j][k]*rhs[1][k][j][isize-1]
                    - lhsX[1][2][AA][isize][j][k]*rhs[2][k][j][isize-1]
                    - lhsX[1][3][AA][isize][j][k]*rhs[3][k][j][isize-1]
                    - lhsX[1][4][AA][isize][j][k]*rhs[4][k][j][isize-1];
  rhs[2][k][j][isize] = rhs[2][k][j][isize] - lhsX[2][0][AA][isize][j][k]*rhs[0][k][j][isize-1]
                    - lhsX[2][1][AA][isize][j][k]*rhs[1][k][j][isize-1]
                    - lhsX[2][2][AA][isize][j][k]*rhs[2][k][j][isize-1]
                    - lhsX[2][3][AA][isize][j][k]*rhs[3][k][j][isize-1]
                    - lhsX[2][4][AA][isize][j][k]*rhs[4][k][j][isize-1];
  rhs[3][k][j][isize] = rhs[3][k][j][isize] - lhsX[3][0][AA][isize][j][k]*rhs[0][k][j][isize-1]
                    - lhsX[3][1][AA][isize][j][k]*rhs[1][k][j][isize-1]
                    - lhsX[3][2][AA][isize][j][k]*rhs[2][k][j][isize-1]
                    - lhsX[3][3][AA][isize][j][k]*rhs[3][k][j][isize-1]
                    - lhsX[3][4][AA][isize][j][k]*rhs[4][k][j][isize-1];
  rhs[4][k][j][isize] = rhs[4][k][j][isize] - lhsX[4][0][AA][isize][j][k]*rhs[0][k][j][isize-1]
                    - lhsX[4][1][AA][isize][j][k]*rhs[1][k][j][isize-1]
                    - lhsX[4][2][AA][isize][j][k]*rhs[2][k][j][isize-1]
                    - lhsX[4][3][AA][isize][j][k]*rhs[3][k][j][isize-1]
                    - lhsX[4][4][AA][isize][j][k]*rhs[4][k][j][isize-1];


	 }
  }
      //---------------------------------------------------------------------
      // B(isize) = B(isize) - C(isize-1)*A(isize)
      //---------------------------------------------------------------------
      //matmul_sub(lhsX[isize-1][j][AA], lhsX[k][isize][j][k][CC], lhsX[k][j][isize][BB]);
    #pragma acc parallel loop gang num_gangs(gp12) num_workers(4) vector_length(32)
    for (j = 1; j <= gp12; j++) {
  #pragma acc loop worker vector
  for (k = 1; k <= gp22; k++) {
	/*
	  for(m = 0; m < 5; m++){
	  	for(n = 0; n < 5; n++){
			lhsX[n][m][BB][isize][j][k] = lhsX[n][m][BB][isize][j][k] - lhsX[n][0][AA][isize][j][k]*lhsX[0][m][CC][isize-1][j][k]
														- lhsX[n][1][AA][isize][j][k]*lhsX[1][m][CC][isize-1][j][k]
														- lhsX[n][2][AA][isize][j][k]*lhsX[2][m][CC][isize-1][j][k]
														- lhsX[n][3][AA][isize][j][k]*lhsX[3][m][CC][isize-1][j][k]
														- lhsX[n][4][AA][isize][j][k]*lhsX[4][m][CC][isize-1][j][k];
		}
	  }
	 */
  lhsX[0][0][BB][isize][j][k] = lhsX[0][0][BB][isize][j][k] - lhsX[0][0][AA][isize][j][k]*lhsX[0][0][CC][isize-1][j][k]
                              - lhsX[0][1][AA][isize][j][k]*lhsX[1][0][CC][isize-1][j][k]
                              - lhsX[0][2][AA][isize][j][k]*lhsX[2][0][CC][isize-1][j][k]
                              - lhsX[0][3][AA][isize][j][k]*lhsX[3][0][CC][isize-1][j][k]
                              - lhsX[0][4][AA][isize][j][k]*lhsX[4][0][CC][isize-1][j][k];
  lhsX[1][0][BB][isize][j][k] = lhsX[1][0][BB][isize][j][k] - lhsX[1][0][AA][isize][j][k]*lhsX[0][0][CC][isize-1][j][k]
                              - lhsX[1][1][AA][isize][j][k]*lhsX[1][0][CC][isize-1][j][k]
                              - lhsX[1][2][AA][isize][j][k]*lhsX[2][0][CC][isize-1][j][k]
                              - lhsX[1][3][AA][isize][j][k]*lhsX[3][0][CC][isize-1][j][k]
                              - lhsX[1][4][AA][isize][j][k]*lhsX[4][0][CC][isize-1][j][k];
  lhsX[2][0][BB][isize][j][k] = lhsX[2][0][BB][isize][j][k] - lhsX[2][0][AA][isize][j][k]*lhsX[0][0][CC][isize-1][j][k]
                              - lhsX[2][1][AA][isize][j][k]*lhsX[1][0][CC][isize-1][j][k]
                              - lhsX[2][2][AA][isize][j][k]*lhsX[2][0][CC][isize-1][j][k]
                              - lhsX[2][3][AA][isize][j][k]*lhsX[3][0][CC][isize-1][j][k]
                              - lhsX[2][4][AA][isize][j][k]*lhsX[4][0][CC][isize-1][j][k];
  lhsX[3][0][BB][isize][j][k] = lhsX[3][0][BB][isize][j][k] - lhsX[3][0][AA][isize][j][k]*lhsX[0][0][CC][isize-1][j][k]
                              - lhsX[3][1][AA][isize][j][k]*lhsX[1][0][CC][isize-1][j][k]
                              - lhsX[3][2][AA][isize][j][k]*lhsX[2][0][CC][isize-1][j][k]
                              - lhsX[3][3][AA][isize][j][k]*lhsX[3][0][CC][isize-1][j][k]
                              - lhsX[3][4][AA][isize][j][k]*lhsX[4][0][CC][isize-1][j][k];
  lhsX[4][0][BB][isize][j][k] = lhsX[4][0][BB][isize][j][k] - lhsX[4][0][AA][isize][j][k]*lhsX[0][0][CC][isize-1][j][k]
                              - lhsX[4][1][AA][isize][j][k]*lhsX[1][0][CC][isize-1][j][k]
                              - lhsX[4][2][AA][isize][j][k]*lhsX[2][0][CC][isize-1][j][k]
                              - lhsX[4][3][AA][isize][j][k]*lhsX[3][0][CC][isize-1][j][k]
                              - lhsX[4][4][AA][isize][j][k]*lhsX[4][0][CC][isize-1][j][k];
  lhsX[0][1][BB][isize][j][k] = lhsX[0][1][BB][isize][j][k] - lhsX[0][0][AA][isize][j][k]*lhsX[0][1][CC][isize-1][j][k]
                              - lhsX[0][1][AA][isize][j][k]*lhsX[1][1][CC][isize-1][j][k]
                              - lhsX[0][2][AA][isize][j][k]*lhsX[2][1][CC][isize-1][j][k]
                              - lhsX[0][3][AA][isize][j][k]*lhsX[3][1][CC][isize-1][j][k]
                              - lhsX[0][4][AA][isize][j][k]*lhsX[4][1][CC][isize-1][j][k];
  lhsX[1][1][BB][isize][j][k] = lhsX[1][1][BB][isize][j][k] - lhsX[1][0][AA][isize][j][k]*lhsX[0][1][CC][isize-1][j][k]
                              - lhsX[1][1][AA][isize][j][k]*lhsX[1][1][CC][isize-1][j][k]
                              - lhsX[1][2][AA][isize][j][k]*lhsX[2][1][CC][isize-1][j][k]
                              - lhsX[1][3][AA][isize][j][k]*lhsX[3][1][CC][isize-1][j][k]
                              - lhsX[1][4][AA][isize][j][k]*lhsX[4][1][CC][isize-1][j][k];
  lhsX[2][1][BB][isize][j][k] = lhsX[2][1][BB][isize][j][k] - lhsX[2][0][AA][isize][j][k]*lhsX[0][1][CC][isize-1][j][k]
                              - lhsX[2][1][AA][isize][j][k]*lhsX[1][1][CC][isize-1][j][k]
                              - lhsX[2][2][AA][isize][j][k]*lhsX[2][1][CC][isize-1][j][k]
                              - lhsX[2][3][AA][isize][j][k]*lhsX[3][1][CC][isize-1][j][k]
                              - lhsX[2][4][AA][isize][j][k]*lhsX[4][1][CC][isize-1][j][k];
  lhsX[3][1][BB][isize][j][k] = lhsX[3][1][BB][isize][j][k] - lhsX[3][0][AA][isize][j][k]*lhsX[0][1][CC][isize-1][j][k]
                              - lhsX[3][1][AA][isize][j][k]*lhsX[1][1][CC][isize-1][j][k]
                              - lhsX[3][2][AA][isize][j][k]*lhsX[2][1][CC][isize-1][j][k]
                              - lhsX[3][3][AA][isize][j][k]*lhsX[3][1][CC][isize-1][j][k]
                              - lhsX[3][4][AA][isize][j][k]*lhsX[4][1][CC][isize-1][j][k];
  lhsX[4][1][BB][isize][j][k] = lhsX[4][1][BB][isize][j][k] - lhsX[4][0][AA][isize][j][k]*lhsX[0][1][CC][isize-1][j][k]
                              - lhsX[4][1][AA][isize][j][k]*lhsX[1][1][CC][isize-1][j][k]
                              - lhsX[4][2][AA][isize][j][k]*lhsX[2][1][CC][isize-1][j][k]
                              - lhsX[4][3][AA][isize][j][k]*lhsX[3][1][CC][isize-1][j][k]
                              - lhsX[4][4][AA][isize][j][k]*lhsX[4][1][CC][isize-1][j][k];
  lhsX[0][2][BB][isize][j][k] = lhsX[0][2][BB][isize][j][k] - lhsX[0][0][AA][isize][j][k]*lhsX[0][2][CC][isize-1][j][k]
                              - lhsX[0][1][AA][isize][j][k]*lhsX[1][2][CC][isize-1][j][k]
                              - lhsX[0][2][AA][isize][j][k]*lhsX[2][2][CC][isize-1][j][k]
                              - lhsX[0][3][AA][isize][j][k]*lhsX[3][2][CC][isize-1][j][k]
                              - lhsX[0][4][AA][isize][j][k]*lhsX[4][2][CC][isize-1][j][k];
  lhsX[1][2][BB][isize][j][k] = lhsX[1][2][BB][isize][j][k] - lhsX[1][0][AA][isize][j][k]*lhsX[0][2][CC][isize-1][j][k]
                              - lhsX[1][1][AA][isize][j][k]*lhsX[1][2][CC][isize-1][j][k]
                              - lhsX[1][2][AA][isize][j][k]*lhsX[2][2][CC][isize-1][j][k]
                              - lhsX[1][3][AA][isize][j][k]*lhsX[3][2][CC][isize-1][j][k]
                              - lhsX[1][4][AA][isize][j][k]*lhsX[4][2][CC][isize-1][j][k];
  lhsX[2][2][BB][isize][j][k] = lhsX[2][2][BB][isize][j][k] - lhsX[2][0][AA][isize][j][k]*lhsX[0][2][CC][isize-1][j][k]
                              - lhsX[2][1][AA][isize][j][k]*lhsX[1][2][CC][isize-1][j][k]
                              - lhsX[2][2][AA][isize][j][k]*lhsX[2][2][CC][isize-1][j][k]
                              - lhsX[2][3][AA][isize][j][k]*lhsX[3][2][CC][isize-1][j][k]
                              - lhsX[2][4][AA][isize][j][k]*lhsX[4][2][CC][isize-1][j][k];
  lhsX[3][2][BB][isize][j][k] = lhsX[3][2][BB][isize][j][k] - lhsX[3][0][AA][isize][j][k]*lhsX[0][2][CC][isize-1][j][k]
                              - lhsX[3][1][AA][isize][j][k]*lhsX[1][2][CC][isize-1][j][k]
                              - lhsX[3][2][AA][isize][j][k]*lhsX[2][2][CC][isize-1][j][k]
                              - lhsX[3][3][AA][isize][j][k]*lhsX[3][2][CC][isize-1][j][k]
                              - lhsX[3][4][AA][isize][j][k]*lhsX[4][2][CC][isize-1][j][k];
  lhsX[4][2][BB][isize][j][k] = lhsX[4][2][BB][isize][j][k] - lhsX[4][0][AA][isize][j][k]*lhsX[0][2][CC][isize-1][j][k]
                              - lhsX[4][1][AA][isize][j][k]*lhsX[1][2][CC][isize-1][j][k]
                              - lhsX[4][2][AA][isize][j][k]*lhsX[2][2][CC][isize-1][j][k]
                              - lhsX[4][3][AA][isize][j][k]*lhsX[3][2][CC][isize-1][j][k]
                              - lhsX[4][4][AA][isize][j][k]*lhsX[4][2][CC][isize-1][j][k];
  lhsX[0][3][BB][isize][j][k] = lhsX[0][3][BB][isize][j][k] - lhsX[0][0][AA][isize][j][k]*lhsX[0][3][CC][isize-1][j][k]
                              - lhsX[0][1][AA][isize][j][k]*lhsX[1][3][CC][isize-1][j][k]
                              - lhsX[0][2][AA][isize][j][k]*lhsX[2][3][CC][isize-1][j][k]
                              - lhsX[0][3][AA][isize][j][k]*lhsX[3][3][CC][isize-1][j][k]
                              - lhsX[0][4][AA][isize][j][k]*lhsX[4][3][CC][isize-1][j][k];
  lhsX[1][3][BB][isize][j][k] = lhsX[1][3][BB][isize][j][k] - lhsX[1][0][AA][isize][j][k]*lhsX[0][3][CC][isize-1][j][k]
                              - lhsX[1][1][AA][isize][j][k]*lhsX[1][3][CC][isize-1][j][k]
                              - lhsX[1][2][AA][isize][j][k]*lhsX[2][3][CC][isize-1][j][k]
                              - lhsX[1][3][AA][isize][j][k]*lhsX[3][3][CC][isize-1][j][k]
                              - lhsX[1][4][AA][isize][j][k]*lhsX[4][3][CC][isize-1][j][k];
  lhsX[2][3][BB][isize][j][k] = lhsX[2][3][BB][isize][j][k] - lhsX[2][0][AA][isize][j][k]*lhsX[0][3][CC][isize-1][j][k]
                              - lhsX[2][1][AA][isize][j][k]*lhsX[1][3][CC][isize-1][j][k]
                              - lhsX[2][2][AA][isize][j][k]*lhsX[2][3][CC][isize-1][j][k]
                              - lhsX[2][3][AA][isize][j][k]*lhsX[3][3][CC][isize-1][j][k]
                              - lhsX[2][4][AA][isize][j][k]*lhsX[4][3][CC][isize-1][j][k];
  lhsX[3][3][BB][isize][j][k] = lhsX[3][3][BB][isize][j][k] - lhsX[3][0][AA][isize][j][k]*lhsX[0][3][CC][isize-1][j][k]
                              - lhsX[3][1][AA][isize][j][k]*lhsX[1][3][CC][isize-1][j][k]
                              - lhsX[3][2][AA][isize][j][k]*lhsX[2][3][CC][isize-1][j][k]
                              - lhsX[3][3][AA][isize][j][k]*lhsX[3][3][CC][isize-1][j][k]
                              - lhsX[3][4][AA][isize][j][k]*lhsX[4][3][CC][isize-1][j][k];
  lhsX[4][3][BB][isize][j][k] = lhsX[4][3][BB][isize][j][k] - lhsX[4][0][AA][isize][j][k]*lhsX[0][3][CC][isize-1][j][k]
                              - lhsX[4][1][AA][isize][j][k]*lhsX[1][3][CC][isize-1][j][k]
                              - lhsX[4][2][AA][isize][j][k]*lhsX[2][3][CC][isize-1][j][k]
                              - lhsX[4][3][AA][isize][j][k]*lhsX[3][3][CC][isize-1][j][k]
                              - lhsX[4][4][AA][isize][j][k]*lhsX[4][3][CC][isize-1][j][k];
  lhsX[0][4][BB][isize][j][k] = lhsX[0][4][BB][isize][j][k] - lhsX[0][0][AA][isize][j][k]*lhsX[0][4][CC][isize-1][j][k]
                              - lhsX[0][1][AA][isize][j][k]*lhsX[1][4][CC][isize-1][j][k]
                              - lhsX[0][2][AA][isize][j][k]*lhsX[2][4][CC][isize-1][j][k]
                              - lhsX[0][3][AA][isize][j][k]*lhsX[3][4][CC][isize-1][j][k]
                              - lhsX[0][4][AA][isize][j][k]*lhsX[4][4][CC][isize-1][j][k];
  lhsX[1][4][BB][isize][j][k] = lhsX[1][4][BB][isize][j][k] - lhsX[1][0][AA][isize][j][k]*lhsX[0][4][CC][isize-1][j][k]
                              - lhsX[1][1][AA][isize][j][k]*lhsX[1][4][CC][isize-1][j][k]
                              - lhsX[1][2][AA][isize][j][k]*lhsX[2][4][CC][isize-1][j][k]
                              - lhsX[1][3][AA][isize][j][k]*lhsX[3][4][CC][isize-1][j][k]
                              - lhsX[1][4][AA][isize][j][k]*lhsX[4][4][CC][isize-1][j][k];
  lhsX[2][4][BB][isize][j][k] = lhsX[2][4][BB][isize][j][k] - lhsX[2][0][AA][isize][j][k]*lhsX[0][4][CC][isize-1][j][k]
                              - lhsX[2][1][AA][isize][j][k]*lhsX[1][4][CC][isize-1][j][k]
                              - lhsX[2][2][AA][isize][j][k]*lhsX[2][4][CC][isize-1][j][k]
                              - lhsX[2][3][AA][isize][j][k]*lhsX[3][4][CC][isize-1][j][k]
                              - lhsX[2][4][AA][isize][j][k]*lhsX[4][4][CC][isize-1][j][k];
  lhsX[3][4][BB][isize][j][k] = lhsX[3][4][BB][isize][j][k] - lhsX[3][0][AA][isize][j][k]*lhsX[0][4][CC][isize-1][j][k]
                              - lhsX[3][1][AA][isize][j][k]*lhsX[1][4][CC][isize-1][j][k]
                              - lhsX[3][2][AA][isize][j][k]*lhsX[2][4][CC][isize-1][j][k]
                              - lhsX[3][3][AA][isize][j][k]*lhsX[3][4][CC][isize-1][j][k]
                              - lhsX[3][4][AA][isize][j][k]*lhsX[4][4][CC][isize-1][j][k];
  lhsX[4][4][BB][isize][j][k] = lhsX[4][4][BB][isize][j][k] - lhsX[4][0][AA][isize][j][k]*lhsX[0][4][CC][isize-1][j][k]
                              - lhsX[4][1][AA][isize][j][k]*lhsX[1][4][CC][isize-1][j][k]
                              - lhsX[4][2][AA][isize][j][k]*lhsX[2][4][CC][isize-1][j][k]
                              - lhsX[4][3][AA][isize][j][k]*lhsX[3][4][CC][isize-1][j][k]
                              - lhsX[4][4][AA][isize][j][k]*lhsX[4][4][CC][isize-1][j][k];


    }
  }
      //---------------------------------------------------------------------
      // multiply rhs() by b_inverse() and copy to rhs      //---------------------------------------------------------------------
      //binvrhs( lhsX[isize][j][BB], rhs[k][k][isize][j] );
    #pragma acc parallel loop gang num_gangs(gp12) num_workers(4) vector_length(32)
    for (j = 1; j <= gp12; j++) {
  #pragma acc loop worker vector
  for (k = 1; k <= gp22; k++) {
	/*
	  for(m = 0; m < 5; m++){
	  	pivot = 1.00/lhsX[m][m][BB][isize][j][k];
		for(n = m+1; n < 5; n++){
			lhsX[m][n][BB][isize][j][k] = lhsX[m][n][BB][isize][j][k]*pivot;
		}
		rhs[m][k][j][isize] = rhs[m][k][j][isize]*pivot;
		
		for(n = 0; n < 5; n++){
			if(n != m){
				coeff = lhsX[n][m][BB][isize][j][k];
				for(z = m+1; z < 5; z++){
					lhsX[n][z][BB][isize][j][k] = lhsX[n][z][BB][isize][j][k] - coeff*lhsX[m][z][BB][isize][j][k];
				}
				rhs[n][k][j][isize] = rhs[n][k][j][isize] - coeff*rhs[m][k][j][isize];
			}
		}
	  }
	 */
  pivot = 1.00/lhsX[0][0][BB][isize][j][k];
  lhsX[0][1][BB][isize][j][k] = lhsX[0][1][BB][isize][j][k]*pivot;
  lhsX[0][2][BB][isize][j][k] = lhsX[0][2][BB][isize][j][k]*pivot;
  lhsX[0][3][BB][isize][j][k] = lhsX[0][3][BB][isize][j][k]*pivot;
  lhsX[0][4][BB][isize][j][k] = lhsX[0][4][BB][isize][j][k]*pivot;
  rhs[0][k][j][isize]   = rhs[0][k][j][isize]  *pivot;

  coeff = lhsX[1][0][BB][isize][j][k];
  lhsX[1][1][BB][isize][j][k]= lhsX[1][1][BB][isize][j][k] - coeff*lhsX[0][1][BB][isize][j][k];
  lhsX[1][2][BB][isize][j][k]= lhsX[1][2][BB][isize][j][k] - coeff*lhsX[0][2][BB][isize][j][k];
  lhsX[1][3][BB][isize][j][k]= lhsX[1][3][BB][isize][j][k] - coeff*lhsX[0][3][BB][isize][j][k];
  lhsX[1][4][BB][isize][j][k]= lhsX[1][4][BB][isize][j][k] - coeff*lhsX[0][4][BB][isize][j][k];
  rhs[1][k][j][isize]   = rhs[1][k][j][isize]   - coeff*rhs[0][k][j][isize];

  coeff = lhsX[2][0][BB][isize][j][k];
  lhsX[2][1][BB][isize][j][k]= lhsX[2][1][BB][isize][j][k] - coeff*lhsX[0][1][BB][isize][j][k];
  lhsX[2][2][BB][isize][j][k]= lhsX[2][2][BB][isize][j][k] - coeff*lhsX[0][2][BB][isize][j][k];
  lhsX[2][3][BB][isize][j][k]= lhsX[2][3][BB][isize][j][k] - coeff*lhsX[0][3][BB][isize][j][k];
  lhsX[2][4][BB][isize][j][k]= lhsX[2][4][BB][isize][j][k] - coeff*lhsX[0][4][BB][isize][j][k];
  rhs[2][k][j][isize]   = rhs[2][k][j][isize]   - coeff*rhs[0][k][j][isize];

  coeff = lhsX[3][0][BB][isize][j][k];
  lhsX[3][1][BB][isize][j][k]= lhsX[3][1][BB][isize][j][k] - coeff*lhsX[0][1][BB][isize][j][k];
  lhsX[3][2][BB][isize][j][k]= lhsX[3][2][BB][isize][j][k] - coeff*lhsX[0][2][BB][isize][j][k];
  lhsX[3][3][BB][isize][j][k]= lhsX[3][3][BB][isize][j][k] - coeff*lhsX[0][3][BB][isize][j][k];
  lhsX[3][4][BB][isize][j][k]= lhsX[3][4][BB][isize][j][k] - coeff*lhsX[0][4][BB][isize][j][k];
  rhs[3][k][j][isize]   = rhs[3][k][j][isize]   - coeff*rhs[0][k][j][isize];

  coeff = lhsX[4][0][BB][isize][j][k];
  lhsX[4][1][BB][isize][j][k]= lhsX[4][1][BB][isize][j][k] - coeff*lhsX[0][1][BB][isize][j][k];
  lhsX[4][2][BB][isize][j][k]= lhsX[4][2][BB][isize][j][k] - coeff*lhsX[0][2][BB][isize][j][k];
  lhsX[4][3][BB][isize][j][k]= lhsX[4][3][BB][isize][j][k] - coeff*lhsX[0][3][BB][isize][j][k];
  lhsX[4][4][BB][isize][j][k]= lhsX[4][4][BB][isize][j][k] - coeff*lhsX[0][4][BB][isize][j][k];
  rhs[4][k][j][isize]   = rhs[4][k][j][isize]   - coeff*rhs[0][k][j][isize];


  pivot = 1.00/lhsX[1][1][BB][isize][j][k];
  lhsX[1][2][BB][isize][j][k] = lhsX[1][2][BB][isize][j][k]*pivot;
  lhsX[1][3][BB][isize][j][k] = lhsX[1][3][BB][isize][j][k]*pivot;
  lhsX[1][4][BB][isize][j][k] = lhsX[1][4][BB][isize][j][k]*pivot;
  rhs[1][k][j][isize]   = rhs[1][k][j][isize]  *pivot;

  coeff = lhsX[0][1][BB][isize][j][k];
  lhsX[0][2][BB][isize][j][k]= lhsX[0][2][BB][isize][j][k] - coeff*lhsX[1][2][BB][isize][j][k];
  lhsX[0][3][BB][isize][j][k]= lhsX[0][3][BB][isize][j][k] - coeff*lhsX[1][3][BB][isize][j][k];
  lhsX[0][4][BB][isize][j][k]= lhsX[0][4][BB][isize][j][k] - coeff*lhsX[1][4][BB][isize][j][k];
  rhs[0][k][j][isize]   = rhs[0][k][j][isize]   - coeff*rhs[1][k][j][isize];

  coeff = lhsX[2][1][BB][isize][j][k];
  lhsX[2][2][BB][isize][j][k]= lhsX[2][2][BB][isize][j][k] - coeff*lhsX[1][2][BB][isize][j][k];
  lhsX[2][3][BB][isize][j][k]= lhsX[2][3][BB][isize][j][k] - coeff*lhsX[1][3][BB][isize][j][k];
  lhsX[2][4][BB][isize][j][k]= lhsX[2][4][BB][isize][j][k] - coeff*lhsX[1][4][BB][isize][j][k];
  rhs[2][k][j][isize]   = rhs[2][k][j][isize]   - coeff*rhs[1][k][j][isize];

  coeff = lhsX[3][1][BB][isize][j][k];
  lhsX[3][2][BB][isize][j][k]= lhsX[3][2][BB][isize][j][k] - coeff*lhsX[1][2][BB][isize][j][k];
  lhsX[3][3][BB][isize][j][k]= lhsX[3][3][BB][isize][j][k] - coeff*lhsX[1][3][BB][isize][j][k];
  lhsX[3][4][BB][isize][j][k]= lhsX[3][4][BB][isize][j][k] - coeff*lhsX[1][4][BB][isize][j][k];
  rhs[3][k][j][isize]   = rhs[3][k][j][isize]   - coeff*rhs[1][k][j][isize];

  coeff = lhsX[4][1][BB][isize][j][k];
  lhsX[4][2][BB][isize][j][k]= lhsX[4][2][BB][isize][j][k] - coeff*lhsX[1][2][BB][isize][j][k];
  lhsX[4][3][BB][isize][j][k]= lhsX[4][3][BB][isize][j][k] - coeff*lhsX[1][3][BB][isize][j][k];
  lhsX[4][4][BB][isize][j][k]= lhsX[4][4][BB][isize][j][k] - coeff*lhsX[1][4][BB][isize][j][k];
  rhs[4][k][j][isize]   = rhs[4][k][j][isize]   - coeff*rhs[1][k][j][isize];


  pivot = 1.00/lhsX[2][2][BB][isize][j][k];
  lhsX[2][3][BB][isize][j][k] = lhsX[2][3][BB][isize][j][k]*pivot;
  lhsX[2][4][BB][isize][j][k] = lhsX[2][4][BB][isize][j][k]*pivot;
  rhs[2][k][j][isize]   = rhs[2][k][j][isize]  *pivot;

  coeff = lhsX[0][2][BB][isize][j][k];
  lhsX[0][3][BB][isize][j][k]= lhsX[0][3][BB][isize][j][k] - coeff*lhsX[2][3][BB][isize][j][k];
  lhsX[0][4][BB][isize][j][k]= lhsX[0][4][BB][isize][j][k] - coeff*lhsX[2][4][BB][isize][j][k];
  rhs[0][k][j][isize]   = rhs[0][k][j][isize]   - coeff*rhs[2][k][j][isize];

  coeff = lhsX[1][2][BB][isize][j][k];
  lhsX[1][3][BB][isize][j][k]= lhsX[1][3][BB][isize][j][k] - coeff*lhsX[2][3][BB][isize][j][k];
  lhsX[1][4][BB][isize][j][k]= lhsX[1][4][BB][isize][j][k] - coeff*lhsX[2][4][BB][isize][j][k];
  rhs[1][k][j][isize]   = rhs[1][k][j][isize]   - coeff*rhs[2][k][j][isize];

  coeff = lhsX[3][2][BB][isize][j][k];
  lhsX[3][3][BB][isize][j][k]= lhsX[3][3][BB][isize][j][k] - coeff*lhsX[2][3][BB][isize][j][k];
  lhsX[3][4][BB][isize][j][k]= lhsX[3][4][BB][isize][j][k] - coeff*lhsX[2][4][BB][isize][j][k];
  rhs[3][k][j][isize]   = rhs[3][k][j][isize]   - coeff*rhs[2][k][j][isize];

  coeff = lhsX[4][2][BB][isize][j][k];
  lhsX[4][3][BB][isize][j][k]= lhsX[4][3][BB][isize][j][k] - coeff*lhsX[2][3][BB][isize][j][k];
  lhsX[4][4][BB][isize][j][k]= lhsX[4][4][BB][isize][j][k] - coeff*lhsX[2][4][BB][isize][j][k];
  rhs[4][k][j][isize]   = rhs[4][k][j][isize]   - coeff*rhs[2][k][j][isize];


  pivot = 1.00/lhsX[3][3][BB][isize][j][k];
  lhsX[3][4][BB][isize][j][k] = lhsX[3][4][BB][isize][j][k]*pivot;
  rhs[3][k][j][isize]   = rhs[3][k][j][isize]  *pivot;

  coeff = lhsX[0][3][BB][isize][j][k];
  lhsX[0][4][BB][isize][j][k]= lhsX[0][4][BB][isize][j][k] - coeff*lhsX[3][4][BB][isize][j][k];
  rhs[0][k][j][isize]   = rhs[0][k][j][isize]   - coeff*rhs[3][k][j][isize];

  coeff = lhsX[1][3][BB][isize][j][k];
  lhsX[1][4][BB][isize][j][k]= lhsX[1][4][BB][isize][j][k] - coeff*lhsX[3][4][BB][isize][j][k];
  rhs[1][k][j][isize]   = rhs[1][k][j][isize]   - coeff*rhs[3][k][j][isize];

  coeff = lhsX[2][3][BB][isize][j][k];
  lhsX[2][4][BB][isize][j][k]= lhsX[2][4][BB][isize][j][k] - coeff*lhsX[3][4][BB][isize][j][k];
  rhs[2][k][j][isize]   = rhs[2][k][j][isize]   - coeff*rhs[3][k][j][isize];

  coeff = lhsX[4][3][BB][isize][j][k];
  lhsX[4][4][BB][isize][j][k]= lhsX[4][4][BB][isize][j][k] - coeff*lhsX[3][4][BB][isize][j][k];
  rhs[4][k][j][isize]   = rhs[4][k][j][isize]   - coeff*rhs[3][k][j][isize];


  pivot = 1.00/lhsX[4][4][BB][isize][j][k];
  rhs[4][k][j][isize]   = rhs[4][k][j][isize]  *pivot;

  coeff = lhsX[0][4][BB][isize][j][k];
  rhs[0][k][j][isize]   = rhs[0][k][j][isize]   - coeff*rhs[4][k][j][isize];

  coeff = lhsX[1][4][BB][isize][j][k];
  rhs[1][k][j][isize]   = rhs[1][k][j][isize]   - coeff*rhs[4][k][j][isize];

  coeff = lhsX[2][4][BB][isize][j][k];
  rhs[2][k][j][isize]   = rhs[2][k][j][isize]   - coeff*rhs[4][k][j][isize];

  coeff = lhsX[3][4][BB][isize][j][k];
  rhs[3][k][j][isize]   = rhs[3][k][j][isize]   - coeff*rhs[4][k][j][isize];


	}
  }

      //---------------------------------------------------------------------
      // back solve: if last cell, then generate U(isize)=rhs(isize)
      // else assume U(isize) is loaded in un pack backsub_info
      // so just use it
      // after u(istart) will be sent to next cell
      //---------------------------------------------------------------------
      for (i = isize-1; i >=0; i--) {
    #pragma acc parallel loop gang num_gangs(gp12) num_workers(4) vector_length(32)
    for (j = 1; j <= gp12; j++) {
  #pragma acc loop worker vector
  for (k = 1; k <= gp22; k++) {
    /*
        for (m = 0; m < BLOCK_SIZE; m++) {
          for (n = 0; n < BLOCK_SIZE; n++) {
            rhs[m][k][j][i] = rhs[m][k][j][i] 
              - lhsX[m][n][CC][i][j][k]*rhs[n][k][j][i+1];
          }
        }
	 */
	  
            rhs[0][k][j][i] = rhs[0][k][j][i] 
              - lhsX[0][0][CC][i][j][k]*rhs[0][k][j][i+1];
            rhs[0][k][j][i] = rhs[0][k][j][i] 
              - lhsX[0][1][CC][i][j][k]*rhs[1][k][j][i+1];
            rhs[0][k][j][i] = rhs[0][k][j][i] 
              - lhsX[0][2][CC][i][j][k]*rhs[2][k][j][i+1];
            rhs[0][k][j][i] = rhs[0][k][j][i] 
              - lhsX[0][3][CC][i][j][k]*rhs[3][k][j][i+1];
            rhs[0][k][j][i] = rhs[0][k][j][i] 
              - lhsX[0][4][CC][i][j][k]*rhs[4][k][j][i+1];
            
			rhs[1][k][j][i] = rhs[1][k][j][i] 
              - lhsX[1][0][CC][i][j][k]*rhs[0][k][j][i+1];
            rhs[1][k][j][i] = rhs[1][k][j][i] 
              - lhsX[1][1][CC][i][j][k]*rhs[1][k][j][i+1];
            rhs[1][k][j][i] = rhs[1][k][j][i] 
              - lhsX[1][2][CC][i][j][k]*rhs[2][k][j][i+1];
            rhs[1][k][j][i] = rhs[1][k][j][i] 
              - lhsX[1][3][CC][i][j][k]*rhs[3][k][j][i+1];
            rhs[1][k][j][i] = rhs[1][k][j][i] 
              - lhsX[1][4][CC][i][j][k]*rhs[4][k][j][i+1];
			
			rhs[2][k][j][i] = rhs[2][k][j][i] 
              - lhsX[2][0][CC][i][j][k]*rhs[0][k][j][i+1];
            rhs[2][k][j][i] = rhs[2][k][j][i] 
              - lhsX[2][1][CC][i][j][k]*rhs[1][k][j][i+1];
            rhs[2][k][j][i] = rhs[2][k][j][i] 
              - lhsX[2][2][CC][i][j][k]*rhs[2][k][j][i+1];
            rhs[2][k][j][i] = rhs[2][k][j][i] 
              - lhsX[2][3][CC][i][j][k]*rhs[3][k][j][i+1];
            rhs[2][k][j][i] = rhs[2][k][j][i] 
              - lhsX[2][4][CC][i][j][k]*rhs[4][k][j][i+1];
			
			rhs[3][k][j][i] = rhs[3][k][j][i] 
              - lhsX[3][0][CC][i][j][k]*rhs[0][k][j][i+1];
            rhs[3][k][j][i] = rhs[3][k][j][i] 
              - lhsX[3][1][CC][i][j][k]*rhs[1][k][j][i+1];
            rhs[3][k][j][i] = rhs[3][k][j][i] 
              - lhsX[3][2][CC][i][j][k]*rhs[2][k][j][i+1];
            rhs[3][k][j][i] = rhs[3][k][j][i] 
              - lhsX[3][3][CC][i][j][k]*rhs[3][k][j][i+1];
            rhs[3][k][j][i] = rhs[3][k][j][i] 
              - lhsX[3][4][CC][i][j][k]*rhs[4][k][j][i+1];
			
			rhs[4][k][j][i] = rhs[4][k][j][i] 
              - lhsX[4][0][CC][i][j][k]*rhs[0][k][j][i+1];
            rhs[4][k][j][i] = rhs[4][k][j][i] 
              - lhsX[4][1][CC][i][j][k]*rhs[1][k][j][i+1];
            rhs[4][k][j][i] = rhs[4][k][j][i] 
              - lhsX[4][2][CC][i][j][k]*rhs[2][k][j][i+1];
            rhs[4][k][j][i] = rhs[4][k][j][i] 
              - lhsX[4][3][CC][i][j][k]*rhs[3][k][j][i+1];
            rhs[4][k][j][i] = rhs[4][k][j][i] 
              - lhsX[4][4][CC][i][j][k]*rhs[4][k][j][i+1];
	 
      }
    }
  }
 }/*end acc data*/
}

########## NEXT FILE ##########
y_solve.c:::
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB BT code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS BT code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

#include "header.h"
//#include "timers.h"

//---------------------------------------------------------------------
// Performs line solves in Y direction by first factoring
// the block-tridiagonal matrix into an upper triangular matrix, 
// and then performing back substitution to solve for the unknow
// vectors of each line.  
// 
// Make sure we treat elements zero to cell_size in the direction
// of the sweep.
//---------------------------------------------------------------------
void y_solve()
{
  int i, j, k, m, n, jsize, z;
  double pivot, coeff;
  int gp22, gp02;
  double fjacY[5][5][PROBLEM_SIZE+1][IMAXP-1][KMAX-1];
  double njacY[5][5][PROBLEM_SIZE+1][IMAXP-1][KMAX-1];
  double lhsY[5][5][3][PROBLEM_SIZE][IMAXP-1][KMAX-1];
  double temp1, temp2, temp3;

  gp22 = grid_points[2]-2;
  gp02 = grid_points[0]-2;

  //---------------------------------------------------------------------
  // This function computes the left hand side for the three y-factors   
  //---------------------------------------------------------------------

  jsize = grid_points[1]-1;

  //---------------------------------------------------------------------
  // Compute the indices for storing the tri-diagonal matrix;
  // determine a (labeled f) and n jacobians for cell c
  //---------------------------------------------------------------------
//#pragma acc data present(rho_i,u,rhs,square,qs,lhsY,fjacY,njacY)
#pragma acc data present(rho_i,u,rhs,square,qs) create(lhsY,fjacY,njacY)
{
	  #pragma acc parallel loop gang num_gangs(jsize+1) num_workers(8) vector_length(32)
      for (j = 0; j <= jsize; j++) {
    #pragma acc loop worker
    for (i = 1; i <= gp02; i++) {
  #pragma acc loop vector
  for (k = 1; k <= gp22; k++) {
        temp1 = rho_i[k][j][i];
        temp2 = temp1 * temp1;
        temp3 = temp1 * temp2;

        fjacY[0][0][j][i][k] = 0.0;
        fjacY[0][1][j][i][k] = 0.0;
        fjacY[0][2][j][i][k] = 1.0;
        fjacY[0][3][j][i][k] = 0.0;
        fjacY[0][4][j][i][k] = 0.0;

        fjacY[1][0][j][i][k] = - ( u[1][k][j][i]*u[2][k][j][i] ) * temp2;
        fjacY[1][1][j][i][k] = u[2][k][j][i] * temp1;
        fjacY[1][2][j][i][k] = u[1][k][j][i] * temp1;
        fjacY[1][3][j][i][k] = 0.0;
        fjacY[1][4][j][i][k] = 0.0;

        fjacY[2][0][j][i][k] = - ( u[2][k][j][i]*u[2][k][j][i]*temp2)
          + c2 * qs[k][j][i];
        fjacY[2][1][j][i][k] = - c2 *  u[1][k][j][i] * temp1;
        fjacY[2][2][j][i][k] = ( 2.0 - c2 ) *  u[2][k][j][i] * temp1;
        fjacY[2][3][j][i][k] = - c2 * u[3][k][j][i] * temp1;
        fjacY[2][4][j][i][k] = c2;

        fjacY[3][0][j][i][k] = - ( u[2][k][j][i]*u[3][k][j][i] ) * temp2;
        fjacY[3][1][j][i][k] = 0.0;
        fjacY[3][2][j][i][k] = u[3][k][j][i] * temp1;
        fjacY[3][3][j][i][k] = u[2][k][j][i] * temp1;
        fjacY[3][4][j][i][k] = 0.0;

        fjacY[4][0][j][i][k] = ( c2 * 2.0 * square[k][j][i] - c1 * u[4][k][j][i] )
          * u[2][k][j][i] * temp2;
        fjacY[4][1][j][i][k] = - c2 * u[1][k][j][i]*u[2][k][j][i] * temp2;
        fjacY[4][2][j][i][k] = c1 * u[4][k][j][i] * temp1 
          - c2 * ( qs[k][j][i] + u[2][k][j][i]*u[2][k][j][i] * temp2 );
        fjacY[4][3][j][i][k] = - c2 * ( u[2][k][j][i]*u[3][k][j][i] ) * temp2;
        fjacY[4][4][j][i][k] = c1 * u[2][k][j][i] * temp1;

        njacY[0][0][j][i][k] = 0.0;
        njacY[0][1][j][i][k] = 0.0;
        njacY[0][2][j][i][k] = 0.0;
        njacY[0][3][j][i][k] = 0.0;
        njacY[0][4][j][i][k] = 0.0;

        njacY[1][0][j][i][k] = - c3c4 * temp2 * u[1][k][j][i];
        njacY[1][1][j][i][k] =   c3c4 * temp1;
        njacY[1][2][j][i][k] =   0.0;
        njacY[1][3][j][i][k] =   0.0;
        njacY[1][4][j][i][k] =   0.0;

        njacY[2][0][j][i][k] = - con43 * c3c4 * temp2 * u[2][k][j][i];
        njacY[2][1][j][i][k] =   0.0;
        njacY[2][2][j][i][k] =   con43 * c3c4 * temp1;
        njacY[2][3][j][i][k] =   0.0;
        njacY[2][4][j][i][k] =   0.0;

        njacY[3][0][j][i][k] = - c3c4 * temp2 * u[3][k][j][i];
        njacY[3][1][j][i][k] =   0.0;
        njacY[3][2][j][i][k] =   0.0;
        njacY[3][3][j][i][k] =   c3c4 * temp1;
        njacY[3][4][j][i][k] =   0.0;

        njacY[4][0][j][i][k] = - (  c3c4
            - c1345 ) * temp3 * (u[1][k][j][i]*u[1][k][j][i])
          - ( con43 * c3c4
              - c1345 ) * temp3 * (u[2][k][j][i]*u[2][k][j][i])
          - ( c3c4 - c1345 ) * temp3 * (u[3][k][j][i]*u[3][k][j][i])
          - c1345 * temp2 * u[4][k][j][i];

        njacY[4][1][j][i][k] = (  c3c4 - c1345 ) * temp2 * u[1][k][j][i];
        njacY[4][2][j][i][k] = ( con43 * c3c4 - c1345 ) * temp2 * u[2][k][j][i];
        njacY[4][3][j][i][k] = ( c3c4 - c1345 ) * temp2 * u[3][k][j][i];
        njacY[4][4][j][i][k] = ( c1345 ) * temp1;
      }
	}
  }

      //---------------------------------------------------------------------
      // now joacobians set, so form left hand side in y direction
      //---------------------------------------------------------------------
      //lhsY[k][i]init(lhsY[k][i], jsize);
  		// zero the whole left hand side for starters
    #pragma acc parallel loop gang num_gangs(gp02) num_workers(8) vector_length(32) 
    for (i = 1; i <= gp02; i++) {
  #pragma acc loop worker vector
  for (k = 1; k <= gp22; k++) {
  		for (n = 0; n < 5; n++) {
    		for (m = 0; m < 5; m++) {
      			lhsY[m][n][0][0][i][k] = 0.0;
      			lhsY[m][n][1][0][i][k] = 0.0;
      			lhsY[m][n][2][0][i][k] = 0.0;
      			lhsY[m][n][0][jsize][i][k] = 0.0;
      			lhsY[m][n][1][jsize][i][k] = 0.0;
      			lhsY[m][n][2][jsize][i][k] = 0.0;
    		}
  		}	
	}
  }

  		// next, set all diagonal values to 1. This is overkill, but convenient
    #pragma acc parallel loop gang num_gangs(gp02) num_workers(8) vector_length(32)
    for (i = 1; i <= gp02; i++) {
  #pragma acc loop worker vector
  for (k = 1; k <= gp22; k++) {
    		lhsY[0][0][1][0][i][k] = 1.0;
    		lhsY[0][0][1][jsize][i][k] = 1.0;
    		lhsY[1][1][1][0][i][k] = 1.0;
    		lhsY[1][1][1][jsize][i][k] = 1.0;
    		lhsY[2][2][1][0][i][k] = 1.0;
    		lhsY[2][2][1][jsize][i][k] = 1.0;
    		lhsY[3][3][1][0][i][k] = 1.0;
    		lhsY[3][3][1][jsize][i][k] = 1.0;
    		lhsY[4][4][1][0][i][k] = 1.0;
    		lhsY[4][4][1][jsize][i][k] = 1.0;
	}
  }
      
	  #pragma acc parallel loop gang num_gangs(jsize-1) num_workers(4) vector_length(32)
	  for (j = 1; j <= jsize-1; j++) {
    #pragma acc loop worker
    for (i = 1; i <= gp02; i++) {
  #pragma acc loop vector
  for (k = 1; k <= gp22; k++) {
        temp1 = dt * ty1;
        temp2 = dt * ty2;

        lhsY[0][0][AA][j][i][k] = - temp2 * fjacY[0][0][j-1][i][k]
          - temp1 * njacY[0][0][j-1][i][k]
          - temp1 * dy1; 
        lhsY[0][1][AA][j][i][k] = - temp2 * fjacY[0][1][j-1][i][k]
          - temp1 * njacY[0][1][j-1][i][k];
        lhsY[0][2][AA][j][i][k] = - temp2 * fjacY[0][2][j-1][i][k]
          - temp1 * njacY[0][2][j-1][i][k];
        lhsY[0][3][AA][j][i][k] = - temp2 * fjacY[0][3][j-1][i][k]
          - temp1 * njacY[0][3][j-1][i][k];
        lhsY[0][4][AA][j][i][k] = - temp2 * fjacY[0][4][j-1][i][k]
          - temp1 * njacY[0][4][j-1][i][k];

        lhsY[1][0][AA][j][i][k] = - temp2 * fjacY[1][0][j-1][i][k]
          - temp1 * njacY[1][0][j-1][i][k];
        lhsY[1][1][AA][j][i][k] = - temp2 * fjacY[1][1][j-1][i][k]
          - temp1 * njacY[1][1][j-1][i][k]
          - temp1 * dy2;
        lhsY[1][2][AA][j][i][k] = - temp2 * fjacY[1][2][j-1][i][k]
          - temp1 * njacY[1][2][j-1][i][k];
        lhsY[1][3][AA][j][i][k] = - temp2 * fjacY[1][3][j-1][i][k]
          - temp1 * njacY[1][3][j-1][i][k];
        lhsY[1][4][AA][j][i][k] = - temp2 * fjacY[1][4][j-1][i][k]
          - temp1 * njacY[1][4][j-1][i][k];

        lhsY[2][0][AA][j][i][k] = - temp2 * fjacY[2][0][j-1][i][k]
          - temp1 * njacY[2][0][j-1][i][k];
        lhsY[2][1][AA][j][i][k] = - temp2 * fjacY[2][1][j-1][i][k]
          - temp1 * njacY[2][1][j-1][i][k];
        lhsY[2][2][AA][j][i][k] = - temp2 * fjacY[2][2][j-1][i][k]
          - temp1 * njacY[2][2][j-1][i][k]
          - temp1 * dy3;
        lhsY[2][3][AA][j][i][k] = - temp2 * fjacY[2][3][j-1][i][k]
          - temp1 * njacY[2][3][j-1][i][k];
        lhsY[2][4][AA][j][i][k] = - temp2 * fjacY[2][4][j-1][i][k]
          - temp1 * njacY[2][4][j-1][i][k];

        lhsY[3][0][AA][j][i][k] = - temp2 * fjacY[3][0][j-1][i][k]
          - temp1 * njacY[3][0][j-1][i][k];
        lhsY[3][1][AA][j][i][k] = - temp2 * fjacY[3][1][j-1][i][k]
          - temp1 * njacY[3][1][j-1][i][k];
        lhsY[3][2][AA][j][i][k] = - temp2 * fjacY[3][2][j-1][i][k]
          - temp1 * njacY[3][2][j-1][i][k];
        lhsY[3][3][AA][j][i][k] = - temp2 * fjacY[3][3][j-1][i][k]
          - temp1 * njacY[3][3][j-1][i][k]
          - temp1 * dy4;
        lhsY[3][4][AA][j][i][k] = - temp2 * fjacY[3][4][j-1][i][k]
          - temp1 * njacY[3][4][j-1][i][k];

        lhsY[4][0][AA][j][i][k] = - temp2 * fjacY[4][0][j-1][i][k]
          - temp1 * njacY[4][0][j-1][i][k];
        lhsY[4][1][AA][j][i][k] = - temp2 * fjacY[4][1][j-1][i][k]
          - temp1 * njacY[4][1][j-1][i][k];
        lhsY[4][2][AA][j][i][k] = - temp2 * fjacY[4][2][j-1][i][k]
          - temp1 * njacY[4][2][j-1][i][k];
        lhsY[4][3][AA][j][i][k] = - temp2 * fjacY[4][3][j-1][i][k]
          - temp1 * njacY[4][3][j-1][i][k];
        lhsY[4][4][AA][j][i][k] = - temp2 * fjacY[4][4][j-1][i][k]
          - temp1 * njacY[4][4][j-1][i][k]
          - temp1 * dy5;

        lhsY[0][0][BB][j][i][k] = 1.0
          + temp1 * 2.0 * njacY[0][0][j][i][k]
          + temp1 * 2.0 * dy1;
        lhsY[0][1][BB][j][i][k] = temp1 * 2.0 * njacY[0][1][j][i][k];
        lhsY[0][2][BB][j][i][k] = temp1 * 2.0 * njacY[0][2][j][i][k];
        lhsY[0][3][BB][j][i][k] = temp1 * 2.0 * njacY[0][3][j][i][k];
        lhsY[0][4][BB][j][i][k] = temp1 * 2.0 * njacY[0][4][j][i][k];

        lhsY[1][0][BB][j][i][k] = temp1 * 2.0 * njacY[1][0][j][i][k];
        lhsY[1][1][BB][j][i][k] = 1.0
          + temp1 * 2.0 * njacY[1][1][j][i][k]
          + temp1 * 2.0 * dy2;
        lhsY[1][2][BB][j][i][k] = temp1 * 2.0 * njacY[1][2][j][i][k];
        lhsY[1][3][BB][j][i][k] = temp1 * 2.0 * njacY[1][3][j][i][k];
        lhsY[1][4][BB][j][i][k] = temp1 * 2.0 * njacY[1][4][j][i][k];

        lhsY[2][0][BB][j][i][k] = temp1 * 2.0 * njacY[2][0][j][i][k];
        lhsY[2][1][BB][j][i][k] = temp1 * 2.0 * njacY[2][1][j][i][k];
        lhsY[2][2][BB][j][i][k] = 1.0
          + temp1 * 2.0 * njacY[2][2][j][i][k]
          + temp1 * 2.0 * dy3;
        lhsY[2][3][BB][j][i][k] = temp1 * 2.0 * njacY[2][3][j][i][k];
        lhsY[2][4][BB][j][i][k] = temp1 * 2.0 * njacY[2][4][j][i][k];

        lhsY[3][0][BB][j][i][k] = temp1 * 2.0 * njacY[3][0][j][i][k];
        lhsY[3][1][BB][j][i][k] = temp1 * 2.0 * njacY[3][1][j][i][k];
        lhsY[3][2][BB][j][i][k] = temp1 * 2.0 * njacY[3][2][j][i][k];
        lhsY[3][3][BB][j][i][k] = 1.0
          + temp1 * 2.0 * njacY[3][3][j][i][k]
          + temp1 * 2.0 * dy4;
        lhsY[3][4][BB][j][i][k] = temp1 * 2.0 * njacY[3][4][j][i][k];

        lhsY[4][0][BB][j][i][k] = temp1 * 2.0 * njacY[4][0][j][i][k];
        lhsY[4][1][BB][j][i][k] = temp1 * 2.0 * njacY[4][1][j][i][k];
        lhsY[4][2][BB][j][i][k] = temp1 * 2.0 * njacY[4][2][j][i][k];
        lhsY[4][3][BB][j][i][k] = temp1 * 2.0 * njacY[4][3][j][i][k];
        lhsY[4][4][BB][j][i][k] = 1.0
          + temp1 * 2.0 * njacY[4][4][j][i][k] 
          + temp1 * 2.0 * dy5;

        lhsY[0][0][CC][j][i][k] =  temp2 * fjacY[0][0][j+1][i][k]
          - temp1 * njacY[0][0][j+1][i][k]
          - temp1 * dy1;
        lhsY[0][1][CC][j][i][k] =  temp2 * fjacY[0][1][j+1][i][k]
          - temp1 * njacY[0][1][j+1][i][k];
        lhsY[0][2][CC][j][i][k] =  temp2 * fjacY[0][2][j+1][i][k]
          - temp1 * njacY[0][2][j+1][i][k];
        lhsY[0][3][CC][j][i][k] =  temp2 * fjacY[0][3][j+1][i][k]
          - temp1 * njacY[0][3][j+1][i][k];
        lhsY[0][4][CC][j][i][k] =  temp2 * fjacY[0][4][j+1][i][k]
          - temp1 * njacY[0][4][j+1][i][k];

        lhsY[1][0][CC][j][i][k] =  temp2 * fjacY[1][0][j+1][i][k]
          - temp1 * njacY[1][0][j+1][i][k];
        lhsY[1][1][CC][j][i][k] =  temp2 * fjacY[1][1][j+1][i][k]
          - temp1 * njacY[1][1][j+1][i][k]
          - temp1 * dy2;
        lhsY[1][2][CC][j][i][k] =  temp2 * fjacY[1][2][j+1][i][k]
          - temp1 * njacY[1][2][j+1][i][k];
        lhsY[1][3][CC][j][i][k] =  temp2 * fjacY[1][3][j+1][i][k]
          - temp1 * njacY[1][3][j+1][i][k];
        lhsY[1][4][CC][j][i][k] =  temp2 * fjacY[1][4][j+1][i][k]
          - temp1 * njacY[1][4][j+1][i][k];

        lhsY[2][0][CC][j][i][k] =  temp2 * fjacY[2][0][j+1][i][k]
          - temp1 * njacY[2][0][j+1][i][k];
        lhsY[2][1][CC][j][i][k] =  temp2 * fjacY[2][1][j+1][i][k]
          - temp1 * njacY[2][1][j+1][i][k];
        lhsY[2][2][CC][j][i][k] =  temp2 * fjacY[2][2][j+1][i][k]
          - temp1 * njacY[2][2][j+1][i][k]
          - temp1 * dy3;
        lhsY[2][3][CC][j][i][k] =  temp2 * fjacY[2][3][j+1][i][k]
          - temp1 * njacY[2][3][j+1][i][k];
        lhsY[2][4][CC][j][i][k] =  temp2 * fjacY[2][4][j+1][i][k]
          - temp1 * njacY[2][4][j+1][i][k];

        lhsY[3][0][CC][j][i][k] =  temp2 * fjacY[3][0][j+1][i][k]
          - temp1 * njacY[3][0][j+1][i][k];
        lhsY[3][1][CC][j][i][k] =  temp2 * fjacY[3][1][j+1][i][k]
          - temp1 * njacY[3][1][j+1][i][k];
        lhsY[3][2][CC][j][i][k] =  temp2 * fjacY[3][2][j+1][i][k]
          - temp1 * njacY[3][2][j+1][i][k];
        lhsY[3][3][CC][j][i][k] =  temp2 * fjacY[3][3][j+1][i][k]
          - temp1 * njacY[3][3][j+1][i][k]
          - temp1 * dy4;
        lhsY[3][4][CC][j][i][k] =  temp2 * fjacY[3][4][j+1][i][k]
          - temp1 * njacY[3][4][j+1][i][k];

        lhsY[4][0][CC][j][i][k] =  temp2 * fjacY[4][0][j+1][i][k]
          - temp1 * njacY[4][0][j+1][i][k];
        lhsY[4][1][CC][j][i][k] =  temp2 * fjacY[4][1][j+1][i][k]
          - temp1 * njacY[4][1][j+1][i][k];
        lhsY[4][2][CC][j][i][k] =  temp2 * fjacY[4][2][j+1][i][k]
          - temp1 * njacY[4][2][j+1][i][k];
        lhsY[4][3][CC][j][i][k] =  temp2 * fjacY[4][3][j+1][i][k]
          - temp1 * njacY[4][3][j+1][i][k];
        lhsY[4][4][CC][j][i][k] =  temp2 * fjacY[4][4][j+1][i][k]
          - temp1 * njacY[4][4][j+1][i][k]
          - temp1 * dy5;
      }
	}
  }
      //---------------------------------------------------------------------
      //---------------------------------------------------------------------

      //---------------------------------------------------------------------
      // performs guaussian elimination on this cell.
      // 
      // assumes that unpacking routines for non-first cells 
      // preload C' and rhs' from previous cell.
      // 
      // assumed send happens outside this routine, but that
      // c'(JMAX) and rhs'(JMAX) will be sent to next cell
      //---------------------------------------------------------------------

      //---------------------------------------------------------------------
      // multiply c[k][0][i] by b_inverse and copy back to c
      // multiply rhs(0) by b_inverse(0) and copy to rhs      //---------------------------------------------------------------------
      //binvcrhs( lhsY[0][i][BB], lhsY[k][0][i][k][CC], rhs[k][0][i] );
    #pragma acc parallel loop gang num_gangs(gp02) num_workers(4) vector_length(32) 
    for (i = 1; i <= gp02; i++) {
  #pragma acc loop worker vector
  for (k = 1; k <= gp22; k++) {
/*
	  for(m = 0; m < 5; m++){
	  	pivot = 1.00/lhsY[m][m][BB][0][i][k];
		for(n = m+1; n < 5; n++){
			lhsY[m][n][BB][0][i][k] = lhsY[m][n][BB][0][i][k]*pivot;
		}
		lhsY[m][0][CC][0][i][k] = lhsY[m][0][CC][0][i][k]*pivot;
		lhsY[m][1][CC][0][i][k] = lhsY[m][1][CC][0][i][k]*pivot;
		lhsY[m][2][CC][0][i][k] = lhsY[m][2][CC][0][i][k]*pivot;
		lhsY[m][3][CC][0][i][k] = lhsY[m][3][CC][0][i][k]*pivot;
		lhsY[m][4][CC][0][i][k] = lhsY[m][4][CC][0][i][k]*pivot;
		rhs[m][k][0][i] = rhs[m][k][0][i]*pivot;

		for(n = 0; n < 5; n++){
			if(n != m){
				coeff = lhsY[n][m][BB][0][i][k];
				for(z = m+1; z < 5; z++){
					lhsY[n][z][BB][0][i][k] = lhsY[n][z][BB][0][i][k] - coeff*lhsY[m][z][BB][0][i][k];
				}
				lhsY[n][0][CC][0][i][k] = lhsY[n][0][CC][0][i][k] - coeff*lhsY[m][0][CC][0][i][k];
				lhsY[n][1][CC][0][i][k] = lhsY[n][1][CC][0][i][k] - coeff*lhsY[m][1][CC][0][i][k];
				lhsY[n][2][CC][0][i][k] = lhsY[n][2][CC][0][i][k] - coeff*lhsY[m][2][CC][0][i][k];
				lhsY[n][3][CC][0][i][k] = lhsY[n][3][CC][0][i][k] - coeff*lhsY[m][3][CC][0][i][k];
				lhsY[n][4][CC][0][i][k] = lhsY[n][4][CC][0][i][k] - coeff*lhsY[m][4][CC][0][i][k];
				rhs[n][k][0][i] = rhs[n][k][0][i] - coeff*rhs[m][k][0][i];
			}
		}
	  }
*/
  pivot = 1.00/lhsY[0][0][BB][0][i][k];
  lhsY[0][1][BB][0][i][k] = lhsY[0][1][BB][0][i][k]*pivot;
  lhsY[0][2][BB][0][i][k] = lhsY[0][2][BB][0][i][k]*pivot;
  lhsY[0][3][BB][0][i][k] = lhsY[0][3][BB][0][i][k]*pivot;
  lhsY[0][4][BB][0][i][k] = lhsY[0][4][BB][0][i][k]*pivot;
  lhsY[0][0][CC][0][i][k] = lhsY[0][0][CC][0][i][k]*pivot;
  lhsY[0][1][CC][0][i][k] = lhsY[0][1][CC][0][i][k]*pivot;
  lhsY[0][2][CC][0][i][k] = lhsY[0][2][CC][0][i][k]*pivot;
  lhsY[0][3][CC][0][i][k] = lhsY[0][3][CC][0][i][k]*pivot;
  lhsY[0][4][CC][0][i][k] = lhsY[0][4][CC][0][i][k]*pivot;
  rhs[0][k][0][i]   = rhs[0][k][0][i]  *pivot;

  coeff = lhsY[1][0][BB][0][i][k];
  lhsY[1][1][BB][0][i][k]= lhsY[1][1][BB][0][i][k] - coeff*lhsY[0][1][BB][0][i][k];
  lhsY[1][2][BB][0][i][k]= lhsY[1][2][BB][0][i][k] - coeff*lhsY[0][2][BB][0][i][k];
  lhsY[1][3][BB][0][i][k]= lhsY[1][3][BB][0][i][k] - coeff*lhsY[0][3][BB][0][i][k];
  lhsY[1][4][BB][0][i][k]= lhsY[1][4][BB][0][i][k] - coeff*lhsY[0][4][BB][0][i][k];
  lhsY[1][0][CC][0][i][k] = lhsY[1][0][CC][0][i][k] - coeff*lhsY[0][0][CC][0][i][k];
  lhsY[1][1][CC][0][i][k] = lhsY[1][1][CC][0][i][k] - coeff*lhsY[0][1][CC][0][i][k];
  lhsY[1][2][CC][0][i][k] = lhsY[1][2][CC][0][i][k] - coeff*lhsY[0][2][CC][0][i][k];
  lhsY[1][3][CC][0][i][k] = lhsY[1][3][CC][0][i][k] - coeff*lhsY[0][3][CC][0][i][k];
  lhsY[1][4][CC][0][i][k] = lhsY[1][4][CC][0][i][k] - coeff*lhsY[0][4][CC][0][i][k];
  rhs[1][k][0][i]   = rhs[1][k][0][i]   - coeff*rhs[0][k][0][i];

  coeff = lhsY[2][0][BB][0][i][k];
  lhsY[2][1][BB][0][i][k]= lhsY[2][1][BB][0][i][k] - coeff*lhsY[0][1][BB][0][i][k];
  lhsY[2][2][BB][0][i][k]= lhsY[2][2][BB][0][i][k] - coeff*lhsY[0][2][BB][0][i][k];
  lhsY[2][3][BB][0][i][k]= lhsY[2][3][BB][0][i][k] - coeff*lhsY[0][3][BB][0][i][k];
  lhsY[2][4][BB][0][i][k]= lhsY[2][4][BB][0][i][k] - coeff*lhsY[0][4][BB][0][i][k];
  lhsY[2][0][CC][0][i][k] = lhsY[2][0][CC][0][i][k] - coeff*lhsY[0][0][CC][0][i][k];
  lhsY[2][1][CC][0][i][k] = lhsY[2][1][CC][0][i][k] - coeff*lhsY[0][1][CC][0][i][k];
  lhsY[2][2][CC][0][i][k] = lhsY[2][2][CC][0][i][k] - coeff*lhsY[0][2][CC][0][i][k];
  lhsY[2][3][CC][0][i][k] = lhsY[2][3][CC][0][i][k] - coeff*lhsY[0][3][CC][0][i][k];
  lhsY[2][4][CC][0][i][k] = lhsY[2][4][CC][0][i][k] - coeff*lhsY[0][4][CC][0][i][k];
  rhs[2][k][0][i]   = rhs[2][k][0][i]   - coeff*rhs[0][k][0][i];

  coeff = lhsY[3][0][BB][0][i][k];
  lhsY[3][1][BB][0][i][k]= lhsY[3][1][BB][0][i][k] - coeff*lhsY[0][1][BB][0][i][k];
  lhsY[3][2][BB][0][i][k]= lhsY[3][2][BB][0][i][k] - coeff*lhsY[0][2][BB][0][i][k];
  lhsY[3][3][BB][0][i][k]= lhsY[3][3][BB][0][i][k] - coeff*lhsY[0][3][BB][0][i][k];
  lhsY[3][4][BB][0][i][k]= lhsY[3][4][BB][0][i][k] - coeff*lhsY[0][4][BB][0][i][k];
  lhsY[3][0][CC][0][i][k] = lhsY[3][0][CC][0][i][k] - coeff*lhsY[0][0][CC][0][i][k];
  lhsY[3][1][CC][0][i][k] = lhsY[3][1][CC][0][i][k] - coeff*lhsY[0][1][CC][0][i][k];
  lhsY[3][2][CC][0][i][k] = lhsY[3][2][CC][0][i][k] - coeff*lhsY[0][2][CC][0][i][k];
  lhsY[3][3][CC][0][i][k] = lhsY[3][3][CC][0][i][k] - coeff*lhsY[0][3][CC][0][i][k];
  lhsY[3][4][CC][0][i][k] = lhsY[3][4][CC][0][i][k] - coeff*lhsY[0][4][CC][0][i][k];
  rhs[3][k][0][i]   = rhs[3][k][0][i]   - coeff*rhs[0][k][0][i];

  coeff = lhsY[4][0][BB][0][i][k];
  lhsY[4][1][BB][0][i][k]= lhsY[4][1][BB][0][i][k] - coeff*lhsY[0][1][BB][0][i][k];
  lhsY[4][2][BB][0][i][k]= lhsY[4][2][BB][0][i][k] - coeff*lhsY[0][2][BB][0][i][k];
  lhsY[4][3][BB][0][i][k]= lhsY[4][3][BB][0][i][k] - coeff*lhsY[0][3][BB][0][i][k];
  lhsY[4][4][BB][0][i][k]= lhsY[4][4][BB][0][i][k] - coeff*lhsY[0][4][BB][0][i][k];
  lhsY[4][0][CC][0][i][k] = lhsY[4][0][CC][0][i][k] - coeff*lhsY[0][0][CC][0][i][k];
  lhsY[4][1][CC][0][i][k] = lhsY[4][1][CC][0][i][k] - coeff*lhsY[0][1][CC][0][i][k];
  lhsY[4][2][CC][0][i][k] = lhsY[4][2][CC][0][i][k] - coeff*lhsY[0][2][CC][0][i][k];
  lhsY[4][3][CC][0][i][k] = lhsY[4][3][CC][0][i][k] - coeff*lhsY[0][3][CC][0][i][k];
  lhsY[4][4][CC][0][i][k] = lhsY[4][4][CC][0][i][k] - coeff*lhsY[0][4][CC][0][i][k];
  rhs[4][k][0][i]   = rhs[4][k][0][i]   - coeff*rhs[0][k][0][i];


  pivot = 1.00/lhsY[1][1][BB][0][i][k];
  lhsY[1][2][BB][0][i][k] = lhsY[1][2][BB][0][i][k]*pivot;
  lhsY[1][3][BB][0][i][k] = lhsY[1][3][BB][0][i][k]*pivot;
  lhsY[1][4][BB][0][i][k] = lhsY[1][4][BB][0][i][k]*pivot;
  lhsY[1][0][CC][0][i][k] = lhsY[1][0][CC][0][i][k]*pivot;
  lhsY[1][1][CC][0][i][k] = lhsY[1][1][CC][0][i][k]*pivot;
  lhsY[1][2][CC][0][i][k] = lhsY[1][2][CC][0][i][k]*pivot;
  lhsY[1][3][CC][0][i][k] = lhsY[1][3][CC][0][i][k]*pivot;
  lhsY[1][4][CC][0][i][k] = lhsY[1][4][CC][0][i][k]*pivot;
  rhs[1][k][0][i]   = rhs[1][k][0][i]  *pivot;

  coeff = lhsY[0][1][BB][0][i][k];
  lhsY[0][2][BB][0][i][k]= lhsY[0][2][BB][0][i][k] - coeff*lhsY[1][2][BB][0][i][k];
  lhsY[0][3][BB][0][i][k]= lhsY[0][3][BB][0][i][k] - coeff*lhsY[1][3][BB][0][i][k];
  lhsY[0][4][BB][0][i][k]= lhsY[0][4][BB][0][i][k] - coeff*lhsY[1][4][BB][0][i][k];
  lhsY[0][0][CC][0][i][k] = lhsY[0][0][CC][0][i][k] - coeff*lhsY[1][0][CC][0][i][k];
  lhsY[0][1][CC][0][i][k] = lhsY[0][1][CC][0][i][k] - coeff*lhsY[1][1][CC][0][i][k];
  lhsY[0][2][CC][0][i][k] = lhsY[0][2][CC][0][i][k] - coeff*lhsY[1][2][CC][0][i][k];
  lhsY[0][3][CC][0][i][k] = lhsY[0][3][CC][0][i][k] - coeff*lhsY[1][3][CC][0][i][k];
  lhsY[0][4][CC][0][i][k] = lhsY[0][4][CC][0][i][k] - coeff*lhsY[1][4][CC][0][i][k];
  rhs[0][k][0][i]   = rhs[0][k][0][i]   - coeff*rhs[1][k][0][i];

  coeff = lhsY[2][1][BB][0][i][k];
  lhsY[2][2][BB][0][i][k]= lhsY[2][2][BB][0][i][k] - coeff*lhsY[1][2][BB][0][i][k];
  lhsY[2][3][BB][0][i][k]= lhsY[2][3][BB][0][i][k] - coeff*lhsY[1][3][BB][0][i][k];
  lhsY[2][4][BB][0][i][k]= lhsY[2][4][BB][0][i][k] - coeff*lhsY[1][4][BB][0][i][k];
  lhsY[2][0][CC][0][i][k] = lhsY[2][0][CC][0][i][k] - coeff*lhsY[1][0][CC][0][i][k];
  lhsY[2][1][CC][0][i][k] = lhsY[2][1][CC][0][i][k] - coeff*lhsY[1][1][CC][0][i][k];
  lhsY[2][2][CC][0][i][k] = lhsY[2][2][CC][0][i][k] - coeff*lhsY[1][2][CC][0][i][k];
  lhsY[2][3][CC][0][i][k] = lhsY[2][3][CC][0][i][k] - coeff*lhsY[1][3][CC][0][i][k];
  lhsY[2][4][CC][0][i][k] = lhsY[2][4][CC][0][i][k] - coeff*lhsY[1][4][CC][0][i][k];
  rhs[2][k][0][i]   = rhs[2][k][0][i]   - coeff*rhs[1][k][0][i];

  coeff = lhsY[3][1][BB][0][i][k];
  lhsY[3][2][BB][0][i][k]= lhsY[3][2][BB][0][i][k] - coeff*lhsY[1][2][BB][0][i][k];
  lhsY[3][3][BB][0][i][k]= lhsY[3][3][BB][0][i][k] - coeff*lhsY[1][3][BB][0][i][k];
  lhsY[3][4][BB][0][i][k]= lhsY[3][4][BB][0][i][k] - coeff*lhsY[1][4][BB][0][i][k];
  lhsY[3][0][CC][0][i][k] = lhsY[3][0][CC][0][i][k] - coeff*lhsY[1][0][CC][0][i][k];
  lhsY[3][1][CC][0][i][k] = lhsY[3][1][CC][0][i][k] - coeff*lhsY[1][1][CC][0][i][k];
  lhsY[3][2][CC][0][i][k] = lhsY[3][2][CC][0][i][k] - coeff*lhsY[1][2][CC][0][i][k];
  lhsY[3][3][CC][0][i][k] = lhsY[3][3][CC][0][i][k] - coeff*lhsY[1][3][CC][0][i][k];
  lhsY[3][4][CC][0][i][k] = lhsY[3][4][CC][0][i][k] - coeff*lhsY[1][4][CC][0][i][k];
  rhs[3][k][0][i]   = rhs[3][k][0][i]   - coeff*rhs[1][k][0][i];

  coeff = lhsY[4][1][BB][0][i][k];
  lhsY[4][2][BB][0][i][k]= lhsY[4][2][BB][0][i][k] - coeff*lhsY[1][2][BB][0][i][k];
  lhsY[4][3][BB][0][i][k]= lhsY[4][3][BB][0][i][k] - coeff*lhsY[1][3][BB][0][i][k];
  lhsY[4][4][BB][0][i][k]= lhsY[4][4][BB][0][i][k] - coeff*lhsY[1][4][BB][0][i][k];
  lhsY[4][0][CC][0][i][k] = lhsY[4][0][CC][0][i][k] - coeff*lhsY[1][0][CC][0][i][k];
  lhsY[4][1][CC][0][i][k] = lhsY[4][1][CC][0][i][k] - coeff*lhsY[1][1][CC][0][i][k];
  lhsY[4][2][CC][0][i][k] = lhsY[4][2][CC][0][i][k] - coeff*lhsY[1][2][CC][0][i][k];
  lhsY[4][3][CC][0][i][k] = lhsY[4][3][CC][0][i][k] - coeff*lhsY[1][3][CC][0][i][k];
  lhsY[4][4][CC][0][i][k] = lhsY[4][4][CC][0][i][k] - coeff*lhsY[1][4][CC][0][i][k];
  rhs[4][k][0][i]   = rhs[4][k][0][i]   - coeff*rhs[1][k][0][i];


  pivot = 1.00/lhsY[2][2][BB][0][i][k];
  lhsY[2][3][BB][0][i][k] = lhsY[2][3][BB][0][i][k]*pivot;
  lhsY[2][4][BB][0][i][k] = lhsY[2][4][BB][0][i][k]*pivot;
  lhsY[2][0][CC][0][i][k] = lhsY[2][0][CC][0][i][k]*pivot;
  lhsY[2][1][CC][0][i][k] = lhsY[2][1][CC][0][i][k]*pivot;
  lhsY[2][2][CC][0][i][k] = lhsY[2][2][CC][0][i][k]*pivot;
  lhsY[2][3][CC][0][i][k] = lhsY[2][3][CC][0][i][k]*pivot;
  lhsY[2][4][CC][0][i][k] = lhsY[2][4][CC][0][i][k]*pivot;
  rhs[2][k][0][i]   = rhs[2][k][0][i]  *pivot;

  coeff = lhsY[0][2][BB][0][i][k];
  lhsY[0][3][BB][0][i][k]= lhsY[0][3][BB][0][i][k] - coeff*lhsY[2][3][BB][0][i][k];
  lhsY[0][4][BB][0][i][k]= lhsY[0][4][BB][0][i][k] - coeff*lhsY[2][4][BB][0][i][k];
  lhsY[0][0][CC][0][i][k] = lhsY[0][0][CC][0][i][k] - coeff*lhsY[2][0][CC][0][i][k];
  lhsY[0][1][CC][0][i][k] = lhsY[0][1][CC][0][i][k] - coeff*lhsY[2][1][CC][0][i][k];
  lhsY[0][2][CC][0][i][k] = lhsY[0][2][CC][0][i][k] - coeff*lhsY[2][2][CC][0][i][k];
  lhsY[0][3][CC][0][i][k] = lhsY[0][3][CC][0][i][k] - coeff*lhsY[2][3][CC][0][i][k];
  lhsY[0][4][CC][0][i][k] = lhsY[0][4][CC][0][i][k] - coeff*lhsY[2][4][CC][0][i][k];
  rhs[0][k][0][i]   = rhs[0][k][0][i]   - coeff*rhs[2][k][0][i];

  coeff = lhsY[1][2][BB][0][i][k];
  lhsY[1][3][BB][0][i][k]= lhsY[1][3][BB][0][i][k] - coeff*lhsY[2][3][BB][0][i][k];
  lhsY[1][4][BB][0][i][k]= lhsY[1][4][BB][0][i][k] - coeff*lhsY[2][4][BB][0][i][k];
  lhsY[1][0][CC][0][i][k] = lhsY[1][0][CC][0][i][k] - coeff*lhsY[2][0][CC][0][i][k];
  lhsY[1][1][CC][0][i][k] = lhsY[1][1][CC][0][i][k] - coeff*lhsY[2][1][CC][0][i][k];
  lhsY[1][2][CC][0][i][k] = lhsY[1][2][CC][0][i][k] - coeff*lhsY[2][2][CC][0][i][k];
  lhsY[1][3][CC][0][i][k] = lhsY[1][3][CC][0][i][k] - coeff*lhsY[2][3][CC][0][i][k];
  lhsY[1][4][CC][0][i][k] = lhsY[1][4][CC][0][i][k] - coeff*lhsY[2][4][CC][0][i][k];
  rhs[1][k][0][i]   = rhs[1][k][0][i]   - coeff*rhs[2][k][0][i];

  coeff = lhsY[3][2][BB][0][i][k];
  lhsY[3][3][BB][0][i][k]= lhsY[3][3][BB][0][i][k] - coeff*lhsY[2][3][BB][0][i][k];
  lhsY[3][4][BB][0][i][k]= lhsY[3][4][BB][0][i][k] - coeff*lhsY[2][4][BB][0][i][k];
  lhsY[3][0][CC][0][i][k] = lhsY[3][0][CC][0][i][k] - coeff*lhsY[2][0][CC][0][i][k];
  lhsY[3][1][CC][0][i][k] = lhsY[3][1][CC][0][i][k] - coeff*lhsY[2][1][CC][0][i][k];
  lhsY[3][2][CC][0][i][k] = lhsY[3][2][CC][0][i][k] - coeff*lhsY[2][2][CC][0][i][k];
  lhsY[3][3][CC][0][i][k] = lhsY[3][3][CC][0][i][k] - coeff*lhsY[2][3][CC][0][i][k];
  lhsY[3][4][CC][0][i][k] = lhsY[3][4][CC][0][i][k] - coeff*lhsY[2][4][CC][0][i][k];
  rhs[3][k][0][i]   = rhs[3][k][0][i]   - coeff*rhs[2][k][0][i];

  coeff = lhsY[4][2][BB][0][i][k];
  lhsY[4][3][BB][0][i][k]= lhsY[4][3][BB][0][i][k] - coeff*lhsY[2][3][BB][0][i][k];
  lhsY[4][4][BB][0][i][k]= lhsY[4][4][BB][0][i][k] - coeff*lhsY[2][4][BB][0][i][k];
  lhsY[4][0][CC][0][i][k] = lhsY[4][0][CC][0][i][k] - coeff*lhsY[2][0][CC][0][i][k];
  lhsY[4][1][CC][0][i][k] = lhsY[4][1][CC][0][i][k] - coeff*lhsY[2][1][CC][0][i][k];
  lhsY[4][2][CC][0][i][k] = lhsY[4][2][CC][0][i][k] - coeff*lhsY[2][2][CC][0][i][k];
  lhsY[4][3][CC][0][i][k] = lhsY[4][3][CC][0][i][k] - coeff*lhsY[2][3][CC][0][i][k];
  lhsY[4][4][CC][0][i][k] = lhsY[4][4][CC][0][i][k] - coeff*lhsY[2][4][CC][0][i][k];
  rhs[4][k][0][i]   = rhs[4][k][0][i]   - coeff*rhs[2][k][0][i];


  pivot = 1.00/lhsY[3][3][BB][0][i][k];
  lhsY[3][4][BB][0][i][k] = lhsY[3][4][BB][0][i][k]*pivot;
  lhsY[3][0][CC][0][i][k] = lhsY[3][0][CC][0][i][k]*pivot;
  lhsY[3][1][CC][0][i][k] = lhsY[3][1][CC][0][i][k]*pivot;
  lhsY[3][2][CC][0][i][k] = lhsY[3][2][CC][0][i][k]*pivot;
  lhsY[3][3][CC][0][i][k] = lhsY[3][3][CC][0][i][k]*pivot;
  lhsY[3][4][CC][0][i][k] = lhsY[3][4][CC][0][i][k]*pivot;
  rhs[3][k][0][i]   = rhs[3][k][0][i]  *pivot;

  coeff = lhsY[0][3][BB][0][i][k];
  lhsY[0][4][BB][0][i][k]= lhsY[0][4][BB][0][i][k] - coeff*lhsY[3][4][BB][0][i][k];
  lhsY[0][0][CC][0][i][k] = lhsY[0][0][CC][0][i][k] - coeff*lhsY[3][0][CC][0][i][k];
  lhsY[0][1][CC][0][i][k] = lhsY[0][1][CC][0][i][k] - coeff*lhsY[3][1][CC][0][i][k];
  lhsY[0][2][CC][0][i][k] = lhsY[0][2][CC][0][i][k] - coeff*lhsY[3][2][CC][0][i][k];
  lhsY[0][3][CC][0][i][k] = lhsY[0][3][CC][0][i][k] - coeff*lhsY[3][3][CC][0][i][k];
  lhsY[0][4][CC][0][i][k] = lhsY[0][4][CC][0][i][k] - coeff*lhsY[3][4][CC][0][i][k];
  rhs[0][k][0][i]   = rhs[0][k][0][i]   - coeff*rhs[3][k][0][i];

  coeff = lhsY[1][3][BB][0][i][k];
  lhsY[1][4][BB][0][i][k]= lhsY[1][4][BB][0][i][k] - coeff*lhsY[3][4][BB][0][i][k];
  lhsY[1][0][CC][0][i][k] = lhsY[1][0][CC][0][i][k] - coeff*lhsY[3][0][CC][0][i][k];
  lhsY[1][1][CC][0][i][k] = lhsY[1][1][CC][0][i][k] - coeff*lhsY[3][1][CC][0][i][k];
  lhsY[1][2][CC][0][i][k] = lhsY[1][2][CC][0][i][k] - coeff*lhsY[3][2][CC][0][i][k];
  lhsY[1][3][CC][0][i][k] = lhsY[1][3][CC][0][i][k] - coeff*lhsY[3][3][CC][0][i][k];
  lhsY[1][4][CC][0][i][k] = lhsY[1][4][CC][0][i][k] - coeff*lhsY[3][4][CC][0][i][k];
  rhs[1][k][0][i]   = rhs[1][k][0][i]   - coeff*rhs[3][k][0][i];

  coeff = lhsY[2][3][BB][0][i][k];
  lhsY[2][4][BB][0][i][k]= lhsY[2][4][BB][0][i][k] - coeff*lhsY[3][4][BB][0][i][k];
  lhsY[2][0][CC][0][i][k] = lhsY[2][0][CC][0][i][k] - coeff*lhsY[3][0][CC][0][i][k];
  lhsY[2][1][CC][0][i][k] = lhsY[2][1][CC][0][i][k] - coeff*lhsY[3][1][CC][0][i][k];
  lhsY[2][2][CC][0][i][k] = lhsY[2][2][CC][0][i][k] - coeff*lhsY[3][2][CC][0][i][k];
  lhsY[2][3][CC][0][i][k] = lhsY[2][3][CC][0][i][k] - coeff*lhsY[3][3][CC][0][i][k];
  lhsY[2][4][CC][0][i][k] = lhsY[2][4][CC][0][i][k] - coeff*lhsY[3][4][CC][0][i][k];
  rhs[2][k][0][i]   = rhs[2][k][0][i]   - coeff*rhs[3][k][0][i];

  coeff = lhsY[4][3][BB][0][i][k];
  lhsY[4][4][BB][0][i][k]= lhsY[4][4][BB][0][i][k] - coeff*lhsY[3][4][BB][0][i][k];
  lhsY[4][0][CC][0][i][k] = lhsY[4][0][CC][0][i][k] - coeff*lhsY[3][0][CC][0][i][k];
  lhsY[4][1][CC][0][i][k] = lhsY[4][1][CC][0][i][k] - coeff*lhsY[3][1][CC][0][i][k];
  lhsY[4][2][CC][0][i][k] = lhsY[4][2][CC][0][i][k] - coeff*lhsY[3][2][CC][0][i][k];
  lhsY[4][3][CC][0][i][k] = lhsY[4][3][CC][0][i][k] - coeff*lhsY[3][3][CC][0][i][k];
  lhsY[4][4][CC][0][i][k] = lhsY[4][4][CC][0][i][k] - coeff*lhsY[3][4][CC][0][i][k];
  rhs[4][k][0][i]   = rhs[4][k][0][i]   - coeff*rhs[3][k][0][i];


  pivot = 1.00/lhsY[4][4][BB][0][i][k];
  lhsY[4][0][CC][0][i][k] = lhsY[4][0][CC][0][i][k]*pivot;
  lhsY[4][1][CC][0][i][k] = lhsY[4][1][CC][0][i][k]*pivot;
  lhsY[4][2][CC][0][i][k] = lhsY[4][2][CC][0][i][k]*pivot;
  lhsY[4][3][CC][0][i][k] = lhsY[4][3][CC][0][i][k]*pivot;
  lhsY[4][4][CC][0][i][k] = lhsY[4][4][CC][0][i][k]*pivot;
  rhs[4][k][0][i]   = rhs[4][k][0][i]  *pivot;

  coeff = lhsY[0][4][BB][0][i][k];
  lhsY[0][0][CC][0][i][k] = lhsY[0][0][CC][0][i][k] - coeff*lhsY[4][0][CC][0][i][k];
  lhsY[0][1][CC][0][i][k] = lhsY[0][1][CC][0][i][k] - coeff*lhsY[4][1][CC][0][i][k];
  lhsY[0][2][CC][0][i][k] = lhsY[0][2][CC][0][i][k] - coeff*lhsY[4][2][CC][0][i][k];
  lhsY[0][3][CC][0][i][k] = lhsY[0][3][CC][0][i][k] - coeff*lhsY[4][3][CC][0][i][k];
  lhsY[0][4][CC][0][i][k] = lhsY[0][4][CC][0][i][k] - coeff*lhsY[4][4][CC][0][i][k];
  rhs[0][k][0][i]   = rhs[0][k][0][i]   - coeff*rhs[4][k][0][i];

  coeff = lhsY[1][4][BB][0][i][k];
  lhsY[1][0][CC][0][i][k] = lhsY[1][0][CC][0][i][k] - coeff*lhsY[4][0][CC][0][i][k];
  lhsY[1][1][CC][0][i][k] = lhsY[1][1][CC][0][i][k] - coeff*lhsY[4][1][CC][0][i][k];
  lhsY[1][2][CC][0][i][k] = lhsY[1][2][CC][0][i][k] - coeff*lhsY[4][2][CC][0][i][k];
  lhsY[1][3][CC][0][i][k] = lhsY[1][3][CC][0][i][k] - coeff*lhsY[4][3][CC][0][i][k];
  lhsY[1][4][CC][0][i][k] = lhsY[1][4][CC][0][i][k] - coeff*lhsY[4][4][CC][0][i][k];
  rhs[1][k][0][i]   = rhs[1][k][0][i]   - coeff*rhs[4][k][0][i];

  coeff = lhsY[2][4][BB][0][i][k];
  lhsY[2][0][CC][0][i][k] = lhsY[2][0][CC][0][i][k] - coeff*lhsY[4][0][CC][0][i][k];
  lhsY[2][1][CC][0][i][k] = lhsY[2][1][CC][0][i][k] - coeff*lhsY[4][1][CC][0][i][k];
  lhsY[2][2][CC][0][i][k] = lhsY[2][2][CC][0][i][k] - coeff*lhsY[4][2][CC][0][i][k];
  lhsY[2][3][CC][0][i][k] = lhsY[2][3][CC][0][i][k] - coeff*lhsY[4][3][CC][0][i][k];
  lhsY[2][4][CC][0][i][k] = lhsY[2][4][CC][0][i][k] - coeff*lhsY[4][4][CC][0][i][k];
  rhs[2][k][0][i]   = rhs[2][k][0][i]   - coeff*rhs[4][k][0][i];

  coeff = lhsY[3][4][BB][0][i][k];
  lhsY[3][0][CC][0][i][k] = lhsY[3][0][CC][0][i][k] - coeff*lhsY[4][0][CC][0][i][k];
  lhsY[3][1][CC][0][i][k] = lhsY[3][1][CC][0][i][k] - coeff*lhsY[4][1][CC][0][i][k];
  lhsY[3][2][CC][0][i][k] = lhsY[3][2][CC][0][i][k] - coeff*lhsY[4][2][CC][0][i][k];
  lhsY[3][3][CC][0][i][k] = lhsY[3][3][CC][0][i][k] - coeff*lhsY[4][3][CC][0][i][k];
  lhsY[3][4][CC][0][i][k] = lhsY[3][4][CC][0][i][k] - coeff*lhsY[4][4][CC][0][i][k];
  rhs[3][k][0][i]   = rhs[3][k][0][i]   - coeff*rhs[4][k][0][i];


	}/*end i*/
  }/*end k*/
      //---------------------------------------------------------------------
      // begin inner most do loop
      // do all the elements of the cell unless last 
      //---------------------------------------------------------------------
    #pragma acc parallel loop gang num_gangs(gp02) num_workers(4) vector_length(32)  
    for (i = 1; i <= gp02; i++) {
 #pragma acc loop worker vector
  for (k = 1; k <= gp22; k++) {
      for (j = 1; j <= jsize-1; j++) {
        //-------------------------------------------------------------------
        // subtract A*lhsY[k][i]_vector(j-1) from lhsY[k][i]_vector(j)
        // 
        // rhs(j) = rhs(j) - A*rhs(j-1)
        //-------------------------------------------------------------------
        //matvec_sub(lhsY[i][j-1][AA], rhs[k][k][j][i], rhs[k][j][i]);
		/*
		for(m = 0; m < 5; m++){
			rhs[m][k][j][i] = rhs[m][k][j][i] - lhsY[m][0][AA][j][i][k]*rhs[0][k][j-1][i]
											  - lhsY[m][1][AA][j][i][k]*rhs[1][k][j-1][i]
											  - lhsY[m][2][AA][j][i][k]*rhs[2][k][j-1][i]
											  - lhsY[m][3][AA][j][i][k]*rhs[3][k][j-1][i]
											  - lhsY[m][4][AA][j][i][k]*rhs[4][k][j-1][i];
		}
		*/

  rhs[0][k][j][i] = rhs[0][k][j][i] - lhsY[0][0][AA][j][i][k]*rhs[0][k][j-1][i]
                    - lhsY[0][1][AA][j][i][k]*rhs[1][k][j-1][i]
                    - lhsY[0][2][AA][j][i][k]*rhs[2][k][j-1][i]
                    - lhsY[0][3][AA][j][i][k]*rhs[3][k][j-1][i]
                    - lhsY[0][4][AA][j][i][k]*rhs[4][k][j-1][i];
  rhs[1][k][j][i] = rhs[1][k][j][i] - lhsY[1][0][AA][j][i][k]*rhs[0][k][j-1][i]
                    - lhsY[1][1][AA][j][i][k]*rhs[1][k][j-1][i]
                    - lhsY[1][2][AA][j][i][k]*rhs[2][k][j-1][i]
                    - lhsY[1][3][AA][j][i][k]*rhs[3][k][j-1][i]
                    - lhsY[1][4][AA][j][i][k]*rhs[4][k][j-1][i];
  rhs[2][k][j][i] = rhs[2][k][j][i] - lhsY[2][0][AA][j][i][k]*rhs[0][k][j-1][i]
                    - lhsY[2][1][AA][j][i][k]*rhs[1][k][j-1][i]
                    - lhsY[2][2][AA][j][i][k]*rhs[2][k][j-1][i]
                    - lhsY[2][3][AA][j][i][k]*rhs[3][k][j-1][i]
                    - lhsY[2][4][AA][j][i][k]*rhs[4][k][j-1][i];
  rhs[3][k][j][i] = rhs[3][k][j][i] - lhsY[3][0][AA][j][i][k]*rhs[0][k][j-1][i]
                    - lhsY[3][1][AA][j][i][k]*rhs[1][k][j-1][i]
                    - lhsY[3][2][AA][j][i][k]*rhs[2][k][j-1][i]
                    - lhsY[3][3][AA][j][i][k]*rhs[3][k][j-1][i]
                    - lhsY[3][4][AA][j][i][k]*rhs[4][k][j-1][i];
  rhs[4][k][j][i] = rhs[4][k][j][i] - lhsY[4][0][AA][j][i][k]*rhs[0][k][j-1][i]
                    - lhsY[4][1][AA][j][i][k]*rhs[1][k][j-1][i]
                    - lhsY[4][2][AA][j][i][k]*rhs[2][k][j-1][i]
                    - lhsY[4][3][AA][j][i][k]*rhs[3][k][j-1][i]
                    - lhsY[4][4][AA][j][i][k]*rhs[4][k][j-1][i];

        //-------------------------------------------------------------------
        // B(j) = B(j) - C(j-1)*A(j)
        //-------------------------------------------------------------------
      //  matmul_sub(lhsY[j-1][i][AA], lhsY[k][j][i][k][CC], lhsY[k][i][j][BB]);
	  /*
	  for(m = 0; m < 5; m++){
	  	for(n = 0; n < 5; n++){
			lhsY[n][m][BB][j][i][k] = lhsY[n][m][BB][j][i][k] - lhsY[n][0][AA][j][i][k]*lhsY[0][m][CC][j-1][i][k]
												- lhsY[n][1][AA][j][i][k]*lhsY[1][m][CC][j-1][i][k]
												- lhsY[n][2][AA][j][i][k]*lhsY[2][m][CC][j-1][i][k]
												- lhsY[n][3][AA][j][i][k]*lhsY[3][m][CC][j-1][i][k]
												- lhsY[n][4][AA][j][i][k]*lhsY[4][m][CC][j-1][i][k];
		}
	  }
		*/
		
  lhsY[0][0][BB][j][i][k] = lhsY[0][0][BB][j][i][k] - lhsY[0][0][AA][j][i][k]*lhsY[0][0][CC][j-1][i][k]
                              - lhsY[0][1][AA][j][i][k]*lhsY[1][0][CC][j-1][i][k]
                              - lhsY[0][2][AA][j][i][k]*lhsY[2][0][CC][j-1][i][k]
                              - lhsY[0][3][AA][j][i][k]*lhsY[3][0][CC][j-1][i][k]
                              - lhsY[0][4][AA][j][i][k]*lhsY[4][0][CC][j-1][i][k];
  lhsY[1][0][BB][j][i][k] = lhsY[1][0][BB][j][i][k] - lhsY[1][0][AA][j][i][k]*lhsY[0][0][CC][j-1][i][k]
                              - lhsY[1][1][AA][j][i][k]*lhsY[1][0][CC][j-1][i][k]
                              - lhsY[1][2][AA][j][i][k]*lhsY[2][0][CC][j-1][i][k]
                              - lhsY[1][3][AA][j][i][k]*lhsY[3][0][CC][j-1][i][k]
                              - lhsY[1][4][AA][j][i][k]*lhsY[4][0][CC][j-1][i][k];
  lhsY[2][0][BB][j][i][k] = lhsY[2][0][BB][j][i][k] - lhsY[2][0][AA][j][i][k]*lhsY[0][0][CC][j-1][i][k]
                              - lhsY[2][1][AA][j][i][k]*lhsY[1][0][CC][j-1][i][k]
                              - lhsY[2][2][AA][j][i][k]*lhsY[2][0][CC][j-1][i][k]
                              - lhsY[2][3][AA][j][i][k]*lhsY[3][0][CC][j-1][i][k]
                              - lhsY[2][4][AA][j][i][k]*lhsY[4][0][CC][j-1][i][k];
  lhsY[3][0][BB][j][i][k] = lhsY[3][0][BB][j][i][k] - lhsY[3][0][AA][j][i][k]*lhsY[0][0][CC][j-1][i][k]
                              - lhsY[3][1][AA][j][i][k]*lhsY[1][0][CC][j-1][i][k]
                              - lhsY[3][2][AA][j][i][k]*lhsY[2][0][CC][j-1][i][k]
                              - lhsY[3][3][AA][j][i][k]*lhsY[3][0][CC][j-1][i][k]
                              - lhsY[3][4][AA][j][i][k]*lhsY[4][0][CC][j-1][i][k];
  lhsY[4][0][BB][j][i][k] = lhsY[4][0][BB][j][i][k] - lhsY[4][0][AA][j][i][k]*lhsY[0][0][CC][j-1][i][k]
                              - lhsY[4][1][AA][j][i][k]*lhsY[1][0][CC][j-1][i][k]
                              - lhsY[4][2][AA][j][i][k]*lhsY[2][0][CC][j-1][i][k]
                              - lhsY[4][3][AA][j][i][k]*lhsY[3][0][CC][j-1][i][k]
                              - lhsY[4][4][AA][j][i][k]*lhsY[4][0][CC][j-1][i][k];
  lhsY[0][1][BB][j][i][k] = lhsY[0][1][BB][j][i][k] - lhsY[0][0][AA][j][i][k]*lhsY[0][1][CC][j-1][i][k]
                              - lhsY[0][1][AA][j][i][k]*lhsY[1][1][CC][j-1][i][k]
                              - lhsY[0][2][AA][j][i][k]*lhsY[2][1][CC][j-1][i][k]
                              - lhsY[0][3][AA][j][i][k]*lhsY[3][1][CC][j-1][i][k]
                              - lhsY[0][4][AA][j][i][k]*lhsY[4][1][CC][j-1][i][k];
  lhsY[1][1][BB][j][i][k] = lhsY[1][1][BB][j][i][k] - lhsY[1][0][AA][j][i][k]*lhsY[0][1][CC][j-1][i][k]
                              - lhsY[1][1][AA][j][i][k]*lhsY[1][1][CC][j-1][i][k]
                              - lhsY[1][2][AA][j][i][k]*lhsY[2][1][CC][j-1][i][k]
                              - lhsY[1][3][AA][j][i][k]*lhsY[3][1][CC][j-1][i][k]
                              - lhsY[1][4][AA][j][i][k]*lhsY[4][1][CC][j-1][i][k];
  lhsY[2][1][BB][j][i][k] = lhsY[2][1][BB][j][i][k] - lhsY[2][0][AA][j][i][k]*lhsY[0][1][CC][j-1][i][k]
                              - lhsY[2][1][AA][j][i][k]*lhsY[1][1][CC][j-1][i][k]
                              - lhsY[2][2][AA][j][i][k]*lhsY[2][1][CC][j-1][i][k]
                              - lhsY[2][3][AA][j][i][k]*lhsY[3][1][CC][j-1][i][k]
                              - lhsY[2][4][AA][j][i][k]*lhsY[4][1][CC][j-1][i][k];
  lhsY[3][1][BB][j][i][k] = lhsY[3][1][BB][j][i][k] - lhsY[3][0][AA][j][i][k]*lhsY[0][1][CC][j-1][i][k]
                              - lhsY[3][1][AA][j][i][k]*lhsY[1][1][CC][j-1][i][k]
                              - lhsY[3][2][AA][j][i][k]*lhsY[2][1][CC][j-1][i][k]
                              - lhsY[3][3][AA][j][i][k]*lhsY[3][1][CC][j-1][i][k]
                              - lhsY[3][4][AA][j][i][k]*lhsY[4][1][CC][j-1][i][k];
  lhsY[4][1][BB][j][i][k] = lhsY[4][1][BB][j][i][k] - lhsY[4][0][AA][j][i][k]*lhsY[0][1][CC][j-1][i][k]
                              - lhsY[4][1][AA][j][i][k]*lhsY[1][1][CC][j-1][i][k]
                              - lhsY[4][2][AA][j][i][k]*lhsY[2][1][CC][j-1][i][k]
                              - lhsY[4][3][AA][j][i][k]*lhsY[3][1][CC][j-1][i][k]
                              - lhsY[4][4][AA][j][i][k]*lhsY[4][1][CC][j-1][i][k];
  lhsY[0][2][BB][j][i][k] = lhsY[0][2][BB][j][i][k] - lhsY[0][0][AA][j][i][k]*lhsY[0][2][CC][j-1][i][k]
                              - lhsY[0][1][AA][j][i][k]*lhsY[1][2][CC][j-1][i][k]
                              - lhsY[0][2][AA][j][i][k]*lhsY[2][2][CC][j-1][i][k]
                              - lhsY[0][3][AA][j][i][k]*lhsY[3][2][CC][j-1][i][k]
                              - lhsY[0][4][AA][j][i][k]*lhsY[4][2][CC][j-1][i][k];
  lhsY[1][2][BB][j][i][k] = lhsY[1][2][BB][j][i][k] - lhsY[1][0][AA][j][i][k]*lhsY[0][2][CC][j-1][i][k]
                              - lhsY[1][1][AA][j][i][k]*lhsY[1][2][CC][j-1][i][k]
                              - lhsY[1][2][AA][j][i][k]*lhsY[2][2][CC][j-1][i][k]
                              - lhsY[1][3][AA][j][i][k]*lhsY[3][2][CC][j-1][i][k]
                              - lhsY[1][4][AA][j][i][k]*lhsY[4][2][CC][j-1][i][k];
  lhsY[2][2][BB][j][i][k] = lhsY[2][2][BB][j][i][k] - lhsY[2][0][AA][j][i][k]*lhsY[0][2][CC][j-1][i][k]
                              - lhsY[2][1][AA][j][i][k]*lhsY[1][2][CC][j-1][i][k]
                              - lhsY[2][2][AA][j][i][k]*lhsY[2][2][CC][j-1][i][k]
                              - lhsY[2][3][AA][j][i][k]*lhsY[3][2][CC][j-1][i][k]
                              - lhsY[2][4][AA][j][i][k]*lhsY[4][2][CC][j-1][i][k];
  lhsY[3][2][BB][j][i][k] = lhsY[3][2][BB][j][i][k] - lhsY[3][0][AA][j][i][k]*lhsY[0][2][CC][j-1][i][k]
                              - lhsY[3][1][AA][j][i][k]*lhsY[1][2][CC][j-1][i][k]
                              - lhsY[3][2][AA][j][i][k]*lhsY[2][2][CC][j-1][i][k]
                              - lhsY[3][3][AA][j][i][k]*lhsY[3][2][CC][j-1][i][k]
                              - lhsY[3][4][AA][j][i][k]*lhsY[4][2][CC][j-1][i][k];
  lhsY[4][2][BB][j][i][k] = lhsY[4][2][BB][j][i][k] - lhsY[4][0][AA][j][i][k]*lhsY[0][2][CC][j-1][i][k]
                              - lhsY[4][1][AA][j][i][k]*lhsY[1][2][CC][j-1][i][k]
                              - lhsY[4][2][AA][j][i][k]*lhsY[2][2][CC][j-1][i][k]
                              - lhsY[4][3][AA][j][i][k]*lhsY[3][2][CC][j-1][i][k]
                              - lhsY[4][4][AA][j][i][k]*lhsY[4][2][CC][j-1][i][k];
  lhsY[0][3][BB][j][i][k] = lhsY[0][3][BB][j][i][k] - lhsY[0][0][AA][j][i][k]*lhsY[0][3][CC][j-1][i][k]
                              - lhsY[0][1][AA][j][i][k]*lhsY[1][3][CC][j-1][i][k]
                              - lhsY[0][2][AA][j][i][k]*lhsY[2][3][CC][j-1][i][k]
                              - lhsY[0][3][AA][j][i][k]*lhsY[3][3][CC][j-1][i][k]
                              - lhsY[0][4][AA][j][i][k]*lhsY[4][3][CC][j-1][i][k];
  lhsY[1][3][BB][j][i][k] = lhsY[1][3][BB][j][i][k] - lhsY[1][0][AA][j][i][k]*lhsY[0][3][CC][j-1][i][k]
                              - lhsY[1][1][AA][j][i][k]*lhsY[1][3][CC][j-1][i][k]
                              - lhsY[1][2][AA][j][i][k]*lhsY[2][3][CC][j-1][i][k]
                              - lhsY[1][3][AA][j][i][k]*lhsY[3][3][CC][j-1][i][k]
                              - lhsY[1][4][AA][j][i][k]*lhsY[4][3][CC][j-1][i][k];
  lhsY[2][3][BB][j][i][k] = lhsY[2][3][BB][j][i][k] - lhsY[2][0][AA][j][i][k]*lhsY[0][3][CC][j-1][i][k]
                              - lhsY[2][1][AA][j][i][k]*lhsY[1][3][CC][j-1][i][k]
                              - lhsY[2][2][AA][j][i][k]*lhsY[2][3][CC][j-1][i][k]
                              - lhsY[2][3][AA][j][i][k]*lhsY[3][3][CC][j-1][i][k]
                              - lhsY[2][4][AA][j][i][k]*lhsY[4][3][CC][j-1][i][k];
  lhsY[3][3][BB][j][i][k] = lhsY[3][3][BB][j][i][k] - lhsY[3][0][AA][j][i][k]*lhsY[0][3][CC][j-1][i][k]
                              - lhsY[3][1][AA][j][i][k]*lhsY[1][3][CC][j-1][i][k]
                              - lhsY[3][2][AA][j][i][k]*lhsY[2][3][CC][j-1][i][k]
                              - lhsY[3][3][AA][j][i][k]*lhsY[3][3][CC][j-1][i][k]
                              - lhsY[3][4][AA][j][i][k]*lhsY[4][3][CC][j-1][i][k];
  lhsY[4][3][BB][j][i][k] = lhsY[4][3][BB][j][i][k] - lhsY[4][0][AA][j][i][k]*lhsY[0][3][CC][j-1][i][k]
                              - lhsY[4][1][AA][j][i][k]*lhsY[1][3][CC][j-1][i][k]
                              - lhsY[4][2][AA][j][i][k]*lhsY[2][3][CC][j-1][i][k]
                              - lhsY[4][3][AA][j][i][k]*lhsY[3][3][CC][j-1][i][k]
                              - lhsY[4][4][AA][j][i][k]*lhsY[4][3][CC][j-1][i][k];
  lhsY[0][4][BB][j][i][k] = lhsY[0][4][BB][j][i][k] - lhsY[0][0][AA][j][i][k]*lhsY[0][4][CC][j-1][i][k]
                              - lhsY[0][1][AA][j][i][k]*lhsY[1][4][CC][j-1][i][k]
                              - lhsY[0][2][AA][j][i][k]*lhsY[2][4][CC][j-1][i][k]
                              - lhsY[0][3][AA][j][i][k]*lhsY[3][4][CC][j-1][i][k]
                              - lhsY[0][4][AA][j][i][k]*lhsY[4][4][CC][j-1][i][k];
  lhsY[1][4][BB][j][i][k] = lhsY[1][4][BB][j][i][k] - lhsY[1][0][AA][j][i][k]*lhsY[0][4][CC][j-1][i][k]
                              - lhsY[1][1][AA][j][i][k]*lhsY[1][4][CC][j-1][i][k]
                              - lhsY[1][2][AA][j][i][k]*lhsY[2][4][CC][j-1][i][k]
                              - lhsY[1][3][AA][j][i][k]*lhsY[3][4][CC][j-1][i][k]
                              - lhsY[1][4][AA][j][i][k]*lhsY[4][4][CC][j-1][i][k];
  lhsY[2][4][BB][j][i][k] = lhsY[2][4][BB][j][i][k] - lhsY[2][0][AA][j][i][k]*lhsY[0][4][CC][j-1][i][k]
                              - lhsY[2][1][AA][j][i][k]*lhsY[1][4][CC][j-1][i][k]
                              - lhsY[2][2][AA][j][i][k]*lhsY[2][4][CC][j-1][i][k]
                              - lhsY[2][3][AA][j][i][k]*lhsY[3][4][CC][j-1][i][k]
                              - lhsY[2][4][AA][j][i][k]*lhsY[4][4][CC][j-1][i][k];
  lhsY[3][4][BB][j][i][k] = lhsY[3][4][BB][j][i][k] - lhsY[3][0][AA][j][i][k]*lhsY[0][4][CC][j-1][i][k]
                              - lhsY[3][1][AA][j][i][k]*lhsY[1][4][CC][j-1][i][k]
                              - lhsY[3][2][AA][j][i][k]*lhsY[2][4][CC][j-1][i][k]
                              - lhsY[3][3][AA][j][i][k]*lhsY[3][4][CC][j-1][i][k]
                              - lhsY[3][4][AA][j][i][k]*lhsY[4][4][CC][j-1][i][k];
  lhsY[4][4][BB][j][i][k] = lhsY[4][4][BB][j][i][k] - lhsY[4][0][AA][j][i][k]*lhsY[0][4][CC][j-1][i][k]
                              - lhsY[4][1][AA][j][i][k]*lhsY[1][4][CC][j-1][i][k]
                              - lhsY[4][2][AA][j][i][k]*lhsY[2][4][CC][j-1][i][k]
                              - lhsY[4][3][AA][j][i][k]*lhsY[3][4][CC][j-1][i][k]
                              - lhsY[4][4][AA][j][i][k]*lhsY[4][4][CC][j-1][i][k];


        //-------------------------------------------------------------------
        // multiply c[k][j][i] by b_inverse and copy back to c
        // multiply rhs[0][k][0][i] by b_inverse[k][i] and copy to rhs        //-------------------------------------------------------------------
        //binvcrhs( lhsY[j][i][BB], lhsY[k][j][i][k][CC], rhs[k][j][i] );
		/*
	  	for(m = 0; m < 5; m++){
	  		pivot = 1.00/lhsY[m][m][BB][j][i][k];
			for(n = m+1; n < 5; n++){
				lhsY[m][n][BB][j][i][k] = lhsY[m][n][BB][j][i][k]*pivot;
			}
			lhsY[m][0][CC][j][i][k] = lhsY[m][0][CC][j][i][k]*pivot;
			lhsY[m][1][CC][j][i][k] = lhsY[m][1][CC][j][i][k]*pivot;
			lhsY[m][2][CC][j][i][k] = lhsY[m][2][CC][j][i][k]*pivot;
			lhsY[m][3][CC][j][i][k] = lhsY[m][3][CC][j][i][k]*pivot;
			lhsY[m][4][CC][j][i][k] = lhsY[m][4][CC][j][i][k]*pivot;
			rhs[m][k][j][i] = rhs[m][k][j][i]*pivot;

			for(n = 0; n < 5; n++){
			   if(n != m){
					coeff = lhsY[n][m][BB][j][i][k];
					for(z = m+1; z < 5; z++){
						lhsY[n][z][BB][j][i][k] = lhsY[n][z][BB][j][i][k] - coeff*lhsY[m][z][BB][j][i][k];
					}
					lhsY[n][0][CC][j][i][k] = lhsY[n][0][CC][j][i][k] - coeff*lhsY[m][0][CC][j][i][k];
					lhsY[n][1][CC][j][i][k] = lhsY[n][1][CC][j][i][k] - coeff*lhsY[m][1][CC][j][i][k];
					lhsY[n][2][CC][j][i][k] = lhsY[n][2][CC][j][i][k] - coeff*lhsY[m][2][CC][j][i][k];
					lhsY[n][3][CC][j][i][k] = lhsY[n][3][CC][j][i][k] - coeff*lhsY[m][3][CC][j][i][k];
					lhsY[n][4][CC][j][i][k] = lhsY[n][4][CC][j][i][k] - coeff*lhsY[m][4][CC][j][i][k];
					rhs[n][k][j][i] = rhs[n][k][j][i] - coeff*rhs[m][k][j][i];
				}
			}
	  	}
		*/
  pivot = 1.00/lhsY[0][0][BB][j][i][k];
  lhsY[0][1][BB][j][i][k] = lhsY[0][1][BB][j][i][k]*pivot;
  lhsY[0][2][BB][j][i][k] = lhsY[0][2][BB][j][i][k]*pivot;
  lhsY[0][3][BB][j][i][k] = lhsY[0][3][BB][j][i][k]*pivot;
  lhsY[0][4][BB][j][i][k] = lhsY[0][4][BB][j][i][k]*pivot;
  lhsY[0][0][CC][j][i][k] = lhsY[0][0][CC][j][i][k]*pivot;
  lhsY[0][1][CC][j][i][k] = lhsY[0][1][CC][j][i][k]*pivot;
  lhsY[0][2][CC][j][i][k] = lhsY[0][2][CC][j][i][k]*pivot;
  lhsY[0][3][CC][j][i][k] = lhsY[0][3][CC][j][i][k]*pivot;
  lhsY[0][4][CC][j][i][k] = lhsY[0][4][CC][j][i][k]*pivot;
  rhs[0][k][j][i]   = rhs[0][k][j][i]  *pivot;

  coeff = lhsY[1][0][BB][j][i][k];
  lhsY[1][1][BB][j][i][k]= lhsY[1][1][BB][j][i][k] - coeff*lhsY[0][1][BB][j][i][k];
  lhsY[1][2][BB][j][i][k]= lhsY[1][2][BB][j][i][k] - coeff*lhsY[0][2][BB][j][i][k];
  lhsY[1][3][BB][j][i][k]= lhsY[1][3][BB][j][i][k] - coeff*lhsY[0][3][BB][j][i][k];
  lhsY[1][4][BB][j][i][k]= lhsY[1][4][BB][j][i][k] - coeff*lhsY[0][4][BB][j][i][k];
  lhsY[1][0][CC][j][i][k] = lhsY[1][0][CC][j][i][k] - coeff*lhsY[0][0][CC][j][i][k];
  lhsY[1][1][CC][j][i][k] = lhsY[1][1][CC][j][i][k] - coeff*lhsY[0][1][CC][j][i][k];
  lhsY[1][2][CC][j][i][k] = lhsY[1][2][CC][j][i][k] - coeff*lhsY[0][2][CC][j][i][k];
  lhsY[1][3][CC][j][i][k] = lhsY[1][3][CC][j][i][k] - coeff*lhsY[0][3][CC][j][i][k];
  lhsY[1][4][CC][j][i][k] = lhsY[1][4][CC][j][i][k] - coeff*lhsY[0][4][CC][j][i][k];
  rhs[1][k][j][i]   = rhs[1][k][j][i]   - coeff*rhs[0][k][j][i];

  coeff = lhsY[2][0][BB][j][i][k];
  lhsY[2][1][BB][j][i][k]= lhsY[2][1][BB][j][i][k] - coeff*lhsY[0][1][BB][j][i][k];
  lhsY[2][2][BB][j][i][k]= lhsY[2][2][BB][j][i][k] - coeff*lhsY[0][2][BB][j][i][k];
  lhsY[2][3][BB][j][i][k]= lhsY[2][3][BB][j][i][k] - coeff*lhsY[0][3][BB][j][i][k];
  lhsY[2][4][BB][j][i][k]= lhsY[2][4][BB][j][i][k] - coeff*lhsY[0][4][BB][j][i][k];
  lhsY[2][0][CC][j][i][k] = lhsY[2][0][CC][j][i][k] - coeff*lhsY[0][0][CC][j][i][k];
  lhsY[2][1][CC][j][i][k] = lhsY[2][1][CC][j][i][k] - coeff*lhsY[0][1][CC][j][i][k];
  lhsY[2][2][CC][j][i][k] = lhsY[2][2][CC][j][i][k] - coeff*lhsY[0][2][CC][j][i][k];
  lhsY[2][3][CC][j][i][k] = lhsY[2][3][CC][j][i][k] - coeff*lhsY[0][3][CC][j][i][k];
  lhsY[2][4][CC][j][i][k] = lhsY[2][4][CC][j][i][k] - coeff*lhsY[0][4][CC][j][i][k];
  rhs[2][k][j][i]   = rhs[2][k][j][i]   - coeff*rhs[0][k][j][i];

  coeff = lhsY[3][0][BB][j][i][k];
  lhsY[3][1][BB][j][i][k]= lhsY[3][1][BB][j][i][k] - coeff*lhsY[0][1][BB][j][i][k];
  lhsY[3][2][BB][j][i][k]= lhsY[3][2][BB][j][i][k] - coeff*lhsY[0][2][BB][j][i][k];
  lhsY[3][3][BB][j][i][k]= lhsY[3][3][BB][j][i][k] - coeff*lhsY[0][3][BB][j][i][k];
  lhsY[3][4][BB][j][i][k]= lhsY[3][4][BB][j][i][k] - coeff*lhsY[0][4][BB][j][i][k];
  lhsY[3][0][CC][j][i][k] = lhsY[3][0][CC][j][i][k] - coeff*lhsY[0][0][CC][j][i][k];
  lhsY[3][1][CC][j][i][k] = lhsY[3][1][CC][j][i][k] - coeff*lhsY[0][1][CC][j][i][k];
  lhsY[3][2][CC][j][i][k] = lhsY[3][2][CC][j][i][k] - coeff*lhsY[0][2][CC][j][i][k];
  lhsY[3][3][CC][j][i][k] = lhsY[3][3][CC][j][i][k] - coeff*lhsY[0][3][CC][j][i][k];
  lhsY[3][4][CC][j][i][k] = lhsY[3][4][CC][j][i][k] - coeff*lhsY[0][4][CC][j][i][k];
  rhs[3][k][j][i]   = rhs[3][k][j][i]   - coeff*rhs[0][k][j][i];

  coeff = lhsY[4][0][BB][j][i][k];
  lhsY[4][1][BB][j][i][k]= lhsY[4][1][BB][j][i][k] - coeff*lhsY[0][1][BB][j][i][k];
  lhsY[4][2][BB][j][i][k]= lhsY[4][2][BB][j][i][k] - coeff*lhsY[0][2][BB][j][i][k];
  lhsY[4][3][BB][j][i][k]= lhsY[4][3][BB][j][i][k] - coeff*lhsY[0][3][BB][j][i][k];
  lhsY[4][4][BB][j][i][k]= lhsY[4][4][BB][j][i][k] - coeff*lhsY[0][4][BB][j][i][k];
  lhsY[4][0][CC][j][i][k] = lhsY[4][0][CC][j][i][k] - coeff*lhsY[0][0][CC][j][i][k];
  lhsY[4][1][CC][j][i][k] = lhsY[4][1][CC][j][i][k] - coeff*lhsY[0][1][CC][j][i][k];
  lhsY[4][2][CC][j][i][k] = lhsY[4][2][CC][j][i][k] - coeff*lhsY[0][2][CC][j][i][k];
  lhsY[4][3][CC][j][i][k] = lhsY[4][3][CC][j][i][k] - coeff*lhsY[0][3][CC][j][i][k];
  lhsY[4][4][CC][j][i][k] = lhsY[4][4][CC][j][i][k] - coeff*lhsY[0][4][CC][j][i][k];
  rhs[4][k][j][i]   = rhs[4][k][j][i]   - coeff*rhs[0][k][j][i];


  pivot = 1.00/lhsY[1][1][BB][j][i][k];
  lhsY[1][2][BB][j][i][k] = lhsY[1][2][BB][j][i][k]*pivot;
  lhsY[1][3][BB][j][i][k] = lhsY[1][3][BB][j][i][k]*pivot;
  lhsY[1][4][BB][j][i][k] = lhsY[1][4][BB][j][i][k]*pivot;
  lhsY[1][0][CC][j][i][k] = lhsY[1][0][CC][j][i][k]*pivot;
  lhsY[1][1][CC][j][i][k] = lhsY[1][1][CC][j][i][k]*pivot;
  lhsY[1][2][CC][j][i][k] = lhsY[1][2][CC][j][i][k]*pivot;
  lhsY[1][3][CC][j][i][k] = lhsY[1][3][CC][j][i][k]*pivot;
  lhsY[1][4][CC][j][i][k] = lhsY[1][4][CC][j][i][k]*pivot;
  rhs[1][k][j][i]   = rhs[1][k][j][i]  *pivot;

  coeff = lhsY[0][1][BB][j][i][k];
  lhsY[0][2][BB][j][i][k]= lhsY[0][2][BB][j][i][k] - coeff*lhsY[1][2][BB][j][i][k];
  lhsY[0][3][BB][j][i][k]= lhsY[0][3][BB][j][i][k] - coeff*lhsY[1][3][BB][j][i][k];
  lhsY[0][4][BB][j][i][k]= lhsY[0][4][BB][j][i][k] - coeff*lhsY[1][4][BB][j][i][k];
  lhsY[0][0][CC][j][i][k] = lhsY[0][0][CC][j][i][k] - coeff*lhsY[1][0][CC][j][i][k];
  lhsY[0][1][CC][j][i][k] = lhsY[0][1][CC][j][i][k] - coeff*lhsY[1][1][CC][j][i][k];
  lhsY[0][2][CC][j][i][k] = lhsY[0][2][CC][j][i][k] - coeff*lhsY[1][2][CC][j][i][k];
  lhsY[0][3][CC][j][i][k] = lhsY[0][3][CC][j][i][k] - coeff*lhsY[1][3][CC][j][i][k];
  lhsY[0][4][CC][j][i][k] = lhsY[0][4][CC][j][i][k] - coeff*lhsY[1][4][CC][j][i][k];
  rhs[0][k][j][i]   = rhs[0][k][j][i]   - coeff*rhs[1][k][j][i];

  coeff = lhsY[2][1][BB][j][i][k];
  lhsY[2][2][BB][j][i][k]= lhsY[2][2][BB][j][i][k] - coeff*lhsY[1][2][BB][j][i][k];
  lhsY[2][3][BB][j][i][k]= lhsY[2][3][BB][j][i][k] - coeff*lhsY[1][3][BB][j][i][k];
  lhsY[2][4][BB][j][i][k]= lhsY[2][4][BB][j][i][k] - coeff*lhsY[1][4][BB][j][i][k];
  lhsY[2][0][CC][j][i][k] = lhsY[2][0][CC][j][i][k] - coeff*lhsY[1][0][CC][j][i][k];
  lhsY[2][1][CC][j][i][k] = lhsY[2][1][CC][j][i][k] - coeff*lhsY[1][1][CC][j][i][k];
  lhsY[2][2][CC][j][i][k] = lhsY[2][2][CC][j][i][k] - coeff*lhsY[1][2][CC][j][i][k];
  lhsY[2][3][CC][j][i][k] = lhsY[2][3][CC][j][i][k] - coeff*lhsY[1][3][CC][j][i][k];
  lhsY[2][4][CC][j][i][k] = lhsY[2][4][CC][j][i][k] - coeff*lhsY[1][4][CC][j][i][k];
  rhs[2][k][j][i]   = rhs[2][k][j][i]   - coeff*rhs[1][k][j][i];

  coeff = lhsY[3][1][BB][j][i][k];
  lhsY[3][2][BB][j][i][k]= lhsY[3][2][BB][j][i][k] - coeff*lhsY[1][2][BB][j][i][k];
  lhsY[3][3][BB][j][i][k]= lhsY[3][3][BB][j][i][k] - coeff*lhsY[1][3][BB][j][i][k];
  lhsY[3][4][BB][j][i][k]= lhsY[3][4][BB][j][i][k] - coeff*lhsY[1][4][BB][j][i][k];
  lhsY[3][0][CC][j][i][k] = lhsY[3][0][CC][j][i][k] - coeff*lhsY[1][0][CC][j][i][k];
  lhsY[3][1][CC][j][i][k] = lhsY[3][1][CC][j][i][k] - coeff*lhsY[1][1][CC][j][i][k];
  lhsY[3][2][CC][j][i][k] = lhsY[3][2][CC][j][i][k] - coeff*lhsY[1][2][CC][j][i][k];
  lhsY[3][3][CC][j][i][k] = lhsY[3][3][CC][j][i][k] - coeff*lhsY[1][3][CC][j][i][k];
  lhsY[3][4][CC][j][i][k] = lhsY[3][4][CC][j][i][k] - coeff*lhsY[1][4][CC][j][i][k];
  rhs[3][k][j][i]   = rhs[3][k][j][i]   - coeff*rhs[1][k][j][i];

  coeff = lhsY[4][1][BB][j][i][k];
  lhsY[4][2][BB][j][i][k]= lhsY[4][2][BB][j][i][k] - coeff*lhsY[1][2][BB][j][i][k];
  lhsY[4][3][BB][j][i][k]= lhsY[4][3][BB][j][i][k] - coeff*lhsY[1][3][BB][j][i][k];
  lhsY[4][4][BB][j][i][k]= lhsY[4][4][BB][j][i][k] - coeff*lhsY[1][4][BB][j][i][k];
  lhsY[4][0][CC][j][i][k] = lhsY[4][0][CC][j][i][k] - coeff*lhsY[1][0][CC][j][i][k];
  lhsY[4][1][CC][j][i][k] = lhsY[4][1][CC][j][i][k] - coeff*lhsY[1][1][CC][j][i][k];
  lhsY[4][2][CC][j][i][k] = lhsY[4][2][CC][j][i][k] - coeff*lhsY[1][2][CC][j][i][k];
  lhsY[4][3][CC][j][i][k] = lhsY[4][3][CC][j][i][k] - coeff*lhsY[1][3][CC][j][i][k];
  lhsY[4][4][CC][j][i][k] = lhsY[4][4][CC][j][i][k] - coeff*lhsY[1][4][CC][j][i][k];
  rhs[4][k][j][i]   = rhs[4][k][j][i]   - coeff*rhs[1][k][j][i];


  pivot = 1.00/lhsY[2][2][BB][j][i][k];
  lhsY[2][3][BB][j][i][k] = lhsY[2][3][BB][j][i][k]*pivot;
  lhsY[2][4][BB][j][i][k] = lhsY[2][4][BB][j][i][k]*pivot;
  lhsY[2][0][CC][j][i][k] = lhsY[2][0][CC][j][i][k]*pivot;
  lhsY[2][1][CC][j][i][k] = lhsY[2][1][CC][j][i][k]*pivot;
  lhsY[2][2][CC][j][i][k] = lhsY[2][2][CC][j][i][k]*pivot;
  lhsY[2][3][CC][j][i][k] = lhsY[2][3][CC][j][i][k]*pivot;
  lhsY[2][4][CC][j][i][k] = lhsY[2][4][CC][j][i][k]*pivot;
  rhs[2][k][j][i]   = rhs[2][k][j][i]  *pivot;

  coeff = lhsY[0][2][BB][j][i][k];
  lhsY[0][3][BB][j][i][k]= lhsY[0][3][BB][j][i][k] - coeff*lhsY[2][3][BB][j][i][k];
  lhsY[0][4][BB][j][i][k]= lhsY[0][4][BB][j][i][k] - coeff*lhsY[2][4][BB][j][i][k];
  lhsY[0][0][CC][j][i][k] = lhsY[0][0][CC][j][i][k] - coeff*lhsY[2][0][CC][j][i][k];
  lhsY[0][1][CC][j][i][k] = lhsY[0][1][CC][j][i][k] - coeff*lhsY[2][1][CC][j][i][k];
  lhsY[0][2][CC][j][i][k] = lhsY[0][2][CC][j][i][k] - coeff*lhsY[2][2][CC][j][i][k];
  lhsY[0][3][CC][j][i][k] = lhsY[0][3][CC][j][i][k] - coeff*lhsY[2][3][CC][j][i][k];
  lhsY[0][4][CC][j][i][k] = lhsY[0][4][CC][j][i][k] - coeff*lhsY[2][4][CC][j][i][k];
  rhs[0][k][j][i]   = rhs[0][k][j][i]   - coeff*rhs[2][k][j][i];

  coeff = lhsY[1][2][BB][j][i][k];
  lhsY[1][3][BB][j][i][k]= lhsY[1][3][BB][j][i][k] - coeff*lhsY[2][3][BB][j][i][k];
  lhsY[1][4][BB][j][i][k]= lhsY[1][4][BB][j][i][k] - coeff*lhsY[2][4][BB][j][i][k];
  lhsY[1][0][CC][j][i][k] = lhsY[1][0][CC][j][i][k] - coeff*lhsY[2][0][CC][j][i][k];
  lhsY[1][1][CC][j][i][k] = lhsY[1][1][CC][j][i][k] - coeff*lhsY[2][1][CC][j][i][k];
  lhsY[1][2][CC][j][i][k] = lhsY[1][2][CC][j][i][k] - coeff*lhsY[2][2][CC][j][i][k];
  lhsY[1][3][CC][j][i][k] = lhsY[1][3][CC][j][i][k] - coeff*lhsY[2][3][CC][j][i][k];
  lhsY[1][4][CC][j][i][k] = lhsY[1][4][CC][j][i][k] - coeff*lhsY[2][4][CC][j][i][k];
  rhs[1][k][j][i]   = rhs[1][k][j][i]   - coeff*rhs[2][k][j][i];

  coeff = lhsY[3][2][BB][j][i][k];
  lhsY[3][3][BB][j][i][k]= lhsY[3][3][BB][j][i][k] - coeff*lhsY[2][3][BB][j][i][k];
  lhsY[3][4][BB][j][i][k]= lhsY[3][4][BB][j][i][k] - coeff*lhsY[2][4][BB][j][i][k];
  lhsY[3][0][CC][j][i][k] = lhsY[3][0][CC][j][i][k] - coeff*lhsY[2][0][CC][j][i][k];
  lhsY[3][1][CC][j][i][k] = lhsY[3][1][CC][j][i][k] - coeff*lhsY[2][1][CC][j][i][k];
  lhsY[3][2][CC][j][i][k] = lhsY[3][2][CC][j][i][k] - coeff*lhsY[2][2][CC][j][i][k];
  lhsY[3][3][CC][j][i][k] = lhsY[3][3][CC][j][i][k] - coeff*lhsY[2][3][CC][j][i][k];
  lhsY[3][4][CC][j][i][k] = lhsY[3][4][CC][j][i][k] - coeff*lhsY[2][4][CC][j][i][k];
  rhs[3][k][j][i]   = rhs[3][k][j][i]   - coeff*rhs[2][k][j][i];

  coeff = lhsY[4][2][BB][j][i][k];
  lhsY[4][3][BB][j][i][k]= lhsY[4][3][BB][j][i][k] - coeff*lhsY[2][3][BB][j][i][k];
  lhsY[4][4][BB][j][i][k]= lhsY[4][4][BB][j][i][k] - coeff*lhsY[2][4][BB][j][i][k];
  lhsY[4][0][CC][j][i][k] = lhsY[4][0][CC][j][i][k] - coeff*lhsY[2][0][CC][j][i][k];
  lhsY[4][1][CC][j][i][k] = lhsY[4][1][CC][j][i][k] - coeff*lhsY[2][1][CC][j][i][k];
  lhsY[4][2][CC][j][i][k] = lhsY[4][2][CC][j][i][k] - coeff*lhsY[2][2][CC][j][i][k];
  lhsY[4][3][CC][j][i][k] = lhsY[4][3][CC][j][i][k] - coeff*lhsY[2][3][CC][j][i][k];
  lhsY[4][4][CC][j][i][k] = lhsY[4][4][CC][j][i][k] - coeff*lhsY[2][4][CC][j][i][k];
  rhs[4][k][j][i]   = rhs[4][k][j][i]   - coeff*rhs[2][k][j][i];


  pivot = 1.00/lhsY[3][3][BB][j][i][k];
  lhsY[3][4][BB][j][i][k] = lhsY[3][4][BB][j][i][k]*pivot;
  lhsY[3][0][CC][j][i][k] = lhsY[3][0][CC][j][i][k]*pivot;
  lhsY[3][1][CC][j][i][k] = lhsY[3][1][CC][j][i][k]*pivot;
  lhsY[3][2][CC][j][i][k] = lhsY[3][2][CC][j][i][k]*pivot;
  lhsY[3][3][CC][j][i][k] = lhsY[3][3][CC][j][i][k]*pivot;
  lhsY[3][4][CC][j][i][k] = lhsY[3][4][CC][j][i][k]*pivot;
  rhs[3][k][j][i]   = rhs[3][k][j][i]  *pivot;

  coeff = lhsY[0][3][BB][j][i][k];
  lhsY[0][4][BB][j][i][k]= lhsY[0][4][BB][j][i][k] - coeff*lhsY[3][4][BB][j][i][k];
  lhsY[0][0][CC][j][i][k] = lhsY[0][0][CC][j][i][k] - coeff*lhsY[3][0][CC][j][i][k];
  lhsY[0][1][CC][j][i][k] = lhsY[0][1][CC][j][i][k] - coeff*lhsY[3][1][CC][j][i][k];
  lhsY[0][2][CC][j][i][k] = lhsY[0][2][CC][j][i][k] - coeff*lhsY[3][2][CC][j][i][k];
  lhsY[0][3][CC][j][i][k] = lhsY[0][3][CC][j][i][k] - coeff*lhsY[3][3][CC][j][i][k];
  lhsY[0][4][CC][j][i][k] = lhsY[0][4][CC][j][i][k] - coeff*lhsY[3][4][CC][j][i][k];
  rhs[0][k][j][i]   = rhs[0][k][j][i]   - coeff*rhs[3][k][j][i];

  coeff = lhsY[1][3][BB][j][i][k];
  lhsY[1][4][BB][j][i][k]= lhsY[1][4][BB][j][i][k] - coeff*lhsY[3][4][BB][j][i][k];
  lhsY[1][0][CC][j][i][k] = lhsY[1][0][CC][j][i][k] - coeff*lhsY[3][0][CC][j][i][k];
  lhsY[1][1][CC][j][i][k] = lhsY[1][1][CC][j][i][k] - coeff*lhsY[3][1][CC][j][i][k];
  lhsY[1][2][CC][j][i][k] = lhsY[1][2][CC][j][i][k] - coeff*lhsY[3][2][CC][j][i][k];
  lhsY[1][3][CC][j][i][k] = lhsY[1][3][CC][j][i][k] - coeff*lhsY[3][3][CC][j][i][k];
  lhsY[1][4][CC][j][i][k] = lhsY[1][4][CC][j][i][k] - coeff*lhsY[3][4][CC][j][i][k];
  rhs[1][k][j][i]   = rhs[1][k][j][i]   - coeff*rhs[3][k][j][i];

  coeff = lhsY[2][3][BB][j][i][k];
  lhsY[2][4][BB][j][i][k]= lhsY[2][4][BB][j][i][k] - coeff*lhsY[3][4][BB][j][i][k];
  lhsY[2][0][CC][j][i][k] = lhsY[2][0][CC][j][i][k] - coeff*lhsY[3][0][CC][j][i][k];
  lhsY[2][1][CC][j][i][k] = lhsY[2][1][CC][j][i][k] - coeff*lhsY[3][1][CC][j][i][k];
  lhsY[2][2][CC][j][i][k] = lhsY[2][2][CC][j][i][k] - coeff*lhsY[3][2][CC][j][i][k];
  lhsY[2][3][CC][j][i][k] = lhsY[2][3][CC][j][i][k] - coeff*lhsY[3][3][CC][j][i][k];
  lhsY[2][4][CC][j][i][k] = lhsY[2][4][CC][j][i][k] - coeff*lhsY[3][4][CC][j][i][k];
  rhs[2][k][j][i]   = rhs[2][k][j][i]   - coeff*rhs[3][k][j][i];

  coeff = lhsY[4][3][BB][j][i][k];
  lhsY[4][4][BB][j][i][k]= lhsY[4][4][BB][j][i][k] - coeff*lhsY[3][4][BB][j][i][k];
  lhsY[4][0][CC][j][i][k] = lhsY[4][0][CC][j][i][k] - coeff*lhsY[3][0][CC][j][i][k];
  lhsY[4][1][CC][j][i][k] = lhsY[4][1][CC][j][i][k] - coeff*lhsY[3][1][CC][j][i][k];
  lhsY[4][2][CC][j][i][k] = lhsY[4][2][CC][j][i][k] - coeff*lhsY[3][2][CC][j][i][k];
  lhsY[4][3][CC][j][i][k] = lhsY[4][3][CC][j][i][k] - coeff*lhsY[3][3][CC][j][i][k];
  lhsY[4][4][CC][j][i][k] = lhsY[4][4][CC][j][i][k] - coeff*lhsY[3][4][CC][j][i][k];
  rhs[4][k][j][i]   = rhs[4][k][j][i]   - coeff*rhs[3][k][j][i];


  pivot = 1.00/lhsY[4][4][BB][j][i][k];
  lhsY[4][0][CC][j][i][k] = lhsY[4][0][CC][j][i][k]*pivot;
  lhsY[4][1][CC][j][i][k] = lhsY[4][1][CC][j][i][k]*pivot;
  lhsY[4][2][CC][j][i][k] = lhsY[4][2][CC][j][i][k]*pivot;
  lhsY[4][3][CC][j][i][k] = lhsY[4][3][CC][j][i][k]*pivot;
  lhsY[4][4][CC][j][i][k] = lhsY[4][4][CC][j][i][k]*pivot;
  rhs[4][k][j][i]   = rhs[4][k][j][i]  *pivot;

  coeff = lhsY[0][4][BB][j][i][k];
  lhsY[0][0][CC][j][i][k] = lhsY[0][0][CC][j][i][k] - coeff*lhsY[4][0][CC][j][i][k];
  lhsY[0][1][CC][j][i][k] = lhsY[0][1][CC][j][i][k] - coeff*lhsY[4][1][CC][j][i][k];
  lhsY[0][2][CC][j][i][k] = lhsY[0][2][CC][j][i][k] - coeff*lhsY[4][2][CC][j][i][k];
  lhsY[0][3][CC][j][i][k] = lhsY[0][3][CC][j][i][k] - coeff*lhsY[4][3][CC][j][i][k];
  lhsY[0][4][CC][j][i][k] = lhsY[0][4][CC][j][i][k] - coeff*lhsY[4][4][CC][j][i][k];
  rhs[0][k][j][i]   = rhs[0][k][j][i]   - coeff*rhs[4][k][j][i];

  coeff = lhsY[1][4][BB][j][i][k];
  lhsY[1][0][CC][j][i][k] = lhsY[1][0][CC][j][i][k] - coeff*lhsY[4][0][CC][j][i][k];
  lhsY[1][1][CC][j][i][k] = lhsY[1][1][CC][j][i][k] - coeff*lhsY[4][1][CC][j][i][k];
  lhsY[1][2][CC][j][i][k] = lhsY[1][2][CC][j][i][k] - coeff*lhsY[4][2][CC][j][i][k];
  lhsY[1][3][CC][j][i][k] = lhsY[1][3][CC][j][i][k] - coeff*lhsY[4][3][CC][j][i][k];
  lhsY[1][4][CC][j][i][k] = lhsY[1][4][CC][j][i][k] - coeff*lhsY[4][4][CC][j][i][k];
  rhs[1][k][j][i]   = rhs[1][k][j][i]   - coeff*rhs[4][k][j][i];

  coeff = lhsY[2][4][BB][j][i][k];
  lhsY[2][0][CC][j][i][k] = lhsY[2][0][CC][j][i][k] - coeff*lhsY[4][0][CC][j][i][k];
  lhsY[2][1][CC][j][i][k] = lhsY[2][1][CC][j][i][k] - coeff*lhsY[4][1][CC][j][i][k];
  lhsY[2][2][CC][j][i][k] = lhsY[2][2][CC][j][i][k] - coeff*lhsY[4][2][CC][j][i][k];
  lhsY[2][3][CC][j][i][k] = lhsY[2][3][CC][j][i][k] - coeff*lhsY[4][3][CC][j][i][k];
  lhsY[2][4][CC][j][i][k] = lhsY[2][4][CC][j][i][k] - coeff*lhsY[4][4][CC][j][i][k];
  rhs[2][k][j][i]   = rhs[2][k][j][i]   - coeff*rhs[4][k][j][i];

  coeff = lhsY[3][4][BB][j][i][k];
  lhsY[3][0][CC][j][i][k] = lhsY[3][0][CC][j][i][k] - coeff*lhsY[4][0][CC][j][i][k];
  lhsY[3][1][CC][j][i][k] = lhsY[3][1][CC][j][i][k] - coeff*lhsY[4][1][CC][j][i][k];
  lhsY[3][2][CC][j][i][k] = lhsY[3][2][CC][j][i][k] - coeff*lhsY[4][2][CC][j][i][k];
  lhsY[3][3][CC][j][i][k] = lhsY[3][3][CC][j][i][k] - coeff*lhsY[4][3][CC][j][i][k];
  lhsY[3][4][CC][j][i][k] = lhsY[3][4][CC][j][i][k] - coeff*lhsY[4][4][CC][j][i][k];
  rhs[3][k][j][i]   = rhs[3][k][j][i]   - coeff*rhs[4][k][j][i];
      }/*end j*/
	}/*end i*/
  }/*end k*/
      //---------------------------------------------------------------------
      // rhs(jsize) = rhs(jsize) - A*rhs(jsize-1)
      //---------------------------------------------------------------------
      //matvec_sub(lhsY[i][jsize-1][AA], rhs[k][k][jsize][i], rhs[k][jsize][i]);
  #pragma acc parallel loop gang num_gangs(gp22) num_workers(4) vector_length(32) 
  for (k = 1; k <= gp22; k++) {
    #pragma acc loop worker vector
    for (i = 1; i <= gp02; i++) {
	/*
		for(m = 0; m < 5; m++){
			rhs[m][k][jsize][i] = rhs[m][k][jsize][i] - lhsY[m][0][AA][jsize][i][k]*rhs[0][k][jsize-1][i]
											  		  - lhsY[m][1][AA][jsize][i][k]*rhs[1][k][jsize-1][i]
											  		  - lhsY[m][2][AA][jsize][i][k]*rhs[2][k][jsize-1][i]
											  		  - lhsY[m][3][AA][jsize][i][k]*rhs[3][k][jsize-1][i]
											  		  - lhsY[m][4][AA][jsize][i][k]*rhs[4][k][jsize-1][i];
		}
	*/
  rhs[0][k][jsize][i] = rhs[0][k][jsize][i] - lhsY[0][0][AA][jsize][i][k]*rhs[0][k][jsize-1][i]
                    - lhsY[0][1][AA][jsize][i][k]*rhs[1][k][jsize-1][i]
                    - lhsY[0][2][AA][jsize][i][k]*rhs[2][k][jsize-1][i]
                    - lhsY[0][3][AA][jsize][i][k]*rhs[3][k][jsize-1][i]
                    - lhsY[0][4][AA][jsize][i][k]*rhs[4][k][jsize-1][i];
  rhs[1][k][jsize][i] = rhs[1][k][jsize][i] - lhsY[1][0][AA][jsize][i][k]*rhs[0][k][jsize-1][i]
                    - lhsY[1][1][AA][jsize][i][k]*rhs[1][k][jsize-1][i]
                    - lhsY[1][2][AA][jsize][i][k]*rhs[2][k][jsize-1][i]
                    - lhsY[1][3][AA][jsize][i][k]*rhs[3][k][jsize-1][i]
                    - lhsY[1][4][AA][jsize][i][k]*rhs[4][k][jsize-1][i];
  rhs[2][k][jsize][i] = rhs[2][k][jsize][i] - lhsY[2][0][AA][jsize][i][k]*rhs[0][k][jsize-1][i]
                    - lhsY[2][1][AA][jsize][i][k]*rhs[1][k][jsize-1][i]
                    - lhsY[2][2][AA][jsize][i][k]*rhs[2][k][jsize-1][i]
                    - lhsY[2][3][AA][jsize][i][k]*rhs[3][k][jsize-1][i]
                    - lhsY[2][4][AA][jsize][i][k]*rhs[4][k][jsize-1][i];
  rhs[3][k][jsize][i] = rhs[3][k][jsize][i] - lhsY[3][0][AA][jsize][i][k]*rhs[0][k][jsize-1][i]
                    - lhsY[3][1][AA][jsize][i][k]*rhs[1][k][jsize-1][i]
                    - lhsY[3][2][AA][jsize][i][k]*rhs[2][k][jsize-1][i]
                    - lhsY[3][3][AA][jsize][i][k]*rhs[3][k][jsize-1][i]
                    - lhsY[3][4][AA][jsize][i][k]*rhs[4][k][jsize-1][i];
  rhs[4][k][jsize][i] = rhs[4][k][jsize][i] - lhsY[4][0][AA][jsize][i][k]*rhs[0][k][jsize-1][i]
                    - lhsY[4][1][AA][jsize][i][k]*rhs[1][k][jsize-1][i]
                    - lhsY[4][2][AA][jsize][i][k]*rhs[2][k][jsize-1][i]
                    - lhsY[4][3][AA][jsize][i][k]*rhs[3][k][jsize-1][i]
                    - lhsY[4][4][AA][jsize][i][k]*rhs[4][k][jsize-1][i];
	}
  }
      //---------------------------------------------------------------------
      // B(jsize) = B(jsize) - C(jsize-1)*A(jsize)
      // matmul_sub(AA,i,jsize,k,c,
      // $              CC,i,jsize-1,k,c,BB,i,jsize,k)
      //---------------------------------------------------------------------
      //matmul_sub(lhsY[jsize-1][i][AA], lhsY[k][jsize][i][k][CC], lhsY[k][i][jsize][BB]);
    #pragma acc parallel loop gang num_gangs(gp02) num_workers(4) vector_length(32)  
    for (i = 1; i <= gp02; i++) {
  #pragma acc loop worker vector
  for (k = 1; k <= gp22; k++) {
	/*
	  for(m = 0; m < 5; m++){
	  	for(n = 0; n < 5; n++){
			lhsY[n][m][BB][jsize][i][k] = lhsY[n][m][BB][jsize][i][k] - lhsY[n][0][AA][jsize][i][k]*lhsY[0][m][CC][jsize-1][i][k]
														- lhsY[n][1][AA][jsize][i][k]*lhsY[1][m][CC][jsize-1][i][k]
														- lhsY[n][2][AA][jsize][i][k]*lhsY[2][m][CC][jsize-1][i][k]
														- lhsY[n][3][AA][jsize][i][k]*lhsY[3][m][CC][jsize-1][i][k]
														- lhsY[n][4][AA][jsize][i][k]*lhsY[4][m][CC][jsize-1][i][k];
		}
	  }
	 */
  lhsY[0][0][BB][jsize][i][k] = lhsY[0][0][BB][jsize][i][k] - lhsY[0][0][AA][jsize][i][k]*lhsY[0][0][CC][jsize-1][i][k]
                              - lhsY[0][1][AA][jsize][i][k]*lhsY[1][0][CC][jsize-1][i][k]
                              - lhsY[0][2][AA][jsize][i][k]*lhsY[2][0][CC][jsize-1][i][k]
                              - lhsY[0][3][AA][jsize][i][k]*lhsY[3][0][CC][jsize-1][i][k]
                              - lhsY[0][4][AA][jsize][i][k]*lhsY[4][0][CC][jsize-1][i][k];
  lhsY[1][0][BB][jsize][i][k] = lhsY[1][0][BB][jsize][i][k] - lhsY[1][0][AA][jsize][i][k]*lhsY[0][0][CC][jsize-1][i][k]
                              - lhsY[1][1][AA][jsize][i][k]*lhsY[1][0][CC][jsize-1][i][k]
                              - lhsY[1][2][AA][jsize][i][k]*lhsY[2][0][CC][jsize-1][i][k]
                              - lhsY[1][3][AA][jsize][i][k]*lhsY[3][0][CC][jsize-1][i][k]
                              - lhsY[1][4][AA][jsize][i][k]*lhsY[4][0][CC][jsize-1][i][k];
  lhsY[2][0][BB][jsize][i][k] = lhsY[2][0][BB][jsize][i][k] - lhsY[2][0][AA][jsize][i][k]*lhsY[0][0][CC][jsize-1][i][k]
                              - lhsY[2][1][AA][jsize][i][k]*lhsY[1][0][CC][jsize-1][i][k]
                              - lhsY[2][2][AA][jsize][i][k]*lhsY[2][0][CC][jsize-1][i][k]
                              - lhsY[2][3][AA][jsize][i][k]*lhsY[3][0][CC][jsize-1][i][k]
                              - lhsY[2][4][AA][jsize][i][k]*lhsY[4][0][CC][jsize-1][i][k];
  lhsY[3][0][BB][jsize][i][k] = lhsY[3][0][BB][jsize][i][k] - lhsY[3][0][AA][jsize][i][k]*lhsY[0][0][CC][jsize-1][i][k]
                              - lhsY[3][1][AA][jsize][i][k]*lhsY[1][0][CC][jsize-1][i][k]
                              - lhsY[3][2][AA][jsize][i][k]*lhsY[2][0][CC][jsize-1][i][k]
                              - lhsY[3][3][AA][jsize][i][k]*lhsY[3][0][CC][jsize-1][i][k]
                              - lhsY[3][4][AA][jsize][i][k]*lhsY[4][0][CC][jsize-1][i][k];
  lhsY[4][0][BB][jsize][i][k] = lhsY[4][0][BB][jsize][i][k] - lhsY[4][0][AA][jsize][i][k]*lhsY[0][0][CC][jsize-1][i][k]
                              - lhsY[4][1][AA][jsize][i][k]*lhsY[1][0][CC][jsize-1][i][k]
                              - lhsY[4][2][AA][jsize][i][k]*lhsY[2][0][CC][jsize-1][i][k]
                              - lhsY[4][3][AA][jsize][i][k]*lhsY[3][0][CC][jsize-1][i][k]
                              - lhsY[4][4][AA][jsize][i][k]*lhsY[4][0][CC][jsize-1][i][k];
  lhsY[0][1][BB][jsize][i][k] = lhsY[0][1][BB][jsize][i][k] - lhsY[0][0][AA][jsize][i][k]*lhsY[0][1][CC][jsize-1][i][k]
                              - lhsY[0][1][AA][jsize][i][k]*lhsY[1][1][CC][jsize-1][i][k]
                              - lhsY[0][2][AA][jsize][i][k]*lhsY[2][1][CC][jsize-1][i][k]
                              - lhsY[0][3][AA][jsize][i][k]*lhsY[3][1][CC][jsize-1][i][k]
                              - lhsY[0][4][AA][jsize][i][k]*lhsY[4][1][CC][jsize-1][i][k];
  lhsY[1][1][BB][jsize][i][k] = lhsY[1][1][BB][jsize][i][k] - lhsY[1][0][AA][jsize][i][k]*lhsY[0][1][CC][jsize-1][i][k]
                              - lhsY[1][1][AA][jsize][i][k]*lhsY[1][1][CC][jsize-1][i][k]
                              - lhsY[1][2][AA][jsize][i][k]*lhsY[2][1][CC][jsize-1][i][k]
                              - lhsY[1][3][AA][jsize][i][k]*lhsY[3][1][CC][jsize-1][i][k]
                              - lhsY[1][4][AA][jsize][i][k]*lhsY[4][1][CC][jsize-1][i][k];
  lhsY[2][1][BB][jsize][i][k] = lhsY[2][1][BB][jsize][i][k] - lhsY[2][0][AA][jsize][i][k]*lhsY[0][1][CC][jsize-1][i][k]
                              - lhsY[2][1][AA][jsize][i][k]*lhsY[1][1][CC][jsize-1][i][k]
                              - lhsY[2][2][AA][jsize][i][k]*lhsY[2][1][CC][jsize-1][i][k]
                              - lhsY[2][3][AA][jsize][i][k]*lhsY[3][1][CC][jsize-1][i][k]
                              - lhsY[2][4][AA][jsize][i][k]*lhsY[4][1][CC][jsize-1][i][k];
  lhsY[3][1][BB][jsize][i][k] = lhsY[3][1][BB][jsize][i][k] - lhsY[3][0][AA][jsize][i][k]*lhsY[0][1][CC][jsize-1][i][k]
                              - lhsY[3][1][AA][jsize][i][k]*lhsY[1][1][CC][jsize-1][i][k]
                              - lhsY[3][2][AA][jsize][i][k]*lhsY[2][1][CC][jsize-1][i][k]
                              - lhsY[3][3][AA][jsize][i][k]*lhsY[3][1][CC][jsize-1][i][k]
                              - lhsY[3][4][AA][jsize][i][k]*lhsY[4][1][CC][jsize-1][i][k];
  lhsY[4][1][BB][jsize][i][k] = lhsY[4][1][BB][jsize][i][k] - lhsY[4][0][AA][jsize][i][k]*lhsY[0][1][CC][jsize-1][i][k]
                              - lhsY[4][1][AA][jsize][i][k]*lhsY[1][1][CC][jsize-1][i][k]
                              - lhsY[4][2][AA][jsize][i][k]*lhsY[2][1][CC][jsize-1][i][k]
                              - lhsY[4][3][AA][jsize][i][k]*lhsY[3][1][CC][jsize-1][i][k]
                              - lhsY[4][4][AA][jsize][i][k]*lhsY[4][1][CC][jsize-1][i][k];
  lhsY[0][2][BB][jsize][i][k] = lhsY[0][2][BB][jsize][i][k] - lhsY[0][0][AA][jsize][i][k]*lhsY[0][2][CC][jsize-1][i][k]
                              - lhsY[0][1][AA][jsize][i][k]*lhsY[1][2][CC][jsize-1][i][k]
                              - lhsY[0][2][AA][jsize][i][k]*lhsY[2][2][CC][jsize-1][i][k]
                              - lhsY[0][3][AA][jsize][i][k]*lhsY[3][2][CC][jsize-1][i][k]
                              - lhsY[0][4][AA][jsize][i][k]*lhsY[4][2][CC][jsize-1][i][k];
  lhsY[1][2][BB][jsize][i][k] = lhsY[1][2][BB][jsize][i][k] - lhsY[1][0][AA][jsize][i][k]*lhsY[0][2][CC][jsize-1][i][k]
                              - lhsY[1][1][AA][jsize][i][k]*lhsY[1][2][CC][jsize-1][i][k]
                              - lhsY[1][2][AA][jsize][i][k]*lhsY[2][2][CC][jsize-1][i][k]
                              - lhsY[1][3][AA][jsize][i][k]*lhsY[3][2][CC][jsize-1][i][k]
                              - lhsY[1][4][AA][jsize][i][k]*lhsY[4][2][CC][jsize-1][i][k];
  lhsY[2][2][BB][jsize][i][k] = lhsY[2][2][BB][jsize][i][k] - lhsY[2][0][AA][jsize][i][k]*lhsY[0][2][CC][jsize-1][i][k]
                              - lhsY[2][1][AA][jsize][i][k]*lhsY[1][2][CC][jsize-1][i][k]
                              - lhsY[2][2][AA][jsize][i][k]*lhsY[2][2][CC][jsize-1][i][k]
                              - lhsY[2][3][AA][jsize][i][k]*lhsY[3][2][CC][jsize-1][i][k]
                              - lhsY[2][4][AA][jsize][i][k]*lhsY[4][2][CC][jsize-1][i][k];
  lhsY[3][2][BB][jsize][i][k] = lhsY[3][2][BB][jsize][i][k] - lhsY[3][0][AA][jsize][i][k]*lhsY[0][2][CC][jsize-1][i][k]
                              - lhsY[3][1][AA][jsize][i][k]*lhsY[1][2][CC][jsize-1][i][k]
                              - lhsY[3][2][AA][jsize][i][k]*lhsY[2][2][CC][jsize-1][i][k]
                              - lhsY[3][3][AA][jsize][i][k]*lhsY[3][2][CC][jsize-1][i][k]
                              - lhsY[3][4][AA][jsize][i][k]*lhsY[4][2][CC][jsize-1][i][k];
  lhsY[4][2][BB][jsize][i][k] = lhsY[4][2][BB][jsize][i][k] - lhsY[4][0][AA][jsize][i][k]*lhsY[0][2][CC][jsize-1][i][k]
                              - lhsY[4][1][AA][jsize][i][k]*lhsY[1][2][CC][jsize-1][i][k]
                              - lhsY[4][2][AA][jsize][i][k]*lhsY[2][2][CC][jsize-1][i][k]
                              - lhsY[4][3][AA][jsize][i][k]*lhsY[3][2][CC][jsize-1][i][k]
                              - lhsY[4][4][AA][jsize][i][k]*lhsY[4][2][CC][jsize-1][i][k];
  lhsY[0][3][BB][jsize][i][k] = lhsY[0][3][BB][jsize][i][k] - lhsY[0][0][AA][jsize][i][k]*lhsY[0][3][CC][jsize-1][i][k]
                              - lhsY[0][1][AA][jsize][i][k]*lhsY[1][3][CC][jsize-1][i][k]
                              - lhsY[0][2][AA][jsize][i][k]*lhsY[2][3][CC][jsize-1][i][k]
                              - lhsY[0][3][AA][jsize][i][k]*lhsY[3][3][CC][jsize-1][i][k]
                              - lhsY[0][4][AA][jsize][i][k]*lhsY[4][3][CC][jsize-1][i][k];
  lhsY[1][3][BB][jsize][i][k] = lhsY[1][3][BB][jsize][i][k] - lhsY[1][0][AA][jsize][i][k]*lhsY[0][3][CC][jsize-1][i][k]
                              - lhsY[1][1][AA][jsize][i][k]*lhsY[1][3][CC][jsize-1][i][k]
                              - lhsY[1][2][AA][jsize][i][k]*lhsY[2][3][CC][jsize-1][i][k]
                              - lhsY[1][3][AA][jsize][i][k]*lhsY[3][3][CC][jsize-1][i][k]
                              - lhsY[1][4][AA][jsize][i][k]*lhsY[4][3][CC][jsize-1][i][k];
  lhsY[2][3][BB][jsize][i][k] = lhsY[2][3][BB][jsize][i][k] - lhsY[2][0][AA][jsize][i][k]*lhsY[0][3][CC][jsize-1][i][k]
                              - lhsY[2][1][AA][jsize][i][k]*lhsY[1][3][CC][jsize-1][i][k]
                              - lhsY[2][2][AA][jsize][i][k]*lhsY[2][3][CC][jsize-1][i][k]
                              - lhsY[2][3][AA][jsize][i][k]*lhsY[3][3][CC][jsize-1][i][k]
                              - lhsY[2][4][AA][jsize][i][k]*lhsY[4][3][CC][jsize-1][i][k];
  lhsY[3][3][BB][jsize][i][k] = lhsY[3][3][BB][jsize][i][k] - lhsY[3][0][AA][jsize][i][k]*lhsY[0][3][CC][jsize-1][i][k]
                              - lhsY[3][1][AA][jsize][i][k]*lhsY[1][3][CC][jsize-1][i][k]
                              - lhsY[3][2][AA][jsize][i][k]*lhsY[2][3][CC][jsize-1][i][k]
                              - lhsY[3][3][AA][jsize][i][k]*lhsY[3][3][CC][jsize-1][i][k]
                              - lhsY[3][4][AA][jsize][i][k]*lhsY[4][3][CC][jsize-1][i][k];
  lhsY[4][3][BB][jsize][i][k] = lhsY[4][3][BB][jsize][i][k] - lhsY[4][0][AA][jsize][i][k]*lhsY[0][3][CC][jsize-1][i][k]
                              - lhsY[4][1][AA][jsize][i][k]*lhsY[1][3][CC][jsize-1][i][k]
                              - lhsY[4][2][AA][jsize][i][k]*lhsY[2][3][CC][jsize-1][i][k]
                              - lhsY[4][3][AA][jsize][i][k]*lhsY[3][3][CC][jsize-1][i][k]
                              - lhsY[4][4][AA][jsize][i][k]*lhsY[4][3][CC][jsize-1][i][k];
  lhsY[0][4][BB][jsize][i][k] = lhsY[0][4][BB][jsize][i][k] - lhsY[0][0][AA][jsize][i][k]*lhsY[0][4][CC][jsize-1][i][k]
                              - lhsY[0][1][AA][jsize][i][k]*lhsY[1][4][CC][jsize-1][i][k]
                              - lhsY[0][2][AA][jsize][i][k]*lhsY[2][4][CC][jsize-1][i][k]
                              - lhsY[0][3][AA][jsize][i][k]*lhsY[3][4][CC][jsize-1][i][k]
                              - lhsY[0][4][AA][jsize][i][k]*lhsY[4][4][CC][jsize-1][i][k];
  lhsY[1][4][BB][jsize][i][k] = lhsY[1][4][BB][jsize][i][k] - lhsY[1][0][AA][jsize][i][k]*lhsY[0][4][CC][jsize-1][i][k]
                              - lhsY[1][1][AA][jsize][i][k]*lhsY[1][4][CC][jsize-1][i][k]
                              - lhsY[1][2][AA][jsize][i][k]*lhsY[2][4][CC][jsize-1][i][k]
                              - lhsY[1][3][AA][jsize][i][k]*lhsY[3][4][CC][jsize-1][i][k]
                              - lhsY[1][4][AA][jsize][i][k]*lhsY[4][4][CC][jsize-1][i][k];
  lhsY[2][4][BB][jsize][i][k] = lhsY[2][4][BB][jsize][i][k] - lhsY[2][0][AA][jsize][i][k]*lhsY[0][4][CC][jsize-1][i][k]
                              - lhsY[2][1][AA][jsize][i][k]*lhsY[1][4][CC][jsize-1][i][k]
                              - lhsY[2][2][AA][jsize][i][k]*lhsY[2][4][CC][jsize-1][i][k]
                              - lhsY[2][3][AA][jsize][i][k]*lhsY[3][4][CC][jsize-1][i][k]
                              - lhsY[2][4][AA][jsize][i][k]*lhsY[4][4][CC][jsize-1][i][k];
  lhsY[3][4][BB][jsize][i][k] = lhsY[3][4][BB][jsize][i][k] - lhsY[3][0][AA][jsize][i][k]*lhsY[0][4][CC][jsize-1][i][k]
                              - lhsY[3][1][AA][jsize][i][k]*lhsY[1][4][CC][jsize-1][i][k]
                              - lhsY[3][2][AA][jsize][i][k]*lhsY[2][4][CC][jsize-1][i][k]
                              - lhsY[3][3][AA][jsize][i][k]*lhsY[3][4][CC][jsize-1][i][k]
                              - lhsY[3][4][AA][jsize][i][k]*lhsY[4][4][CC][jsize-1][i][k];
  lhsY[4][4][BB][jsize][i][k] = lhsY[4][4][BB][jsize][i][k] - lhsY[4][0][AA][jsize][i][k]*lhsY[0][4][CC][jsize-1][i][k]
                              - lhsY[4][1][AA][jsize][i][k]*lhsY[1][4][CC][jsize-1][i][k]
                              - lhsY[4][2][AA][jsize][i][k]*lhsY[2][4][CC][jsize-1][i][k]
                              - lhsY[4][3][AA][jsize][i][k]*lhsY[3][4][CC][jsize-1][i][k]
                              - lhsY[4][4][AA][jsize][i][k]*lhsY[4][4][CC][jsize-1][i][k];


	}
  }
      //---------------------------------------------------------------------
      // multiply rhs(jsize) by b_inverse(jsize) and copy to rhs      //---------------------------------------------------------------------
      //binvrhs( lhsY[i][jsize][BB], rhs[k][k][jsize][i] );
    #pragma acc parallel loop gang num_gangs(gp02) num_workers(4) vector_length(32) 
    for (i = 1; i <= gp02; i++) { 
  #pragma acc loop worker vector
  for (k = 1; k <= gp22; k++) {
	/*
	  for(m = 0; m < 5; m++){
	  	pivot = 1.00/lhsY[m][m][BB][jsize][i][k];
		for(n = m+1; n < 5; n++){
			lhsY[m][n][BB][jsize][i][k] = lhsY[m][n][BB][jsize][i][k]*pivot;
		}
		rhs[m][k][jsize][i] = rhs[m][k][jsize][i]*pivot;
		
		for(n = 0; n < 5; n++){
			if(n != m){
				coeff = lhsY[n][m][BB][jsize][i][k];
				for(z = m+1; z < 5; z++){
					lhsY[n][z][BB][jsize][i][k] = lhsY[n][z][BB][jsize][i][k] - coeff*lhsY[m][z][BB][jsize][i][k];
				}
				rhs[n][k][jsize][i] = rhs[n][k][jsize][i] - coeff*rhs[m][k][jsize][i];
			}
		}
	  }
	*/
  pivot = 1.00/lhsY[0][0][BB][jsize][i][k];
  lhsY[0][1][BB][jsize][i][k] = lhsY[0][1][BB][jsize][i][k]*pivot;
  lhsY[0][2][BB][jsize][i][k] = lhsY[0][2][BB][jsize][i][k]*pivot;
  lhsY[0][3][BB][jsize][i][k] = lhsY[0][3][BB][jsize][i][k]*pivot;
  lhsY[0][4][BB][jsize][i][k] = lhsY[0][4][BB][jsize][i][k]*pivot;
  rhs[0][k][jsize][i]   = rhs[0][k][jsize][i]  *pivot;

  coeff = lhsY[1][0][BB][jsize][i][k];
  lhsY[1][1][BB][jsize][i][k]= lhsY[1][1][BB][jsize][i][k] - coeff*lhsY[0][1][BB][jsize][i][k];
  lhsY[1][2][BB][jsize][i][k]= lhsY[1][2][BB][jsize][i][k] - coeff*lhsY[0][2][BB][jsize][i][k];
  lhsY[1][3][BB][jsize][i][k]= lhsY[1][3][BB][jsize][i][k] - coeff*lhsY[0][3][BB][jsize][i][k];
  lhsY[1][4][BB][jsize][i][k]= lhsY[1][4][BB][jsize][i][k] - coeff*lhsY[0][4][BB][jsize][i][k];
  rhs[1][k][jsize][i]   = rhs[1][k][jsize][i]   - coeff*rhs[0][k][jsize][i];

  coeff = lhsY[2][0][BB][jsize][i][k];
  lhsY[2][1][BB][jsize][i][k]= lhsY[2][1][BB][jsize][i][k] - coeff*lhsY[0][1][BB][jsize][i][k];
  lhsY[2][2][BB][jsize][i][k]= lhsY[2][2][BB][jsize][i][k] - coeff*lhsY[0][2][BB][jsize][i][k];
  lhsY[2][3][BB][jsize][i][k]= lhsY[2][3][BB][jsize][i][k] - coeff*lhsY[0][3][BB][jsize][i][k];
  lhsY[2][4][BB][jsize][i][k]= lhsY[2][4][BB][jsize][i][k] - coeff*lhsY[0][4][BB][jsize][i][k];
  rhs[2][k][jsize][i]   = rhs[2][k][jsize][i]   - coeff*rhs[0][k][jsize][i];

  coeff = lhsY[3][0][BB][jsize][i][k];
  lhsY[3][1][BB][jsize][i][k]= lhsY[3][1][BB][jsize][i][k] - coeff*lhsY[0][1][BB][jsize][i][k];
  lhsY[3][2][BB][jsize][i][k]= lhsY[3][2][BB][jsize][i][k] - coeff*lhsY[0][2][BB][jsize][i][k];
  lhsY[3][3][BB][jsize][i][k]= lhsY[3][3][BB][jsize][i][k] - coeff*lhsY[0][3][BB][jsize][i][k];
  lhsY[3][4][BB][jsize][i][k]= lhsY[3][4][BB][jsize][i][k] - coeff*lhsY[0][4][BB][jsize][i][k];
  rhs[3][k][jsize][i]   = rhs[3][k][jsize][i]   - coeff*rhs[0][k][jsize][i];

  coeff = lhsY[4][0][BB][jsize][i][k];
  lhsY[4][1][BB][jsize][i][k]= lhsY[4][1][BB][jsize][i][k] - coeff*lhsY[0][1][BB][jsize][i][k];
  lhsY[4][2][BB][jsize][i][k]= lhsY[4][2][BB][jsize][i][k] - coeff*lhsY[0][2][BB][jsize][i][k];
  lhsY[4][3][BB][jsize][i][k]= lhsY[4][3][BB][jsize][i][k] - coeff*lhsY[0][3][BB][jsize][i][k];
  lhsY[4][4][BB][jsize][i][k]= lhsY[4][4][BB][jsize][i][k] - coeff*lhsY[0][4][BB][jsize][i][k];
  rhs[4][k][jsize][i]   = rhs[4][k][jsize][i]   - coeff*rhs[0][k][jsize][i];


  pivot = 1.00/lhsY[1][1][BB][jsize][i][k];
  lhsY[1][2][BB][jsize][i][k] = lhsY[1][2][BB][jsize][i][k]*pivot;
  lhsY[1][3][BB][jsize][i][k] = lhsY[1][3][BB][jsize][i][k]*pivot;
  lhsY[1][4][BB][jsize][i][k] = lhsY[1][4][BB][jsize][i][k]*pivot;
  rhs[1][k][jsize][i]   = rhs[1][k][jsize][i]  *pivot;

  coeff = lhsY[0][1][BB][jsize][i][k];
  lhsY[0][2][BB][jsize][i][k]= lhsY[0][2][BB][jsize][i][k] - coeff*lhsY[1][2][BB][jsize][i][k];
  lhsY[0][3][BB][jsize][i][k]= lhsY[0][3][BB][jsize][i][k] - coeff*lhsY[1][3][BB][jsize][i][k];
  lhsY[0][4][BB][jsize][i][k]= lhsY[0][4][BB][jsize][i][k] - coeff*lhsY[1][4][BB][jsize][i][k];
  rhs[0][k][jsize][i]   = rhs[0][k][jsize][i]   - coeff*rhs[1][k][jsize][i];

  coeff = lhsY[2][1][BB][jsize][i][k];
  lhsY[2][2][BB][jsize][i][k]= lhsY[2][2][BB][jsize][i][k] - coeff*lhsY[1][2][BB][jsize][i][k];
  lhsY[2][3][BB][jsize][i][k]= lhsY[2][3][BB][jsize][i][k] - coeff*lhsY[1][3][BB][jsize][i][k];
  lhsY[2][4][BB][jsize][i][k]= lhsY[2][4][BB][jsize][i][k] - coeff*lhsY[1][4][BB][jsize][i][k];
  rhs[2][k][jsize][i]   = rhs[2][k][jsize][i]   - coeff*rhs[1][k][jsize][i];

  coeff = lhsY[3][1][BB][jsize][i][k];
  lhsY[3][2][BB][jsize][i][k]= lhsY[3][2][BB][jsize][i][k] - coeff*lhsY[1][2][BB][jsize][i][k];
  lhsY[3][3][BB][jsize][i][k]= lhsY[3][3][BB][jsize][i][k] - coeff*lhsY[1][3][BB][jsize][i][k];
  lhsY[3][4][BB][jsize][i][k]= lhsY[3][4][BB][jsize][i][k] - coeff*lhsY[1][4][BB][jsize][i][k];
  rhs[3][k][jsize][i]   = rhs[3][k][jsize][i]   - coeff*rhs[1][k][jsize][i];

  coeff = lhsY[4][1][BB][jsize][i][k];
  lhsY[4][2][BB][jsize][i][k]= lhsY[4][2][BB][jsize][i][k] - coeff*lhsY[1][2][BB][jsize][i][k];
  lhsY[4][3][BB][jsize][i][k]= lhsY[4][3][BB][jsize][i][k] - coeff*lhsY[1][3][BB][jsize][i][k];
  lhsY[4][4][BB][jsize][i][k]= lhsY[4][4][BB][jsize][i][k] - coeff*lhsY[1][4][BB][jsize][i][k];
  rhs[4][k][jsize][i]   = rhs[4][k][jsize][i]   - coeff*rhs[1][k][jsize][i];


  pivot = 1.00/lhsY[2][2][BB][jsize][i][k];
  lhsY[2][3][BB][jsize][i][k] = lhsY[2][3][BB][jsize][i][k]*pivot;
  lhsY[2][4][BB][jsize][i][k] = lhsY[2][4][BB][jsize][i][k]*pivot;
  rhs[2][k][jsize][i]   = rhs[2][k][jsize][i]  *pivot;

  coeff = lhsY[0][2][BB][jsize][i][k];
  lhsY[0][3][BB][jsize][i][k]= lhsY[0][3][BB][jsize][i][k] - coeff*lhsY[2][3][BB][jsize][i][k];
  lhsY[0][4][BB][jsize][i][k]= lhsY[0][4][BB][jsize][i][k] - coeff*lhsY[2][4][BB][jsize][i][k];
  rhs[0][k][jsize][i]   = rhs[0][k][jsize][i]   - coeff*rhs[2][k][jsize][i];

  coeff = lhsY[1][2][BB][jsize][i][k];
  lhsY[1][3][BB][jsize][i][k]= lhsY[1][3][BB][jsize][i][k] - coeff*lhsY[2][3][BB][jsize][i][k];
  lhsY[1][4][BB][jsize][i][k]= lhsY[1][4][BB][jsize][i][k] - coeff*lhsY[2][4][BB][jsize][i][k];
  rhs[1][k][jsize][i]   = rhs[1][k][jsize][i]   - coeff*rhs[2][k][jsize][i];

  coeff = lhsY[3][2][BB][jsize][i][k];
  lhsY[3][3][BB][jsize][i][k]= lhsY[3][3][BB][jsize][i][k] - coeff*lhsY[2][3][BB][jsize][i][k];
  lhsY[3][4][BB][jsize][i][k]= lhsY[3][4][BB][jsize][i][k] - coeff*lhsY[2][4][BB][jsize][i][k];
  rhs[3][k][jsize][i]   = rhs[3][k][jsize][i]   - coeff*rhs[2][k][jsize][i];

  coeff = lhsY[4][2][BB][jsize][i][k];
  lhsY[4][3][BB][jsize][i][k]= lhsY[4][3][BB][jsize][i][k] - coeff*lhsY[2][3][BB][jsize][i][k];
  lhsY[4][4][BB][jsize][i][k]= lhsY[4][4][BB][jsize][i][k] - coeff*lhsY[2][4][BB][jsize][i][k];
  rhs[4][k][jsize][i]   = rhs[4][k][jsize][i]   - coeff*rhs[2][k][jsize][i];


  pivot = 1.00/lhsY[3][3][BB][jsize][i][k];
  lhsY[3][4][BB][jsize][i][k] = lhsY[3][4][BB][jsize][i][k]*pivot;
  rhs[3][k][jsize][i]   = rhs[3][k][jsize][i]  *pivot;

  coeff = lhsY[0][3][BB][jsize][i][k];
  lhsY[0][4][BB][jsize][i][k]= lhsY[0][4][BB][jsize][i][k] - coeff*lhsY[3][4][BB][jsize][i][k];
  rhs[0][k][jsize][i]   = rhs[0][k][jsize][i]   - coeff*rhs[3][k][jsize][i];

  coeff = lhsY[1][3][BB][jsize][i][k];
  lhsY[1][4][BB][jsize][i][k]= lhsY[1][4][BB][jsize][i][k] - coeff*lhsY[3][4][BB][jsize][i][k];
  rhs[1][k][jsize][i]   = rhs[1][k][jsize][i]   - coeff*rhs[3][k][jsize][i];

  coeff = lhsY[2][3][BB][jsize][i][k];
  lhsY[2][4][BB][jsize][i][k]= lhsY[2][4][BB][jsize][i][k] - coeff*lhsY[3][4][BB][jsize][i][k];
  rhs[2][k][jsize][i]   = rhs[2][k][jsize][i]   - coeff*rhs[3][k][jsize][i];

  coeff = lhsY[4][3][BB][jsize][i][k];
  lhsY[4][4][BB][jsize][i][k]= lhsY[4][4][BB][jsize][i][k] - coeff*lhsY[3][4][BB][jsize][i][k];
  rhs[4][k][jsize][i]   = rhs[4][k][jsize][i]   - coeff*rhs[3][k][jsize][i];


  pivot = 1.00/lhsY[4][4][BB][jsize][i][k];
  rhs[4][k][jsize][i]   = rhs[4][k][jsize][i]  *pivot;

  coeff = lhsY[0][4][BB][jsize][i][k];
  rhs[0][k][jsize][i]   = rhs[0][k][jsize][i]   - coeff*rhs[4][k][jsize][i];

  coeff = lhsY[1][4][BB][jsize][i][k];
  rhs[1][k][jsize][i]   = rhs[1][k][jsize][i]   - coeff*rhs[4][k][jsize][i];

  coeff = lhsY[2][4][BB][jsize][i][k];
  rhs[2][k][jsize][i]   = rhs[2][k][jsize][i]   - coeff*rhs[4][k][jsize][i];

  coeff = lhsY[3][4][BB][jsize][i][k];
  rhs[3][k][jsize][i]   = rhs[3][k][jsize][i]   - coeff*rhs[4][k][jsize][i];


	}
  }
      //---------------------------------------------------------------------
      // back solve: if last cell, then generate U(jsize)=rhs(jsize)
      // else assume U(jsize) is loaded in un pack backsub_info
      // so just use it
      // after u(jstart) will be sent to next cell
      //---------------------------------------------------------------------
      for (j = jsize-1; j >= 0; j--) {
  #pragma acc parallel loop gang num_gangs(gp22) num_workers(4) vector_length(32) 
  for (k = 1; k <= gp22; k++) {
    #pragma acc loop worker vector
    for (i = 1; i <= gp02; i++) {
        /*
        for (m = 0; m < BLOCK_SIZE; m++) {
          for (n = 0; n < BLOCK_SIZE; n++) {
            rhs[m][k][j][i] = rhs[m][k][j][i] 
              - lhsY[m][n][CC][j][i][k]*rhs[n][k][j+1][i];
          }
        }
        */
	  
            rhs[0][k][j][i] = rhs[0][k][j][i] 
              - lhsY[0][0][CC][j][i][k]*rhs[0][k][j+1][i];
            rhs[0][k][j][i] = rhs[0][k][j][i] 
              - lhsY[0][1][CC][j][i][k]*rhs[1][k][j+1][i];
            rhs[0][k][j][i] = rhs[0][k][j][i] 
              - lhsY[0][2][CC][j][i][k]*rhs[2][k][j+1][i];
            rhs[0][k][j][i] = rhs[0][k][j][i] 
              - lhsY[0][3][CC][j][i][k]*rhs[3][k][j+1][i];
            rhs[0][k][j][i] = rhs[0][k][j][i] 
              - lhsY[0][4][CC][j][i][k]*rhs[4][k][j+1][i];
            
			rhs[1][k][j][i] = rhs[1][k][j][i] 
              - lhsY[1][0][CC][j][i][k]*rhs[0][k][j+1][i];
            rhs[1][k][j][i] = rhs[1][k][j][i] 
              - lhsY[1][1][CC][j][i][k]*rhs[1][k][j+1][i];
            rhs[1][k][j][i] = rhs[1][k][j][i] 
              - lhsY[1][2][CC][j][i][k]*rhs[2][k][j+1][i];
            rhs[1][k][j][i] = rhs[1][k][j][i] 
              - lhsY[1][3][CC][j][i][k]*rhs[3][k][j+1][i];
            rhs[1][k][j][i] = rhs[1][k][j][i] 
              - lhsY[1][4][CC][j][i][k]*rhs[4][k][j+1][i];
			
			rhs[2][k][j][i] = rhs[2][k][j][i] 
              - lhsY[2][0][CC][j][i][k]*rhs[0][k][j+1][i];
            rhs[2][k][j][i] = rhs[2][k][j][i] 
              - lhsY[2][1][CC][j][i][k]*rhs[1][k][j+1][i];
            rhs[2][k][j][i] = rhs[2][k][j][i] 
              - lhsY[2][2][CC][j][i][k]*rhs[2][k][j+1][i];
            rhs[2][k][j][i] = rhs[2][k][j][i] 
              - lhsY[2][3][CC][j][i][k]*rhs[3][k][j+1][i];
            rhs[2][k][j][i] = rhs[2][k][j][i] 
              - lhsY[2][4][CC][j][i][k]*rhs[4][k][j+1][i];
			
			rhs[3][k][j][i] = rhs[3][k][j][i] 
              - lhsY[3][0][CC][j][i][k]*rhs[0][k][j+1][i];
            rhs[3][k][j][i] = rhs[3][k][j][i] 
              - lhsY[3][1][CC][j][i][k]*rhs[1][k][j+1][i];
            rhs[3][k][j][i] = rhs[3][k][j][i] 
              - lhsY[3][2][CC][j][i][k]*rhs[2][k][j+1][i];
            rhs[3][k][j][i] = rhs[3][k][j][i] 
              - lhsY[3][3][CC][j][i][k]*rhs[3][k][j+1][i];
            rhs[3][k][j][i] = rhs[3][k][j][i] 
              - lhsY[3][4][CC][j][i][k]*rhs[4][k][j+1][i];
			
			rhs[4][k][j][i] = rhs[4][k][j][i] 
              - lhsY[4][0][CC][j][i][k]*rhs[0][k][j+1][i];
            rhs[4][k][j][i] = rhs[4][k][j][i] 
              - lhsY[4][1][CC][j][i][k]*rhs[1][k][j+1][i];
            rhs[4][k][j][i] = rhs[4][k][j][i] 
              - lhsY[4][2][CC][j][i][k]*rhs[2][k][j+1][i];
            rhs[4][k][j][i] = rhs[4][k][j][i] 
              - lhsY[4][3][CC][j][i][k]*rhs[3][k][j+1][i];
            rhs[4][k][j][i] = rhs[4][k][j][i] 
              - lhsY[4][4][CC][j][i][k]*rhs[4][k][j+1][i];
      }
    }
  }
}/*end acc data*/

}

########## NEXT FILE ##########
z_solve.c:::
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB BT code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS BT code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

#include "header.h"
//#include "timers.h"

//---------------------------------------------------------------------
// Performs line solves in Z direction by first factoring
// the block-tridiagonal matrix into an upper triangular matrix, 
// and then performing back substitution to solve for the unknow
// vectors of each line.  
// 
// Make sure we treat elements zero to cell_size in the direction
// of the sweep.
//---------------------------------------------------------------------
void z_solve()
{
  int i, j, k, m, n, ksize, z;
  double pivot, coeff;
  int gp12, gp02;
  double fjacZ[5][5][PROBLEM_SIZE+1][IMAXP-1][JMAXP-1];
  double njacZ[5][5][PROBLEM_SIZE+1][IMAXP-1][JMAXP-1];
  double lhsZ[5][5][3][PROBLEM_SIZE][IMAXP-1][JMAXP-1];
  double temp1, temp2, temp3;

  gp12 = grid_points[1]-2;
  gp02 = grid_points[0]-2;

  //---------------------------------------------------------------------
  // This function computes the left hand side for the three z-factors   
  //---------------------------------------------------------------------

  ksize = grid_points[2]-1;

  //---------------------------------------------------------------------
  // Compute the indices for storing the block-diagonal matrix;
  // determine c (labeled f) and s jacobians
  //---------------------------------------------------------------------
//#pragma acc data present(u,rhs,square,qs,lhsZ,fjacZ,njacZ)
#pragma acc data present(u,rhs,square,qs) create(lhsZ,fjacZ,njacZ)
{
	  #pragma acc parallel loop gang num_gangs(ksize+1) num_workers(4) vector_length(32)
      for (k = 0; k <= ksize; k++) {
    #pragma acc loop worker
    for (i = 1; i <= gp02; i++) {
  #pragma acc loop vector
  for (j = 1; j <= gp12; j++) {
        temp1 = 1.0 / u[0][k][j][i];
        temp2 = temp1 * temp1;
        temp3 = temp1 * temp2;

        fjacZ[0][0][k][i][j] = 0.0;
        fjacZ[0][1][k][i][j] = 0.0;
        fjacZ[0][2][k][i][j] = 0.0;
        fjacZ[0][3][k][i][j] = 1.0;
        fjacZ[0][4][k][i][j] = 0.0;

        fjacZ[1][0][k][i][j] = - ( u[1][k][j][i]*u[3][k][j][i] ) * temp2;
        fjacZ[1][1][k][i][j] = u[3][k][j][i] * temp1;
        fjacZ[1][2][k][i][j] = 0.0;
        fjacZ[1][3][k][i][j] = u[1][k][j][i] * temp1;
        fjacZ[1][4][k][i][j] = 0.0;

        fjacZ[2][0][k][i][j] = - ( u[2][k][j][i]*u[3][k][j][i] ) * temp2;
        fjacZ[2][1][k][i][j] = 0.0;
        fjacZ[2][2][k][i][j] = u[3][k][j][i] * temp1;
        fjacZ[2][3][k][i][j] = u[2][k][j][i] * temp1;
        fjacZ[2][4][k][i][j] = 0.0;

        fjacZ[3][0][k][i][j] = - (u[3][k][j][i]*u[3][k][j][i] * temp2 ) 
          + c2 * qs[k][j][i];
        fjacZ[3][1][k][i][j] = - c2 *  u[1][k][j][i] * temp1;
        fjacZ[3][2][k][i][j] = - c2 *  u[2][k][j][i] * temp1;
        fjacZ[3][3][k][i][j] = ( 2.0 - c2 ) *  u[3][k][j][i] * temp1;
        fjacZ[3][4][k][i][j] = c2;

        fjacZ[4][0][k][i][j] = ( c2 * 2.0 * square[k][j][i] - c1 * u[4][k][j][i] )
          * u[3][k][j][i] * temp2;
        fjacZ[4][1][k][i][j] = - c2 * ( u[1][k][j][i]*u[3][k][j][i] ) * temp2;
        fjacZ[4][2][k][i][j] = - c2 * ( u[2][k][j][i]*u[3][k][j][i] ) * temp2;
        fjacZ[4][3][k][i][j] = c1 * ( u[4][k][j][i] * temp1 )
          - c2 * ( qs[k][j][i] + u[3][k][j][i]*u[3][k][j][i] * temp2 );
        fjacZ[4][4][k][i][j] = c1 * u[3][k][j][i] * temp1;

        njacZ[0][0][k][i][j] = 0.0;
        njacZ[0][1][k][i][j] = 0.0;
        njacZ[0][2][k][i][j] = 0.0;
        njacZ[0][3][k][i][j] = 0.0;
        njacZ[0][4][k][i][j] = 0.0;

        njacZ[1][0][k][i][j] = - c3c4 * temp2 * u[1][k][j][i];
        njacZ[1][1][k][i][j] =   c3c4 * temp1;
        njacZ[1][2][k][i][j] =   0.0;
        njacZ[1][3][k][i][j] =   0.0;
        njacZ[1][4][k][i][j] =   0.0;

        njacZ[2][0][k][i][j] = - c3c4 * temp2 * u[2][k][j][i];
        njacZ[2][1][k][i][j] =   0.0;
        njacZ[2][2][k][i][j] =   c3c4 * temp1;
        njacZ[2][3][k][i][j] =   0.0;
        njacZ[2][4][k][i][j] =   0.0;

        njacZ[3][0][k][i][j] = - con43 * c3c4 * temp2 * u[3][k][j][i];
        njacZ[3][1][k][i][j] =   0.0;
        njacZ[3][2][k][i][j] =   0.0;
        njacZ[3][3][k][i][j] =   con43 * c3 * c4 * temp1;
        njacZ[3][4][k][i][j] =   0.0;

        njacZ[4][0][k][i][j] = - (  c3c4
            - c1345 ) * temp3 * (u[1][k][j][i]*u[1][k][j][i])
          - ( c3c4 - c1345 ) * temp3 * (u[2][k][j][i]*u[2][k][j][i])
          - ( con43 * c3c4
              - c1345 ) * temp3 * (u[3][k][j][i]*u[3][k][j][i])
          - c1345 * temp2 * u[4][k][j][i];

        njacZ[4][1][k][i][j] = (  c3c4 - c1345 ) * temp2 * u[1][k][j][i];
        njacZ[4][2][k][i][j] = (  c3c4 - c1345 ) * temp2 * u[2][k][j][i];
        njacZ[4][3][k][i][j] = ( con43 * c3c4
            - c1345 ) * temp2 * u[3][k][j][i];
        njacZ[4][4][k][i][j] = ( c1345 )* temp1;
      }
	}
  }
      //---------------------------------------------------------------------
      // now jacobians set, so form left hand side in z direction
      //---------------------------------------------------------------------
      //lhsZ[j][i]init(lhsZ[j][i], ksize);
  // zero the whole left hand side for starters
    #pragma acc parallel loop gang num_gangs(gp02) num_workers(4) vector_length(32)
    for (i = 1; i <= gp02; i++) {
  #pragma acc loop worker vector
  for (j = 1; j <= gp12; j++) {
  		for (n = 0; n < 5; n++) {
    		for (m = 0; m < 5; m++) {
      			lhsZ[m][n][0][0][i][j] = 0.0;
      			lhsZ[m][n][1][0][i][j] = 0.0;
      			lhsZ[m][n][2][0][i][j] = 0.0;
      			lhsZ[m][n][0][ksize][i][j] = 0.0;
      			lhsZ[m][n][1][ksize][i][j] = 0.0;
      			lhsZ[m][n][2][ksize][i][j] = 0.0;
    		}
  		}
	}
  }

  // next, set all diagonal values to 1. This is overkill, but convenient
    #pragma acc parallel loop gang num_gangs(gp02) num_workers(4) vector_length(32)
    for (i = 1; i <= gp02; i++) {
  #pragma acc loop worker vector
  for (j = 1; j <= gp12; j++) {
    		lhsZ[0][0][1][0][i][j] = 1.0;
    		lhsZ[0][0][1][ksize][i][j] = 1.0;
    		lhsZ[1][1][1][0][i][j] = 1.0;
    		lhsZ[1][1][1][ksize][i][j] = 1.0;
    		lhsZ[2][2][1][0][i][j] = 1.0;
    		lhsZ[2][2][1][ksize][i][j] = 1.0;
    		lhsZ[3][3][1][0][i][j] = 1.0;
    		lhsZ[3][3][1][ksize][i][j] = 1.0;
    		lhsZ[4][4][1][0][i][j] = 1.0;
    		lhsZ[4][4][1][ksize][i][j] = 1.0;
	}
  }

	  #pragma acc parallel loop gang num_gangs(ksize-1) num_workers(4) vector_length(32)
      for (k = 1; k <= ksize-1; k++) {
    #pragma acc loop worker
    for (i = 1; i <= gp02; i++) {
  #pragma acc loop vector
  for (j = 1; j <= gp12; j++) {
        temp1 = dt * tz1;
        temp2 = dt * tz2;

        lhsZ[0][0][AA][k][i][j] = - temp2 * fjacZ[0][0][k-1][i][j]
          - temp1 * njacZ[0][0][k-1][i][j]
          - temp1 * dz1; 
        lhsZ[0][1][AA][k][i][j] = - temp2 * fjacZ[0][1][k-1][i][j]
          - temp1 * njacZ[0][1][k-1][i][j];
        lhsZ[0][2][AA][k][i][j] = - temp2 * fjacZ[0][2][k-1][i][j]
          - temp1 * njacZ[0][2][k-1][i][j];
        lhsZ[0][3][AA][k][i][j] = - temp2 * fjacZ[0][3][k-1][i][j]
          - temp1 * njacZ[0][3][k-1][i][j];
        lhsZ[0][4][AA][k][i][j] = - temp2 * fjacZ[0][4][k-1][i][j]
          - temp1 * njacZ[0][4][k-1][i][j];

        lhsZ[1][0][AA][k][i][j] = - temp2 * fjacZ[1][0][k-1][i][j]
          - temp1 * njacZ[1][0][k-1][i][j];
        lhsZ[1][1][AA][k][i][j] = - temp2 * fjacZ[1][1][k-1][i][j]
          - temp1 * njacZ[1][1][k-1][i][j]
          - temp1 * dz2;
        lhsZ[1][2][AA][k][i][j] = - temp2 * fjacZ[1][2][k-1][i][j]
          - temp1 * njacZ[1][2][k-1][i][j];
        lhsZ[1][3][AA][k][i][j] = - temp2 * fjacZ[1][3][k-1][i][j]
          - temp1 * njacZ[1][3][k-1][i][j];
        lhsZ[1][4][AA][k][i][j] = - temp2 * fjacZ[1][4][k-1][i][j]
          - temp1 * njacZ[1][4][k-1][i][j];

        lhsZ[2][0][AA][k][i][j] = - temp2 * fjacZ[2][0][k-1][i][j]
          - temp1 * njacZ[2][0][k-1][i][j];
        lhsZ[2][1][AA][k][i][j] = - temp2 * fjacZ[2][1][k-1][i][j]
          - temp1 * njacZ[2][1][k-1][i][j];
        lhsZ[2][2][AA][k][i][j] = - temp2 * fjacZ[2][2][k-1][i][j]
          - temp1 * njacZ[2][2][k-1][i][j]
          - temp1 * dz3;
        lhsZ[2][3][AA][k][i][j] = - temp2 * fjacZ[2][3][k-1][i][j]
          - temp1 * njacZ[2][3][k-1][i][j];
        lhsZ[2][4][AA][k][i][j] = - temp2 * fjacZ[2][4][k-1][i][j]
          - temp1 * njacZ[2][4][k-1][i][j];

        lhsZ[3][0][AA][k][i][j] = - temp2 * fjacZ[3][0][k-1][i][j]
          - temp1 * njacZ[3][0][k-1][i][j];
        lhsZ[3][1][AA][k][i][j] = - temp2 * fjacZ[3][1][k-1][i][j]
          - temp1 * njacZ[3][1][k-1][i][j];
        lhsZ[3][2][AA][k][i][j] = - temp2 * fjacZ[3][2][k-1][i][j]
          - temp1 * njacZ[3][2][k-1][i][j];
        lhsZ[3][3][AA][k][i][j] = - temp2 * fjacZ[3][3][k-1][i][j]
          - temp1 * njacZ[3][3][k-1][i][j]
          - temp1 * dz4;
        lhsZ[3][4][AA][k][i][j] = - temp2 * fjacZ[3][4][k-1][i][j]
          - temp1 * njacZ[3][4][k-1][i][j];

        lhsZ[4][0][AA][k][i][j] = - temp2 * fjacZ[4][0][k-1][i][j]
          - temp1 * njacZ[4][0][k-1][i][j];
        lhsZ[4][1][AA][k][i][j] = - temp2 * fjacZ[4][1][k-1][i][j]
          - temp1 * njacZ[4][1][k-1][i][j];
        lhsZ[4][2][AA][k][i][j] = - temp2 * fjacZ[4][2][k-1][i][j]
          - temp1 * njacZ[4][2][k-1][i][j];
        lhsZ[4][3][AA][k][i][j] = - temp2 * fjacZ[4][3][k-1][i][j]
          - temp1 * njacZ[4][3][k-1][i][j];
        lhsZ[4][4][AA][k][i][j] = - temp2 * fjacZ[4][4][k-1][i][j]
          - temp1 * njacZ[4][4][k-1][i][j]
          - temp1 * dz5;

        lhsZ[0][0][BB][k][i][j] = 1.0
          + temp1 * 2.0 * njacZ[0][0][k][i][j]
          + temp1 * 2.0 * dz1;
        lhsZ[0][1][BB][k][i][j] = temp1 * 2.0 * njacZ[0][1][k][i][j];
        lhsZ[0][2][BB][k][i][j] = temp1 * 2.0 * njacZ[0][2][k][i][j];
        lhsZ[0][3][BB][k][i][j] = temp1 * 2.0 * njacZ[0][3][k][i][j];
        lhsZ[0][4][BB][k][i][j] = temp1 * 2.0 * njacZ[0][4][k][i][j];

        lhsZ[1][0][BB][k][i][j] = temp1 * 2.0 * njacZ[1][0][k][i][j];
        lhsZ[1][1][BB][k][i][j] = 1.0
          + temp1 * 2.0 * njacZ[1][1][k][i][j]
          + temp1 * 2.0 * dz2;
        lhsZ[1][2][BB][k][i][j] = temp1 * 2.0 * njacZ[1][2][k][i][j];
        lhsZ[1][3][BB][k][i][j] = temp1 * 2.0 * njacZ[1][3][k][i][j];
        lhsZ[1][4][BB][k][i][j] = temp1 * 2.0 * njacZ[1][4][k][i][j];

        lhsZ[2][0][BB][k][i][j] = temp1 * 2.0 * njacZ[2][0][k][i][j];
        lhsZ[2][1][BB][k][i][j] = temp1 * 2.0 * njacZ[2][1][k][i][j];
        lhsZ[2][2][BB][k][i][j] = 1.0
          + temp1 * 2.0 * njacZ[2][2][k][i][j]
          + temp1 * 2.0 * dz3;
        lhsZ[2][3][BB][k][i][j] = temp1 * 2.0 * njacZ[2][3][k][i][j];
        lhsZ[2][4][BB][k][i][j] = temp1 * 2.0 * njacZ[2][4][k][i][j];

        lhsZ[3][0][BB][k][i][j] = temp1 * 2.0 * njacZ[3][0][k][i][j];
        lhsZ[3][1][BB][k][i][j] = temp1 * 2.0 * njacZ[3][1][k][i][j];
        lhsZ[3][2][BB][k][i][j] = temp1 * 2.0 * njacZ[3][2][k][i][j];
        lhsZ[3][3][BB][k][i][j] = 1.0
          + temp1 * 2.0 * njacZ[3][3][k][i][j]
          + temp1 * 2.0 * dz4;
        lhsZ[3][4][BB][k][i][j] = temp1 * 2.0 * njacZ[3][4][k][i][j];

        lhsZ[4][0][BB][k][i][j] = temp1 * 2.0 * njacZ[4][0][k][i][j];
        lhsZ[4][1][BB][k][i][j] = temp1 * 2.0 * njacZ[4][1][k][i][j];
        lhsZ[4][2][BB][k][i][j] = temp1 * 2.0 * njacZ[4][2][k][i][j];
        lhsZ[4][3][BB][k][i][j] = temp1 * 2.0 * njacZ[4][3][k][i][j];
        lhsZ[4][4][BB][k][i][j] = 1.0
          + temp1 * 2.0 * njacZ[4][4][k][i][j] 
          + temp1 * 2.0 * dz5;

        lhsZ[0][0][CC][k][i][j] =  temp2 * fjacZ[0][0][k+1][i][j]
          - temp1 * njacZ[0][0][k+1][i][j]
          - temp1 * dz1;
        lhsZ[0][1][CC][k][i][j] =  temp2 * fjacZ[0][1][k+1][i][j]
          - temp1 * njacZ[0][1][k+1][i][j];
        lhsZ[0][2][CC][k][i][j] =  temp2 * fjacZ[0][2][k+1][i][j]
          - temp1 * njacZ[0][2][k+1][i][j];
        lhsZ[0][3][CC][k][i][j] =  temp2 * fjacZ[0][3][k+1][i][j]
          - temp1 * njacZ[0][3][k+1][i][j];
        lhsZ[0][4][CC][k][i][j] =  temp2 * fjacZ[0][4][k+1][i][j]
          - temp1 * njacZ[0][4][k+1][i][j];

        lhsZ[1][0][CC][k][i][j] =  temp2 * fjacZ[1][0][k+1][i][j]
          - temp1 * njacZ[1][0][k+1][i][j];
        lhsZ[1][1][CC][k][i][j] =  temp2 * fjacZ[1][1][k+1][i][j]
          - temp1 * njacZ[1][1][k+1][i][j]
          - temp1 * dz2;
        lhsZ[1][2][CC][k][i][j] =  temp2 * fjacZ[1][2][k+1][i][j]
          - temp1 * njacZ[1][2][k+1][i][j];
        lhsZ[1][3][CC][k][i][j] =  temp2 * fjacZ[1][3][k+1][i][j]
          - temp1 * njacZ[1][3][k+1][i][j];
        lhsZ[1][4][CC][k][i][j] =  temp2 * fjacZ[1][4][k+1][i][j]
          - temp1 * njacZ[1][4][k+1][i][j];

        lhsZ[2][0][CC][k][i][j] =  temp2 * fjacZ[2][0][k+1][i][j]
          - temp1 * njacZ[2][0][k+1][i][j];
        lhsZ[2][1][CC][k][i][j] =  temp2 * fjacZ[2][1][k+1][i][j]
          - temp1 * njacZ[2][1][k+1][i][j];
        lhsZ[2][2][CC][k][i][j] =  temp2 * fjacZ[2][2][k+1][i][j]
          - temp1 * njacZ[2][2][k+1][i][j]
          - temp1 * dz3;
        lhsZ[2][3][CC][k][i][j] =  temp2 * fjacZ[2][3][k+1][i][j]
          - temp1 * njacZ[2][3][k+1][i][j];
        lhsZ[2][4][CC][k][i][j] =  temp2 * fjacZ[2][4][k+1][i][j]
          - temp1 * njacZ[2][4][k+1][i][j];

        lhsZ[3][0][CC][k][i][j] =  temp2 * fjacZ[3][0][k+1][i][j]
          - temp1 * njacZ[3][0][k+1][i][j];
        lhsZ[3][1][CC][k][i][j] =  temp2 * fjacZ[3][1][k+1][i][j]
          - temp1 * njacZ[3][1][k+1][i][j];
        lhsZ[3][2][CC][k][i][j] =  temp2 * fjacZ[3][2][k+1][i][j]
          - temp1 * njacZ[3][2][k+1][i][j];
        lhsZ[3][3][CC][k][i][j] =  temp2 * fjacZ[3][3][k+1][i][j]
          - temp1 * njacZ[3][3][k+1][i][j]
          - temp1 * dz4;
        lhsZ[3][4][CC][k][i][j] =  temp2 * fjacZ[3][4][k+1][i][j]
          - temp1 * njacZ[3][4][k+1][i][j];

        lhsZ[4][0][CC][k][i][j] =  temp2 * fjacZ[4][0][k+1][i][j]
          - temp1 * njacZ[4][0][k+1][i][j];
        lhsZ[4][1][CC][k][i][j] =  temp2 * fjacZ[4][1][k+1][i][j]
          - temp1 * njacZ[4][1][k+1][i][j];
        lhsZ[4][2][CC][k][i][j] =  temp2 * fjacZ[4][2][k+1][i][j]
          - temp1 * njacZ[4][2][k+1][i][j];
        lhsZ[4][3][CC][k][i][j] =  temp2 * fjacZ[4][3][k+1][i][j]
          - temp1 * njacZ[4][3][k+1][i][j];
        lhsZ[4][4][CC][k][i][j] =  temp2 * fjacZ[4][4][k+1][i][j]
          - temp1 * njacZ[4][4][k+1][i][j]
          - temp1 * dz5;
      }
	}
  }
      //---------------------------------------------------------------------
      //---------------------------------------------------------------------

      //---------------------------------------------------------------------
      // performs guaussian elimination on this cell.
      // 
      // assumes that unpacking routines for non-first cells 
      // preload C' and rhs' from previous cell.
      // 
      // assumed send happens outside this routine, but that
      // c'(KMAX) and rhs'(KMAX) will be sent to next cell.
      //---------------------------------------------------------------------

      //---------------------------------------------------------------------
      // outer most do loops - sweeping in i direction
      //---------------------------------------------------------------------

      //---------------------------------------------------------------------
      // multiply c[0][j][i] by b_inverse and copy back to c
      // multiply rhs(0) by b_inverse(0) and copy to rhs      //---------------------------------------------------------------------
      //binvcrhs( lhsZ[0][i][BB], lhsZ[j][0][i][j][CC], rhs[0][j][i] );
    #pragma acc parallel loop gang num_gangs(gp02) num_workers(4) vector_length(32) 
    for (i = 1; i <= gp02; i++) {
  #pragma acc loop worker vector
  for (j = 1; j <= gp12; j++) {
/*
	  for(m = 0; m < 5; m++){
	  	pivot = 1.00/lhsZ[m][m][BB][0][i][j];
		for(n = m+1; n < 5; n++){
			lhsZ[m][n][BB][0][i][j] = lhsZ[m][n][BB][0][i][j]*pivot;
		}
		lhsZ[m][0][CC][0][i][j] = lhsZ[m][0][CC][0][i][j]*pivot;
		lhsZ[m][1][CC][0][i][j] = lhsZ[m][1][CC][0][i][j]*pivot;
		lhsZ[m][2][CC][0][i][j] = lhsZ[m][2][CC][0][i][j]*pivot;
		lhsZ[m][3][CC][0][i][j] = lhsZ[m][3][CC][0][i][j]*pivot;
		lhsZ[m][4][CC][0][i][j] = lhsZ[m][4][CC][0][i][j]*pivot;
		rhs[m][0][j][i] = rhs[m][0][j][i]*pivot;

		for(n = 0; n < 5; n++){
			if(n != m){
				coeff = lhsZ[n][m][BB][0][i][j];
				for(z = m+1; z < 5; z++){
					lhsZ[n][z][BB][0][i][j] = lhsZ[n][z][BB][0][i][j] - coeff*lhsZ[m][z][BB][0][i][j];
				}
				lhsZ[n][0][CC][0][i][j] = lhsZ[n][0][CC][0][i][j] - coeff*lhsZ[m][0][CC][0][i][j];
				lhsZ[n][1][CC][0][i][j] = lhsZ[n][1][CC][0][i][j] - coeff*lhsZ[m][1][CC][0][i][j];
				lhsZ[n][2][CC][0][i][j] = lhsZ[n][2][CC][0][i][j] - coeff*lhsZ[m][2][CC][0][i][j];
				lhsZ[n][3][CC][0][i][j] = lhsZ[n][3][CC][0][i][j] - coeff*lhsZ[m][3][CC][0][i][j];
				lhsZ[n][4][CC][0][i][j] = lhsZ[n][4][CC][0][i][j] - coeff*lhsZ[m][4][CC][0][i][j];
				rhs[n][0][j][i] = rhs[n][0][j][i] - coeff*rhs[m][0][j][i];
			}
		}
	  }
*/
  pivot = 1.00/lhsZ[0][0][BB][0][i][j];
  lhsZ[0][1][BB][0][i][j] = lhsZ[0][1][BB][0][i][j]*pivot;
  lhsZ[0][2][BB][0][i][j] = lhsZ[0][2][BB][0][i][j]*pivot;
  lhsZ[0][3][BB][0][i][j] = lhsZ[0][3][BB][0][i][j]*pivot;
  lhsZ[0][4][BB][0][i][j] = lhsZ[0][4][BB][0][i][j]*pivot;
  lhsZ[0][0][CC][0][i][j] = lhsZ[0][0][CC][0][i][j]*pivot;
  lhsZ[0][1][CC][0][i][j] = lhsZ[0][1][CC][0][i][j]*pivot;
  lhsZ[0][2][CC][0][i][j] = lhsZ[0][2][CC][0][i][j]*pivot;
  lhsZ[0][3][CC][0][i][j] = lhsZ[0][3][CC][0][i][j]*pivot;
  lhsZ[0][4][CC][0][i][j] = lhsZ[0][4][CC][0][i][j]*pivot;
  rhs[0][0][j][i]   = rhs[0][0][j][i]  *pivot;

  coeff = lhsZ[1][0][BB][0][i][j];
  lhsZ[1][1][BB][0][i][j]= lhsZ[1][1][BB][0][i][j] - coeff*lhsZ[0][1][BB][0][i][j];
  lhsZ[1][2][BB][0][i][j]= lhsZ[1][2][BB][0][i][j] - coeff*lhsZ[0][2][BB][0][i][j];
  lhsZ[1][3][BB][0][i][j]= lhsZ[1][3][BB][0][i][j] - coeff*lhsZ[0][3][BB][0][i][j];
  lhsZ[1][4][BB][0][i][j]= lhsZ[1][4][BB][0][i][j] - coeff*lhsZ[0][4][BB][0][i][j];
  lhsZ[1][0][CC][0][i][j] = lhsZ[1][0][CC][0][i][j] - coeff*lhsZ[0][0][CC][0][i][j];
  lhsZ[1][1][CC][0][i][j] = lhsZ[1][1][CC][0][i][j] - coeff*lhsZ[0][1][CC][0][i][j];
  lhsZ[1][2][CC][0][i][j] = lhsZ[1][2][CC][0][i][j] - coeff*lhsZ[0][2][CC][0][i][j];
  lhsZ[1][3][CC][0][i][j] = lhsZ[1][3][CC][0][i][j] - coeff*lhsZ[0][3][CC][0][i][j];
  lhsZ[1][4][CC][0][i][j] = lhsZ[1][4][CC][0][i][j] - coeff*lhsZ[0][4][CC][0][i][j];
  rhs[1][0][j][i]   = rhs[1][0][j][i]   - coeff*rhs[0][0][j][i];

  coeff = lhsZ[2][0][BB][0][i][j];
  lhsZ[2][1][BB][0][i][j]= lhsZ[2][1][BB][0][i][j] - coeff*lhsZ[0][1][BB][0][i][j];
  lhsZ[2][2][BB][0][i][j]= lhsZ[2][2][BB][0][i][j] - coeff*lhsZ[0][2][BB][0][i][j];
  lhsZ[2][3][BB][0][i][j]= lhsZ[2][3][BB][0][i][j] - coeff*lhsZ[0][3][BB][0][i][j];
  lhsZ[2][4][BB][0][i][j]= lhsZ[2][4][BB][0][i][j] - coeff*lhsZ[0][4][BB][0][i][j];
  lhsZ[2][0][CC][0][i][j] = lhsZ[2][0][CC][0][i][j] - coeff*lhsZ[0][0][CC][0][i][j];
  lhsZ[2][1][CC][0][i][j] = lhsZ[2][1][CC][0][i][j] - coeff*lhsZ[0][1][CC][0][i][j];
  lhsZ[2][2][CC][0][i][j] = lhsZ[2][2][CC][0][i][j] - coeff*lhsZ[0][2][CC][0][i][j];
  lhsZ[2][3][CC][0][i][j] = lhsZ[2][3][CC][0][i][j] - coeff*lhsZ[0][3][CC][0][i][j];
  lhsZ[2][4][CC][0][i][j] = lhsZ[2][4][CC][0][i][j] - coeff*lhsZ[0][4][CC][0][i][j];
  rhs[2][0][j][i]   = rhs[2][0][j][i]   - coeff*rhs[0][0][j][i];

  coeff = lhsZ[3][0][BB][0][i][j];
  lhsZ[3][1][BB][0][i][j]= lhsZ[3][1][BB][0][i][j] - coeff*lhsZ[0][1][BB][0][i][j];
  lhsZ[3][2][BB][0][i][j]= lhsZ[3][2][BB][0][i][j] - coeff*lhsZ[0][2][BB][0][i][j];
  lhsZ[3][3][BB][0][i][j]= lhsZ[3][3][BB][0][i][j] - coeff*lhsZ[0][3][BB][0][i][j];
  lhsZ[3][4][BB][0][i][j]= lhsZ[3][4][BB][0][i][j] - coeff*lhsZ[0][4][BB][0][i][j];
  lhsZ[3][0][CC][0][i][j] = lhsZ[3][0][CC][0][i][j] - coeff*lhsZ[0][0][CC][0][i][j];
  lhsZ[3][1][CC][0][i][j] = lhsZ[3][1][CC][0][i][j] - coeff*lhsZ[0][1][CC][0][i][j];
  lhsZ[3][2][CC][0][i][j] = lhsZ[3][2][CC][0][i][j] - coeff*lhsZ[0][2][CC][0][i][j];
  lhsZ[3][3][CC][0][i][j] = lhsZ[3][3][CC][0][i][j] - coeff*lhsZ[0][3][CC][0][i][j];
  lhsZ[3][4][CC][0][i][j] = lhsZ[3][4][CC][0][i][j] - coeff*lhsZ[0][4][CC][0][i][j];
  rhs[3][0][j][i]   = rhs[3][0][j][i]   - coeff*rhs[0][0][j][i];

  coeff = lhsZ[4][0][BB][0][i][j];
  lhsZ[4][1][BB][0][i][j]= lhsZ[4][1][BB][0][i][j] - coeff*lhsZ[0][1][BB][0][i][j];
  lhsZ[4][2][BB][0][i][j]= lhsZ[4][2][BB][0][i][j] - coeff*lhsZ[0][2][BB][0][i][j];
  lhsZ[4][3][BB][0][i][j]= lhsZ[4][3][BB][0][i][j] - coeff*lhsZ[0][3][BB][0][i][j];
  lhsZ[4][4][BB][0][i][j]= lhsZ[4][4][BB][0][i][j] - coeff*lhsZ[0][4][BB][0][i][j];
  lhsZ[4][0][CC][0][i][j] = lhsZ[4][0][CC][0][i][j] - coeff*lhsZ[0][0][CC][0][i][j];
  lhsZ[4][1][CC][0][i][j] = lhsZ[4][1][CC][0][i][j] - coeff*lhsZ[0][1][CC][0][i][j];
  lhsZ[4][2][CC][0][i][j] = lhsZ[4][2][CC][0][i][j] - coeff*lhsZ[0][2][CC][0][i][j];
  lhsZ[4][3][CC][0][i][j] = lhsZ[4][3][CC][0][i][j] - coeff*lhsZ[0][3][CC][0][i][j];
  lhsZ[4][4][CC][0][i][j] = lhsZ[4][4][CC][0][i][j] - coeff*lhsZ[0][4][CC][0][i][j];
  rhs[4][0][j][i]   = rhs[4][0][j][i]   - coeff*rhs[0][0][j][i];


  pivot = 1.00/lhsZ[1][1][BB][0][i][j];
  lhsZ[1][2][BB][0][i][j] = lhsZ[1][2][BB][0][i][j]*pivot;
  lhsZ[1][3][BB][0][i][j] = lhsZ[1][3][BB][0][i][j]*pivot;
  lhsZ[1][4][BB][0][i][j] = lhsZ[1][4][BB][0][i][j]*pivot;
  lhsZ[1][0][CC][0][i][j] = lhsZ[1][0][CC][0][i][j]*pivot;
  lhsZ[1][1][CC][0][i][j] = lhsZ[1][1][CC][0][i][j]*pivot;
  lhsZ[1][2][CC][0][i][j] = lhsZ[1][2][CC][0][i][j]*pivot;
  lhsZ[1][3][CC][0][i][j] = lhsZ[1][3][CC][0][i][j]*pivot;
  lhsZ[1][4][CC][0][i][j] = lhsZ[1][4][CC][0][i][j]*pivot;
  rhs[1][0][j][i]   = rhs[1][0][j][i]  *pivot;

  coeff = lhsZ[0][1][BB][0][i][j];
  lhsZ[0][2][BB][0][i][j]= lhsZ[0][2][BB][0][i][j] - coeff*lhsZ[1][2][BB][0][i][j];
  lhsZ[0][3][BB][0][i][j]= lhsZ[0][3][BB][0][i][j] - coeff*lhsZ[1][3][BB][0][i][j];
  lhsZ[0][4][BB][0][i][j]= lhsZ[0][4][BB][0][i][j] - coeff*lhsZ[1][4][BB][0][i][j];
  lhsZ[0][0][CC][0][i][j] = lhsZ[0][0][CC][0][i][j] - coeff*lhsZ[1][0][CC][0][i][j];
  lhsZ[0][1][CC][0][i][j] = lhsZ[0][1][CC][0][i][j] - coeff*lhsZ[1][1][CC][0][i][j];
  lhsZ[0][2][CC][0][i][j] = lhsZ[0][2][CC][0][i][j] - coeff*lhsZ[1][2][CC][0][i][j];
  lhsZ[0][3][CC][0][i][j] = lhsZ[0][3][CC][0][i][j] - coeff*lhsZ[1][3][CC][0][i][j];
  lhsZ[0][4][CC][0][i][j] = lhsZ[0][4][CC][0][i][j] - coeff*lhsZ[1][4][CC][0][i][j];
  rhs[0][0][j][i]   = rhs[0][0][j][i]   - coeff*rhs[1][0][j][i];

  coeff = lhsZ[2][1][BB][0][i][j];
  lhsZ[2][2][BB][0][i][j]= lhsZ[2][2][BB][0][i][j] - coeff*lhsZ[1][2][BB][0][i][j];
  lhsZ[2][3][BB][0][i][j]= lhsZ[2][3][BB][0][i][j] - coeff*lhsZ[1][3][BB][0][i][j];
  lhsZ[2][4][BB][0][i][j]= lhsZ[2][4][BB][0][i][j] - coeff*lhsZ[1][4][BB][0][i][j];
  lhsZ[2][0][CC][0][i][j] = lhsZ[2][0][CC][0][i][j] - coeff*lhsZ[1][0][CC][0][i][j];
  lhsZ[2][1][CC][0][i][j] = lhsZ[2][1][CC][0][i][j] - coeff*lhsZ[1][1][CC][0][i][j];
  lhsZ[2][2][CC][0][i][j] = lhsZ[2][2][CC][0][i][j] - coeff*lhsZ[1][2][CC][0][i][j];
  lhsZ[2][3][CC][0][i][j] = lhsZ[2][3][CC][0][i][j] - coeff*lhsZ[1][3][CC][0][i][j];
  lhsZ[2][4][CC][0][i][j] = lhsZ[2][4][CC][0][i][j] - coeff*lhsZ[1][4][CC][0][i][j];
  rhs[2][0][j][i]   = rhs[2][0][j][i]   - coeff*rhs[1][0][j][i];

  coeff = lhsZ[3][1][BB][0][i][j];
  lhsZ[3][2][BB][0][i][j]= lhsZ[3][2][BB][0][i][j] - coeff*lhsZ[1][2][BB][0][i][j];
  lhsZ[3][3][BB][0][i][j]= lhsZ[3][3][BB][0][i][j] - coeff*lhsZ[1][3][BB][0][i][j];
  lhsZ[3][4][BB][0][i][j]= lhsZ[3][4][BB][0][i][j] - coeff*lhsZ[1][4][BB][0][i][j];
  lhsZ[3][0][CC][0][i][j] = lhsZ[3][0][CC][0][i][j] - coeff*lhsZ[1][0][CC][0][i][j];
  lhsZ[3][1][CC][0][i][j] = lhsZ[3][1][CC][0][i][j] - coeff*lhsZ[1][1][CC][0][i][j];
  lhsZ[3][2][CC][0][i][j] = lhsZ[3][2][CC][0][i][j] - coeff*lhsZ[1][2][CC][0][i][j];
  lhsZ[3][3][CC][0][i][j] = lhsZ[3][3][CC][0][i][j] - coeff*lhsZ[1][3][CC][0][i][j];
  lhsZ[3][4][CC][0][i][j] = lhsZ[3][4][CC][0][i][j] - coeff*lhsZ[1][4][CC][0][i][j];
  rhs[3][0][j][i]   = rhs[3][0][j][i]   - coeff*rhs[1][0][j][i];

  coeff = lhsZ[4][1][BB][0][i][j];
  lhsZ[4][2][BB][0][i][j]= lhsZ[4][2][BB][0][i][j] - coeff*lhsZ[1][2][BB][0][i][j];
  lhsZ[4][3][BB][0][i][j]= lhsZ[4][3][BB][0][i][j] - coeff*lhsZ[1][3][BB][0][i][j];
  lhsZ[4][4][BB][0][i][j]= lhsZ[4][4][BB][0][i][j] - coeff*lhsZ[1][4][BB][0][i][j];
  lhsZ[4][0][CC][0][i][j] = lhsZ[4][0][CC][0][i][j] - coeff*lhsZ[1][0][CC][0][i][j];
  lhsZ[4][1][CC][0][i][j] = lhsZ[4][1][CC][0][i][j] - coeff*lhsZ[1][1][CC][0][i][j];
  lhsZ[4][2][CC][0][i][j] = lhsZ[4][2][CC][0][i][j] - coeff*lhsZ[1][2][CC][0][i][j];
  lhsZ[4][3][CC][0][i][j] = lhsZ[4][3][CC][0][i][j] - coeff*lhsZ[1][3][CC][0][i][j];
  lhsZ[4][4][CC][0][i][j] = lhsZ[4][4][CC][0][i][j] - coeff*lhsZ[1][4][CC][0][i][j];
  rhs[4][0][j][i]   = rhs[4][0][j][i]   - coeff*rhs[1][0][j][i];


  pivot = 1.00/lhsZ[2][2][BB][0][i][j];
  lhsZ[2][3][BB][0][i][j] = lhsZ[2][3][BB][0][i][j]*pivot;
  lhsZ[2][4][BB][0][i][j] = lhsZ[2][4][BB][0][i][j]*pivot;
  lhsZ[2][0][CC][0][i][j] = lhsZ[2][0][CC][0][i][j]*pivot;
  lhsZ[2][1][CC][0][i][j] = lhsZ[2][1][CC][0][i][j]*pivot;
  lhsZ[2][2][CC][0][i][j] = lhsZ[2][2][CC][0][i][j]*pivot;
  lhsZ[2][3][CC][0][i][j] = lhsZ[2][3][CC][0][i][j]*pivot;
  lhsZ[2][4][CC][0][i][j] = lhsZ[2][4][CC][0][i][j]*pivot;
  rhs[2][0][j][i]   = rhs[2][0][j][i]  *pivot;

  coeff = lhsZ[0][2][BB][0][i][j];
  lhsZ[0][3][BB][0][i][j]= lhsZ[0][3][BB][0][i][j] - coeff*lhsZ[2][3][BB][0][i][j];
  lhsZ[0][4][BB][0][i][j]= lhsZ[0][4][BB][0][i][j] - coeff*lhsZ[2][4][BB][0][i][j];
  lhsZ[0][0][CC][0][i][j] = lhsZ[0][0][CC][0][i][j] - coeff*lhsZ[2][0][CC][0][i][j];
  lhsZ[0][1][CC][0][i][j] = lhsZ[0][1][CC][0][i][j] - coeff*lhsZ[2][1][CC][0][i][j];
  lhsZ[0][2][CC][0][i][j] = lhsZ[0][2][CC][0][i][j] - coeff*lhsZ[2][2][CC][0][i][j];
  lhsZ[0][3][CC][0][i][j] = lhsZ[0][3][CC][0][i][j] - coeff*lhsZ[2][3][CC][0][i][j];
  lhsZ[0][4][CC][0][i][j] = lhsZ[0][4][CC][0][i][j] - coeff*lhsZ[2][4][CC][0][i][j];
  rhs[0][0][j][i]   = rhs[0][0][j][i]   - coeff*rhs[2][0][j][i];

  coeff = lhsZ[1][2][BB][0][i][j];
  lhsZ[1][3][BB][0][i][j]= lhsZ[1][3][BB][0][i][j] - coeff*lhsZ[2][3][BB][0][i][j];
  lhsZ[1][4][BB][0][i][j]= lhsZ[1][4][BB][0][i][j] - coeff*lhsZ[2][4][BB][0][i][j];
  lhsZ[1][0][CC][0][i][j] = lhsZ[1][0][CC][0][i][j] - coeff*lhsZ[2][0][CC][0][i][j];
  lhsZ[1][1][CC][0][i][j] = lhsZ[1][1][CC][0][i][j] - coeff*lhsZ[2][1][CC][0][i][j];
  lhsZ[1][2][CC][0][i][j] = lhsZ[1][2][CC][0][i][j] - coeff*lhsZ[2][2][CC][0][i][j];
  lhsZ[1][3][CC][0][i][j] = lhsZ[1][3][CC][0][i][j] - coeff*lhsZ[2][3][CC][0][i][j];
  lhsZ[1][4][CC][0][i][j] = lhsZ[1][4][CC][0][i][j] - coeff*lhsZ[2][4][CC][0][i][j];
  rhs[1][0][j][i]   = rhs[1][0][j][i]   - coeff*rhs[2][0][j][i];

  coeff = lhsZ[3][2][BB][0][i][j];
  lhsZ[3][3][BB][0][i][j]= lhsZ[3][3][BB][0][i][j] - coeff*lhsZ[2][3][BB][0][i][j];
  lhsZ[3][4][BB][0][i][j]= lhsZ[3][4][BB][0][i][j] - coeff*lhsZ[2][4][BB][0][i][j];
  lhsZ[3][0][CC][0][i][j] = lhsZ[3][0][CC][0][i][j] - coeff*lhsZ[2][0][CC][0][i][j];
  lhsZ[3][1][CC][0][i][j] = lhsZ[3][1][CC][0][i][j] - coeff*lhsZ[2][1][CC][0][i][j];
  lhsZ[3][2][CC][0][i][j] = lhsZ[3][2][CC][0][i][j] - coeff*lhsZ[2][2][CC][0][i][j];
  lhsZ[3][3][CC][0][i][j] = lhsZ[3][3][CC][0][i][j] - coeff*lhsZ[2][3][CC][0][i][j];
  lhsZ[3][4][CC][0][i][j] = lhsZ[3][4][CC][0][i][j] - coeff*lhsZ[2][4][CC][0][i][j];
  rhs[3][0][j][i]   = rhs[3][0][j][i]   - coeff*rhs[2][0][j][i];

  coeff = lhsZ[4][2][BB][0][i][j];
  lhsZ[4][3][BB][0][i][j]= lhsZ[4][3][BB][0][i][j] - coeff*lhsZ[2][3][BB][0][i][j];
  lhsZ[4][4][BB][0][i][j]= lhsZ[4][4][BB][0][i][j] - coeff*lhsZ[2][4][BB][0][i][j];
  lhsZ[4][0][CC][0][i][j] = lhsZ[4][0][CC][0][i][j] - coeff*lhsZ[2][0][CC][0][i][j];
  lhsZ[4][1][CC][0][i][j] = lhsZ[4][1][CC][0][i][j] - coeff*lhsZ[2][1][CC][0][i][j];
  lhsZ[4][2][CC][0][i][j] = lhsZ[4][2][CC][0][i][j] - coeff*lhsZ[2][2][CC][0][i][j];
  lhsZ[4][3][CC][0][i][j] = lhsZ[4][3][CC][0][i][j] - coeff*lhsZ[2][3][CC][0][i][j];
  lhsZ[4][4][CC][0][i][j] = lhsZ[4][4][CC][0][i][j] - coeff*lhsZ[2][4][CC][0][i][j];
  rhs[4][0][j][i]   = rhs[4][0][j][i]   - coeff*rhs[2][0][j][i];


  pivot = 1.00/lhsZ[3][3][BB][0][i][j];
  lhsZ[3][4][BB][0][i][j] = lhsZ[3][4][BB][0][i][j]*pivot;
  lhsZ[3][0][CC][0][i][j] = lhsZ[3][0][CC][0][i][j]*pivot;
  lhsZ[3][1][CC][0][i][j] = lhsZ[3][1][CC][0][i][j]*pivot;
  lhsZ[3][2][CC][0][i][j] = lhsZ[3][2][CC][0][i][j]*pivot;
  lhsZ[3][3][CC][0][i][j] = lhsZ[3][3][CC][0][i][j]*pivot;
  lhsZ[3][4][CC][0][i][j] = lhsZ[3][4][CC][0][i][j]*pivot;
  rhs[3][0][j][i]   = rhs[3][0][j][i]  *pivot;

  coeff = lhsZ[0][3][BB][0][i][j];
  lhsZ[0][4][BB][0][i][j]= lhsZ[0][4][BB][0][i][j] - coeff*lhsZ[3][4][BB][0][i][j];
  lhsZ[0][0][CC][0][i][j] = lhsZ[0][0][CC][0][i][j] - coeff*lhsZ[3][0][CC][0][i][j];
  lhsZ[0][1][CC][0][i][j] = lhsZ[0][1][CC][0][i][j] - coeff*lhsZ[3][1][CC][0][i][j];
  lhsZ[0][2][CC][0][i][j] = lhsZ[0][2][CC][0][i][j] - coeff*lhsZ[3][2][CC][0][i][j];
  lhsZ[0][3][CC][0][i][j] = lhsZ[0][3][CC][0][i][j] - coeff*lhsZ[3][3][CC][0][i][j];
  lhsZ[0][4][CC][0][i][j] = lhsZ[0][4][CC][0][i][j] - coeff*lhsZ[3][4][CC][0][i][j];
  rhs[0][0][j][i]   = rhs[0][0][j][i]   - coeff*rhs[3][0][j][i];

  coeff = lhsZ[1][3][BB][0][i][j];
  lhsZ[1][4][BB][0][i][j]= lhsZ[1][4][BB][0][i][j] - coeff*lhsZ[3][4][BB][0][i][j];
  lhsZ[1][0][CC][0][i][j] = lhsZ[1][0][CC][0][i][j] - coeff*lhsZ[3][0][CC][0][i][j];
  lhsZ[1][1][CC][0][i][j] = lhsZ[1][1][CC][0][i][j] - coeff*lhsZ[3][1][CC][0][i][j];
  lhsZ[1][2][CC][0][i][j] = lhsZ[1][2][CC][0][i][j] - coeff*lhsZ[3][2][CC][0][i][j];
  lhsZ[1][3][CC][0][i][j] = lhsZ[1][3][CC][0][i][j] - coeff*lhsZ[3][3][CC][0][i][j];
  lhsZ[1][4][CC][0][i][j] = lhsZ[1][4][CC][0][i][j] - coeff*lhsZ[3][4][CC][0][i][j];
  rhs[1][0][j][i]   = rhs[1][0][j][i]   - coeff*rhs[3][0][j][i];

  coeff = lhsZ[2][3][BB][0][i][j];
  lhsZ[2][4][BB][0][i][j]= lhsZ[2][4][BB][0][i][j] - coeff*lhsZ[3][4][BB][0][i][j];
  lhsZ[2][0][CC][0][i][j] = lhsZ[2][0][CC][0][i][j] - coeff*lhsZ[3][0][CC][0][i][j];
  lhsZ[2][1][CC][0][i][j] = lhsZ[2][1][CC][0][i][j] - coeff*lhsZ[3][1][CC][0][i][j];
  lhsZ[2][2][CC][0][i][j] = lhsZ[2][2][CC][0][i][j] - coeff*lhsZ[3][2][CC][0][i][j];
  lhsZ[2][3][CC][0][i][j] = lhsZ[2][3][CC][0][i][j] - coeff*lhsZ[3][3][CC][0][i][j];
  lhsZ[2][4][CC][0][i][j] = lhsZ[2][4][CC][0][i][j] - coeff*lhsZ[3][4][CC][0][i][j];
  rhs[2][0][j][i]   = rhs[2][0][j][i]   - coeff*rhs[3][0][j][i];

  coeff = lhsZ[4][3][BB][0][i][j];
  lhsZ[4][4][BB][0][i][j]= lhsZ[4][4][BB][0][i][j] - coeff*lhsZ[3][4][BB][0][i][j];
  lhsZ[4][0][CC][0][i][j] = lhsZ[4][0][CC][0][i][j] - coeff*lhsZ[3][0][CC][0][i][j];
  lhsZ[4][1][CC][0][i][j] = lhsZ[4][1][CC][0][i][j] - coeff*lhsZ[3][1][CC][0][i][j];
  lhsZ[4][2][CC][0][i][j] = lhsZ[4][2][CC][0][i][j] - coeff*lhsZ[3][2][CC][0][i][j];
  lhsZ[4][3][CC][0][i][j] = lhsZ[4][3][CC][0][i][j] - coeff*lhsZ[3][3][CC][0][i][j];
  lhsZ[4][4][CC][0][i][j] = lhsZ[4][4][CC][0][i][j] - coeff*lhsZ[3][4][CC][0][i][j];
  rhs[4][0][j][i]   = rhs[4][0][j][i]   - coeff*rhs[3][0][j][i];


  pivot = 1.00/lhsZ[4][4][BB][0][i][j];
  lhsZ[4][0][CC][0][i][j] = lhsZ[4][0][CC][0][i][j]*pivot;
  lhsZ[4][1][CC][0][i][j] = lhsZ[4][1][CC][0][i][j]*pivot;
  lhsZ[4][2][CC][0][i][j] = lhsZ[4][2][CC][0][i][j]*pivot;
  lhsZ[4][3][CC][0][i][j] = lhsZ[4][3][CC][0][i][j]*pivot;
  lhsZ[4][4][CC][0][i][j] = lhsZ[4][4][CC][0][i][j]*pivot;
  rhs[4][0][j][i]   = rhs[4][0][j][i]  *pivot;

  coeff = lhsZ[0][4][BB][0][i][j];
  lhsZ[0][0][CC][0][i][j] = lhsZ[0][0][CC][0][i][j] - coeff*lhsZ[4][0][CC][0][i][j];
  lhsZ[0][1][CC][0][i][j] = lhsZ[0][1][CC][0][i][j] - coeff*lhsZ[4][1][CC][0][i][j];
  lhsZ[0][2][CC][0][i][j] = lhsZ[0][2][CC][0][i][j] - coeff*lhsZ[4][2][CC][0][i][j];
  lhsZ[0][3][CC][0][i][j] = lhsZ[0][3][CC][0][i][j] - coeff*lhsZ[4][3][CC][0][i][j];
  lhsZ[0][4][CC][0][i][j] = lhsZ[0][4][CC][0][i][j] - coeff*lhsZ[4][4][CC][0][i][j];
  rhs[0][0][j][i]   = rhs[0][0][j][i]   - coeff*rhs[4][0][j][i];

  coeff = lhsZ[1][4][BB][0][i][j];
  lhsZ[1][0][CC][0][i][j] = lhsZ[1][0][CC][0][i][j] - coeff*lhsZ[4][0][CC][0][i][j];
  lhsZ[1][1][CC][0][i][j] = lhsZ[1][1][CC][0][i][j] - coeff*lhsZ[4][1][CC][0][i][j];
  lhsZ[1][2][CC][0][i][j] = lhsZ[1][2][CC][0][i][j] - coeff*lhsZ[4][2][CC][0][i][j];
  lhsZ[1][3][CC][0][i][j] = lhsZ[1][3][CC][0][i][j] - coeff*lhsZ[4][3][CC][0][i][j];
  lhsZ[1][4][CC][0][i][j] = lhsZ[1][4][CC][0][i][j] - coeff*lhsZ[4][4][CC][0][i][j];
  rhs[1][0][j][i]   = rhs[1][0][j][i]   - coeff*rhs[4][0][j][i];

  coeff = lhsZ[2][4][BB][0][i][j];
  lhsZ[2][0][CC][0][i][j] = lhsZ[2][0][CC][0][i][j] - coeff*lhsZ[4][0][CC][0][i][j];
  lhsZ[2][1][CC][0][i][j] = lhsZ[2][1][CC][0][i][j] - coeff*lhsZ[4][1][CC][0][i][j];
  lhsZ[2][2][CC][0][i][j] = lhsZ[2][2][CC][0][i][j] - coeff*lhsZ[4][2][CC][0][i][j];
  lhsZ[2][3][CC][0][i][j] = lhsZ[2][3][CC][0][i][j] - coeff*lhsZ[4][3][CC][0][i][j];
  lhsZ[2][4][CC][0][i][j] = lhsZ[2][4][CC][0][i][j] - coeff*lhsZ[4][4][CC][0][i][j];
  rhs[2][0][j][i]   = rhs[2][0][j][i]   - coeff*rhs[4][0][j][i];

  coeff = lhsZ[3][4][BB][0][i][j];
  lhsZ[3][0][CC][0][i][j] = lhsZ[3][0][CC][0][i][j] - coeff*lhsZ[4][0][CC][0][i][j];
  lhsZ[3][1][CC][0][i][j] = lhsZ[3][1][CC][0][i][j] - coeff*lhsZ[4][1][CC][0][i][j];
  lhsZ[3][2][CC][0][i][j] = lhsZ[3][2][CC][0][i][j] - coeff*lhsZ[4][2][CC][0][i][j];
  lhsZ[3][3][CC][0][i][j] = lhsZ[3][3][CC][0][i][j] - coeff*lhsZ[4][3][CC][0][i][j];
  lhsZ[3][4][CC][0][i][j] = lhsZ[3][4][CC][0][i][j] - coeff*lhsZ[4][4][CC][0][i][j];
  rhs[3][0][j][i]   = rhs[3][0][j][i]   - coeff*rhs[4][0][j][i];

	}
  }
      //---------------------------------------------------------------------
      // begin inner most do loop
      // do all the elements of the cell unless last 
      //---------------------------------------------------------------------
    #pragma acc  parallel loop gang num_gangs(gp02) num_workers(4) vector_length(32) 
    for (i = 1; i <= gp02; i++) {
  #pragma acc loop worker vector
  for (j = 1; j <= gp12; j++) {
      for (k = 1; k <= ksize-1; k++) {
        //-------------------------------------------------------------------
        // subtract A*lhsZ[j][i]_vector(k-1) from lhsZ[j][i]_vector(k)
        // 
        // rhs(k) = rhs(k) - A*rhs(k-1)
        //-------------------------------------------------------------------
        //matvec_sub(lhsZ[i][j][AA], rhs[j][k-1][k][i], rhs[k][j][i]);
		/*
		for(m = 0; m < 5; m++){
			rhs[m][k][j][i] = rhs[m][k][j][i] - lhsZ[m][0][AA][k][i][j]*rhs[0][k-1][j][i]
											  - lhsZ[m][1][AA][k][i][j]*rhs[1][k-1][j][i]
											  - lhsZ[m][2][AA][k][i][j]*rhs[2][k-1][j][i]
											  - lhsZ[m][3][AA][k][i][j]*rhs[3][k-1][j][i]
											  - lhsZ[m][4][AA][k][i][j]*rhs[4][k-1][j][i];
		}
		*/
  rhs[0][k][j][i] = rhs[0][k][j][i] - lhsZ[0][0][AA][k][i][j]*rhs[0][k-1][j][i]
                    - lhsZ[0][1][AA][k][i][j]*rhs[1][k-1][j][i]
                    - lhsZ[0][2][AA][k][i][j]*rhs[2][k-1][j][i]
                    - lhsZ[0][3][AA][k][i][j]*rhs[3][k-1][j][i]
                    - lhsZ[0][4][AA][k][i][j]*rhs[4][k-1][j][i];
  rhs[1][k][j][i] = rhs[1][k][j][i] - lhsZ[1][0][AA][k][i][j]*rhs[0][k-1][j][i]
                    - lhsZ[1][1][AA][k][i][j]*rhs[1][k-1][j][i]
                    - lhsZ[1][2][AA][k][i][j]*rhs[2][k-1][j][i]
                    - lhsZ[1][3][AA][k][i][j]*rhs[3][k-1][j][i]
                    - lhsZ[1][4][AA][k][i][j]*rhs[4][k-1][j][i];
  rhs[2][k][j][i] = rhs[2][k][j][i] - lhsZ[2][0][AA][k][i][j]*rhs[0][k-1][j][i]
                    - lhsZ[2][1][AA][k][i][j]*rhs[1][k-1][j][i]
                    - lhsZ[2][2][AA][k][i][j]*rhs[2][k-1][j][i]
                    - lhsZ[2][3][AA][k][i][j]*rhs[3][k-1][j][i]
                    - lhsZ[2][4][AA][k][i][j]*rhs[4][k-1][j][i];
  rhs[3][k][j][i] = rhs[3][k][j][i] - lhsZ[3][0][AA][k][i][j]*rhs[0][k-1][j][i]
                    - lhsZ[3][1][AA][k][i][j]*rhs[1][k-1][j][i]
                    - lhsZ[3][2][AA][k][i][j]*rhs[2][k-1][j][i]
                    - lhsZ[3][3][AA][k][i][j]*rhs[3][k-1][j][i]
                    - lhsZ[3][4][AA][k][i][j]*rhs[4][k-1][j][i];
  rhs[4][k][j][i] = rhs[4][k][j][i] - lhsZ[4][0][AA][k][i][j]*rhs[0][k-1][j][i]
                    - lhsZ[4][1][AA][k][i][j]*rhs[1][k-1][j][i]
                    - lhsZ[4][2][AA][k][i][j]*rhs[2][k-1][j][i]
                    - lhsZ[4][3][AA][k][i][j]*rhs[3][k-1][j][i]
                    - lhsZ[4][4][AA][k][i][j]*rhs[4][k-1][j][i];



        //-------------------------------------------------------------------
        // B(k) = B(k) - C(k-1)*A(k)
        // matmul_sub(AA,i,j,k,c,CC,i,j,k-1,c,BB,i,j,k)
        //-------------------------------------------------------------------
        //matmul_sub(lhsZ[k-1][i][AA], lhsZ[j][k][i][j][CC], lhsZ[j][i][k][BB]);
		/*
	  for(m = 0; m < 5; m++){
	  	for(n = 0; n < 5; n++){
			lhsZ[n][m][BB][k][i][j] = lhsZ[n][m][BB][k][i][j] - lhsZ[n][0][AA][k][i][j]*lhsZ[0][m][CC][k-1][i][j]
												- lhsZ[n][1][AA][k][i][j]*lhsZ[1][m][CC][k-1][i][j]
												- lhsZ[n][2][AA][k][i][j]*lhsZ[2][m][CC][k-1][i][j]
												- lhsZ[n][3][AA][k][i][j]*lhsZ[3][m][CC][k-1][i][j]
												- lhsZ[n][4][AA][k][i][j]*lhsZ[4][m][CC][k-1][i][j];
		}
	  }
	  */
  lhsZ[0][0][BB][k][i][j] = lhsZ[0][0][BB][k][i][j] - lhsZ[0][0][AA][k][i][j]*lhsZ[0][0][CC][k-1][i][j]
                              - lhsZ[0][1][AA][k][i][j]*lhsZ[1][0][CC][k-1][i][j]
                              - lhsZ[0][2][AA][k][i][j]*lhsZ[2][0][CC][k-1][i][j]
                              - lhsZ[0][3][AA][k][i][j]*lhsZ[3][0][CC][k-1][i][j]
                              - lhsZ[0][4][AA][k][i][j]*lhsZ[4][0][CC][k-1][i][j];
  lhsZ[1][0][BB][k][i][j] = lhsZ[1][0][BB][k][i][j] - lhsZ[1][0][AA][k][i][j]*lhsZ[0][0][CC][k-1][i][j]
                              - lhsZ[1][1][AA][k][i][j]*lhsZ[1][0][CC][k-1][i][j]
                              - lhsZ[1][2][AA][k][i][j]*lhsZ[2][0][CC][k-1][i][j]
                              - lhsZ[1][3][AA][k][i][j]*lhsZ[3][0][CC][k-1][i][j]
                              - lhsZ[1][4][AA][k][i][j]*lhsZ[4][0][CC][k-1][i][j];
  lhsZ[2][0][BB][k][i][j] = lhsZ[2][0][BB][k][i][j] - lhsZ[2][0][AA][k][i][j]*lhsZ[0][0][CC][k-1][i][j]
                              - lhsZ[2][1][AA][k][i][j]*lhsZ[1][0][CC][k-1][i][j]
                              - lhsZ[2][2][AA][k][i][j]*lhsZ[2][0][CC][k-1][i][j]
                              - lhsZ[2][3][AA][k][i][j]*lhsZ[3][0][CC][k-1][i][j]
                              - lhsZ[2][4][AA][k][i][j]*lhsZ[4][0][CC][k-1][i][j];
  lhsZ[3][0][BB][k][i][j] = lhsZ[3][0][BB][k][i][j] - lhsZ[3][0][AA][k][i][j]*lhsZ[0][0][CC][k-1][i][j]
                              - lhsZ[3][1][AA][k][i][j]*lhsZ[1][0][CC][k-1][i][j]
                              - lhsZ[3][2][AA][k][i][j]*lhsZ[2][0][CC][k-1][i][j]
                              - lhsZ[3][3][AA][k][i][j]*lhsZ[3][0][CC][k-1][i][j]
                              - lhsZ[3][4][AA][k][i][j]*lhsZ[4][0][CC][k-1][i][j];
  lhsZ[4][0][BB][k][i][j] = lhsZ[4][0][BB][k][i][j] - lhsZ[4][0][AA][k][i][j]*lhsZ[0][0][CC][k-1][i][j]
                              - lhsZ[4][1][AA][k][i][j]*lhsZ[1][0][CC][k-1][i][j]
                              - lhsZ[4][2][AA][k][i][j]*lhsZ[2][0][CC][k-1][i][j]
                              - lhsZ[4][3][AA][k][i][j]*lhsZ[3][0][CC][k-1][i][j]
                              - lhsZ[4][4][AA][k][i][j]*lhsZ[4][0][CC][k-1][i][j];
  lhsZ[0][1][BB][k][i][j] = lhsZ[0][1][BB][k][i][j] - lhsZ[0][0][AA][k][i][j]*lhsZ[0][1][CC][k-1][i][j]
                              - lhsZ[0][1][AA][k][i][j]*lhsZ[1][1][CC][k-1][i][j]
                              - lhsZ[0][2][AA][k][i][j]*lhsZ[2][1][CC][k-1][i][j]
                              - lhsZ[0][3][AA][k][i][j]*lhsZ[3][1][CC][k-1][i][j]
                              - lhsZ[0][4][AA][k][i][j]*lhsZ[4][1][CC][k-1][i][j];
  lhsZ[1][1][BB][k][i][j] = lhsZ[1][1][BB][k][i][j] - lhsZ[1][0][AA][k][i][j]*lhsZ[0][1][CC][k-1][i][j]
                              - lhsZ[1][1][AA][k][i][j]*lhsZ[1][1][CC][k-1][i][j]
                              - lhsZ[1][2][AA][k][i][j]*lhsZ[2][1][CC][k-1][i][j]
                              - lhsZ[1][3][AA][k][i][j]*lhsZ[3][1][CC][k-1][i][j]
                              - lhsZ[1][4][AA][k][i][j]*lhsZ[4][1][CC][k-1][i][j];
  lhsZ[2][1][BB][k][i][j] = lhsZ[2][1][BB][k][i][j] - lhsZ[2][0][AA][k][i][j]*lhsZ[0][1][CC][k-1][i][j]
                              - lhsZ[2][1][AA][k][i][j]*lhsZ[1][1][CC][k-1][i][j]
                              - lhsZ[2][2][AA][k][i][j]*lhsZ[2][1][CC][k-1][i][j]
                              - lhsZ[2][3][AA][k][i][j]*lhsZ[3][1][CC][k-1][i][j]
                              - lhsZ[2][4][AA][k][i][j]*lhsZ[4][1][CC][k-1][i][j];
  lhsZ[3][1][BB][k][i][j] = lhsZ[3][1][BB][k][i][j] - lhsZ[3][0][AA][k][i][j]*lhsZ[0][1][CC][k-1][i][j]
                              - lhsZ[3][1][AA][k][i][j]*lhsZ[1][1][CC][k-1][i][j]
                              - lhsZ[3][2][AA][k][i][j]*lhsZ[2][1][CC][k-1][i][j]
                              - lhsZ[3][3][AA][k][i][j]*lhsZ[3][1][CC][k-1][i][j]
                              - lhsZ[3][4][AA][k][i][j]*lhsZ[4][1][CC][k-1][i][j];
  lhsZ[4][1][BB][k][i][j] = lhsZ[4][1][BB][k][i][j] - lhsZ[4][0][AA][k][i][j]*lhsZ[0][1][CC][k-1][i][j]
                              - lhsZ[4][1][AA][k][i][j]*lhsZ[1][1][CC][k-1][i][j]
                              - lhsZ[4][2][AA][k][i][j]*lhsZ[2][1][CC][k-1][i][j]
                              - lhsZ[4][3][AA][k][i][j]*lhsZ[3][1][CC][k-1][i][j]
                              - lhsZ[4][4][AA][k][i][j]*lhsZ[4][1][CC][k-1][i][j];
  lhsZ[0][2][BB][k][i][j] = lhsZ[0][2][BB][k][i][j] - lhsZ[0][0][AA][k][i][j]*lhsZ[0][2][CC][k-1][i][j]
                              - lhsZ[0][1][AA][k][i][j]*lhsZ[1][2][CC][k-1][i][j]
                              - lhsZ[0][2][AA][k][i][j]*lhsZ[2][2][CC][k-1][i][j]
                              - lhsZ[0][3][AA][k][i][j]*lhsZ[3][2][CC][k-1][i][j]
                              - lhsZ[0][4][AA][k][i][j]*lhsZ[4][2][CC][k-1][i][j];
  lhsZ[1][2][BB][k][i][j] = lhsZ[1][2][BB][k][i][j] - lhsZ[1][0][AA][k][i][j]*lhsZ[0][2][CC][k-1][i][j]
                              - lhsZ[1][1][AA][k][i][j]*lhsZ[1][2][CC][k-1][i][j]
                              - lhsZ[1][2][AA][k][i][j]*lhsZ[2][2][CC][k-1][i][j]
                              - lhsZ[1][3][AA][k][i][j]*lhsZ[3][2][CC][k-1][i][j]
                              - lhsZ[1][4][AA][k][i][j]*lhsZ[4][2][CC][k-1][i][j];
  lhsZ[2][2][BB][k][i][j] = lhsZ[2][2][BB][k][i][j] - lhsZ[2][0][AA][k][i][j]*lhsZ[0][2][CC][k-1][i][j]
                              - lhsZ[2][1][AA][k][i][j]*lhsZ[1][2][CC][k-1][i][j]
                              - lhsZ[2][2][AA][k][i][j]*lhsZ[2][2][CC][k-1][i][j]
                              - lhsZ[2][3][AA][k][i][j]*lhsZ[3][2][CC][k-1][i][j]
                              - lhsZ[2][4][AA][k][i][j]*lhsZ[4][2][CC][k-1][i][j];
  lhsZ[3][2][BB][k][i][j] = lhsZ[3][2][BB][k][i][j] - lhsZ[3][0][AA][k][i][j]*lhsZ[0][2][CC][k-1][i][j]
                              - lhsZ[3][1][AA][k][i][j]*lhsZ[1][2][CC][k-1][i][j]
                              - lhsZ[3][2][AA][k][i][j]*lhsZ[2][2][CC][k-1][i][j]
                              - lhsZ[3][3][AA][k][i][j]*lhsZ[3][2][CC][k-1][i][j]
                              - lhsZ[3][4][AA][k][i][j]*lhsZ[4][2][CC][k-1][i][j];
  lhsZ[4][2][BB][k][i][j] = lhsZ[4][2][BB][k][i][j] - lhsZ[4][0][AA][k][i][j]*lhsZ[0][2][CC][k-1][i][j]
                              - lhsZ[4][1][AA][k][i][j]*lhsZ[1][2][CC][k-1][i][j]
                              - lhsZ[4][2][AA][k][i][j]*lhsZ[2][2][CC][k-1][i][j]
                              - lhsZ[4][3][AA][k][i][j]*lhsZ[3][2][CC][k-1][i][j]
                              - lhsZ[4][4][AA][k][i][j]*lhsZ[4][2][CC][k-1][i][j];
  lhsZ[0][3][BB][k][i][j] = lhsZ[0][3][BB][k][i][j] - lhsZ[0][0][AA][k][i][j]*lhsZ[0][3][CC][k-1][i][j]
                              - lhsZ[0][1][AA][k][i][j]*lhsZ[1][3][CC][k-1][i][j]
                              - lhsZ[0][2][AA][k][i][j]*lhsZ[2][3][CC][k-1][i][j]
                              - lhsZ[0][3][AA][k][i][j]*lhsZ[3][3][CC][k-1][i][j]
                              - lhsZ[0][4][AA][k][i][j]*lhsZ[4][3][CC][k-1][i][j];
  lhsZ[1][3][BB][k][i][j] = lhsZ[1][3][BB][k][i][j] - lhsZ[1][0][AA][k][i][j]*lhsZ[0][3][CC][k-1][i][j]
                              - lhsZ[1][1][AA][k][i][j]*lhsZ[1][3][CC][k-1][i][j]
                              - lhsZ[1][2][AA][k][i][j]*lhsZ[2][3][CC][k-1][i][j]
                              - lhsZ[1][3][AA][k][i][j]*lhsZ[3][3][CC][k-1][i][j]
                              - lhsZ[1][4][AA][k][i][j]*lhsZ[4][3][CC][k-1][i][j];
  lhsZ[2][3][BB][k][i][j] = lhsZ[2][3][BB][k][i][j] - lhsZ[2][0][AA][k][i][j]*lhsZ[0][3][CC][k-1][i][j]
                              - lhsZ[2][1][AA][k][i][j]*lhsZ[1][3][CC][k-1][i][j]
                              - lhsZ[2][2][AA][k][i][j]*lhsZ[2][3][CC][k-1][i][j]
                              - lhsZ[2][3][AA][k][i][j]*lhsZ[3][3][CC][k-1][i][j]
                              - lhsZ[2][4][AA][k][i][j]*lhsZ[4][3][CC][k-1][i][j];
  lhsZ[3][3][BB][k][i][j] = lhsZ[3][3][BB][k][i][j] - lhsZ[3][0][AA][k][i][j]*lhsZ[0][3][CC][k-1][i][j]
                              - lhsZ[3][1][AA][k][i][j]*lhsZ[1][3][CC][k-1][i][j]
                              - lhsZ[3][2][AA][k][i][j]*lhsZ[2][3][CC][k-1][i][j]
                              - lhsZ[3][3][AA][k][i][j]*lhsZ[3][3][CC][k-1][i][j]
                              - lhsZ[3][4][AA][k][i][j]*lhsZ[4][3][CC][k-1][i][j];
  lhsZ[4][3][BB][k][i][j] = lhsZ[4][3][BB][k][i][j] - lhsZ[4][0][AA][k][i][j]*lhsZ[0][3][CC][k-1][i][j]
                              - lhsZ[4][1][AA][k][i][j]*lhsZ[1][3][CC][k-1][i][j]
                              - lhsZ[4][2][AA][k][i][j]*lhsZ[2][3][CC][k-1][i][j]
                              - lhsZ[4][3][AA][k][i][j]*lhsZ[3][3][CC][k-1][i][j]
                              - lhsZ[4][4][AA][k][i][j]*lhsZ[4][3][CC][k-1][i][j];
  lhsZ[0][4][BB][k][i][j] = lhsZ[0][4][BB][k][i][j] - lhsZ[0][0][AA][k][i][j]*lhsZ[0][4][CC][k-1][i][j]
                              - lhsZ[0][1][AA][k][i][j]*lhsZ[1][4][CC][k-1][i][j]
                              - lhsZ[0][2][AA][k][i][j]*lhsZ[2][4][CC][k-1][i][j]
                              - lhsZ[0][3][AA][k][i][j]*lhsZ[3][4][CC][k-1][i][j]
                              - lhsZ[0][4][AA][k][i][j]*lhsZ[4][4][CC][k-1][i][j];
  lhsZ[1][4][BB][k][i][j] = lhsZ[1][4][BB][k][i][j] - lhsZ[1][0][AA][k][i][j]*lhsZ[0][4][CC][k-1][i][j]
                              - lhsZ[1][1][AA][k][i][j]*lhsZ[1][4][CC][k-1][i][j]
                              - lhsZ[1][2][AA][k][i][j]*lhsZ[2][4][CC][k-1][i][j]
                              - lhsZ[1][3][AA][k][i][j]*lhsZ[3][4][CC][k-1][i][j]
                              - lhsZ[1][4][AA][k][i][j]*lhsZ[4][4][CC][k-1][i][j];
  lhsZ[2][4][BB][k][i][j] = lhsZ[2][4][BB][k][i][j] - lhsZ[2][0][AA][k][i][j]*lhsZ[0][4][CC][k-1][i][j]
                              - lhsZ[2][1][AA][k][i][j]*lhsZ[1][4][CC][k-1][i][j]
                              - lhsZ[2][2][AA][k][i][j]*lhsZ[2][4][CC][k-1][i][j]
                              - lhsZ[2][3][AA][k][i][j]*lhsZ[3][4][CC][k-1][i][j]
                              - lhsZ[2][4][AA][k][i][j]*lhsZ[4][4][CC][k-1][i][j];
  lhsZ[3][4][BB][k][i][j] = lhsZ[3][4][BB][k][i][j] - lhsZ[3][0][AA][k][i][j]*lhsZ[0][4][CC][k-1][i][j]
                              - lhsZ[3][1][AA][k][i][j]*lhsZ[1][4][CC][k-1][i][j]
                              - lhsZ[3][2][AA][k][i][j]*lhsZ[2][4][CC][k-1][i][j]
                              - lhsZ[3][3][AA][k][i][j]*lhsZ[3][4][CC][k-1][i][j]
                              - lhsZ[3][4][AA][k][i][j]*lhsZ[4][4][CC][k-1][i][j];
  lhsZ[4][4][BB][k][i][j] = lhsZ[4][4][BB][k][i][j] - lhsZ[4][0][AA][k][i][j]*lhsZ[0][4][CC][k-1][i][j]
                              - lhsZ[4][1][AA][k][i][j]*lhsZ[1][4][CC][k-1][i][j]
                              - lhsZ[4][2][AA][k][i][j]*lhsZ[2][4][CC][k-1][i][j]
                              - lhsZ[4][3][AA][k][i][j]*lhsZ[3][4][CC][k-1][i][j]
                              - lhsZ[4][4][AA][k][i][j]*lhsZ[4][4][CC][k-1][i][j];

        //-------------------------------------------------------------------
        // multiply c[k][j][i] by b_inverse and copy back to c
        // multiply rhs[j][0][j][i] by b_inverse[0][i] and copy to rhs        //-------------------------------------------------------------------
        //binvcrhs( lhsZ[k][i][BB], lhsZ[j][k][i][j][CC], rhs[k][j][i] );
		/*
	  	for(m = 0; m < 5; m++){
	  		pivot = 1.00/lhsZ[m][m][BB][k][i][j];
			for(n = m+1; n < 5; n++){
				lhsZ[m][n][BB][k][i][j] = lhsZ[m][n][BB][k][i][j]*pivot;
			}
			lhsZ[m][0][CC][k][i][j] = lhsZ[m][0][CC][k][i][j]*pivot;
			lhsZ[m][1][CC][k][i][j] = lhsZ[m][1][CC][k][i][j]*pivot;
			lhsZ[m][2][CC][k][i][j] = lhsZ[m][2][CC][k][i][j]*pivot;
			lhsZ[m][3][CC][k][i][j] = lhsZ[m][3][CC][k][i][j]*pivot;
			lhsZ[m][4][CC][k][i][j] = lhsZ[m][4][CC][k][i][j]*pivot;
			rhs[m][k][j][i] = rhs[m][k][j][i]*pivot;

			for(n = 0; n < 5; n++){
				if(n != m){
					coeff = lhsZ[n][m][BB][k][i][j];
					for(z = m+1; z < 5; z++){
						lhsZ[n][z][BB][k][i][j] = lhsZ[n][z][BB][k][i][j] - coeff*lhsZ[m][z][BB][k][i][j];
					}
					lhsZ[n][0][CC][k][i][j] = lhsZ[n][0][CC][k][i][j] - coeff*lhsZ[m][0][CC][k][i][j];
					lhsZ[n][1][CC][k][i][j] = lhsZ[n][1][CC][k][i][j] - coeff*lhsZ[m][1][CC][k][i][j];
					lhsZ[n][2][CC][k][i][j] = lhsZ[n][2][CC][k][i][j] - coeff*lhsZ[m][2][CC][k][i][j];
					lhsZ[n][3][CC][k][i][j] = lhsZ[n][3][CC][k][i][j] - coeff*lhsZ[m][3][CC][k][i][j];
					lhsZ[n][4][CC][k][i][j] = lhsZ[n][4][CC][k][i][j] - coeff*lhsZ[m][4][CC][k][i][j];
					rhs[n][k][j][i] = rhs[n][k][j][i] - coeff*rhs[m][k][j][i];
				}
			}
	  	}
		*/
  pivot = 1.00/lhsZ[0][0][BB][k][i][j];
  lhsZ[0][1][BB][k][i][j] = lhsZ[0][1][BB][k][i][j]*pivot;
  lhsZ[0][2][BB][k][i][j] = lhsZ[0][2][BB][k][i][j]*pivot;
  lhsZ[0][3][BB][k][i][j] = lhsZ[0][3][BB][k][i][j]*pivot;
  lhsZ[0][4][BB][k][i][j] = lhsZ[0][4][BB][k][i][j]*pivot;
  lhsZ[0][0][CC][k][i][j] = lhsZ[0][0][CC][k][i][j]*pivot;
  lhsZ[0][1][CC][k][i][j] = lhsZ[0][1][CC][k][i][j]*pivot;
  lhsZ[0][2][CC][k][i][j] = lhsZ[0][2][CC][k][i][j]*pivot;
  lhsZ[0][3][CC][k][i][j] = lhsZ[0][3][CC][k][i][j]*pivot;
  lhsZ[0][4][CC][k][i][j] = lhsZ[0][4][CC][k][i][j]*pivot;
  rhs[0][k][j][i]   = rhs[0][k][j][i]  *pivot;

  coeff = lhsZ[1][0][BB][k][i][j];
  lhsZ[1][1][BB][k][i][j]= lhsZ[1][1][BB][k][i][j] - coeff*lhsZ[0][1][BB][k][i][j];
  lhsZ[1][2][BB][k][i][j]= lhsZ[1][2][BB][k][i][j] - coeff*lhsZ[0][2][BB][k][i][j];
  lhsZ[1][3][BB][k][i][j]= lhsZ[1][3][BB][k][i][j] - coeff*lhsZ[0][3][BB][k][i][j];
  lhsZ[1][4][BB][k][i][j]= lhsZ[1][4][BB][k][i][j] - coeff*lhsZ[0][4][BB][k][i][j];
  lhsZ[1][0][CC][k][i][j] = lhsZ[1][0][CC][k][i][j] - coeff*lhsZ[0][0][CC][k][i][j];
  lhsZ[1][1][CC][k][i][j] = lhsZ[1][1][CC][k][i][j] - coeff*lhsZ[0][1][CC][k][i][j];
  lhsZ[1][2][CC][k][i][j] = lhsZ[1][2][CC][k][i][j] - coeff*lhsZ[0][2][CC][k][i][j];
  lhsZ[1][3][CC][k][i][j] = lhsZ[1][3][CC][k][i][j] - coeff*lhsZ[0][3][CC][k][i][j];
  lhsZ[1][4][CC][k][i][j] = lhsZ[1][4][CC][k][i][j] - coeff*lhsZ[0][4][CC][k][i][j];
  rhs[1][k][j][i]   = rhs[1][k][j][i]   - coeff*rhs[0][k][j][i];

  coeff = lhsZ[2][0][BB][k][i][j];
  lhsZ[2][1][BB][k][i][j]= lhsZ[2][1][BB][k][i][j] - coeff*lhsZ[0][1][BB][k][i][j];
  lhsZ[2][2][BB][k][i][j]= lhsZ[2][2][BB][k][i][j] - coeff*lhsZ[0][2][BB][k][i][j];
  lhsZ[2][3][BB][k][i][j]= lhsZ[2][3][BB][k][i][j] - coeff*lhsZ[0][3][BB][k][i][j];
  lhsZ[2][4][BB][k][i][j]= lhsZ[2][4][BB][k][i][j] - coeff*lhsZ[0][4][BB][k][i][j];
  lhsZ[2][0][CC][k][i][j] = lhsZ[2][0][CC][k][i][j] - coeff*lhsZ[0][0][CC][k][i][j];
  lhsZ[2][1][CC][k][i][j] = lhsZ[2][1][CC][k][i][j] - coeff*lhsZ[0][1][CC][k][i][j];
  lhsZ[2][2][CC][k][i][j] = lhsZ[2][2][CC][k][i][j] - coeff*lhsZ[0][2][CC][k][i][j];
  lhsZ[2][3][CC][k][i][j] = lhsZ[2][3][CC][k][i][j] - coeff*lhsZ[0][3][CC][k][i][j];
  lhsZ[2][4][CC][k][i][j] = lhsZ[2][4][CC][k][i][j] - coeff*lhsZ[0][4][CC][k][i][j];
  rhs[2][k][j][i]   = rhs[2][k][j][i]   - coeff*rhs[0][k][j][i];

  coeff = lhsZ[3][0][BB][k][i][j];
  lhsZ[3][1][BB][k][i][j]= lhsZ[3][1][BB][k][i][j] - coeff*lhsZ[0][1][BB][k][i][j];
  lhsZ[3][2][BB][k][i][j]= lhsZ[3][2][BB][k][i][j] - coeff*lhsZ[0][2][BB][k][i][j];
  lhsZ[3][3][BB][k][i][j]= lhsZ[3][3][BB][k][i][j] - coeff*lhsZ[0][3][BB][k][i][j];
  lhsZ[3][4][BB][k][i][j]= lhsZ[3][4][BB][k][i][j] - coeff*lhsZ[0][4][BB][k][i][j];
  lhsZ[3][0][CC][k][i][j] = lhsZ[3][0][CC][k][i][j] - coeff*lhsZ[0][0][CC][k][i][j];
  lhsZ[3][1][CC][k][i][j] = lhsZ[3][1][CC][k][i][j] - coeff*lhsZ[0][1][CC][k][i][j];
  lhsZ[3][2][CC][k][i][j] = lhsZ[3][2][CC][k][i][j] - coeff*lhsZ[0][2][CC][k][i][j];
  lhsZ[3][3][CC][k][i][j] = lhsZ[3][3][CC][k][i][j] - coeff*lhsZ[0][3][CC][k][i][j];
  lhsZ[3][4][CC][k][i][j] = lhsZ[3][4][CC][k][i][j] - coeff*lhsZ[0][4][CC][k][i][j];
  rhs[3][k][j][i]   = rhs[3][k][j][i]   - coeff*rhs[0][k][j][i];

  coeff = lhsZ[4][0][BB][k][i][j];
  lhsZ[4][1][BB][k][i][j]= lhsZ[4][1][BB][k][i][j] - coeff*lhsZ[0][1][BB][k][i][j];
  lhsZ[4][2][BB][k][i][j]= lhsZ[4][2][BB][k][i][j] - coeff*lhsZ[0][2][BB][k][i][j];
  lhsZ[4][3][BB][k][i][j]= lhsZ[4][3][BB][k][i][j] - coeff*lhsZ[0][3][BB][k][i][j];
  lhsZ[4][4][BB][k][i][j]= lhsZ[4][4][BB][k][i][j] - coeff*lhsZ[0][4][BB][k][i][j];
  lhsZ[4][0][CC][k][i][j] = lhsZ[4][0][CC][k][i][j] - coeff*lhsZ[0][0][CC][k][i][j];
  lhsZ[4][1][CC][k][i][j] = lhsZ[4][1][CC][k][i][j] - coeff*lhsZ[0][1][CC][k][i][j];
  lhsZ[4][2][CC][k][i][j] = lhsZ[4][2][CC][k][i][j] - coeff*lhsZ[0][2][CC][k][i][j];
  lhsZ[4][3][CC][k][i][j] = lhsZ[4][3][CC][k][i][j] - coeff*lhsZ[0][3][CC][k][i][j];
  lhsZ[4][4][CC][k][i][j] = lhsZ[4][4][CC][k][i][j] - coeff*lhsZ[0][4][CC][k][i][j];
  rhs[4][k][j][i]   = rhs[4][k][j][i]   - coeff*rhs[0][k][j][i];


  pivot = 1.00/lhsZ[1][1][BB][k][i][j];
  lhsZ[1][2][BB][k][i][j] = lhsZ[1][2][BB][k][i][j]*pivot;
  lhsZ[1][3][BB][k][i][j] = lhsZ[1][3][BB][k][i][j]*pivot;
  lhsZ[1][4][BB][k][i][j] = lhsZ[1][4][BB][k][i][j]*pivot;
  lhsZ[1][0][CC][k][i][j] = lhsZ[1][0][CC][k][i][j]*pivot;
  lhsZ[1][1][CC][k][i][j] = lhsZ[1][1][CC][k][i][j]*pivot;
  lhsZ[1][2][CC][k][i][j] = lhsZ[1][2][CC][k][i][j]*pivot;
  lhsZ[1][3][CC][k][i][j] = lhsZ[1][3][CC][k][i][j]*pivot;
  lhsZ[1][4][CC][k][i][j] = lhsZ[1][4][CC][k][i][j]*pivot;
  rhs[1][k][j][i]   = rhs[1][k][j][i]  *pivot;

  coeff = lhsZ[0][1][BB][k][i][j];
  lhsZ[0][2][BB][k][i][j]= lhsZ[0][2][BB][k][i][j] - coeff*lhsZ[1][2][BB][k][i][j];
  lhsZ[0][3][BB][k][i][j]= lhsZ[0][3][BB][k][i][j] - coeff*lhsZ[1][3][BB][k][i][j];
  lhsZ[0][4][BB][k][i][j]= lhsZ[0][4][BB][k][i][j] - coeff*lhsZ[1][4][BB][k][i][j];
  lhsZ[0][0][CC][k][i][j] = lhsZ[0][0][CC][k][i][j] - coeff*lhsZ[1][0][CC][k][i][j];
  lhsZ[0][1][CC][k][i][j] = lhsZ[0][1][CC][k][i][j] - coeff*lhsZ[1][1][CC][k][i][j];
  lhsZ[0][2][CC][k][i][j] = lhsZ[0][2][CC][k][i][j] - coeff*lhsZ[1][2][CC][k][i][j];
  lhsZ[0][3][CC][k][i][j] = lhsZ[0][3][CC][k][i][j] - coeff*lhsZ[1][3][CC][k][i][j];
  lhsZ[0][4][CC][k][i][j] = lhsZ[0][4][CC][k][i][j] - coeff*lhsZ[1][4][CC][k][i][j];
  rhs[0][k][j][i]   = rhs[0][k][j][i]   - coeff*rhs[1][k][j][i];

  coeff = lhsZ[2][1][BB][k][i][j];
  lhsZ[2][2][BB][k][i][j]= lhsZ[2][2][BB][k][i][j] - coeff*lhsZ[1][2][BB][k][i][j];
  lhsZ[2][3][BB][k][i][j]= lhsZ[2][3][BB][k][i][j] - coeff*lhsZ[1][3][BB][k][i][j];
  lhsZ[2][4][BB][k][i][j]= lhsZ[2][4][BB][k][i][j] - coeff*lhsZ[1][4][BB][k][i][j];
  lhsZ[2][0][CC][k][i][j] = lhsZ[2][0][CC][k][i][j] - coeff*lhsZ[1][0][CC][k][i][j];
  lhsZ[2][1][CC][k][i][j] = lhsZ[2][1][CC][k][i][j] - coeff*lhsZ[1][1][CC][k][i][j];
  lhsZ[2][2][CC][k][i][j] = lhsZ[2][2][CC][k][i][j] - coeff*lhsZ[1][2][CC][k][i][j];
  lhsZ[2][3][CC][k][i][j] = lhsZ[2][3][CC][k][i][j] - coeff*lhsZ[1][3][CC][k][i][j];
  lhsZ[2][4][CC][k][i][j] = lhsZ[2][4][CC][k][i][j] - coeff*lhsZ[1][4][CC][k][i][j];
  rhs[2][k][j][i]   = rhs[2][k][j][i]   - coeff*rhs[1][k][j][i];

  coeff = lhsZ[3][1][BB][k][i][j];
  lhsZ[3][2][BB][k][i][j]= lhsZ[3][2][BB][k][i][j] - coeff*lhsZ[1][2][BB][k][i][j];
  lhsZ[3][3][BB][k][i][j]= lhsZ[3][3][BB][k][i][j] - coeff*lhsZ[1][3][BB][k][i][j];
  lhsZ[3][4][BB][k][i][j]= lhsZ[3][4][BB][k][i][j] - coeff*lhsZ[1][4][BB][k][i][j];
  lhsZ[3][0][CC][k][i][j] = lhsZ[3][0][CC][k][i][j] - coeff*lhsZ[1][0][CC][k][i][j];
  lhsZ[3][1][CC][k][i][j] = lhsZ[3][1][CC][k][i][j] - coeff*lhsZ[1][1][CC][k][i][j];
  lhsZ[3][2][CC][k][i][j] = lhsZ[3][2][CC][k][i][j] - coeff*lhsZ[1][2][CC][k][i][j];
  lhsZ[3][3][CC][k][i][j] = lhsZ[3][3][CC][k][i][j] - coeff*lhsZ[1][3][CC][k][i][j];
  lhsZ[3][4][CC][k][i][j] = lhsZ[3][4][CC][k][i][j] - coeff*lhsZ[1][4][CC][k][i][j];
  rhs[3][k][j][i]   = rhs[3][k][j][i]   - coeff*rhs[1][k][j][i];

  coeff = lhsZ[4][1][BB][k][i][j];
  lhsZ[4][2][BB][k][i][j]= lhsZ[4][2][BB][k][i][j] - coeff*lhsZ[1][2][BB][k][i][j];
  lhsZ[4][3][BB][k][i][j]= lhsZ[4][3][BB][k][i][j] - coeff*lhsZ[1][3][BB][k][i][j];
  lhsZ[4][4][BB][k][i][j]= lhsZ[4][4][BB][k][i][j] - coeff*lhsZ[1][4][BB][k][i][j];
  lhsZ[4][0][CC][k][i][j] = lhsZ[4][0][CC][k][i][j] - coeff*lhsZ[1][0][CC][k][i][j];
  lhsZ[4][1][CC][k][i][j] = lhsZ[4][1][CC][k][i][j] - coeff*lhsZ[1][1][CC][k][i][j];
  lhsZ[4][2][CC][k][i][j] = lhsZ[4][2][CC][k][i][j] - coeff*lhsZ[1][2][CC][k][i][j];
  lhsZ[4][3][CC][k][i][j] = lhsZ[4][3][CC][k][i][j] - coeff*lhsZ[1][3][CC][k][i][j];
  lhsZ[4][4][CC][k][i][j] = lhsZ[4][4][CC][k][i][j] - coeff*lhsZ[1][4][CC][k][i][j];
  rhs[4][k][j][i]   = rhs[4][k][j][i]   - coeff*rhs[1][k][j][i];


  pivot = 1.00/lhsZ[2][2][BB][k][i][j];
  lhsZ[2][3][BB][k][i][j] = lhsZ[2][3][BB][k][i][j]*pivot;
  lhsZ[2][4][BB][k][i][j] = lhsZ[2][4][BB][k][i][j]*pivot;
  lhsZ[2][0][CC][k][i][j] = lhsZ[2][0][CC][k][i][j]*pivot;
  lhsZ[2][1][CC][k][i][j] = lhsZ[2][1][CC][k][i][j]*pivot;
  lhsZ[2][2][CC][k][i][j] = lhsZ[2][2][CC][k][i][j]*pivot;
  lhsZ[2][3][CC][k][i][j] = lhsZ[2][3][CC][k][i][j]*pivot;
  lhsZ[2][4][CC][k][i][j] = lhsZ[2][4][CC][k][i][j]*pivot;
  rhs[2][k][j][i]   = rhs[2][k][j][i]  *pivot;

  coeff = lhsZ[0][2][BB][k][i][j];
  lhsZ[0][3][BB][k][i][j]= lhsZ[0][3][BB][k][i][j] - coeff*lhsZ[2][3][BB][k][i][j];
  lhsZ[0][4][BB][k][i][j]= lhsZ[0][4][BB][k][i][j] - coeff*lhsZ[2][4][BB][k][i][j];
  lhsZ[0][0][CC][k][i][j] = lhsZ[0][0][CC][k][i][j] - coeff*lhsZ[2][0][CC][k][i][j];
  lhsZ[0][1][CC][k][i][j] = lhsZ[0][1][CC][k][i][j] - coeff*lhsZ[2][1][CC][k][i][j];
  lhsZ[0][2][CC][k][i][j] = lhsZ[0][2][CC][k][i][j] - coeff*lhsZ[2][2][CC][k][i][j];
  lhsZ[0][3][CC][k][i][j] = lhsZ[0][3][CC][k][i][j] - coeff*lhsZ[2][3][CC][k][i][j];
  lhsZ[0][4][CC][k][i][j] = lhsZ[0][4][CC][k][i][j] - coeff*lhsZ[2][4][CC][k][i][j];
  rhs[0][k][j][i]   = rhs[0][k][j][i]   - coeff*rhs[2][k][j][i];

  coeff = lhsZ[1][2][BB][k][i][j];
  lhsZ[1][3][BB][k][i][j]= lhsZ[1][3][BB][k][i][j] - coeff*lhsZ[2][3][BB][k][i][j];
  lhsZ[1][4][BB][k][i][j]= lhsZ[1][4][BB][k][i][j] - coeff*lhsZ[2][4][BB][k][i][j];
  lhsZ[1][0][CC][k][i][j] = lhsZ[1][0][CC][k][i][j] - coeff*lhsZ[2][0][CC][k][i][j];
  lhsZ[1][1][CC][k][i][j] = lhsZ[1][1][CC][k][i][j] - coeff*lhsZ[2][1][CC][k][i][j];
  lhsZ[1][2][CC][k][i][j] = lhsZ[1][2][CC][k][i][j] - coeff*lhsZ[2][2][CC][k][i][j];
  lhsZ[1][3][CC][k][i][j] = lhsZ[1][3][CC][k][i][j] - coeff*lhsZ[2][3][CC][k][i][j];
  lhsZ[1][4][CC][k][i][j] = lhsZ[1][4][CC][k][i][j] - coeff*lhsZ[2][4][CC][k][i][j];
  rhs[1][k][j][i]   = rhs[1][k][j][i]   - coeff*rhs[2][k][j][i];

  coeff = lhsZ[3][2][BB][k][i][j];
  lhsZ[3][3][BB][k][i][j]= lhsZ[3][3][BB][k][i][j] - coeff*lhsZ[2][3][BB][k][i][j];
  lhsZ[3][4][BB][k][i][j]= lhsZ[3][4][BB][k][i][j] - coeff*lhsZ[2][4][BB][k][i][j];
  lhsZ[3][0][CC][k][i][j] = lhsZ[3][0][CC][k][i][j] - coeff*lhsZ[2][0][CC][k][i][j];
  lhsZ[3][1][CC][k][i][j] = lhsZ[3][1][CC][k][i][j] - coeff*lhsZ[2][1][CC][k][i][j];
  lhsZ[3][2][CC][k][i][j] = lhsZ[3][2][CC][k][i][j] - coeff*lhsZ[2][2][CC][k][i][j];
  lhsZ[3][3][CC][k][i][j] = lhsZ[3][3][CC][k][i][j] - coeff*lhsZ[2][3][CC][k][i][j];
  lhsZ[3][4][CC][k][i][j] = lhsZ[3][4][CC][k][i][j] - coeff*lhsZ[2][4][CC][k][i][j];
  rhs[3][k][j][i]   = rhs[3][k][j][i]   - coeff*rhs[2][k][j][i];

  coeff = lhsZ[4][2][BB][k][i][j];
  lhsZ[4][3][BB][k][i][j]= lhsZ[4][3][BB][k][i][j] - coeff*lhsZ[2][3][BB][k][i][j];
  lhsZ[4][4][BB][k][i][j]= lhsZ[4][4][BB][k][i][j] - coeff*lhsZ[2][4][BB][k][i][j];
  lhsZ[4][0][CC][k][i][j] = lhsZ[4][0][CC][k][i][j] - coeff*lhsZ[2][0][CC][k][i][j];
  lhsZ[4][1][CC][k][i][j] = lhsZ[4][1][CC][k][i][j] - coeff*lhsZ[2][1][CC][k][i][j];
  lhsZ[4][2][CC][k][i][j] = lhsZ[4][2][CC][k][i][j] - coeff*lhsZ[2][2][CC][k][i][j];
  lhsZ[4][3][CC][k][i][j] = lhsZ[4][3][CC][k][i][j] - coeff*lhsZ[2][3][CC][k][i][j];
  lhsZ[4][4][CC][k][i][j] = lhsZ[4][4][CC][k][i][j] - coeff*lhsZ[2][4][CC][k][i][j];
  rhs[4][k][j][i]   = rhs[4][k][j][i]   - coeff*rhs[2][k][j][i];


  pivot = 1.00/lhsZ[3][3][BB][k][i][j];
  lhsZ[3][4][BB][k][i][j] = lhsZ[3][4][BB][k][i][j]*pivot;
  lhsZ[3][0][CC][k][i][j] = lhsZ[3][0][CC][k][i][j]*pivot;
  lhsZ[3][1][CC][k][i][j] = lhsZ[3][1][CC][k][i][j]*pivot;
  lhsZ[3][2][CC][k][i][j] = lhsZ[3][2][CC][k][i][j]*pivot;
  lhsZ[3][3][CC][k][i][j] = lhsZ[3][3][CC][k][i][j]*pivot;
  lhsZ[3][4][CC][k][i][j] = lhsZ[3][4][CC][k][i][j]*pivot;
  rhs[3][k][j][i]   = rhs[3][k][j][i]  *pivot;

  coeff = lhsZ[0][3][BB][k][i][j];
  lhsZ[0][4][BB][k][i][j]= lhsZ[0][4][BB][k][i][j] - coeff*lhsZ[3][4][BB][k][i][j];
  lhsZ[0][0][CC][k][i][j] = lhsZ[0][0][CC][k][i][j] - coeff*lhsZ[3][0][CC][k][i][j];
  lhsZ[0][1][CC][k][i][j] = lhsZ[0][1][CC][k][i][j] - coeff*lhsZ[3][1][CC][k][i][j];
  lhsZ[0][2][CC][k][i][j] = lhsZ[0][2][CC][k][i][j] - coeff*lhsZ[3][2][CC][k][i][j];
  lhsZ[0][3][CC][k][i][j] = lhsZ[0][3][CC][k][i][j] - coeff*lhsZ[3][3][CC][k][i][j];
  lhsZ[0][4][CC][k][i][j] = lhsZ[0][4][CC][k][i][j] - coeff*lhsZ[3][4][CC][k][i][j];
  rhs[0][k][j][i]   = rhs[0][k][j][i]   - coeff*rhs[3][k][j][i];

  coeff = lhsZ[1][3][BB][k][i][j];
  lhsZ[1][4][BB][k][i][j]= lhsZ[1][4][BB][k][i][j] - coeff*lhsZ[3][4][BB][k][i][j];
  lhsZ[1][0][CC][k][i][j] = lhsZ[1][0][CC][k][i][j] - coeff*lhsZ[3][0][CC][k][i][j];
  lhsZ[1][1][CC][k][i][j] = lhsZ[1][1][CC][k][i][j] - coeff*lhsZ[3][1][CC][k][i][j];
  lhsZ[1][2][CC][k][i][j] = lhsZ[1][2][CC][k][i][j] - coeff*lhsZ[3][2][CC][k][i][j];
  lhsZ[1][3][CC][k][i][j] = lhsZ[1][3][CC][k][i][j] - coeff*lhsZ[3][3][CC][k][i][j];
  lhsZ[1][4][CC][k][i][j] = lhsZ[1][4][CC][k][i][j] - coeff*lhsZ[3][4][CC][k][i][j];
  rhs[1][k][j][i]   = rhs[1][k][j][i]   - coeff*rhs[3][k][j][i];

  coeff = lhsZ[2][3][BB][k][i][j];
  lhsZ[2][4][BB][k][i][j]= lhsZ[2][4][BB][k][i][j] - coeff*lhsZ[3][4][BB][k][i][j];
  lhsZ[2][0][CC][k][i][j] = lhsZ[2][0][CC][k][i][j] - coeff*lhsZ[3][0][CC][k][i][j];
  lhsZ[2][1][CC][k][i][j] = lhsZ[2][1][CC][k][i][j] - coeff*lhsZ[3][1][CC][k][i][j];
  lhsZ[2][2][CC][k][i][j] = lhsZ[2][2][CC][k][i][j] - coeff*lhsZ[3][2][CC][k][i][j];
  lhsZ[2][3][CC][k][i][j] = lhsZ[2][3][CC][k][i][j] - coeff*lhsZ[3][3][CC][k][i][j];
  lhsZ[2][4][CC][k][i][j] = lhsZ[2][4][CC][k][i][j] - coeff*lhsZ[3][4][CC][k][i][j];
  rhs[2][k][j][i]   = rhs[2][k][j][i]   - coeff*rhs[3][k][j][i];

  coeff = lhsZ[4][3][BB][k][i][j];
  lhsZ[4][4][BB][k][i][j]= lhsZ[4][4][BB][k][i][j] - coeff*lhsZ[3][4][BB][k][i][j];
  lhsZ[4][0][CC][k][i][j] = lhsZ[4][0][CC][k][i][j] - coeff*lhsZ[3][0][CC][k][i][j];
  lhsZ[4][1][CC][k][i][j] = lhsZ[4][1][CC][k][i][j] - coeff*lhsZ[3][1][CC][k][i][j];
  lhsZ[4][2][CC][k][i][j] = lhsZ[4][2][CC][k][i][j] - coeff*lhsZ[3][2][CC][k][i][j];
  lhsZ[4][3][CC][k][i][j] = lhsZ[4][3][CC][k][i][j] - coeff*lhsZ[3][3][CC][k][i][j];
  lhsZ[4][4][CC][k][i][j] = lhsZ[4][4][CC][k][i][j] - coeff*lhsZ[3][4][CC][k][i][j];
  rhs[4][k][j][i]   = rhs[4][k][j][i]   - coeff*rhs[3][k][j][i];


  pivot = 1.00/lhsZ[4][4][BB][k][i][j];
  lhsZ[4][0][CC][k][i][j] = lhsZ[4][0][CC][k][i][j]*pivot;
  lhsZ[4][1][CC][k][i][j] = lhsZ[4][1][CC][k][i][j]*pivot;
  lhsZ[4][2][CC][k][i][j] = lhsZ[4][2][CC][k][i][j]*pivot;
  lhsZ[4][3][CC][k][i][j] = lhsZ[4][3][CC][k][i][j]*pivot;
  lhsZ[4][4][CC][k][i][j] = lhsZ[4][4][CC][k][i][j]*pivot;
  rhs[4][k][j][i]   = rhs[4][k][j][i]  *pivot;

  coeff = lhsZ[0][4][BB][k][i][j];
  lhsZ[0][0][CC][k][i][j] = lhsZ[0][0][CC][k][i][j] - coeff*lhsZ[4][0][CC][k][i][j];
  lhsZ[0][1][CC][k][i][j] = lhsZ[0][1][CC][k][i][j] - coeff*lhsZ[4][1][CC][k][i][j];
  lhsZ[0][2][CC][k][i][j] = lhsZ[0][2][CC][k][i][j] - coeff*lhsZ[4][2][CC][k][i][j];
  lhsZ[0][3][CC][k][i][j] = lhsZ[0][3][CC][k][i][j] - coeff*lhsZ[4][3][CC][k][i][j];
  lhsZ[0][4][CC][k][i][j] = lhsZ[0][4][CC][k][i][j] - coeff*lhsZ[4][4][CC][k][i][j];
  rhs[0][k][j][i]   = rhs[0][k][j][i]   - coeff*rhs[4][k][j][i];

  coeff = lhsZ[1][4][BB][k][i][j];
  lhsZ[1][0][CC][k][i][j] = lhsZ[1][0][CC][k][i][j] - coeff*lhsZ[4][0][CC][k][i][j];
  lhsZ[1][1][CC][k][i][j] = lhsZ[1][1][CC][k][i][j] - coeff*lhsZ[4][1][CC][k][i][j];
  lhsZ[1][2][CC][k][i][j] = lhsZ[1][2][CC][k][i][j] - coeff*lhsZ[4][2][CC][k][i][j];
  lhsZ[1][3][CC][k][i][j] = lhsZ[1][3][CC][k][i][j] - coeff*lhsZ[4][3][CC][k][i][j];
  lhsZ[1][4][CC][k][i][j] = lhsZ[1][4][CC][k][i][j] - coeff*lhsZ[4][4][CC][k][i][j];
  rhs[1][k][j][i]   = rhs[1][k][j][i]   - coeff*rhs[4][k][j][i];

  coeff = lhsZ[2][4][BB][k][i][j];
  lhsZ[2][0][CC][k][i][j] = lhsZ[2][0][CC][k][i][j] - coeff*lhsZ[4][0][CC][k][i][j];
  lhsZ[2][1][CC][k][i][j] = lhsZ[2][1][CC][k][i][j] - coeff*lhsZ[4][1][CC][k][i][j];
  lhsZ[2][2][CC][k][i][j] = lhsZ[2][2][CC][k][i][j] - coeff*lhsZ[4][2][CC][k][i][j];
  lhsZ[2][3][CC][k][i][j] = lhsZ[2][3][CC][k][i][j] - coeff*lhsZ[4][3][CC][k][i][j];
  lhsZ[2][4][CC][k][i][j] = lhsZ[2][4][CC][k][i][j] - coeff*lhsZ[4][4][CC][k][i][j];
  rhs[2][k][j][i]   = rhs[2][k][j][i]   - coeff*rhs[4][k][j][i];

  coeff = lhsZ[3][4][BB][k][i][j];
  lhsZ[3][0][CC][k][i][j] = lhsZ[3][0][CC][k][i][j] - coeff*lhsZ[4][0][CC][k][i][j];
  lhsZ[3][1][CC][k][i][j] = lhsZ[3][1][CC][k][i][j] - coeff*lhsZ[4][1][CC][k][i][j];
  lhsZ[3][2][CC][k][i][j] = lhsZ[3][2][CC][k][i][j] - coeff*lhsZ[4][2][CC][k][i][j];
  lhsZ[3][3][CC][k][i][j] = lhsZ[3][3][CC][k][i][j] - coeff*lhsZ[4][3][CC][k][i][j];
  lhsZ[3][4][CC][k][i][j] = lhsZ[3][4][CC][k][i][j] - coeff*lhsZ[4][4][CC][k][i][j];
  rhs[3][k][j][i]   = rhs[3][k][j][i]   - coeff*rhs[4][k][j][i];



      }/*end loop k*/
	}/*end loop i*/
  }/*end loop j*/
      //---------------------------------------------------------------------
      // Now finish up special cases for last cell
      //---------------------------------------------------------------------

      //---------------------------------------------------------------------
      // rhs(ksize) = rhs(ksize) - A*rhs(ksize-1)
      //---------------------------------------------------------------------
      //matvec_sub(lhsZ[i][j][AA], rhs[j][ksize-1][ksize][i], rhs[ksize][j][i]);
    #pragma acc  parallel loop gang num_gangs(gp02) num_workers(4) vector_length(32)
    for (i = 1; i <= gp02; i++) {
  #pragma acc loop worker vector
  for (j = 1; j <= gp12; j++) {
	/*
		for(m = 0; m < 5; m++){
			rhs[m][ksize][j][i] = rhs[m][ksize][j][i] - lhsZ[m][0][AA][ksize][i][j]*rhs[0][ksize-1][j][i]
											          - lhsZ[m][1][AA][ksize][i][j]*rhs[1][ksize-1][j][i]
											          - lhsZ[m][2][AA][ksize][i][j]*rhs[2][ksize-1][j][i]
											          - lhsZ[m][3][AA][ksize][i][j]*rhs[3][ksize-1][j][i]
											          - lhsZ[m][4][AA][ksize][i][j]*rhs[4][ksize-1][j][i];
		}
	*/
  rhs[0][ksize][j][i] = rhs[0][ksize][j][i] - lhsZ[0][0][AA][ksize][i][j]*rhs[0][ksize-1][j][i]
                    - lhsZ[0][1][AA][ksize][i][j]*rhs[1][ksize-1][j][i]
                    - lhsZ[0][2][AA][ksize][i][j]*rhs[2][ksize-1][j][i]
                    - lhsZ[0][3][AA][ksize][i][j]*rhs[3][ksize-1][j][i]
                    - lhsZ[0][4][AA][ksize][i][j]*rhs[4][ksize-1][j][i];
  rhs[1][ksize][j][i] = rhs[1][ksize][j][i] - lhsZ[1][0][AA][ksize][i][j]*rhs[0][ksize-1][j][i]
                    - lhsZ[1][1][AA][ksize][i][j]*rhs[1][ksize-1][j][i]
                    - lhsZ[1][2][AA][ksize][i][j]*rhs[2][ksize-1][j][i]
                    - lhsZ[1][3][AA][ksize][i][j]*rhs[3][ksize-1][j][i]
                    - lhsZ[1][4][AA][ksize][i][j]*rhs[4][ksize-1][j][i];
  rhs[2][ksize][j][i] = rhs[2][ksize][j][i] - lhsZ[2][0][AA][ksize][i][j]*rhs[0][ksize-1][j][i]
                    - lhsZ[2][1][AA][ksize][i][j]*rhs[1][ksize-1][j][i]
                    - lhsZ[2][2][AA][ksize][i][j]*rhs[2][ksize-1][j][i]
                    - lhsZ[2][3][AA][ksize][i][j]*rhs[3][ksize-1][j][i]
                    - lhsZ[2][4][AA][ksize][i][j]*rhs[4][ksize-1][j][i];
  rhs[3][ksize][j][i] = rhs[3][ksize][j][i] - lhsZ[3][0][AA][ksize][i][j]*rhs[0][ksize-1][j][i]
                    - lhsZ[3][1][AA][ksize][i][j]*rhs[1][ksize-1][j][i]
                    - lhsZ[3][2][AA][ksize][i][j]*rhs[2][ksize-1][j][i]
                    - lhsZ[3][3][AA][ksize][i][j]*rhs[3][ksize-1][j][i]
                    - lhsZ[3][4][AA][ksize][i][j]*rhs[4][ksize-1][j][i];
  rhs[4][ksize][j][i] = rhs[4][ksize][j][i] - lhsZ[4][0][AA][ksize][i][j]*rhs[0][ksize-1][j][i]
                    - lhsZ[4][1][AA][ksize][i][j]*rhs[1][ksize-1][j][i]
                    - lhsZ[4][2][AA][ksize][i][j]*rhs[2][ksize-1][j][i]
                    - lhsZ[4][3][AA][ksize][i][j]*rhs[3][ksize-1][j][i]
                    - lhsZ[4][4][AA][ksize][i][j]*rhs[4][ksize-1][j][i];
	}
  }
      //---------------------------------------------------------------------
      // B(ksize) = B(ksize) - C(ksize-1)*A(ksize)
      // matmul_sub(AA,i,j,ksize,c,
      // $              CC,i,j,ksize-1,c,BB,i,j,ksize)
      //---------------------------------------------------------------------
      //matmul_sub(lhsZ[ksize-1][i][AA], lhsZ[j][ksize][i][j][CC], lhsZ[j][i][ksize][BB]);
  #pragma acc  parallel loop gang num_gangs(gp12) num_workers(4) vector_length(32) 
  for (j = 1; j <= gp12; j++) {
    #pragma acc loop worker vector
    for (i = 1; i <= gp02; i++) {
	/*
	  for(m = 0; m < 5; m++){
	  	for(n = 0; n < 5; n++){
			lhsZ[n][m][BB][ksize][i][j] = lhsZ[n][m][BB][ksize][i][j] - lhsZ[n][0][AA][ksize][i][j]*lhsZ[0][m][CC][ksize-1][i][j]
														- lhsZ[n][1][AA][ksize][i][j]*lhsZ[1][m][CC][ksize-1][i][j]
														- lhsZ[n][2][AA][ksize][i][j]*lhsZ[2][m][CC][ksize-1][i][j]
														- lhsZ[n][3][AA][ksize][i][j]*lhsZ[3][m][CC][ksize-1][i][j]
														- lhsZ[n][4][AA][ksize][i][j]*lhsZ[4][m][CC][ksize-1][i][j];
		}
	  }
	*/
  lhsZ[0][0][BB][ksize][i][j] = lhsZ[0][0][BB][ksize][i][j] - lhsZ[0][0][AA][ksize][i][j]*lhsZ[0][0][CC][ksize-1][i][j]
                              - lhsZ[0][1][AA][ksize][i][j]*lhsZ[1][0][CC][ksize-1][i][j]
                              - lhsZ[0][2][AA][ksize][i][j]*lhsZ[2][0][CC][ksize-1][i][j]
                              - lhsZ[0][3][AA][ksize][i][j]*lhsZ[3][0][CC][ksize-1][i][j]
                              - lhsZ[0][4][AA][ksize][i][j]*lhsZ[4][0][CC][ksize-1][i][j];
  lhsZ[1][0][BB][ksize][i][j] = lhsZ[1][0][BB][ksize][i][j] - lhsZ[1][0][AA][ksize][i][j]*lhsZ[0][0][CC][ksize-1][i][j]
                              - lhsZ[1][1][AA][ksize][i][j]*lhsZ[1][0][CC][ksize-1][i][j]
                              - lhsZ[1][2][AA][ksize][i][j]*lhsZ[2][0][CC][ksize-1][i][j]
                              - lhsZ[1][3][AA][ksize][i][j]*lhsZ[3][0][CC][ksize-1][i][j]
                              - lhsZ[1][4][AA][ksize][i][j]*lhsZ[4][0][CC][ksize-1][i][j];
  lhsZ[2][0][BB][ksize][i][j] = lhsZ[2][0][BB][ksize][i][j] - lhsZ[2][0][AA][ksize][i][j]*lhsZ[0][0][CC][ksize-1][i][j]
                              - lhsZ[2][1][AA][ksize][i][j]*lhsZ[1][0][CC][ksize-1][i][j]
                              - lhsZ[2][2][AA][ksize][i][j]*lhsZ[2][0][CC][ksize-1][i][j]
                              - lhsZ[2][3][AA][ksize][i][j]*lhsZ[3][0][CC][ksize-1][i][j]
                              - lhsZ[2][4][AA][ksize][i][j]*lhsZ[4][0][CC][ksize-1][i][j];
  lhsZ[3][0][BB][ksize][i][j] = lhsZ[3][0][BB][ksize][i][j] - lhsZ[3][0][AA][ksize][i][j]*lhsZ[0][0][CC][ksize-1][i][j]
                              - lhsZ[3][1][AA][ksize][i][j]*lhsZ[1][0][CC][ksize-1][i][j]
                              - lhsZ[3][2][AA][ksize][i][j]*lhsZ[2][0][CC][ksize-1][i][j]
                              - lhsZ[3][3][AA][ksize][i][j]*lhsZ[3][0][CC][ksize-1][i][j]
                              - lhsZ[3][4][AA][ksize][i][j]*lhsZ[4][0][CC][ksize-1][i][j];
  lhsZ[4][0][BB][ksize][i][j] = lhsZ[4][0][BB][ksize][i][j] - lhsZ[4][0][AA][ksize][i][j]*lhsZ[0][0][CC][ksize-1][i][j]
                              - lhsZ[4][1][AA][ksize][i][j]*lhsZ[1][0][CC][ksize-1][i][j]
                              - lhsZ[4][2][AA][ksize][i][j]*lhsZ[2][0][CC][ksize-1][i][j]
                              - lhsZ[4][3][AA][ksize][i][j]*lhsZ[3][0][CC][ksize-1][i][j]
                              - lhsZ[4][4][AA][ksize][i][j]*lhsZ[4][0][CC][ksize-1][i][j];
  lhsZ[0][1][BB][ksize][i][j] = lhsZ[0][1][BB][ksize][i][j] - lhsZ[0][0][AA][ksize][i][j]*lhsZ[0][1][CC][ksize-1][i][j]
                              - lhsZ[0][1][AA][ksize][i][j]*lhsZ[1][1][CC][ksize-1][i][j]
                              - lhsZ[0][2][AA][ksize][i][j]*lhsZ[2][1][CC][ksize-1][i][j]
                              - lhsZ[0][3][AA][ksize][i][j]*lhsZ[3][1][CC][ksize-1][i][j]
                              - lhsZ[0][4][AA][ksize][i][j]*lhsZ[4][1][CC][ksize-1][i][j];
  lhsZ[1][1][BB][ksize][i][j] = lhsZ[1][1][BB][ksize][i][j] - lhsZ[1][0][AA][ksize][i][j]*lhsZ[0][1][CC][ksize-1][i][j]
                              - lhsZ[1][1][AA][ksize][i][j]*lhsZ[1][1][CC][ksize-1][i][j]
                              - lhsZ[1][2][AA][ksize][i][j]*lhsZ[2][1][CC][ksize-1][i][j]
                              - lhsZ[1][3][AA][ksize][i][j]*lhsZ[3][1][CC][ksize-1][i][j]
                              - lhsZ[1][4][AA][ksize][i][j]*lhsZ[4][1][CC][ksize-1][i][j];
  lhsZ[2][1][BB][ksize][i][j] = lhsZ[2][1][BB][ksize][i][j] - lhsZ[2][0][AA][ksize][i][j]*lhsZ[0][1][CC][ksize-1][i][j]
                              - lhsZ[2][1][AA][ksize][i][j]*lhsZ[1][1][CC][ksize-1][i][j]
                              - lhsZ[2][2][AA][ksize][i][j]*lhsZ[2][1][CC][ksize-1][i][j]
                              - lhsZ[2][3][AA][ksize][i][j]*lhsZ[3][1][CC][ksize-1][i][j]
                              - lhsZ[2][4][AA][ksize][i][j]*lhsZ[4][1][CC][ksize-1][i][j];
  lhsZ[3][1][BB][ksize][i][j] = lhsZ[3][1][BB][ksize][i][j] - lhsZ[3][0][AA][ksize][i][j]*lhsZ[0][1][CC][ksize-1][i][j]
                              - lhsZ[3][1][AA][ksize][i][j]*lhsZ[1][1][CC][ksize-1][i][j]
                              - lhsZ[3][2][AA][ksize][i][j]*lhsZ[2][1][CC][ksize-1][i][j]
                              - lhsZ[3][3][AA][ksize][i][j]*lhsZ[3][1][CC][ksize-1][i][j]
                              - lhsZ[3][4][AA][ksize][i][j]*lhsZ[4][1][CC][ksize-1][i][j];
  lhsZ[4][1][BB][ksize][i][j] = lhsZ[4][1][BB][ksize][i][j] - lhsZ[4][0][AA][ksize][i][j]*lhsZ[0][1][CC][ksize-1][i][j]
                              - lhsZ[4][1][AA][ksize][i][j]*lhsZ[1][1][CC][ksize-1][i][j]
                              - lhsZ[4][2][AA][ksize][i][j]*lhsZ[2][1][CC][ksize-1][i][j]
                              - lhsZ[4][3][AA][ksize][i][j]*lhsZ[3][1][CC][ksize-1][i][j]
                              - lhsZ[4][4][AA][ksize][i][j]*lhsZ[4][1][CC][ksize-1][i][j];
  lhsZ[0][2][BB][ksize][i][j] = lhsZ[0][2][BB][ksize][i][j] - lhsZ[0][0][AA][ksize][i][j]*lhsZ[0][2][CC][ksize-1][i][j]
                              - lhsZ[0][1][AA][ksize][i][j]*lhsZ[1][2][CC][ksize-1][i][j]
                              - lhsZ[0][2][AA][ksize][i][j]*lhsZ[2][2][CC][ksize-1][i][j]
                              - lhsZ[0][3][AA][ksize][i][j]*lhsZ[3][2][CC][ksize-1][i][j]
                              - lhsZ[0][4][AA][ksize][i][j]*lhsZ[4][2][CC][ksize-1][i][j];
  lhsZ[1][2][BB][ksize][i][j] = lhsZ[1][2][BB][ksize][i][j] - lhsZ[1][0][AA][ksize][i][j]*lhsZ[0][2][CC][ksize-1][i][j]
                              - lhsZ[1][1][AA][ksize][i][j]*lhsZ[1][2][CC][ksize-1][i][j]
                              - lhsZ[1][2][AA][ksize][i][j]*lhsZ[2][2][CC][ksize-1][i][j]
                              - lhsZ[1][3][AA][ksize][i][j]*lhsZ[3][2][CC][ksize-1][i][j]
                              - lhsZ[1][4][AA][ksize][i][j]*lhsZ[4][2][CC][ksize-1][i][j];
  lhsZ[2][2][BB][ksize][i][j] = lhsZ[2][2][BB][ksize][i][j] - lhsZ[2][0][AA][ksize][i][j]*lhsZ[0][2][CC][ksize-1][i][j]
                              - lhsZ[2][1][AA][ksize][i][j]*lhsZ[1][2][CC][ksize-1][i][j]
                              - lhsZ[2][2][AA][ksize][i][j]*lhsZ[2][2][CC][ksize-1][i][j]
                              - lhsZ[2][3][AA][ksize][i][j]*lhsZ[3][2][CC][ksize-1][i][j]
                              - lhsZ[2][4][AA][ksize][i][j]*lhsZ[4][2][CC][ksize-1][i][j];
  lhsZ[3][2][BB][ksize][i][j] = lhsZ[3][2][BB][ksize][i][j] - lhsZ[3][0][AA][ksize][i][j]*lhsZ[0][2][CC][ksize-1][i][j]
                              - lhsZ[3][1][AA][ksize][i][j]*lhsZ[1][2][CC][ksize-1][i][j]
                              - lhsZ[3][2][AA][ksize][i][j]*lhsZ[2][2][CC][ksize-1][i][j]
                              - lhsZ[3][3][AA][ksize][i][j]*lhsZ[3][2][CC][ksize-1][i][j]
                              - lhsZ[3][4][AA][ksize][i][j]*lhsZ[4][2][CC][ksize-1][i][j];
  lhsZ[4][2][BB][ksize][i][j] = lhsZ[4][2][BB][ksize][i][j] - lhsZ[4][0][AA][ksize][i][j]*lhsZ[0][2][CC][ksize-1][i][j]
                              - lhsZ[4][1][AA][ksize][i][j]*lhsZ[1][2][CC][ksize-1][i][j]
                              - lhsZ[4][2][AA][ksize][i][j]*lhsZ[2][2][CC][ksize-1][i][j]
                              - lhsZ[4][3][AA][ksize][i][j]*lhsZ[3][2][CC][ksize-1][i][j]
                              - lhsZ[4][4][AA][ksize][i][j]*lhsZ[4][2][CC][ksize-1][i][j];
  lhsZ[0][3][BB][ksize][i][j] = lhsZ[0][3][BB][ksize][i][j] - lhsZ[0][0][AA][ksize][i][j]*lhsZ[0][3][CC][ksize-1][i][j]
                              - lhsZ[0][1][AA][ksize][i][j]*lhsZ[1][3][CC][ksize-1][i][j]
                              - lhsZ[0][2][AA][ksize][i][j]*lhsZ[2][3][CC][ksize-1][i][j]
                              - lhsZ[0][3][AA][ksize][i][j]*lhsZ[3][3][CC][ksize-1][i][j]
                              - lhsZ[0][4][AA][ksize][i][j]*lhsZ[4][3][CC][ksize-1][i][j];
  lhsZ[1][3][BB][ksize][i][j] = lhsZ[1][3][BB][ksize][i][j] - lhsZ[1][0][AA][ksize][i][j]*lhsZ[0][3][CC][ksize-1][i][j]
                              - lhsZ[1][1][AA][ksize][i][j]*lhsZ[1][3][CC][ksize-1][i][j]
                              - lhsZ[1][2][AA][ksize][i][j]*lhsZ[2][3][CC][ksize-1][i][j]
                              - lhsZ[1][3][AA][ksize][i][j]*lhsZ[3][3][CC][ksize-1][i][j]
                              - lhsZ[1][4][AA][ksize][i][j]*lhsZ[4][3][CC][ksize-1][i][j];
  lhsZ[2][3][BB][ksize][i][j] = lhsZ[2][3][BB][ksize][i][j] - lhsZ[2][0][AA][ksize][i][j]*lhsZ[0][3][CC][ksize-1][i][j]
                              - lhsZ[2][1][AA][ksize][i][j]*lhsZ[1][3][CC][ksize-1][i][j]
                              - lhsZ[2][2][AA][ksize][i][j]*lhsZ[2][3][CC][ksize-1][i][j]
                              - lhsZ[2][3][AA][ksize][i][j]*lhsZ[3][3][CC][ksize-1][i][j]
                              - lhsZ[2][4][AA][ksize][i][j]*lhsZ[4][3][CC][ksize-1][i][j];
  lhsZ[3][3][BB][ksize][i][j] = lhsZ[3][3][BB][ksize][i][j] - lhsZ[3][0][AA][ksize][i][j]*lhsZ[0][3][CC][ksize-1][i][j]
                              - lhsZ[3][1][AA][ksize][i][j]*lhsZ[1][3][CC][ksize-1][i][j]
                              - lhsZ[3][2][AA][ksize][i][j]*lhsZ[2][3][CC][ksize-1][i][j]
                              - lhsZ[3][3][AA][ksize][i][j]*lhsZ[3][3][CC][ksize-1][i][j]
                              - lhsZ[3][4][AA][ksize][i][j]*lhsZ[4][3][CC][ksize-1][i][j];
  lhsZ[4][3][BB][ksize][i][j] = lhsZ[4][3][BB][ksize][i][j] - lhsZ[4][0][AA][ksize][i][j]*lhsZ[0][3][CC][ksize-1][i][j]
                              - lhsZ[4][1][AA][ksize][i][j]*lhsZ[1][3][CC][ksize-1][i][j]
                              - lhsZ[4][2][AA][ksize][i][j]*lhsZ[2][3][CC][ksize-1][i][j]
                              - lhsZ[4][3][AA][ksize][i][j]*lhsZ[3][3][CC][ksize-1][i][j]
                              - lhsZ[4][4][AA][ksize][i][j]*lhsZ[4][3][CC][ksize-1][i][j];
  lhsZ[0][4][BB][ksize][i][j] = lhsZ[0][4][BB][ksize][i][j] - lhsZ[0][0][AA][ksize][i][j]*lhsZ[0][4][CC][ksize-1][i][j]
                              - lhsZ[0][1][AA][ksize][i][j]*lhsZ[1][4][CC][ksize-1][i][j]
                              - lhsZ[0][2][AA][ksize][i][j]*lhsZ[2][4][CC][ksize-1][i][j]
                              - lhsZ[0][3][AA][ksize][i][j]*lhsZ[3][4][CC][ksize-1][i][j]
                              - lhsZ[0][4][AA][ksize][i][j]*lhsZ[4][4][CC][ksize-1][i][j];
  lhsZ[1][4][BB][ksize][i][j] = lhsZ[1][4][BB][ksize][i][j] - lhsZ[1][0][AA][ksize][i][j]*lhsZ[0][4][CC][ksize-1][i][j]
                              - lhsZ[1][1][AA][ksize][i][j]*lhsZ[1][4][CC][ksize-1][i][j]
                              - lhsZ[1][2][AA][ksize][i][j]*lhsZ[2][4][CC][ksize-1][i][j]
                              - lhsZ[1][3][AA][ksize][i][j]*lhsZ[3][4][CC][ksize-1][i][j]
                              - lhsZ[1][4][AA][ksize][i][j]*lhsZ[4][4][CC][ksize-1][i][j];
  lhsZ[2][4][BB][ksize][i][j] = lhsZ[2][4][BB][ksize][i][j] - lhsZ[2][0][AA][ksize][i][j]*lhsZ[0][4][CC][ksize-1][i][j]
                              - lhsZ[2][1][AA][ksize][i][j]*lhsZ[1][4][CC][ksize-1][i][j]
                              - lhsZ[2][2][AA][ksize][i][j]*lhsZ[2][4][CC][ksize-1][i][j]
                              - lhsZ[2][3][AA][ksize][i][j]*lhsZ[3][4][CC][ksize-1][i][j]
                              - lhsZ[2][4][AA][ksize][i][j]*lhsZ[4][4][CC][ksize-1][i][j];
  lhsZ[3][4][BB][ksize][i][j] = lhsZ[3][4][BB][ksize][i][j] - lhsZ[3][0][AA][ksize][i][j]*lhsZ[0][4][CC][ksize-1][i][j]
                              - lhsZ[3][1][AA][ksize][i][j]*lhsZ[1][4][CC][ksize-1][i][j]
                              - lhsZ[3][2][AA][ksize][i][j]*lhsZ[2][4][CC][ksize-1][i][j]
                              - lhsZ[3][3][AA][ksize][i][j]*lhsZ[3][4][CC][ksize-1][i][j]
                              - lhsZ[3][4][AA][ksize][i][j]*lhsZ[4][4][CC][ksize-1][i][j];
  lhsZ[4][4][BB][ksize][i][j] = lhsZ[4][4][BB][ksize][i][j] - lhsZ[4][0][AA][ksize][i][j]*lhsZ[0][4][CC][ksize-1][i][j]
                              - lhsZ[4][1][AA][ksize][i][j]*lhsZ[1][4][CC][ksize-1][i][j]
                              - lhsZ[4][2][AA][ksize][i][j]*lhsZ[2][4][CC][ksize-1][i][j]
                              - lhsZ[4][3][AA][ksize][i][j]*lhsZ[3][4][CC][ksize-1][i][j]
                              - lhsZ[4][4][AA][ksize][i][j]*lhsZ[4][4][CC][ksize-1][i][j];

	}
  }
      //---------------------------------------------------------------------
      // multiply rhs(ksize) by b_inverse(ksize) and copy to rhs      //---------------------------------------------------------------------
      //binvrhs( lhsZ[i][j][BB], rhs[j][ksize][ksize][i] );
    #pragma acc parallel loop gang num_gangs(gp02) num_workers(4) vector_length(32)
    for (i = 1; i <= gp02; i++) {
  #pragma acc loop worker vector
  for (j = 1; j <= gp12; j++) {
	/*
	  for(m = 0; m < 5; m++){
	  	pivot = 1.00/lhsZ[m][m][BB][ksize][i][j];
		for(n = m+1; n < 5; n++){
			lhsZ[m][n][BB][ksize][i][j] = lhsZ[m][n][BB][ksize][i][j]*pivot;
		}
		rhs[m][ksize][j][i] = rhs[m][ksize][j][i]*pivot;
		
		for(n = 0; n < 5; n++){
			if(n != m){
				coeff = lhsZ[n][m][BB][ksize][i][j];
				for(z = m+1; z < 5; z++){
					lhsZ[n][z][BB][ksize][i][j] = lhsZ[n][z][BB][ksize][i][j] - coeff*lhsZ[m][z][BB][ksize][i][j];
				}
				rhs[n][ksize][j][i] = rhs[n][ksize][j][i] - coeff*rhs[m][ksize][j][i];
			}
		}
	  }
	*/

  pivot = 1.00/lhsZ[0][0][BB][ksize][i][j];
  lhsZ[0][1][BB][ksize][i][j] = lhsZ[0][1][BB][ksize][i][j]*pivot;
  lhsZ[0][2][BB][ksize][i][j] = lhsZ[0][2][BB][ksize][i][j]*pivot;
  lhsZ[0][3][BB][ksize][i][j] = lhsZ[0][3][BB][ksize][i][j]*pivot;
  lhsZ[0][4][BB][ksize][i][j] = lhsZ[0][4][BB][ksize][i][j]*pivot;
  rhs[0][ksize][j][i]   = rhs[0][ksize][j][i]  *pivot;

  coeff = lhsZ[1][0][BB][ksize][i][j];
  lhsZ[1][1][BB][ksize][i][j]= lhsZ[1][1][BB][ksize][i][j] - coeff*lhsZ[0][1][BB][ksize][i][j];
  lhsZ[1][2][BB][ksize][i][j]= lhsZ[1][2][BB][ksize][i][j] - coeff*lhsZ[0][2][BB][ksize][i][j];
  lhsZ[1][3][BB][ksize][i][j]= lhsZ[1][3][BB][ksize][i][j] - coeff*lhsZ[0][3][BB][ksize][i][j];
  lhsZ[1][4][BB][ksize][i][j]= lhsZ[1][4][BB][ksize][i][j] - coeff*lhsZ[0][4][BB][ksize][i][j];
  rhs[1][ksize][j][i]   = rhs[1][ksize][j][i]   - coeff*rhs[0][ksize][j][i];

  coeff = lhsZ[2][0][BB][ksize][i][j];
  lhsZ[2][1][BB][ksize][i][j]= lhsZ[2][1][BB][ksize][i][j] - coeff*lhsZ[0][1][BB][ksize][i][j];
  lhsZ[2][2][BB][ksize][i][j]= lhsZ[2][2][BB][ksize][i][j] - coeff*lhsZ[0][2][BB][ksize][i][j];
  lhsZ[2][3][BB][ksize][i][j]= lhsZ[2][3][BB][ksize][i][j] - coeff*lhsZ[0][3][BB][ksize][i][j];
  lhsZ[2][4][BB][ksize][i][j]= lhsZ[2][4][BB][ksize][i][j] - coeff*lhsZ[0][4][BB][ksize][i][j];
  rhs[2][ksize][j][i]   = rhs[2][ksize][j][i]   - coeff*rhs[0][ksize][j][i];

  coeff = lhsZ[3][0][BB][ksize][i][j];
  lhsZ[3][1][BB][ksize][i][j]= lhsZ[3][1][BB][ksize][i][j] - coeff*lhsZ[0][1][BB][ksize][i][j];
  lhsZ[3][2][BB][ksize][i][j]= lhsZ[3][2][BB][ksize][i][j] - coeff*lhsZ[0][2][BB][ksize][i][j];
  lhsZ[3][3][BB][ksize][i][j]= lhsZ[3][3][BB][ksize][i][j] - coeff*lhsZ[0][3][BB][ksize][i][j];
  lhsZ[3][4][BB][ksize][i][j]= lhsZ[3][4][BB][ksize][i][j] - coeff*lhsZ[0][4][BB][ksize][i][j];
  rhs[3][ksize][j][i]   = rhs[3][ksize][j][i]   - coeff*rhs[0][ksize][j][i];

  coeff = lhsZ[4][0][BB][ksize][i][j];
  lhsZ[4][1][BB][ksize][i][j]= lhsZ[4][1][BB][ksize][i][j] - coeff*lhsZ[0][1][BB][ksize][i][j];
  lhsZ[4][2][BB][ksize][i][j]= lhsZ[4][2][BB][ksize][i][j] - coeff*lhsZ[0][2][BB][ksize][i][j];
  lhsZ[4][3][BB][ksize][i][j]= lhsZ[4][3][BB][ksize][i][j] - coeff*lhsZ[0][3][BB][ksize][i][j];
  lhsZ[4][4][BB][ksize][i][j]= lhsZ[4][4][BB][ksize][i][j] - coeff*lhsZ[0][4][BB][ksize][i][j];
  rhs[4][ksize][j][i]   = rhs[4][ksize][j][i]   - coeff*rhs[0][ksize][j][i];


  pivot = 1.00/lhsZ[1][1][BB][ksize][i][j];
  lhsZ[1][2][BB][ksize][i][j] = lhsZ[1][2][BB][ksize][i][j]*pivot;
  lhsZ[1][3][BB][ksize][i][j] = lhsZ[1][3][BB][ksize][i][j]*pivot;
  lhsZ[1][4][BB][ksize][i][j] = lhsZ[1][4][BB][ksize][i][j]*pivot;
  rhs[1][ksize][j][i]   = rhs[1][ksize][j][i]  *pivot;

  coeff = lhsZ[0][1][BB][ksize][i][j];
  lhsZ[0][2][BB][ksize][i][j]= lhsZ[0][2][BB][ksize][i][j] - coeff*lhsZ[1][2][BB][ksize][i][j];
  lhsZ[0][3][BB][ksize][i][j]= lhsZ[0][3][BB][ksize][i][j] - coeff*lhsZ[1][3][BB][ksize][i][j];
  lhsZ[0][4][BB][ksize][i][j]= lhsZ[0][4][BB][ksize][i][j] - coeff*lhsZ[1][4][BB][ksize][i][j];
  rhs[0][ksize][j][i]   = rhs[0][ksize][j][i]   - coeff*rhs[1][ksize][j][i];

  coeff = lhsZ[2][1][BB][ksize][i][j];
  lhsZ[2][2][BB][ksize][i][j]= lhsZ[2][2][BB][ksize][i][j] - coeff*lhsZ[1][2][BB][ksize][i][j];
  lhsZ[2][3][BB][ksize][i][j]= lhsZ[2][3][BB][ksize][i][j] - coeff*lhsZ[1][3][BB][ksize][i][j];
  lhsZ[2][4][BB][ksize][i][j]= lhsZ[2][4][BB][ksize][i][j] - coeff*lhsZ[1][4][BB][ksize][i][j];
  rhs[2][ksize][j][i]   = rhs[2][ksize][j][i]   - coeff*rhs[1][ksize][j][i];

  coeff = lhsZ[3][1][BB][ksize][i][j];
  lhsZ[3][2][BB][ksize][i][j]= lhsZ[3][2][BB][ksize][i][j] - coeff*lhsZ[1][2][BB][ksize][i][j];
  lhsZ[3][3][BB][ksize][i][j]= lhsZ[3][3][BB][ksize][i][j] - coeff*lhsZ[1][3][BB][ksize][i][j];
  lhsZ[3][4][BB][ksize][i][j]= lhsZ[3][4][BB][ksize][i][j] - coeff*lhsZ[1][4][BB][ksize][i][j];
  rhs[3][ksize][j][i]   = rhs[3][ksize][j][i]   - coeff*rhs[1][ksize][j][i];

  coeff = lhsZ[4][1][BB][ksize][i][j];
  lhsZ[4][2][BB][ksize][i][j]= lhsZ[4][2][BB][ksize][i][j] - coeff*lhsZ[1][2][BB][ksize][i][j];
  lhsZ[4][3][BB][ksize][i][j]= lhsZ[4][3][BB][ksize][i][j] - coeff*lhsZ[1][3][BB][ksize][i][j];
  lhsZ[4][4][BB][ksize][i][j]= lhsZ[4][4][BB][ksize][i][j] - coeff*lhsZ[1][4][BB][ksize][i][j];
  rhs[4][ksize][j][i]   = rhs[4][ksize][j][i]   - coeff*rhs[1][ksize][j][i];


  pivot = 1.00/lhsZ[2][2][BB][ksize][i][j];
  lhsZ[2][3][BB][ksize][i][j] = lhsZ[2][3][BB][ksize][i][j]*pivot;
  lhsZ[2][4][BB][ksize][i][j] = lhsZ[2][4][BB][ksize][i][j]*pivot;
  rhs[2][ksize][j][i]   = rhs[2][ksize][j][i]  *pivot;

  coeff = lhsZ[0][2][BB][ksize][i][j];
  lhsZ[0][3][BB][ksize][i][j]= lhsZ[0][3][BB][ksize][i][j] - coeff*lhsZ[2][3][BB][ksize][i][j];
  lhsZ[0][4][BB][ksize][i][j]= lhsZ[0][4][BB][ksize][i][j] - coeff*lhsZ[2][4][BB][ksize][i][j];
  rhs[0][ksize][j][i]   = rhs[0][ksize][j][i]   - coeff*rhs[2][ksize][j][i];

  coeff = lhsZ[1][2][BB][ksize][i][j];
  lhsZ[1][3][BB][ksize][i][j]= lhsZ[1][3][BB][ksize][i][j] - coeff*lhsZ[2][3][BB][ksize][i][j];
  lhsZ[1][4][BB][ksize][i][j]= lhsZ[1][4][BB][ksize][i][j] - coeff*lhsZ[2][4][BB][ksize][i][j];
  rhs[1][ksize][j][i]   = rhs[1][ksize][j][i]   - coeff*rhs[2][ksize][j][i];

  coeff = lhsZ[3][2][BB][ksize][i][j];
  lhsZ[3][3][BB][ksize][i][j]= lhsZ[3][3][BB][ksize][i][j] - coeff*lhsZ[2][3][BB][ksize][i][j];
  lhsZ[3][4][BB][ksize][i][j]= lhsZ[3][4][BB][ksize][i][j] - coeff*lhsZ[2][4][BB][ksize][i][j];
  rhs[3][ksize][j][i]   = rhs[3][ksize][j][i]   - coeff*rhs[2][ksize][j][i];

  coeff = lhsZ[4][2][BB][ksize][i][j];
  lhsZ[4][3][BB][ksize][i][j]= lhsZ[4][3][BB][ksize][i][j] - coeff*lhsZ[2][3][BB][ksize][i][j];
  lhsZ[4][4][BB][ksize][i][j]= lhsZ[4][4][BB][ksize][i][j] - coeff*lhsZ[2][4][BB][ksize][i][j];
  rhs[4][ksize][j][i]   = rhs[4][ksize][j][i]   - coeff*rhs[2][ksize][j][i];


  pivot = 1.00/lhsZ[3][3][BB][ksize][i][j];
  lhsZ[3][4][BB][ksize][i][j] = lhsZ[3][4][BB][ksize][i][j]*pivot;
  rhs[3][ksize][j][i]   = rhs[3][ksize][j][i]  *pivot;

  coeff = lhsZ[0][3][BB][ksize][i][j];
  lhsZ[0][4][BB][ksize][i][j]= lhsZ[0][4][BB][ksize][i][j] - coeff*lhsZ[3][4][BB][ksize][i][j];
  rhs[0][ksize][j][i]   = rhs[0][ksize][j][i]   - coeff*rhs[3][ksize][j][i];

  coeff = lhsZ[1][3][BB][ksize][i][j];
  lhsZ[1][4][BB][ksize][i][j]= lhsZ[1][4][BB][ksize][i][j] - coeff*lhsZ[3][4][BB][ksize][i][j];
  rhs[1][ksize][j][i]   = rhs[1][ksize][j][i]   - coeff*rhs[3][ksize][j][i];

  coeff = lhsZ[2][3][BB][ksize][i][j];
  lhsZ[2][4][BB][ksize][i][j]= lhsZ[2][4][BB][ksize][i][j] - coeff*lhsZ[3][4][BB][ksize][i][j];
  rhs[2][ksize][j][i]   = rhs[2][ksize][j][i]   - coeff*rhs[3][ksize][j][i];

  coeff = lhsZ[4][3][BB][ksize][i][j];
  lhsZ[4][4][BB][ksize][i][j]= lhsZ[4][4][BB][ksize][i][j] - coeff*lhsZ[3][4][BB][ksize][i][j];
  rhs[4][ksize][j][i]   = rhs[4][ksize][j][i]   - coeff*rhs[3][ksize][j][i];


  pivot = 1.00/lhsZ[4][4][BB][ksize][i][j];
  rhs[4][ksize][j][i]   = rhs[4][ksize][j][i]  *pivot;

  coeff = lhsZ[0][4][BB][ksize][i][j];
  rhs[0][ksize][j][i]   = rhs[0][ksize][j][i]   - coeff*rhs[4][ksize][j][i];

  coeff = lhsZ[1][4][BB][ksize][i][j];
  rhs[1][ksize][j][i]   = rhs[1][ksize][j][i]   - coeff*rhs[4][ksize][j][i];

  coeff = lhsZ[2][4][BB][ksize][i][j];
  rhs[2][ksize][j][i]   = rhs[2][ksize][j][i]   - coeff*rhs[4][ksize][j][i];

  coeff = lhsZ[3][4][BB][ksize][i][j];
  rhs[3][ksize][j][i]   = rhs[3][ksize][j][i]   - coeff*rhs[4][ksize][j][i];


	}
  }
      //---------------------------------------------------------------------
      //---------------------------------------------------------------------

      //---------------------------------------------------------------------
      // back solve: if last cell, then generate U(ksize)=rhs(ksize)
      // else assume U(ksize) is loaded in un pack backsub_info
      // so just use it
      // after u(kstart) will be sent to next cell
      //---------------------------------------------------------------------

      for (k = ksize-1; k >= 0; k--) {
  #pragma acc  parallel loop gang num_gangs(gp12) num_workers(4) vector_length(32) 
  for (j = 1; j <= gp12; j++) {
    #pragma acc loop worker vector
    for (i = 1; i <= gp02; i++) {
        /*
        for (m = 0; m < BLOCK_SIZE; m++) {
          for (n = 0; n < BLOCK_SIZE; n++) {
            rhs[m][k][j][i] = rhs[m][k][j][i] 
              - lhsZ[m][n][CC][k][i][j]*rhs[n][k+1][j][i];
          }
        }
        */
	  
            rhs[0][k][j][i] = rhs[0][k][j][i] 
              - lhsZ[0][0][CC][k][i][j]*rhs[0][k+1][j][i];
            rhs[0][k][j][i] = rhs[0][k][j][i] 
              - lhsZ[0][1][CC][k][i][j]*rhs[1][k+1][j][i];
            rhs[0][k][j][i] = rhs[0][k][j][i] 
              - lhsZ[0][2][CC][k][i][j]*rhs[2][k+1][j][i];
            rhs[0][k][j][i] = rhs[0][k][j][i] 
              - lhsZ[0][3][CC][k][i][j]*rhs[3][k+1][j][i];
            rhs[0][k][j][i] = rhs[0][k][j][i] 
              - lhsZ[0][4][CC][k][i][j]*rhs[4][k+1][j][i];

            rhs[1][k][j][i] = rhs[1][k][j][i] 
              - lhsZ[1][0][CC][k][i][j]*rhs[0][k+1][j][i];
            rhs[1][k][j][i] = rhs[1][k][j][i] 
              - lhsZ[1][1][CC][k][i][j]*rhs[1][k+1][j][i];
            rhs[1][k][j][i] = rhs[1][k][j][i] 
              - lhsZ[1][2][CC][k][i][j]*rhs[2][k+1][j][i];
            rhs[1][k][j][i] = rhs[1][k][j][i] 
              - lhsZ[1][3][CC][k][i][j]*rhs[3][k+1][j][i];
            rhs[1][k][j][i] = rhs[1][k][j][i] 
              - lhsZ[1][4][CC][k][i][j]*rhs[4][k+1][j][i];
            
			rhs[2][k][j][i] = rhs[2][k][j][i] 
              - lhsZ[2][0][CC][k][i][j]*rhs[0][k+1][j][i];
            rhs[2][k][j][i] = rhs[2][k][j][i] 
              - lhsZ[2][1][CC][k][i][j]*rhs[1][k+1][j][i];
            rhs[2][k][j][i] = rhs[2][k][j][i] 
              - lhsZ[2][2][CC][k][i][j]*rhs[2][k+1][j][i];
            rhs[2][k][j][i] = rhs[2][k][j][i] 
              - lhsZ[2][3][CC][k][i][j]*rhs[3][k+1][j][i];
            rhs[2][k][j][i] = rhs[2][k][j][i] 
              - lhsZ[2][4][CC][k][i][j]*rhs[4][k+1][j][i];
			
			rhs[3][k][j][i] = rhs[3][k][j][i] 
              - lhsZ[3][0][CC][k][i][j]*rhs[0][k+1][j][i];
            rhs[3][k][j][i] = rhs[3][k][j][i] 
              - lhsZ[3][1][CC][k][i][j]*rhs[1][k+1][j][i];
            rhs[3][k][j][i] = rhs[3][k][j][i] 
              - lhsZ[3][2][CC][k][i][j]*rhs[2][k+1][j][i];
            rhs[3][k][j][i] = rhs[3][k][j][i] 
              - lhsZ[3][3][CC][k][i][j]*rhs[3][k+1][j][i];
            rhs[3][k][j][i] = rhs[3][k][j][i] 
              - lhsZ[3][4][CC][k][i][j]*rhs[4][k+1][j][i];
			
			rhs[4][k][j][i] = rhs[4][k][j][i] 
              - lhsZ[4][0][CC][k][i][j]*rhs[0][k+1][j][i];
            rhs[4][k][j][i] = rhs[4][k][j][i] 
              - lhsZ[4][1][CC][k][i][j]*rhs[1][k+1][j][i];
            rhs[4][k][j][i] = rhs[4][k][j][i] 
              - lhsZ[4][2][CC][k][i][j]*rhs[2][k+1][j][i];
            rhs[4][k][j][i] = rhs[4][k][j][i] 
              - lhsZ[4][3][CC][k][i][j]*rhs[3][k+1][j][i];
            rhs[4][k][j][i] = rhs[4][k][j][i] 
              - lhsZ[4][4][CC][k][i][j]*rhs[4][k+1][j][i];
	  
      }
    }
  }
}/*end acc data*/

}

########## NEXT FILE ##########
cg.c:::
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB CG code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS CG code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

//---------------------------------------------------------------------
// NPB CG OpenACC version      
//---------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include "globals.h"
#include "randdp.h"
#include "timers.h"
#include "print_results.h"
#include <openacc.h>
//---------------------------------------------------------------------
unsigned int  nz =  (NA*(NONZER+1)*(NONZER+1));
unsigned int  naz = (NA*(NONZER+1));
unsigned int  na = NA;
/* common / main_int_mem / */
static int colidx[NZ];
static int rowstr[NA+1];
static int iv[NA];
static int arow[NA];
static int acol[NAZ];

/* common / main_flt_mem / */
static double aelt[NAZ];
static double a[NZ];
static double x[NA+2];
static double z[NA+2];
static double p[NA+2];
static double q[NA+2];
static double r[NA+2];

/* common / partit_size / */
static int naa;
static int nzz;
static int firstrow;
static int lastrow;
static int firstcol;
static int lastcol;

/* common /urando/ */
static double amult;
static double tran;

/* common /timers/ */
static logical timeron;
//---------------------------------------------------------------------


//---------------------------------------------------------------------
static void conj_grad(int colidx[],
                      int rowstr[],
                      double x[],
                      double z[],
                      double a[],
                      double p[],
                      double q[],
                      double r[],
                      double *rnorm);
static void makea(int n,
                  int nz,
                  double a[],
                  int colidx[],
                  int rowstr[],
                  int firstrow,
                  int lastrow,
                  int firstcol,
                  int lastcol,
                  int arow[],
                  int acol[][NONZER+1],
                  double aelt[][NONZER+1],
                  int iv[]);
static void sparse(double a[],
                   int colidx[],
                   int rowstr[],
                   int n,
                   int nz,
                   int nozer,
                   int arow[],
                   int acol[][NONZER+1],
                   double aelt[][NONZER+1],
                   int firstrow,
                   int lastrow,
                   int nzloc[],
                   double rcond,
                   double shift);
static void sprnvc(int n, int nz, int nn1, double v[], int iv[]);
static int icnvrt(double x, int ipwr2);
static void vecset(int n, double v[], int iv[], int *nzv, int i, double val);
static int conj_calls = 0;
static int loop_iter = 0;
//---------------------------------------------------------------------


int main(int argc, char *argv[])
{
  int i, j, k, it;
  int end;

  double zeta;
  double rnorm;
  double norm_temp1, norm_temp2;

  double t, mflops, tmax;
  char Class;
  int verified;
  double zeta_verify_value, epsilon, err;

  char *t_names[T_last];
  acc_init(acc_device_default);

  for (i = 0; i < T_last; i++) {
    timer_clear(i);
  }
  
  FILE *fp;
  if ((fp = fopen("timer.flag", "r")) != NULL) {
    timeron = true;
    t_names[T_init] = "init";
    t_names[T_bench] = "benchmk";
    t_names[T_conj_grad] = "conjgd";
    fclose(fp);
  } else {
    timeron = false;
  }

  timer_start(T_init);

  firstrow = 0;
  lastrow  = NA-1;
  firstcol = 0;
  lastcol  = NA-1;

  if (NA == 1400 && NONZER == 7 && NITER == 15 && SHIFT == 10) {
    Class = 'S';
    zeta_verify_value = 8.5971775078648;
  } else if (NA == 7000 && NONZER == 8 && NITER == 15 && SHIFT == 12) {
    Class = 'W';
    zeta_verify_value = 10.362595087124;
  } else if (NA == 14000 && NONZER == 11 && NITER == 15 && SHIFT == 20) {
    Class = 'A';
    zeta_verify_value = 17.130235054029;
  } else if (NA == 75000 && NONZER == 13 && NITER == 75 && SHIFT == 60) {
    Class = 'B';
    zeta_verify_value = 22.712745482631;
  } else if (NA == 150000 && NONZER == 15 && NITER == 75 && SHIFT == 110) {
    Class = 'C';
    zeta_verify_value = 28.973605592845;
  } else if (NA == 1500000 && NONZER == 21 && NITER == 100 && SHIFT == 500) {
    Class = 'D';
    zeta_verify_value = 52.514532105794;
  } else if (NA == 9000000 && NONZER == 26 && NITER == 100 && SHIFT == 1500) {
    Class = 'E';
    zeta_verify_value = 77.522164599383;
  } else {
    Class = 'U';
  }

  printf("\n\n NAS Parallel Benchmarks (NPB3.3-ACC-C) - CG Benchmark\n\n");
  printf(" Size: %11d\n", NA);
  printf(" Iterations: %5d\n", NITER);
  printf("\n");

  naa = NA;
  nzz = NZ;

  //---------------------------------------------------------------------
  // Inialize random number generator
  //---------------------------------------------------------------------
  tran    = 314159265.0;
  amult   = 1220703125.0;
  zeta    = randlc(&tran, amult);

  //---------------------------------------------------------------------
  //  
  //---------------------------------------------------------------------
  makea(naa, nzz, a, colidx, rowstr, 
        firstrow, lastrow, firstcol, lastcol, 
        arow, 
        (int (*)[NONZER+1])(void*)acol, 
        (double (*)[NONZER+1])(void*)aelt,
        iv);

  //---------------------------------------------------------------------
  // Note: as a result of the above call to makea:
  //      values of j used in indexing rowstr go from 0 --> lastrow-firstrow
  //      values of colidx which are col indexes go from firstcol --> lastcol
  //      So:
  //      Shift the col index vals from actual (firstcol --> lastcol ) 
  //      to local, i.e., (0 --> lastcol-firstcol)
  //---------------------------------------------------------------------
  for (j = 0; j < lastrow - firstrow + 1; j++) {
    for (k = rowstr[j]; k < rowstr[j+1]; k++) {
      colidx[k] = colidx[k] - firstcol;
    }
  }

#pragma acc data copyin(colidx[0:nz],a[0:nz], \
						rowstr[0:na+1]) \
				 create(x[0:na+2],z[0:na+2], \
						p[0:na+2],q[0:na+2], \
						r[0:na+2])
{
  //---------------------------------------------------------------------
  // set starting vector to (1, 1, .... 1)
  //---------------------------------------------------------------------
  int na_gangs = NA+1;
  #pragma acc kernels loop gang((na_gangs+127)/128) vector(128) 
  for (i = 0; i < NA+1; i++) {
    x[i] = 1.0;
  }

  end = lastcol - firstcol + 1;
  #pragma acc kernels loop gang((end+127)/128) vector(128) 
  for (j = 0; j < end; j++) {
    q[j] = 0.0;
    z[j] = 0.0;
    r[j] = 0.0;
    p[j] = 0.0;
  }

  zeta = 0.0;

  //---------------------------------------------------------------------
  //---->
  // Do one iteration untimed to init all code and data page tables
  //---->                    (then reinit, start timing, to niter its)
  //---------------------------------------------------------------------
  for (it = 1; it <= 1; it++) {
    //---------------------------------------------------------------------
    // The call to the conjugate gradient routine:
    //---------------------------------------------------------------------
    conj_grad(colidx, rowstr, x, z, a, p, q, r, &rnorm);

    //---------------------------------------------------------------------
    // zeta = shift + 1/(x.z)
    // So, first: (x.z)
    // Also, find norm of z
    // So, first: (z.z)
    //---------------------------------------------------------------------
    norm_temp1 = 0.0;
    norm_temp2 = 0.0;
	#pragma acc parallel loop num_gangs((end+127)/128) num_workers(4) \
                         vector_length(32) reduction(+:norm_temp2)
    for (j = 0; j < end; j++) {
      //norm_temp1 = norm_temp1 + x[j] * z[j];
      norm_temp2 = norm_temp2 + z[j] * z[j];
    }

    norm_temp2 = 1.0 / sqrt(norm_temp2);

    //---------------------------------------------------------------------
    // Normalize z to obtain x
    //---------------------------------------------------------------------
	#pragma acc kernels loop gang((end+127)/128) vector(128) 
    for (j = 0; j < end; j++) {     
      x[j] = norm_temp2 * z[j];
    }
  } // end of do one iteration untimed


  //---------------------------------------------------------------------
  // set starting vector to (1, 1, .... 1)
  //---------------------------------------------------------------------
  na_gangs = NA+1;
  #pragma acc kernels loop gang((na_gangs+127)/128) vector(128)
  for (i = 0; i < NA+1; i++) {
    x[i] = 1.0;
  }

  zeta = 0.0;

  timer_stop(T_init);

  printf(" Initialization time = %15.3f seconds\n", timer_read(T_init));

  timer_start(T_bench);

  //---------------------------------------------------------------------
  //---->
  // Main Iteration for inverse power method
  //---->
  //---------------------------------------------------------------------
  for (it = 1; it <= NITER; it++) {
    //---------------------------------------------------------------------
    // The call to the conjugate gradient routine:
    //---------------------------------------------------------------------
    conj_grad(colidx, rowstr, x, z, a, p, q, r, &rnorm);

    //---------------------------------------------------------------------
    // zeta = shift + 1/(x.z)
    // So, first: (x.z)
    // Also, find norm of z
    // So, first: (z.z)
    //---------------------------------------------------------------------
    norm_temp1 = 0.0;
    norm_temp2 = 0.0;
	#pragma acc parallel loop gang worker vector num_gangs((end+127)/128) num_workers(4) \
                              vector_length(32) reduction(+:norm_temp1,norm_temp2)
    for (j = 0; j < end; j++) {
      norm_temp1 = norm_temp1 + x[j]*z[j];
      norm_temp2 = norm_temp2 + z[j]*z[j];
    }

    norm_temp2 = 1.0 / sqrt(norm_temp2);

    zeta = SHIFT + 1.0 / norm_temp1;
    if (it == 1) 
      printf("\n   iteration           ||r||                 zeta\n");
    printf("    %5d       %20.14E%20.13f\n", it, rnorm, zeta);

    //---------------------------------------------------------------------
    // Normalize z to obtain x
    //---------------------------------------------------------------------
	#pragma acc kernels loop gang((end+127)/128) vector(128)
    for (j = 0; j < end; j++) {
      x[j] = norm_temp2 * z[j];
    }
  } // end of main iter inv pow meth

  timer_stop(T_bench);
}/*end acc data*/
  //---------------------------------------------------------------------
  // End of timed section
  //---------------------------------------------------------------------

  t = timer_read(T_bench);

  printf(" Benchmark completed\n");

  epsilon = 1.0e-10;
  if (Class != 'U') {
    err = fabs(zeta - zeta_verify_value) / zeta_verify_value;
    if (err <= epsilon) {
      verified = true;
      printf(" VERIFICATION SUCCESSFUL\n");
      printf(" Zeta is    %20.13E\n", zeta);
      printf(" Error is   %20.13E\n", err);
    } else {
      verified = false;
      printf(" VERIFICATION FAILED\n");
      printf(" Zeta                %20.13E\n", zeta);
      printf(" The correct zeta is %20.13E\n", zeta_verify_value);
    }
  } else {
    verified = false;
    printf(" Problem size unknown\n");
    printf(" NO VERIFICATION PERFORMED\n");
  }

  if (t != 0.0) {
    mflops = (double)(2*NITER*NA)
                   * (3.0+(double)(NONZER*(NONZER+1))
                     + 25.0*(5.0+(double)(NONZER*(NONZER+1)))
                     + 3.0) / t / 1000000.0;
  } else {
    mflops = 0.0;
  }

  print_results("CG", Class, NA, 0, 0,
                NITER, t,
                mflops, "          floating point", 
                verified, NPBVERSION, COMPILETIME,
                CS1, CS2, CS3, CS4, CS5, CS6, CS7);

  //---------------------------------------------------------------------
  // More timers
  //---------------------------------------------------------------------
  if (timeron) {
    tmax = timer_read(T_bench);
    if (tmax == 0.0) tmax = 1.0;
    printf("  SECTION   Time (secs)\n");
    for (i = 0; i < T_last; i++) {
      t = timer_read(i);
      if (i == T_init) {
        printf("  %8s:%9.3f\n", t_names[i], t);
      } else {
        printf("  %8s:%9.3f  (%6.2f%%)\n", t_names[i], t, t*100.0/tmax);
        if (i == T_conj_grad) {
          t = tmax - t;
          printf("    --> %8s:%9.3f  (%6.2f%%)\n", "rest", t, t*100.0/tmax);
        }
      }
    }
  }
  acc_shutdown(acc_device_default);
  printf("conj calls=%d, loop iter = %d. \n", conj_calls, loop_iter);
  return 0;
}


//---------------------------------------------------------------------
// Floaging point arrays here are named as in NPB1 spec discussion of 
// CG algorithm
//---------------------------------------------------------------------
static void conj_grad(int colidx[],
                      int rowstr[],
                      double x[],
                      double z[],
                      double a[],
                      double p[],
                      double q[],
                      double r[],
                      double *rnorm)
{
  int j, k,tmp1,tmp2,tmp3;
  int end;
  int cgit, cgitmax = 25;
  double d, sum, rho, rho0, alpha, beta;
  double sum_array[NA+2];
  conj_calls ++;
  rho = 0.0;
  unsigned int num_gangs = 0;
 #pragma acc data present(colidx[0:nz], \
						 rowstr[0:na+1], \
						 x[0:na+2],z[0:na+2], \
						 a[0:nz],p[0:na+2], \
						 q[0:na+2],r[0:na+2])
{
  //---------------------------------------------------------------------
  // Initialize the CG algorithm:
  //---------------------------------------------------------------------
  #pragma acc kernels loop gang((naa+127)/128) vector(128) independent
  for (j = 0; j < naa; j++) {
    q[j] = 0.0;
    z[j] = 0.0;
    r[j] = x[j];
    p[j] = r[j];
  }

  //---------------------------------------------------------------------
  // rho = r.r
  // Now, obtain the norm of r: First, sum squares of r elements locally...
  //---------------------------------------------------------------------
  //num_gangs = (lastcol - firstcol + 1)/128;
  #pragma acc parallel loop gang worker vector num_gangs((lastcol-firstcol+1+127)/128) \
                            num_workers(4) vector_length(32) reduction(+:rho) 
  for (j = 0; j < lastcol - firstcol + 1; j++) {
    rho = rho + r[j]*r[j];
  }
  
  //---------------------------------------------------------------------
  //---->
  // The conj grad iteration loop
  //---->
  //---------------------------------------------------------------------
//#pragma acc kernels loop private(cgit,j,k)
  for (cgit = 1; cgit <= cgitmax; cgit++) {
  //#pragma acc update host(p[0:NA+2])
    //---------------------------------------------------------------------
    // q = A.p
    // The partition submatrix-vector multiply: use workspace w
    //---------------------------------------------------------------------
    //
    // NOTE: this version of the multiply is actually (slightly: maybe %5) 
    //       faster on the sp2 on 16 nodes than is the unrolled-by-2 version 
    //       below.   On the Cray t3d, the reverse is true, i.e., the 
    //       unrolled-by-two version is some 10% faster.  
    //       The unrolled-by-8 version below is significantly faster
    //       on the Cray t3d - overall speed of code is 1.5 times faster.
	/*
    for (j = 0; j < lastrow - firstrow + 1; j++) {
        sum_array[j]=0.0; 
    }     
    for (j = 0; j < lastrow - firstrow + 1; j++) {
      tmp1=rowstr[j];
      tmp2=rowstr[j+1];
      for (k = tmp1; k < tmp2; k++) {
        tmp3=colidx[k];
        sum_array[j] = sum_array[j] + a[k]*p[tmp3];
      }
      q[j] = sum_array[j];
    }
	*/
    loop_iter ++;
    //num_gangs = (lastrow - firstrow + 1)/128;
    end = lastrow - firstrow + 1;

	#pragma acc parallel num_gangs(end) num_workers(4) vector_length(32)
	{
		#pragma acc loop gang 	
		for (j = 0; j < end; j++) {
		  tmp1 = rowstr[j];
		  tmp2 = rowstr[j+1];
		  sum = 0.0;
		  #pragma acc loop worker vector reduction(+:sum)
		  for (k = tmp1; k < tmp2; k++) {
			tmp3 = colidx[k];
		    sum = sum + a[k]*p[tmp3];
		  }
		  q[j] = sum;
		}
    }
    //---------------------------------------------------------------------
    // Obtain p.q
    //---------------------------------------------------------------------
    d = 0.0;
	end = lastcol - firstcol + 1;
	#pragma acc parallel num_gangs((end+127)/128) num_workers(4) vector_length(32)
	{
		#pragma acc loop gang worker vector reduction(+:d) 
		for (j = 0; j < end; j++) {
		  d = d + p[j]*q[j];
		}
    }

    //---------------------------------------------------------------------
    // Obtain alpha = rho / (p.q)
    //---------------------------------------------------------------------
    alpha = rho / d;

    //---------------------------------------------------------------------
    // Save a temporary of rho
    //---------------------------------------------------------------------
    rho0 = rho;

    //---------------------------------------------------------------------
    // Obtain z = z + alpha*p
    // and    r = r - alpha*q
    //---------------------------------------------------------------------
    rho = 0.0;
	#pragma acc kernels loop gang((end+1023)/1024) vector(1024) independent
    for (j = 0; j < end; j++) {
      z[j] = z[j] + alpha*p[j];
      r[j] = r[j] - alpha*q[j];
    }
              
    //---------------------------------------------------------------------
    // rho = r.r
    // Now, obtain the norm of r: First, sum squares of r elements locally...
    //---------------------------------------------------------------------
	#pragma acc parallel num_gangs((end+127)/128) num_workers(4) vector_length(32)
	{
		#pragma acc loop gang worker vector reduction(+:rho)
		for (j = 0; j < end; j++) 
		{
		  rho = rho + r[j]*r[j];
		}
    }

    //---------------------------------------------------------------------
    // Obtain beta:
    //---------------------------------------------------------------------
    beta = rho / rho0;

    //---------------------------------------------------------------------
    // p = r + beta*p
    //---------------------------------------------------------------------
	#pragma acc kernels loop gang((end+127)/128) vector(128) independent
    for (j = 0; j < end; j++) {
      p[j] = r[j] + beta*p[j];
    } 
  } // end of do cgit=1,cgitmax

  //---------------------------------------------------------------------
  // Compute residual norm explicitly:  ||r|| = ||x - A.z||
  // First, form A.z
  // The partition submatrix-vector multiply
  //---------------------------------------------------------------------

  end = lastrow - firstrow + 1;
  //num_gangs = end/128;
  #pragma acc parallel loop gang num_gangs(end) \
                       num_workers(4) vector_length(32)
  for (j = 0; j < end; j++) {
    tmp1=rowstr[j];
    tmp2=rowstr[j+1];
    d = 0.0;
	#pragma acc loop worker vector reduction(+:d)
    for (k = tmp1; k < tmp2; k++) {
        tmp3=colidx[k];
        d = d + a[k]*z[tmp3];
    }
    r[j] = d;
  }
   
  //---------------------------------------------------------------------
  // At this point, r contains A.z 
  //---------------------------------------------------------------------
  sum = 0.0;
  //num_gangs = (lastcol-firstcol+1)/128;
  #pragma acc parallel loop gang worker vector \
                       num_gangs((lastcol-firstcol+1+127)/128) \
                       num_workers(4) vector_length(32) \
                       reduction(+:sum)
  for (j = 0; j < lastcol-firstcol+1; j++) {
    d   = x[j] - r[j];
    sum = sum + d*d;
  }

}/*end acc data*/
  *rnorm = sqrt(sum);
}


//---------------------------------------------------------------------
// generate the test problem for benchmark 6
// makea generates a sparse matrix with a
// prescribed sparsity distribution
//
// parameter    type        usage
//
// input
//
// n            i           number of cols/rows of matrix
// nz           i           nonzeros as declared array size
// rcond        r*8         condition number
// shift        r*8         main diagonal shift
//
// output
//
// a            r*8         array for nonzeros
// colidx       i           col indices
// rowstr       i           row pointers
//
// workspace
//
// iv, arow, acol i
// aelt           r*8
//---------------------------------------------------------------------
static void makea(int n,
                  int nz,
                  double a[],
                  int colidx[],
                  int rowstr[],
                  int firstrow,
                  int lastrow,
                  int firstcol,
                  int lastcol,
                  int arow[],
                  int acol[][NONZER+1],
                  double aelt[][NONZER+1],
                  int iv[])
{
  int iouter, ivelt, nzv, nn1;
  int ivc[NONZER+1];
  double vc[NONZER+1];

  //---------------------------------------------------------------------
  // nonzer is approximately  (int(sqrt(nnza /n)));
  //---------------------------------------------------------------------

  //---------------------------------------------------------------------
  // nn1 is the smallest power of two not less than n
  //---------------------------------------------------------------------
  nn1 = 1;
  do {
    nn1 = 2 * nn1;
  } while (nn1 < n);

  //---------------------------------------------------------------------
  // Generate nonzero positions and save for the use in sparse.
  //---------------------------------------------------------------------
  for (iouter = 0; iouter < n; iouter++) {
    nzv = NONZER;
    sprnvc(n, nzv, nn1, vc, ivc);
    vecset(n, vc, ivc, &nzv, iouter+1, 0.5);
    arow[iouter] = nzv;
    
    for (ivelt = 0; ivelt < nzv; ivelt++) {
      acol[iouter][ivelt] = ivc[ivelt] - 1;
      aelt[iouter][ivelt] = vc[ivelt];
    }
  }

  //---------------------------------------------------------------------
  // ... make the sparse matrix from list of elements with duplicates
  //     (iv is used as  workspace)
  //---------------------------------------------------------------------
  sparse(a, colidx, rowstr, n, nz, NONZER, arow, acol, 
         aelt, firstrow, lastrow,
         iv, RCOND, SHIFT);
}


//---------------------------------------------------------------------
// rows range from firstrow to lastrow
// the rowstr pointers are defined for nrows = lastrow-firstrow+1 values
//---------------------------------------------------------------------
static void sparse(double a[],
                   int colidx[],
                   int rowstr[],
                   int n,
                   int nz,
                   int nozer,
                   int arow[],
                   int acol[][NONZER+1],
                   double aelt[][NONZER+1],
                   int firstrow,
                   int lastrow,
                   int nzloc[],
                   double rcond,
                   double shift)
{
  int nrows;

  //---------------------------------------------------
  // generate a sparse matrix from a list of
  // [col, row, element] tri
  //---------------------------------------------------
  int i, j, j1, j2, nza, k, kk, nzrow, jcol;
  double size, scale, ratio, va;
  logical cont40;

  //---------------------------------------------------------------------
  // how many rows of result
  //---------------------------------------------------------------------
  nrows = lastrow - firstrow + 1;

  //---------------------------------------------------------------------
  // ...count the number of triples in each row
  //---------------------------------------------------------------------
  for (j = 0; j < nrows+1; j++) {
    rowstr[j] = 0;
  }

  for (i = 0; i < n; i++) {
    for (nza = 0; nza < arow[i]; nza++) {
      j = acol[i][nza] + 1;
      rowstr[j] = rowstr[j] + arow[i];
    }
  }

  rowstr[0] = 0;
  for (j = 1; j < nrows+1; j++) {
    rowstr[j] = rowstr[j] + rowstr[j-1];
  }
  nza = rowstr[nrows] - 1;

  //---------------------------------------------------------------------
  // ... rowstr(j) now is the location of the first nonzero
  //     of row j of a
  //---------------------------------------------------------------------
  if (nza > nz) {
    printf("Space for matrix elements exceeded in sparse\n");
    printf("nza, nzmax = %d, %d\n", nza, nz);
    exit(EXIT_FAILURE);
  }

  //---------------------------------------------------------------------
  // ... preload data pages
  //---------------------------------------------------------------------
  for (j = 0; j < nrows; j++) {
    for (k = rowstr[j]; k < rowstr[j+1]; k++) {
      a[k] = 0.0;
      colidx[k] = -1;
    }
    nzloc[j] = 0;
  }

  //---------------------------------------------------------------------
  // ... generate actual values by summing duplicates
  //---------------------------------------------------------------------
  size = 1.0;
  ratio = pow(rcond, (1.0 / (double)(n)));

  for (i = 0; i < n; i++) {
    for (nza = 0; nza < arow[i]; nza++) {
      j = acol[i][nza];

      scale = size * aelt[i][nza];
      for (nzrow = 0; nzrow < arow[i]; nzrow++) {
        jcol = acol[i][nzrow];
        va = aelt[i][nzrow] * scale;

        //--------------------------------------------------------------------
        // ... add the identity * rcond to the generated matrix to bound
        //     the smallest eigenvalue from below by rcond
        //--------------------------------------------------------------------
        if (jcol == j && j == i) {
          va = va + rcond - shift;
        }

        cont40 = false;
        for (k = rowstr[j]; k < rowstr[j+1]; k++) {
          if (colidx[k] > jcol) {
            //----------------------------------------------------------------
            // ... insert colidx here orderly
            //----------------------------------------------------------------
            for (kk = rowstr[j+1]-2; kk >= k; kk--) {
              if (colidx[kk] > -1) {
                a[kk+1]  = a[kk];
                colidx[kk+1] = colidx[kk];
              }
            }
            colidx[k] = jcol;
            a[k]  = 0.0;
            cont40 = true;
            break;
          } else if (colidx[k] == -1) {
            colidx[k] = jcol;
            cont40 = true;
            break;
          } else if (colidx[k] == jcol) {
            //--------------------------------------------------------------
            // ... mark the duplicated entry
            //--------------------------------------------------------------
            nzloc[j] = nzloc[j] + 1;
            cont40 = true;
            break;
          }
        }
        if (cont40 == false) {
          printf("internal error in sparse: i=%d\n", i);
          exit(EXIT_FAILURE);
        }
        a[k] = a[k] + va;
      }
    }
    size = size * ratio;
  }

  //---------------------------------------------------------------------
  // ... remove empty entries and generate final results
  //---------------------------------------------------------------------
  for (j = 1; j < nrows; j++) {
    nzloc[j] = nzloc[j] + nzloc[j-1];
  }

  for (j = 0; j < nrows; j++) {
    if (j > 0) {
      j1 = rowstr[j] - nzloc[j-1];
    } else {
      j1 = 0;
    }
    j2 = rowstr[j+1] - nzloc[j];
    nza = rowstr[j];
    for (k = j1; k < j2; k++) {
      a[k] = a[nza];
      colidx[k] = colidx[nza];
      nza = nza + 1;
    }
  }
  for (j = 1; j < nrows+1; j++) {
    rowstr[j] = rowstr[j] - nzloc[j-1];
  }
  nza = rowstr[nrows] - 1;
}


//---------------------------------------------------------------------
// generate a sparse n-vector (v, iv)
// having nzv nonzeros
//
// mark(i) is set to 1 if position i is nonzero.
// mark is all zero on entry and is reset to all zero before exit
// this corrects a performance bug found by John G. Lewis, caused by
// reinitialization of mark on every one of the n calls to sprnvc
//---------------------------------------------------------------------
static void sprnvc(int n, int nz, int nn1, double v[], int iv[])
{
  int nzv, ii, i;
  double vecelt, vecloc;

  nzv = 0;

  while (nzv < nz) {
    vecelt = randlc(&tran, amult);

    //---------------------------------------------------------------------
    // generate an integer between 1 and n in a portable manner
    //---------------------------------------------------------------------
    vecloc = randlc(&tran, amult);
    i = icnvrt(vecloc, nn1) + 1;
    if (i > n) continue;

    //---------------------------------------------------------------------
    // was this integer generated already?
    //---------------------------------------------------------------------
    logical was_gen = false;
    for (ii = 0; ii < nzv; ii++) {
      if (iv[ii] == i) {
        was_gen = true;
        break;
      }
    }
    if (was_gen) continue;
    v[nzv] = vecelt;
    iv[nzv] = i;
    nzv = nzv + 1;
  }
}


//---------------------------------------------------------------------
// scale a double precision number x in (0,1) by a power of 2 and chop it
//---------------------------------------------------------------------
static int icnvrt(double x, int ipwr2)
{
  return (int)(ipwr2 * x);
}


//---------------------------------------------------------------------
// set ith element of sparse vector (v, iv) with
// nzv nonzeros to val
//---------------------------------------------------------------------
static void vecset(int n, double v[], int iv[], int *nzv, int i, double val)
{
  int k;
  logical set;

  set = false;
  for (k = 0; k < *nzv; k++) {
    if (iv[k] == i) {
      v[k] = val;
      set  = true;
    }
  }
  if (set == false) {
    v[*nzv]  = val;
    iv[*nzv] = i;
    *nzv     = *nzv + 1;
  }
}


########## NEXT FILE ##########
ep.c:::
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB EP code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS EP code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

//--------------------------------------------------------------------
//      program EMBAR
//--------------------------------------------------------------------
//  This is the OpenACC version of the APP Benchmark 1,
//  the "embarassingly parallel" benchmark.
//
//
//  M is the Log_2 of the number of complex pairs of uniform (0, 1) random
//  numbers.  MK is the Log_2 of the size of each batch of uniform random
//  numbers.  MK can be set for convenience on a given system, since it does
//  not affect the results.
//--------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include "type.h"
#include "npbparams.h"
#include "timers.h"
#include "print_results.h"
#include <openacc.h>

#define MAX(X,Y)  (((X) > (Y)) ? (X) : (Y))

int MK;
int MM;
int NN;
double EPSILON;
double A;
double S;
int NK;
int NQ;

int BLKSIZE;

double r23;
double r46;
double t23;
double t46;

inline double randlc_ep( double *x, double a )
{
  //--------------------------------------------------------------------
  //
  //  This routine returns a uniform pseudorandom double precision number in the
  //  range (0, 1) by using the linear congruential generator
  //
  //  x_{k+1} = a x_k  (mod 2^46)
  //
  //  where 0 < x_k < 2^46 and 0 < a < 2^46.  This scheme generates 2^44 numbers
  //  before repeating.  The argument A is the same as 'a' in the above formula,
  //  and X is the same as x_0.  A and X must be odd double precision integers
  //  in the range (1, 2^46).  The returned value randlc_ep is normalized to be
  //  between 0 and 1, i.e. randlc_ep = 2^(-46) * x_1.  X is updated to contain
  //  the new seed x_1, so that subsequent calls to randlc_ep using the same
  //  arguments will generate a continuous sequence.
  //
  //  This routine should produce the same results on any computer with at least
  //  48 mantissa bits in double precision floating point data.  On 64 bit
  //  systems, double precision should be disabled.
  //
  //  David H. Bailey     October 26, 1990
  //
  //--------------------------------------------------------------------

  // r23 = pow(0.5, 23.0);
  ////  pow(0.5, 23.0) = 1.1920928955078125e-07
  // r46 = r23 * r23;
  // t23 = pow(2.0, 23.0);
  ////  pow(2.0, 23.0) = 8.388608e+06
  // t46 = t23 * t23;
/*
  const double r23 = 1.1920928955078125e-07;
  const double r46 = r23 * r23;
  const double t23 = 8.388608e+06;
  const double t46 = t23 * t23;
*/
  double t1, t2, t3, t4, a1, a2, x1, x2, z;
  double r;

  //--------------------------------------------------------------------
  //  Break A into two parts such that A = 2^23 * A1 + A2.
  //--------------------------------------------------------------------
  t1 = r23 * a;
  a1 = (int) t1;
  a2 = a - t23 * a1;

  //--------------------------------------------------------------------
  //  Break X into two parts such that X = 2^23 * X1 + X2, compute
  //  Z = A1 * X2 + A2 * X1  (mod 2^23), and then
  //  X = 2^23 * Z + A2 * X2  (mod 2^46).
  //--------------------------------------------------------------------
  t1 = r23 * (*x);
  x1 = (int) t1;
  x2 = *x - t23 * x1;
  t1 = a1 * x2 + a2 * x1;
  t2 = (int) (r23 * t1);
  z = t1 - t23 * t2;
  t3 = t23 * z + a2 * x2;
  t4 = (int) (r46 * t3);
  *x = t3 - t46 * t4;
  r = r46 * (*x);

  return r;
}

int main() 
{
  double Mops, t1, t2, t3, t4, x1, x2;
  double sx, sy, tm, an, tt, gc;
  double sx_verify_value, sy_verify_value, sx_err, sy_err;
  int    np;
  int    i, ik, kk, l, k, nit;
  int    k_offset, j;
  int verified, timers_enabled;
  double q0, q1, q2, q3, q4, q5, q6, q7, q8, q9;
    
    MK =  16;
    MM =  (M - MK);
    NN =       (1 << MM);
    EPSILON =  1.0e-8;
    A =        1220703125.0;
    S =        271828183.0;
    NK = 1 << MK;
    NQ = 10;

  //  BLKSIZE = 1792;
    BLKSIZE = 2048;

    r23 = 1.1920928955078125e-07;
    r46 = r23 * r23;
    t23 = 8.388608e+06;
    t46 = t23 * t23;

  double x[2*(1<<16)];
  double q[10]; 
  double *xx, *qq;
  
  /*variables for inlining vranlc()*/
  double in_t1, in_t2, in_t3, in_t4;
  double in_a1, in_a2, in_x1, in_x2, in_z;

  double tmp_sx, tmp_sy;
  double dum[3] = {1.0, 1.0, 1.0};
  char   size[16];
    

  int blksize = BLKSIZE;
  int blk, koff, numblks;

  FILE *fp;

  acc_init(acc_device_default);

  if ((fp = fopen("timer.flag", "r")) == NULL) {
    timers_enabled = 0;
  } else {
    timers_enabled = 1;
    fclose(fp);
  }

  if (NN < blksize) {
     blksize = NN;
  }
  numblks = ceil( (double)NN / (double) blksize);

  xx = (double*)malloc(blksize*2*NK*sizeof(double));
  qq = (double*)malloc(blksize*NQ*sizeof(double));

  //--------------------------------------------------------------------
  //  Because the size of the problem is too large to store in a 32-bit
  //  integer for some classes, we put it into a string (for printing).
  //  Have to strip off the decimal point put in there by the floating
  //  point print statement (internal file)
  //--------------------------------------------------------------------

  sprintf(size, "%15.0lf", pow(2.0, M+1));
  j = 14;
  if (size[j] == '.') j--;
  size[j+1] = '\0';
  printf("\n\n NAS Parallel Benchmarks (NPB3.3-ACC-C) - EP Benchmark\n");
  printf("\n Number of random numbers generated: %15s\n", size);

  verified = 0;

  //--------------------------------------------------------------------
  //  Compute the number of "batches" of random number pairs generated 
  //  per processor. Adjust if the number of processors does not evenly 
  //  divide the total number
  //--------------------------------------------------------------------

  np = NN; 
printf("NK=%d NN=%d NQ=%d BLKS=%d NBLKS=%d\n",NK,NN,NQ,blksize,numblks);
  //--------------------------------------------------------------------
  //  Call the random number generator functions and initialize
  //  the x-array to reduce the effects of paging on the timings.
  //  Also, call all mathematical functions that are used. Make
  //  sure these initializations cannot be eliminated as dead code.
  //--------------------------------------------------------------------
#pragma acc data create(xx[0:blksize*2*NK],qq[0:blksize*NQ]) copyout(q[0:NQ])
{
  vranlc(0, &dum[0], dum[1], &dum[2]);
  dum[0] = randlc_ep(&dum[1], dum[2]);

#pragma acc parallel num_gangs((NQ+127)/128) vector_length(128) present(q[0:NQ])
{
  #pragma acc loop gang vector
  for (i = 0; i < NQ; i++) {
    q[i] = 0.0;
  }
}
  Mops = log(sqrt(fabs(MAX(1.0, 1.0))));   

  timer_clear(0);
  timer_clear(1);
  timer_clear(2);
  timer_start(0);

  /*this function actullay does nothing, so comment it*/
  //vranlc(0, &t1, A, x);

  //#pragma acc update device(x[0:2*NK])
  //--------------------------------------------------------------------
  //  Compute AN = A ^ (2 * NK) (mod 2^46).
  //--------------------------------------------------------------------

  t1 = A;

  for (i = 0; i < MK + 1; i++) {
    t2 = randlc_ep(&t1, t1);
  }

  an = t1;
  tt = S;
  gc = 0.0;
  sx = 0.0;
  sy = 0.0;
  k_offset = -1;

for (blk=0; blk < numblks; ++blk) {

 koff = blk*blksize;

 if (koff + blksize > np) {
     blksize = np - (blk*blksize);
 }
 
#pragma acc parallel num_gangs(blksize) vector_length(128) present(qq[0:blksize*NQ])
{
 #pragma acc loop gang
 for(k=0; k<blksize; k++)
  {
    #pragma acc loop vector
  	for(i=0; i<NQ; i++)
		qq[k*NQ + i] = 0.0;
  }
}

/*
#pragma acc parallel num_gangs(blksize) vector_length(128) present(xx[0:blksize*2*NK])
{
 #pragma acc loop gang
 for(k=0; k<blksize; k++)
  {
	#pragma acc loop vector
	for(i=0; i<2*NK; i++)
		xx[k*2*NK + i] = -1.0e99;
  }
 }
*/
  //--------------------------------------------------------------------
  //  Each instance of this loop may be performed independently. We compute
  //  the k offsets separately to take into account the fact that some nodes
  //  have more numbers to generate than others
  //--------------------------------------------------------------------


#pragma acc parallel num_gangs((blksize+255)/256) num_workers(1) vector_length(256) \
                     present(xx[0:blksize*2*NK],qq[0:blksize*NQ]) 
{ 
  #pragma acc loop gang worker vector reduction(+:sx,sy)
  for (k = 1; k <= blksize; k++) {
    kk = k_offset + k + koff; 
    t1 = S;
    t2 = an;

    // Find starting seed t1 for this kk.

    for (i = 1; i <= 100; i++) {
      ik = kk / 2;
      if ((2 * ik) != kk)
      {
        in_t1 = r23 * t2;
        in_a1 = (int)in_t1;
        in_a2 = t2 - t23 * in_a1;
        
        in_t1 = r23 * t1;
        in_x1 = (int)in_t1;
        in_x2 = t1 - t23 * in_x1;
        in_t1 = in_a1 * in_x2 + in_a2 * in_x1;
        in_t2 = (int)(r23 * in_t1);
        in_z = in_t1 - t23 * in_t2;
        in_t3 = t23 * in_z + in_a2 * in_x2;
        in_t4 = (int)(r46 * in_t3);
        t1 = in_t3 - t46 * in_t4;
        t3 = r46 * t1;
      }
      if (ik == 0) break;
        in_t1 = r23 * t2;
        in_a1 = (int)in_t1;
        in_a2 = t2 - t23 * in_a1;
        
        in_t1 = r23 * t2;
        in_x1 = (int)in_t1;
        in_x2 = t2 - t23 * in_x1;
        in_t1 = in_a1 * in_x2 + in_a2 * in_x1;
        in_t2 = (int)(r23 * in_t1);
        in_z = in_t1 - t23 * in_t2;
        in_t3 = t23 * in_z + in_a2 * in_x2;
        in_t4 = (int)(r46 * in_t3);
        t2 = in_t3 - t46 * in_t4;
        t3 = r46 * t2;
      kk = ik;
    }

    //--------------------------------------------------------------------
    //  Compute uniform pseudorandom numbers.
    //--------------------------------------------------------------------
    //vranlc(2 * NK, &t1, A, x);
	/*inline vranlc function*/
    in_t1 = r23 * A;
    in_a1 = (int)in_t1;
    in_a2 = A - t23 * in_a1;

    for(i=0; i<2*NK; i++)
    {
		in_t1 = r23 * t1;
		in_x1 = (int)in_t1;
		in_x2 = t1 - t23 * in_x1;
		in_t1 = in_a1 * in_x2 + in_a2 * in_x1;
		in_t2 = (int)(r23 * in_t1);
		in_z = in_t1 - t23 * in_t2;
		in_t3 = t23*in_z + in_a2 *in_x2;
		in_t4 = (int)(r46 * in_t3);
		t1 = in_t3 - t46 * in_t4;
        xx[i*blksize + (k-1)] = r46 * t1;
    }

    //--------------------------------------------------------------------
    //  Compute Gaussian deviates by acceptance-rejection method and 
    //  tally counts in concentri//square annuli.  This loop is not 
    //  vectorizable. 
    //--------------------------------------------------------------------
    //if (timers_enabled) timer_start(1);

	tmp_sx = 0.0;
	tmp_sy = 0.0;

    for (i = 0; i < NK; i++) {
      x1 = 2.0 * xx[2*i*blksize + (k-1)] - 1.0;
      x2 = 2.0 * xx[(2*i+1)*blksize + (k-1)] - 1.0;
      t1 = x1 * x1 + x2 * x2;
      if (t1 <= 1.0) {
        t2   = sqrt(-2.0 * log(t1) / t1);
        t3   = (x1 * t2); 
        t4   = (x2 * t2); 
        l    = MAX(fabs(t3), fabs(t4));
        qq[l*blksize + (k-1)] += 1.0;
        tmp_sx   = tmp_sx + t3;  
        tmp_sy   = tmp_sy + t4;  
      }
    }

    sx += tmp_sx;
    sy += tmp_sy;

  }
}/*end acc parallel*/

  //  printf("sx=%f,sy=%f\n", sx, sy);
  #pragma acc parallel num_gangs(NQ) num_workers(4) vector_length(32) \
                       present(q[0:NQ],qq[0:blksize*NQ])
  {
	#pragma acc loop gang reduction(+:gc) 
	for(i=0; i<NQ; i++)
	{
		double sum_qi = 0.0;
		#pragma acc loop worker vector reduction(+:sum_qi)
		for(k=0; k<blksize; k++)
			sum_qi = sum_qi + qq[i*blksize + k];
		/*sum of each column of qq/q[i] */
		q[i] += sum_qi;
		/*final sum of q*/
		gc += sum_qi;
	}
   }
 }
 
}/*end acc data*/

  timer_stop(0);
  tm = timer_read(0);

  nit = 0;
  verified = 1;
  if (M == 24) {
    sx_verify_value = -3.247834652034740e+3;
    sy_verify_value = -6.958407078382297e+3;
  } else if (M == 25) {
    sx_verify_value = -2.863319731645753e+3;
    sy_verify_value = -6.320053679109499e+3;
  } else if (M == 28) {
    sx_verify_value = -4.295875165629892e+3;
    sy_verify_value = -1.580732573678431e+4;
  } else if (M == 30) {
    sx_verify_value =  4.033815542441498e+4;
    sy_verify_value = -2.660669192809235e+4;
  } else if (M == 32) {
    sx_verify_value =  4.764367927995374e+4;
    sy_verify_value = -8.084072988043731e+4;
  } else if (M == 36) {
    sx_verify_value =  1.982481200946593e+5;
    sy_verify_value = -1.020596636361769e+5;
  } else if (M == 40) {
    sx_verify_value = -5.319717441530e+05;
    sy_verify_value = -3.688834557731e+05;
  } else {
    verified = 0;
  }

  if (verified) {
    sx_err = fabs((sx - sx_verify_value) / sx_verify_value);
    sy_err = fabs((sy - sy_verify_value) / sy_verify_value);
    verified = ((sx_err <= EPSILON) && (sy_err <= EPSILON));
  }

  Mops = pow(2.0, M+1) / tm / 1000000.0;

  printf("\nEP Benchmark Results:\n\n");
  printf("CPU Time =%10.4lf\n", tm);
  printf("N = 2^%5d\n", M);
  printf("No. Gaussian Pairs = %15.0lf\n", gc);
  printf("Sums = %25.15lE %25.15lE\n", sx, sy);
  printf("Counts: \n");
  for (i = 0; i < NQ; i++) {
    printf("%3d%15.0lf\n", i, q[i]);
  }

  print_results("EP", CLASS, M+1, 0, 0, nit,
      tm, Mops, 
      "Random numbers generated",
      verified, NPBVERSION, COMPILETIME, CS1,
      CS2, CS3, CS4, CS5, CS6, CS7);

  if (timers_enabled) {
    if (tm <= 0.0) tm = 1.0;
    tt = timer_read(0);
    printf("\nTotal time:     %9.3lf (%6.2lf)\n", tt, tt*100.0/tm);
    tt = timer_read(1);
    printf("Gaussian pairs: %9.3lf (%6.2lf)\n", tt, tt*100.0/tm);
    tt = timer_read(2);
    printf("Random numbers: %9.3lf (%6.2lf)\n", tt, tt*100.0/tm);
  }

	free(xx);
	free(qq);

  return 0;
}

########## NEXT FILE ##########
ft.c:::
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is an OpenMP C version of the NPB FT code. This OpenMP  //
//  C version is developed by the Center for Manycore Programming at Seoul //
//  National University and derived from the OpenMP Fortran versions in    //
//  "NPB3.3-OMP" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this OpenMP C version to              //
//  cmp@aces.snu.ac.kr                                                     //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS FT code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

//---------------------------------------------------------------------
// FT benchmark
//---------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "npbparams.h"
#include <openacc.h>

#include "randdp.h"
#include "timers.h"
#include "print_results.h"

//#define FFTBLOCKPAD_DEFAULT   33
//#define FFTBLOCK_DEFAULT      32
#define FFTBLOCKPAD   33
#define FFTBLOCK      32

typedef enum { false, true } logical;
typedef struct { 
  double real;
  double imag;
} dcomplex;

/* common /blockinfo/ */
static int fftblock, fftblockpad;

static int dims[3];

#define T_total       1
#define T_setup       2
#define T_fft         3
#define T_evolve      4
#define T_checksum    5 
#define T_fftx        6
#define T_ffty        7
#define T_fftz        8
#define T_max         8

static logical timers_enabled;
static logical debug;


#define SEED          314159265.0
#define A             1220703125.0
#define PI            3.141592653589793238
#define ALPHA         1.0e-6

//static dcomplex u[NXP];
static double u_real[NXP];
static double u_imag[NXP];
static dcomplex sums[NITER_DEFAULT+1];
static int niter;

#define dcmplx(r,i)       (dcomplex){r, i}
#define dcmplx_add(a,b)   (dcomplex){(a).real+(b).real, (a).imag+(b).imag}
#define dcmplx_sub(a,b)   (dcomplex){(a).real-(b).real, (a).imag-(b).imag}
#define dcmplx_mul(a,b)   (dcomplex){((a).real*(b).real)-((a).imag*(b).imag),\
                                     ((a).real*(b).imag)+((a).imag*(b).real)}
#define dcmplx_mul2(a,b)  (dcomplex){(a).real*(b), (a).imag*(b)}
static inline dcomplex dcmplx_div(dcomplex z1, dcomplex z2) {
  double a = z1.real;
  double b = z1.imag;
  double c = z2.real;
  double d = z2.imag;

  double divisor = c*c + d*d;
  double real = (a*c + b*d) / divisor;
  double imag = (b*c - a*d) / divisor;
  dcomplex result = (dcomplex){real, imag};
  return result;
}
#define dcmplx_div2(a,b)  (dcomplex){(a).real/(b), (a).imag/(b)}
#define dcmplx_abs(x)     sqrt(((x).real*(x).real) + ((x).imag*(x).imag))

#define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}

//---------------------------------------------------------------------------
//static  dcomplex gty1[MAXDIM][MAXDIM][MAXDIM];
//static  dcomplex gty2[MAXDIM][MAXDIM][MAXDIM];
static  double gty1_real[MAXDIM][MAXDIM][MAXDIM];
static  double gty1_imag[MAXDIM][MAXDIM][MAXDIM];
static  double gty2_real[MAXDIM][MAXDIM][MAXDIM];
static  double gty2_imag[MAXDIM][MAXDIM][MAXDIM];

//---------------------------------------------------------------------
// u0, u1, u2 are the main arrays in the problem. 
// Depending on the decomposition, these arrays will have different 
// dimensions. To accomodate all possibilities, we allocate them as 
// one-dimensional arrays and pass them to subroutines for different 
// views
//  - u0 contains the initial (transformed) initial condition
//  - u1 and u2 are working arrays
//  - twiddle contains exponents for the time evolution operator. 
//---------------------------------------------------------------------
//---------------------------------------------------------------------
// Large arrays are in common so that they are allocated on the
// heap rather than the stack. This common block is not
// referenced directly anywhere else. Padding is to avoid accidental 
// cache problems, since all array sizes are powers of two.
//---------------------------------------------------------------------
/* common /bigarrays/ */
//dcomplex u0[NTOTALP];
//dcomplex pad1[3];
//dcomplex u1[NTOTALP];
//dcomplex pad2[3];
double u0_real[NTOTALP];
double u0_imag[NTOTALP];
double u1_real[NTOTALP];
double u1_imag[NTOTALP];
double twiddle[NTOTALP];
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
static void init_ui(int d1, int d2, int d3);
static void evolve(int d1, int d2, int d3);
static void compute_initial_conditions(int d1, int d2, int d3);
static double ipow46(double a, int exponent);
static void setup();
static void compute_indexmap(int d1, int d2, int d3);
static void print_timers();
static void fft(int dir);
static void cffts1_pos(int is, int d1, int d2, int d3);
static void cffts1_neg(int is, int d1, int d2, int d3);
static void cffts2_pos(int is, int d1, int d2, int d3);
static void cffts2_neg(int is, int d1, int d2, int d3);
static void cffts3_pos(int is, int d1, int d2, int d3);
static void cffts3_neg(int is, int d1, int d2, int d3);
static void fft_init(int n);
static int ilog2(int n);
static void checksum(int i, int d1, int d2, int d3);
static void verify(int d1, int d2, int d3, int nt, 
                   logical *verified, char *Class);
//---------------------------------------------------------------------------


int main(int argc, char *argv[])
{
  int i;
  int iter;
  double total_time, mflops;
  logical verified;
  char Class;

  acc_init(acc_device_default);
  //---------------------------------------------------------------------
  // Run the entire problem once to make sure all data is touched. 
  // This reduces variable startup costs, which is important for such a 
  // short benchmark. The other NPB 2 implementations are similar. 
  //---------------------------------------------------------------------
  for (i = 1; i <= T_max; i++) {
    timer_clear(i);
  }
  setup();
#pragma acc data create(u0_real,u0_imag,u1_real,u1_imag,u_real,u_imag,\
                        twiddle,gty1_real,gty1_imag, gty2_real, gty2_imag)
{
  init_ui(dims[0], dims[1], dims[2]);
  compute_indexmap(dims[0], dims[1], dims[2]);
  compute_initial_conditions(dims[0], dims[1], dims[2]);
  fft_init(dims[0]);
  fft(1);

  //---------------------------------------------------------------------
  // Start over from the beginning. Note that all operations must
  // be timed, in contrast to other benchmarks. 
  //---------------------------------------------------------------------
  for (i = 1; i <= T_max; i++) {
    timer_clear(i);
  }

  timer_start(T_total);
  if (timers_enabled) timer_start(T_setup);

  compute_indexmap(dims[0], dims[1], dims[2]);

  compute_initial_conditions(dims[0], dims[1], dims[2]);

  fft_init(dims[0]);

  fft(1);

  for (iter = 1; iter <= niter; iter++) {
    evolve(dims[0], dims[1], dims[2]);
    fft(-1);
    checksum(iter, dims[0], dims[1], dims[2]);
  }

  verify(NX, NY, NZ, niter, &verified, &Class);
  timer_stop(T_total);
  total_time = timer_read(T_total);
}

  if (total_time != 0.0) {
    mflops = 1.0e-6 * (double)NTOTAL *
            (14.8157 + 7.19641 * log((double)NTOTAL)
            + (5.23518 + 7.21113 * log((double)NTOTAL)) * niter)
            / total_time;
  } else {
    mflops = 0.0;
  }
  print_results("FT", Class, NX, NY, NZ, niter,
                total_time, mflops, "          floating point", verified, 
                NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, CS7);
  if (timers_enabled) print_timers();

  return 0;
}


//---------------------------------------------------------------------
// touch all the big data
//---------------------------------------------------------------------
static void init_ui(int d1, int d2, int d3)
{
  int i, j, k;

 #pragma acc parallel num_gangs(d3) num_workers(8) vector_length(128) \
                      present(u0_real,u0_imag,u1_real,u1_imag,twiddle)
 {
  #pragma acc loop gang
  for (k = 0; k < d3; k++) {
    #pragma acc loop worker 
    for (j = 0; j < d2; j++) {
      #pragma acc loop vector
      for (i = 0; i < d1; i++) {
        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = 0.0;
        u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = 0.0;
        u1_real[k*d2*(d1+1) + j*(d1+1) + i] = 0.0;
        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = 0.0;
        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = 0.0;
      }
    }
  }
 }
}


//---------------------------------------------------------------------
// evolve u0 -> u1 (t time steps) in fourier space
//---------------------------------------------------------------------
static void evolve(int d1, int d2, int d3)
{
  int i, j, k;

  #pragma acc parallel num_gangs(d3) num_workers(8) vector_length(128) \
                      present(u0_real,u0_imag,u1_real,u1_imag,twiddle)
  {
  #pragma acc loop gang
  for (k = 0; k < d3; k++) {
    #pragma acc loop worker 
    for (j = 0; j < d2; j++) {
      #pragma acc loop vector
      for (i = 0; i < d1; i++) {
        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]
											   *twiddle[k*d2*(d1+1) + j*(d1+1) + i];
		u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]
												*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
		
		u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
		u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
      }
    }
  }
 }
}


//---------------------------------------------------------------------
// Fill in array u0 with initial conditions from 
// random number generator 
//---------------------------------------------------------------------
static void compute_initial_conditions(int d1, int d2, int d3)
{
  int k, j;
  int NZ_var;
  NZ_var = NZ;
  double x0, start, an, dummy, starts[NZ];

  start = SEED;
  //---------------------------------------------------------------------
  // Jump to the starting element for our first plane.
  //---------------------------------------------------------------------
  an = ipow46(A, 0);
  dummy = randlc(&start, an);
  an = ipow46(A, 2*NX*NY);

  starts[0] = start;
  for (k = 1; k < d3; k++) {
    dummy = randlc(&start, an);
    starts[k] = start;
  }

//#pragma acc update host(u1_real,u1_imag)
  //---------------------------------------------------------------------
  // Go through by z planes filling in one square at a time.
  //---------------------------------------------------------------------
//#pragma acc parallel num_gangs(d3/128) vector_length(128) present(u1_real,u1_imag) copyin(starts[0:d3])
{
  //#pragma acc loop gang vector
  for (k = 0; k < d3; k++) {
    x0 = starts[k];
    for (j = 0; j < d2; j++) {
  //    vranlc(2*NX, &x0, A, (double *)&u1[k*d2*(d1+1) + j*(d1+1) + 0]);
        const double r23 = 1.1920928955078125e-07;
        const double r46 = r23 * r23;
        const double t23 = 8.388608e+06;
        const double t46 = t23 * t23;

        double t1, t2, t3, t4, a1, a2, x1, x2, z;

        int i;
       
        t1 = r23*A;
        a1 = (int)t1;
        a2 = A - t23*a1;
        
        for(i=0; i<2*NX; i++){
            t1 = r23 * x0;
            x1 = (int)t1;
            x2 = x0 - t23*x1;
            t1 = a1 * x2 + a2 * x1;
            t2 = (int) (r23 * t1);
            z = t1 - t23 * t2;
            t3 = t23 * z + a2 * x2;
            t4 = (int) (r46 * t3) ;
            x0 = t3 - t46 * t4;
            //y[i] = r46 * x0;
            if(i%2 == 0)
                u1_real[k*d2*(d1+1) + j*(d1+1) + i/2] = r46*x0;
            else
                u1_imag[k*d2*(d1+1) + j*(d1+1) + i/2] = r46*x0;
        }  
    }
  }
}
#pragma acc update device(u1_real,u1_imag)
}


//---------------------------------------------------------------------
// compute a^exponent mod 2^46
//---------------------------------------------------------------------
static double ipow46(double a, int exponent)
{
  double result, dummy, q, r;
  int n, n2;

  //---------------------------------------------------------------------
  // Use
  //   a^n = a^(n/2)*a^(n/2) if n even else
  //   a^n = a*a^(n-1)       if n odd
  //---------------------------------------------------------------------
  result = 1;
  if (exponent == 0) return result;
  q = a;
  r = 1;
  n = exponent;

  while (n > 1) {
    n2 = n / 2;
    if (n2 * 2 == n) {
      dummy = randlc(&q, q);
      n = n2;
    } else {
      dummy = randlc(&r, q);
      n = n-1;
    }
  }
  dummy = randlc(&r, q);
  result = r;
  return result;
}


static void setup()
{
  FILE *fp;
  debug = false;

  if ((fp = fopen("timer.flag", "r")) != NULL) {
    timers_enabled = true;
    fclose(fp);
  } else {
    timers_enabled = false;
  }

  niter = NITER_DEFAULT;

  printf("\n\n NAS Parallel Benchmarks (NPB3.3-ACC-C) - FT Benchmark\n\n");
  printf(" Size                : %4dx%4dx%4d\n", NX, NY, NZ);
  printf(" Iterations                  :%7d\n", niter);
  printf("\n");

  dims[0] = NX;
  dims[1] = NY;
  dims[2] = NZ;

  //---------------------------------------------------------------------
  // Set up info for blocking of ffts and transposes.  This improves
  // performance on cache-based systems. Blocking involves
  // working on a chunk of the problem at a time, taking chunks
  // along the first, second, or third dimension. 
  //
  // - In cffts1 blocking is on 2nd dimension (with fft on 1st dim)
  // - In cffts2/3 blocking is on 1st dimension (with fft on 2nd and 3rd dims)

  // Since 1st dim is always in processor, we'll assume it's long enough 
  // (default blocking factor is 16 so min size for 1st dim is 16)
  // The only case we have to worry about is cffts1 in a 2d decomposition. 
  // so the blocking factor should not be larger than the 2nd dimension. 
  //---------------------------------------------------------------------
}


//---------------------------------------------------------------------
// compute function from local (i,j,k) to ibar^2+jbar^2+kbar^2 
// for time evolution exponent. 
//---------------------------------------------------------------------
static void compute_indexmap(int d1, int d2, int d3)
{
  int i, j, k, kk, kk2, jj, kj2, ii;
  double ap;

  //---------------------------------------------------------------------
  // basically we want to convert the fortran indices 
  //   1 2 3 4 5 6 7 8 
  // to 
  //   0 1 2 3 -4 -3 -2 -1
  // The following magic formula does the trick:
  // mod(i-1+n/2, n) - n/2
  //---------------------------------------------------------------------

  ap = -4.0 * ALPHA * PI * PI;

#pragma acc parallel num_gangs(d3) num_workers(8) vector_length(128) present(twiddle)
{
  #pragma acc loop gang
  for (k = 0; k < d3; k++) {
    #pragma acc loop worker 
    for (j = 0; j < d2; j++) {
      #pragma acc loop vector
      for (i = 0; i < d1; i++) {
    	kk = ((k + NZ/2) % NZ) - NZ/2;
    	kk2 = kk*kk;
      	jj = ((j + NY/2) % NY) - NY/2;
      	kj2 = jj*jj + kk2;
        ii = ((i + NX/2) % NX) - NX/2;
        //twiddle[k][j][i] = exp(ap * (double)(ii*ii+kj2));
        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
      }
    }
  }
 }
}


static void print_timers()
{
  int i;
  double t, t_m;
  char *tstrings[T_max+1];
  tstrings[1] = "          total "; 
  tstrings[2] = "          setup "; 
  tstrings[3] = "            fft "; 
  tstrings[4] = "         evolve "; 
  tstrings[5] = "       checksum "; 
  tstrings[6] = "           fftx "; 
  tstrings[7] = "           ffty "; 
  tstrings[8] = "           fftz ";

  t_m = timer_read(T_total);
  if (t_m <= 0.0) t_m = 1.00;
  for (i = 1; i <= T_max; i++) {
    t = timer_read(i);
    printf(" timer %2d(%16s) :%9.4f (%6.2f%%)\n", 
        i, tstrings[i], t, t*100.0/t_m);
  }
}

//---------------------------------------------------------------------
// compute the roots-of-unity array that will be used for subsequent FFTs. 
//---------------------------------------------------------------------
static void fft_init(int n)
{
  int m, nu, ku, i, j, ln;
  double t, ti;

  //---------------------------------------------------------------------
  // Initialize the U array with sines and cosines in a manner that permits
  // stride one access at each FFT iteration.
  //---------------------------------------------------------------------
  nu = n;
  m = ilog2(n);
  //u[0] = dcmplx(m, 0.0);

#pragma acc parallel num_gangs(1) num_workers(1) vector_length(1) present(u_real,u_imag)
{
  u_real[0] = m;
  u_imag[0] = 0.0;
}
  ku = 2;
  ln = 1;

  for (j = 1; j <= m; j++) {
    t = PI / ln;

 #pragma acc parallel num_gangs((ln+127)/128) vector_length(128) present(u_real,u_imag)
 {
    #pragma acc loop gang vector
    for (i = 0; i <= ln - 1; i++) {
      ti = i * t;
      //u[i+ku-1] = dcmplx(cos(ti), sin(ti));
      u_real[i+ku-1] = (double)cos(ti);
      u_imag[i+ku-1] = (double)sin(ti);
    }
  }

    ku = ku + ln;
    ln = 2 * ln;
 }
}

//---------------------------------------------------------------------
// note: args x1, x2 must be different arrays
// note: args for cfftsx are (direction, layout, xin, xout, scratch)
//       xin/xout may be the same and it can be somewhat faster
//       if they are
//---------------------------------------------------------------------
static void fft(int dir)
{
  if (dir == 1) {
    cffts1_pos(1, dims[0], dims[1], dims[2]);
    cffts2_pos(1, dims[0], dims[1], dims[2]);
    cffts3_pos(1, dims[0], dims[1], dims[2]);
  } else {
    cffts3_neg(-1, dims[0], dims[1], dims[2]);
    cffts2_neg(-1, dims[0], dims[1], dims[2]);
    cffts1_neg(-1, dims[0], dims[1], dims[2]);
  }
}

static void cffts1_pos(int is, int d1, int d2, int d3)
{
  int logd1;
  int i, j, k, jj;
  int l, j1, i1, k1;
  int n1, li, lj, lk, ku, i11, i12, i21, i22;
  double uu1_real, x11_real, x21_real;
  double uu1_imag, x11_imag, x21_imag;
  double uu2_real, x12_real, x22_real;
  double uu2_imag, x12_imag, x22_imag;
  double temp_real, temp2_real;
  double temp_imag, temp2_imag;

  logd1 = ilog2(d1);

 #pragma acc parallel num_gangs(d3) vector_length(128) \
                      present(gty1_real,gty1_imag,gty2_real,gty2_imag,\
                              u1_real,u1_imag,u_real,u_imag) 
 {
  #pragma acc loop gang
  for (k = 0; k < d3; k++) {
   #pragma acc loop vector
    for (j = 0; j < d2; j++) {
        for (i = 0; i < d1; i++) {
          gty1_real[k][i][j] = u1_real[k*d2*(d1+1) + j*(d1+1) + i];
          gty1_imag[k][i][j] = u1_imag[k*d2*(d1+1) + j*(d1+1) + i];
        }

	  for(l = 1; l <= logd1; l += 2){
  		n1 = d1 / 2;
  		lk = 1 << (l - 1);
  		li = 1 << (logd1 - l);
  		lj = 2 * lk;
  		ku = li;
 		for (i1 = 0; i1 <= li - 1; i1++) {
    		for (k1 = 0; k1 <= lk - 1; k1++) {
    				i11 = i1 * lk;
    				i12 = i11 + n1;
    				i21 = i1 * lj;
   				 	i22 = i21 + lk;
	
					uu1_real = u_real[ku+i1];
					uu1_imag = u_imag[ku+i1];

        			x11_real = gty1_real[k][i11+k1][j];
        			x11_imag = gty1_imag[k][i11+k1][j];
		
        			x21_real = gty1_real[k][i12+k1][j];
        			x21_imag = gty1_imag[k][i12+k1][j];

					gty2_real[k][i21+k1][j] = x11_real + x21_real;
	   				gty2_imag[k][i21+k1][j] = x11_imag + x21_imag;
		
					temp_real = x11_real - x21_real;
					temp_imag = x11_imag - x21_imag;
					gty2_real[k][i22+k1][j] = (uu1_real)*(temp_real) - (uu1_imag)*(temp_imag);
					gty2_imag[k][i22+k1][j] = (uu1_real)*(temp_imag) + (uu1_imag)*(temp_real);

    		}
  		}
	  	if(l == logd1){
      		for (j1 = 0; j1 < d1; j1++) {
          			gty1_real[k][j1][j] = gty2_real[k][j1][j];
          			gty1_imag[k][j1][j] = gty2_imag[k][j1][j];
      		}
		 }else{
  			n1 = d1 / 2;
  			lk = 1 << (l+1 - 1);
		    li = 1 << (logd1 - (l+1));
			lj = 2 * lk;
		    ku = li;
			
  			for (i1 = 0; i1 <= li - 1; i1++) {
   				for (k1 = 0; k1 <= lk - 1; k1++) {
    					i11 = i1 * lk;
    					i12 = i11 + n1;
    					i21 = i1 * lj;
    					i22 = i21 + lk;
	
						uu2_real = u_real[ku+i1];
						uu2_imag = u_imag[ku+i1];
        
						x12_real = gty2_real[k][i11+k1][j];
        				x12_imag = gty2_imag[k][i11+k1][j];
		
        				x22_real = gty2_real[k][i12+k1][j];
        				x22_imag = gty2_imag[k][i12+k1][j];

						gty1_real[k][i21+k1][j] = x12_real + x22_real;
	    				gty1_imag[k][i21+k1][j] = x12_imag + x22_imag;
		
						temp2_real = x12_real - x22_real;
						temp2_imag = x12_imag - x22_imag;
						gty1_real[k][i22+k1][j] = (uu2_real)*(temp2_real) - (uu2_imag)*(temp2_imag);
						gty1_imag[k][i22+k1][j] = (uu2_real)*(temp2_imag) + (uu2_imag)*(temp2_real);
    			}
  			  }
		   }/*end else*/
	 	}/*end l*/
	
        for (i = 0; i < d1; i++) {
          u1_real[k*d2*(d1+1) + j*(d1+1) + i] = gty1_real[k][i][j];
          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = gty1_imag[k][i][j];
        }
    }
  }
 }/*end acc parallel*/
}

static void cffts1_neg(int is, int d1, int d2, int d3)
{
  int logd1;
  int i, j, k, jj;
  int l, j1, i1, k1;
  int n1, li, lj, lk, ku, i11, i12, i21, i22;
  double uu1_real, x11_real, x21_real;
  double uu1_imag, x11_imag, x21_imag;
  double uu2_real, x12_real, x22_real;
  double uu2_imag, x12_imag, x22_imag;
  double temp_real, temp2_real;
  double temp_imag, temp2_imag;
  
  logd1 = ilog2(d1);
  
  #pragma acc parallel num_gangs(d3) vector_length(128) \
                       present(gty1_real,gty1_imag,gty2_real,gty2_imag,\
                               u1_real,u1_imag,u_real,u_imag) 
 {
  #pragma acc loop gang
  for (k = 0; k < d3; k++) {
   #pragma acc loop vector
    for (j = 0; j < d2; j++ ){
        for (i = 0; i < d1; i++) {
          gty1_real[k][i][j] = u1_real[k*d2*(d1+1) + j*(d1+1) + i];
          gty1_imag[k][i][j] = u1_imag[k*d2*(d1+1) + j*(d1+1) + i];
        }

	  for(l = 1; l <= logd1; l += 2){
  		n1 = d1 / 2;
  		lk = 1 << (l - 1);
  		li = 1 << (logd1 - l);
  		lj = 2 * lk;
  		ku = li;
 		for (i1 = 0; i1 <= li - 1; i1++) {
    		for (k1 = 0; k1 <= lk - 1; k1++) {
    				i11 = i1 * lk;
    				i12 = i11 + n1;
    				i21 = i1 * lj;
   				 	i22 = i21 + lk;
	
					uu1_real = u_real[ku+i1];
					uu1_imag = -1.0*u_imag[ku+i1];

        			x11_real = gty1_real[k][i11+k1][j];
        			x11_imag = gty1_imag[k][i11+k1][j];
		
        			x21_real = gty1_real[k][i12+k1][j];
        			x21_imag = gty1_imag[k][i12+k1][j];

					gty2_real[k][i21+k1][j] = x11_real + x21_real;
	   				gty2_imag[k][i21+k1][j] = x11_imag + x21_imag;
		
					temp_real = x11_real - x21_real;
					temp_imag = x11_imag - x21_imag;
					gty2_real[k][i22+k1][j] = (uu1_real)*(temp_real) - (uu1_imag)*(temp_imag);
					gty2_imag[k][i22+k1][j] = (uu1_real)*(temp_imag) + (uu1_imag)*(temp_real);

    		}
  		}
	  	if(l == logd1){
      		for (j1 = 0; j1 < d1; j1++) {
          			gty1_real[k][j1][j] = gty2_real[k][j1][j];
          			gty1_imag[k][j1][j] = gty2_imag[k][j1][j];
      		}
		 }else{
  			n1 = d1 / 2;
  			lk = 1 << (l+1 - 1);
		    li = 1 << (logd1 - (l+1));
			lj = 2 * lk;
		    ku = li;
			
  			for (i1 = 0; i1 <= li - 1; i1++) {
   				for (k1 = 0; k1 <= lk - 1; k1++) {
    					i11 = i1 * lk;
    					i12 = i11 + n1;
    					i21 = i1 * lj;
    					i22 = i21 + lk;
	
						uu2_real = u_real[ku+i1];
						uu2_imag = -1.0*u_imag[ku+i1];
        
						x12_real = gty2_real[k][i11+k1][j];
        				x12_imag = gty2_imag[k][i11+k1][j];
		
        				x22_real = gty2_real[k][i12+k1][j];
        				x22_imag = gty2_imag[k][i12+k1][j];

						gty1_real[k][i21+k1][j] = x12_real + x22_real;
	    				gty1_imag[k][i21+k1][j] = x12_imag + x22_imag;
		
						temp2_real = x12_real - x22_real;
						temp2_imag = x12_imag - x22_imag;
						gty1_real[k][i22+k1][j] = (uu2_real)*(temp2_real) - (uu2_imag)*(temp2_imag);
						gty1_imag[k][i22+k1][j] = (uu2_real)*(temp2_imag) + (uu2_imag)*(temp2_real);
    			}
  			  }
		   }/*end else*/
	 	}/*end l*/
	
        for (i = 0; i < d1; i++) {
          u1_real[k*d2*(d1+1) + j*(d1+1) + i] = gty1_real[k][i][j];
          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = gty1_imag[k][i][j];
        }
    }
  }
 }/*end acc parallel*/
}


static void cffts2_pos(int is, int d1, int d2, int d3)
{
  int logd2;
  int i, j, k, ii;
  int l, j1, i1, k1;
  int n1, li, lj, lk, ku, i11, i12, i21, i22;
  double uu1_real, x11_real, x21_real;
  double uu1_imag, x11_imag, x21_imag;
  double uu2_real, x12_real, x22_real;
  double uu2_imag, x12_imag, x22_imag;
  double temp_real, temp2_real;
  double temp_imag, temp2_imag;

  logd2 = ilog2(d2);
  
  #pragma acc parallel num_gangs(d3) vector_length(128) \
                       present(gty1_real,gty1_imag,gty2_real,gty2_imag,\
                               u1_real,u1_imag,u_real,u_imag) 
  {
  #pragma acc loop gang
  for (k = 0; k < d3; k++) {
    #pragma acc loop vector
    for (i = 0; i < d1; i++) {
      for (j = 0; j < d2; j++) {
          gty1_real[k][j][i] = u1_real[k*d2*(d1+1) + j*(d1+1) + i];
          gty1_imag[k][j][i] = u1_imag[k*d2*(d1+1) + j*(d1+1) + i];
      }

	  for(l = 1; l <= logd2; l += 2){
  		n1 = d2 / 2;
  		lk = 1 << (l - 1);
  		li = 1 << (logd2 - l);
  		lj = 2 * lk;
  		ku = li;
 		for (i1 = 0; i1 <= li - 1; i1++) {
    		for (k1 = 0; k1 <= lk - 1; k1++) {
    				i11 = i1 * lk;
    				i12 = i11 + n1;
    				i21 = i1 * lj;
   				 	i22 = i21 + lk;
	
					uu1_real = u_real[ku+i1];
					uu1_imag = u_imag[ku+i1];

        			x11_real = gty1_real[k][i11+k1][i];
        			x11_imag = gty1_imag[k][i11+k1][i];
		
        			x21_real = gty1_real[k][i12+k1][i];
        			x21_imag = gty1_imag[k][i12+k1][i];

					gty2_real[k][i21+k1][i] = x11_real + x21_real;
	   				gty2_imag[k][i21+k1][i] = x11_imag + x21_imag;
		
					temp_real = x11_real - x21_real;
					temp_imag = x11_imag - x21_imag;
					gty2_real[k][i22+k1][i] = (uu1_real)*(temp_real) - (uu1_imag)*(temp_imag);
					gty2_imag[k][i22+k1][i] = (uu1_real)*(temp_imag) + (uu1_imag)*(temp_real);

    		}
  		}
	  	if(l == logd2){
      		for (j1 = 0; j1 < d1; j1++) {
          			//ty1[j][i] = ty2[j][i];
          			gty1_real[k][j1][i] = gty2_real[k][j1][i];
          			gty1_imag[k][j1][i] = gty2_imag[k][j1][i];
      		}
		 }else{
  			n1 = d2 / 2;
  			lk = 1 << (l+1 - 1);
		    li = 1 << (logd2 - (l+1));
			lj = 2 * lk;
		    ku = li;
			
  			for (i1 = 0; i1 <= li - 1; i1++) {
   				for (k1 = 0; k1 <= lk - 1; k1++) {
    					i11 = i1 * lk;
    					i12 = i11 + n1;
    					i21 = i1 * lj;
    					i22 = i21 + lk;
	
						uu2_real = u_real[ku+i1];
						uu2_imag = u_imag[ku+i1];
        
						x12_real = gty2_real[k][i11+k1][i];
        				x12_imag = gty2_imag[k][i11+k1][i];
		
        				x22_real = gty2_real[k][i12+k1][i];
        				x22_imag = gty2_imag[k][i12+k1][i];

						gty1_real[k][i21+k1][i] = x12_real + x22_real;
	    				gty1_imag[k][i21+k1][i] = x12_imag + x22_imag;
		
						temp2_real = x12_real - x22_real;
						temp2_imag = x12_imag - x22_imag;
						gty1_real[k][i22+k1][i] = (uu2_real)*(temp2_real) - (uu2_imag)*(temp2_imag);
						gty1_imag[k][i22+k1][i] = (uu2_real)*(temp2_imag) + (uu2_imag)*(temp2_real);
    			}
  			  }
		   }/*end else*/
	 	}/*end l*/

	for (j = 0; j < d2; j++) {
          u1_real[k*d2*(d1+1) + j*(d1+1) + i] = gty1_real[k][j][i];
          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = gty1_imag[k][j][i];
      }
    }
  }
 }/*end acc parallel*/
}

static void cffts2_neg(int is, int d1, int d2, int d3)
{
  int logd2;
  int i, j, k, ii;
  int l, j1, i1, k1;
  int n1, li, lj, lk, ku, i11, i12, i21, i22;
  double uu1_real, x11_real, x21_real;
  double uu1_imag, x11_imag, x21_imag;
  double uu2_real, x12_real, x22_real;
  double uu2_imag, x12_imag, x22_imag;
  double temp_real, temp2_real;
  double temp_imag, temp2_imag;

  logd2 = ilog2(d2);
  
 #pragma acc parallel num_gangs(d3) vector_length(128) \
                      present(gty1_real,gty1_imag,gty2_real,gty2_imag,\
                              u1_real,u1_imag,u_real,u_imag) 
 {
  #pragma acc loop gang
  for (k = 0; k < d3; k++) {
    #pragma acc loop vector
    for (i = 0; i < d1; i ++) {
      for (j = 0; j < d2; j++) {
          gty1_real[k][j][i] = u1_real[k*d2*(d1+1) + j*(d1+1) + i];
          gty1_imag[k][j][i] = u1_imag[k*d2*(d1+1) + j*(d1+1) + i];
      }

	  for(l = 1; l <= logd2; l += 2){
  		n1 = d2 / 2;
  		lk = 1 << (l - 1);
  		li = 1 << (logd2 - l);
  		lj = 2 * lk;
  		ku = li;
 		for (i1 = 0; i1 <= li - 1; i1++) {
    		for (k1 = 0; k1 <= lk - 1; k1++) {
    				i11 = i1 * lk;
    				i12 = i11 + n1;
    				i21 = i1 * lj;
   				 	i22 = i21 + lk;
	
					uu1_real = u_real[ku+i1];
					uu1_imag = -1.0*u_imag[ku+i1];

        			x11_real = gty1_real[k][i11+k1][i];
        			x11_imag = gty1_imag[k][i11+k1][i];
		
        			x21_real = gty1_real[k][i12+k1][i];
        			x21_imag = gty1_imag[k][i12+k1][i];

					gty2_real[k][i21+k1][i] = x11_real + x21_real;
	   				gty2_imag[k][i21+k1][i] = x11_imag + x21_imag;
		
					temp_real = x11_real - x21_real;
					temp_imag = x11_imag - x21_imag;
					gty2_real[k][i22+k1][i] = (uu1_real)*(temp_real) - (uu1_imag)*(temp_imag);
					gty2_imag[k][i22+k1][i] = (uu1_real)*(temp_imag) + (uu1_imag)*(temp_real);

    		}
  		}
	  	if(l == logd2){
      		for (j1 = 0; j1 < d1; j1++) {
          			gty1_real[k][j1][i] = gty2_real[k][j1][i];
          			gty1_imag[k][j1][i] = gty2_imag[k][j1][i];
      		}
		 }else{
  			n1 = d2 / 2;
  			lk = 1 << (l+1 - 1);
		    li = 1 << (logd2 - (l+1));
			lj = 2 * lk;
		    ku = li;
			
  			for (i1 = 0; i1 <= li - 1; i1++) {
   				for (k1 = 0; k1 <= lk - 1; k1++) {
    					i11 = i1 * lk;
    					i12 = i11 + n1;
    					i21 = i1 * lj;
    					i22 = i21 + lk;
	
						uu2_real = u_real[ku+i1];
						uu2_imag = -1.0*u_imag[ku+i1];
        
						x12_real = gty2_real[k][i11+k1][i];
        				x12_imag = gty2_imag[k][i11+k1][i];
		
        				x22_real = gty2_real[k][i12+k1][i];
        				x22_imag = gty2_imag[k][i12+k1][i];

						gty1_real[k][i21+k1][i] = x12_real + x22_real;
	    				gty1_imag[k][i21+k1][i] = x12_imag + x22_imag;
		
						temp2_real = x12_real - x22_real;
						temp2_imag = x12_imag - x22_imag;
						gty1_real[k][i22+k1][i] = (uu2_real)*(temp2_real) - (uu2_imag)*(temp2_imag);
						gty1_imag[k][i22+k1][i] = (uu2_real)*(temp2_imag) + (uu2_imag)*(temp2_real);
    			}
  			  }
		   }/*end else*/
	 	}/*end l*/

	for (j = 0; j < d2; j++) {
          u1_real[k*d2*(d1+1) + j*(d1+1) + i] = gty1_real[k][j][i];
          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = gty1_imag[k][j][i];
      }
    }
  }
 }/*end acc parallel*/
}

/*is == 1*/
static void cffts3_pos(int is, int d1, int d2, int d3)
{
  int logd3;
  int i, j, k, ii;
  int l, j1, i1, k1;
  int n1, li, lj, lk, ku, i11, i12, i21, i22;
  double uu1_real, x11_real, x21_real;
  double uu1_imag, x11_imag, x21_imag;
  double uu2_real, x12_real, x22_real;
  double uu2_imag, x12_imag, x22_imag;
  double temp_real, temp2_real;
  double temp_imag, temp2_imag;
  
  logd3 = ilog2(d3);

  #pragma acc parallel num_gangs(d2) vector_length(128) \
                       present(gty1_real,gty1_imag,gty2_real,gty2_imag,\
                               u0_real,u0_imag,u1_real,u1_imag,u_real,u_imag) 
 {
  #pragma acc loop gang
  for (j = 0; j < d2; j++) {
    #pragma acc loop vector
    for (i = 0; i < d1; i ++) {
      for (k = 0; k < d3; k++) {
          gty1_real[j][k][i] = u1_real[k*d2*(d1+1) + j*(d1+1) + i];
          gty1_imag[j][k][i] = u1_imag[k*d2*(d1+1) + j*(d1+1) + i];
      }

	  for(l = 1; l <= logd3; l += 2){
  		n1 = d3 / 2;
  		lk = 1 << (l - 1);
  		li = 1 << (logd3 - l);
  		lj = 2 * lk;
  		ku = li;
 		for (i1 = 0; i1 <= li - 1; i1++) {
    		for (k1 = 0; k1 <= lk - 1; k1++) {
    				i11 = i1 * lk;
    				i12 = i11 + n1;
    				i21 = i1 * lj;
   				 	i22 = i21 + lk;
	
					uu1_real = u_real[ku+i1];
					uu1_imag = u_imag[ku+i1];

        			x11_real = gty1_real[j][i11+k1][i];
        			x11_imag = gty1_imag[j][i11+k1][i];
		
        			x21_real = gty1_real[j][i12+k1][i];
        			x21_imag = gty1_imag[j][i12+k1][i];

					gty2_real[j][i21+k1][i] = x11_real + x21_real;
	   				gty2_imag[j][i21+k1][i] = x11_imag + x21_imag;
		
					temp_real = x11_real - x21_real;
					temp_imag = x11_imag - x21_imag;
					gty2_real[j][i22+k1][i] = (uu1_real)*(temp_real) - (uu1_imag)*(temp_imag);
					gty2_imag[j][i22+k1][i] = (uu1_real)*(temp_imag) + (uu1_imag)*(temp_real);

    		}
  		}
	  	if(l == logd3){
      		for (j1 = 0; j1 < d1; j1++) {
          			gty1_real[j][j1][i] = gty2_real[j][j1][i];
          			gty1_imag[j][j1][i] = gty2_imag[j][j1][i];
      		}
		 }else{
  			n1 = d3 / 2;
  			lk = 1 << (l+1 - 1);
		    li = 1 << (logd3 - (l+1));
			lj = 2 * lk;
		    ku = li;
			
  			for (i1 = 0; i1 <= li - 1; i1++) {
   				for (k1 = 0; k1 <= lk - 1; k1++) {
    					i11 = i1 * lk;
    					i12 = i11 + n1;
    					i21 = i1 * lj;
    					i22 = i21 + lk;
	
						uu2_real = u_real[ku+i1];
						uu2_imag = u_imag[ku+i1];
        
						x12_real = gty2_real[j][i11+k1][i];
        				x12_imag = gty2_imag[j][i11+k1][i];
		
        				x22_real = gty2_real[j][i12+k1][i];
        				x22_imag = gty2_imag[j][i12+k1][i];

						gty1_real[j][i21+k1][i] = x12_real + x22_real;
	    				gty1_imag[j][i21+k1][i] = x12_imag + x22_imag;
		
						temp2_real = x12_real - x22_real;
						temp2_imag = x12_imag - x22_imag;
						gty1_real[j][i22+k1][i] = (uu2_real)*(temp2_real) - (uu2_imag)*(temp2_imag);
						gty1_imag[j][i22+k1][i] = (uu2_real)*(temp2_imag) + (uu2_imag)*(temp2_real);
    			}
  			  }
		   }/*end else*/
	 	}/*end l*/

      for (k = 0; k < d3; k++) {
          u0_real[k*d2*(d1+1) + j*(d1+1) + i] = gty1_real[j][k][i];
          u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = gty1_imag[j][k][i];
      }
    }
  }
 }/* end acc parlalel */
}



/*is==-1*/
static void cffts3_neg(int is, int d1, int d2, int d3)
{
  int logd3;
  int i, j, k, ii;
  int l, j1, i1, k1;
  int n1, li, lj, lk, ku, i11, i12, i21, i22;
  double uu1_real, x11_real, x21_real;
  double uu1_imag, x11_imag, x21_imag;
  double uu2_real, x12_real, x22_real;
  double uu2_imag, x12_imag, x22_imag;
  double temp_real, temp2_real;
  double temp_imag, temp2_imag;

  logd3 = ilog2(d3);
  
  #pragma acc parallel num_gangs(d2) vector_length(128) \
                       present(gty1_real,gty1_imag,gty2_real,gty2_imag,\
                               u1_real,u1_imag,u_real,u_imag) 
  {
  #pragma acc loop gang
  for (j = 0; j < d2; j++) {
    #pragma acc loop vector
    for (i = 0; i < d1; i++) {
      for (k = 0; k < d3; k++) {
          gty1_real[j][k][i] = u1_real[k*d2*(d1+1) + j*(d1+1) + i];
          gty1_imag[j][k][i] = u1_imag[k*d2*(d1+1) + j*(d1+1) + i];
      }

	  for(l = 1; l <= logd3; l += 2){
  		n1 = d3 / 2;
  		lk = 1 << (l - 1);
  		li = 1 << (logd3 - l);
  		lj = 2 * lk;
  		ku = li;
 		for (i1 = 0; i1 <= li - 1; i1++) {
    		for (k1 = 0; k1 <= lk - 1; k1++) {
    				i11 = i1 * lk;
    				i12 = i11 + n1;
    				i21 = i1 * lj;
   				 	i22 = i21 + lk;
	
					uu1_real = u_real[ku+i1];
					uu1_imag = -1.0*u_imag[ku+i1];

        			x11_real = gty1_real[j][i11+k1][i];
        			x11_imag = gty1_imag[j][i11+k1][i];
		
        			x21_real = gty1_real[j][i12+k1][i];
        			x21_imag = gty1_imag[j][i12+k1][i];

					gty2_real[j][i21+k1][i] = x11_real + x21_real;
	   				gty2_imag[j][i21+k1][i] = x11_imag + x21_imag;
		
					temp_real = x11_real - x21_real;
					temp_imag = x11_imag - x21_imag;
					gty2_real[j][i22+k1][i] = (uu1_real)*(temp_real) - (uu1_imag)*(temp_imag);
					gty2_imag[j][i22+k1][i] = (uu1_real)*(temp_imag) + (uu1_imag)*(temp_real);

    		}
  		}
	  	if(l == logd3){
      		for (j1 = 0; j1 < d1; j1++) {
          			gty1_real[j][j1][i] = gty2_real[j][j1][i];
          			gty1_imag[j][j1][i] = gty2_imag[j][j1][i];
      		}
		 }else{
  			n1 = d3 / 2;
  			lk = 1 << (l+1 - 1);
		    li = 1 << (logd3 - (l+1));
			lj = 2 * lk;
		    ku = li;
			
  			for (i1 = 0; i1 <= li - 1; i1++) {
   				for (k1 = 0; k1 <= lk - 1; k1++) {
    					i11 = i1 * lk;
    					i12 = i11 + n1;
    					i21 = i1 * lj;
    					i22 = i21 + lk;
	
						uu2_real = u_real[ku+i1];
						uu2_imag = -1.0*u_imag[ku+i1];
        
						x12_real = gty2_real[j][i11+k1][i];
        				x12_imag = gty2_imag[j][i11+k1][i];
		
        				x22_real = gty2_real[j][i12+k1][i];
        				x22_imag = gty2_imag[j][i12+k1][i];

						gty1_real[j][i21+k1][i] = x12_real + x22_real;
	    				gty1_imag[j][i21+k1][i] = x12_imag + x22_imag;
		
						temp2_real = x12_real - x22_real;
						temp2_imag = x12_imag - x22_imag;
						gty1_real[j][i22+k1][i] = (uu2_real)*(temp2_real) - (uu2_imag)*(temp2_imag);
						gty1_imag[j][i22+k1][i] = (uu2_real)*(temp2_imag) + (uu2_imag)*(temp2_real);
    			}
  			  }
		   }/*end else*/
	 	}/*end l*/

      for (k = 0; k < d3; k++) {
          u1_real[k*d2*(d1+1) + j*(d1+1) + i] = gty1_real[j][k][i];
          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = gty1_imag[j][k][i];
      }
    }
  }
 }/*end acc parallel*/
}


static int ilog2(int n)
{
  int nn, lg;
  if (n == 1) return 0;
  lg = 1;
  nn = 2;
  while (nn < n) {
    nn = nn*2;
    lg = lg+1;
  }
  return lg;
}


static void checksum(int i, int d1, int d2, int d3)
{

  int j, q, r, s;
  double temp1,temp2;
  // dcomplex chk = dcmplx(0.0, 0.0);
  dcomplex chk;
  chk.real = 0.0;
  chk.imag = 0.0;

  temp1 = 0.0;
  temp2 = 0.0;

//#pragma acc update host(u1_real,u1_imag)
#pragma acc parallel num_gangs(1) num_workers(1) \
                     vector_length(1024) present(u1_real,u1_imag)
{
	#pragma acc loop gang worker vector reduction(+:temp1,temp2)
    for (j = 1; j <= 1024; j++) {
      q = j % NX;
      r = 3*j % NY;
      s = 5*j % NZ;
	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
    }
}
	 chk.real = temp1;
	 chk.imag = temp2;

  chk = dcmplx_div2(chk, (double)(NTOTAL));

  printf(" T =%5d     Checksum =%22.12E%22.12E\n", i, chk.real, chk.imag);
  sums[i] = chk;
}


static void verify(int d1, int d2, int d3, int nt, 
                   logical *verified, char *Class)
{
  int i;
  double err, epsilon;

  //---------------------------------------------------------------------
  // Reference checksums
  //---------------------------------------------------------------------
  dcomplex csum_ref[25+1];

  *Class = 'U';

  epsilon = 1.0e-12;
  *verified = false;

  if (d1 == 64 && d2 == 64 && d3 == 64 && nt == 6) {
    //---------------------------------------------------------------------
    //   Sample size reference checksums
    //---------------------------------------------------------------------
    *Class = 'S';
    csum_ref[1] = dcmplx(5.546087004964E+02, 4.845363331978E+02);
    csum_ref[2] = dcmplx(5.546385409189E+02, 4.865304269511E+02);
    csum_ref[3] = dcmplx(5.546148406171E+02, 4.883910722336E+02);
    csum_ref[4] = dcmplx(5.545423607415E+02, 4.901273169046E+02);
    csum_ref[5] = dcmplx(5.544255039624E+02, 4.917475857993E+02);
    csum_ref[6] = dcmplx(5.542683411902E+02, 4.932597244941E+02);

  } else if (d1 == 128 && d2 == 128 && d3 == 32 && nt == 6) {
    //---------------------------------------------------------------------
    //   Class W size reference checksums
    //---------------------------------------------------------------------
    *Class = 'W';
    csum_ref[1] = dcmplx(5.673612178944E+02, 5.293246849175E+02);
    csum_ref[2] = dcmplx(5.631436885271E+02, 5.282149986629E+02);
    csum_ref[3] = dcmplx(5.594024089970E+02, 5.270996558037E+02);
    csum_ref[4] = dcmplx(5.560698047020E+02, 5.260027904925E+02);
    csum_ref[5] = dcmplx(5.530898991250E+02, 5.249400845633E+02);
    csum_ref[6] = dcmplx(5.504159734538E+02, 5.239212247086E+02);

  } else if (d1 == 256 && d2 == 256 && d3 == 128 && nt == 6) {
    //---------------------------------------------------------------------
    //   Class A size reference checksums
    //---------------------------------------------------------------------
    *Class = 'A';
    csum_ref[1] = dcmplx(5.046735008193E+02, 5.114047905510E+02);
    csum_ref[2] = dcmplx(5.059412319734E+02, 5.098809666433E+02);
    csum_ref[3] = dcmplx(5.069376896287E+02, 5.098144042213E+02);
    csum_ref[4] = dcmplx(5.077892868474E+02, 5.101336130759E+02);
    csum_ref[5] = dcmplx(5.085233095391E+02, 5.104914655194E+02);
    csum_ref[6] = dcmplx(5.091487099959E+02, 5.107917842803E+02);

  } else if (d1 == 512 && d2 == 256 && d3 == 256 && nt == 20) {
    //---------------------------------------------------------------------
    //   Class B size reference checksums
    //---------------------------------------------------------------------
    *Class = 'B';
    csum_ref[1]  = dcmplx(5.177643571579E+02, 5.077803458597E+02);
    csum_ref[2]  = dcmplx(5.154521291263E+02, 5.088249431599E+02);
    csum_ref[3]  = dcmplx(5.146409228649E+02, 5.096208912659E+02);
    csum_ref[4]  = dcmplx(5.142378756213E+02, 5.101023387619E+02);
    csum_ref[5]  = dcmplx(5.139626667737E+02, 5.103976610617E+02);
    csum_ref[6]  = dcmplx(5.137423460082E+02, 5.105948019802E+02);
    csum_ref[7]  = dcmplx(5.135547056878E+02, 5.107404165783E+02);
    csum_ref[8]  = dcmplx(5.133910925466E+02, 5.108576573661E+02);
    csum_ref[9]  = dcmplx(5.132470705390E+02, 5.109577278523E+02);
    csum_ref[10] = dcmplx(5.131197729984E+02, 5.110460304483E+02);
    csum_ref[11] = dcmplx(5.130070319283E+02, 5.111252433800E+02);
    csum_ref[12] = dcmplx(5.129070537032E+02, 5.111968077718E+02);
    csum_ref[13] = dcmplx(5.128182883502E+02, 5.112616233064E+02);
    csum_ref[14] = dcmplx(5.127393733383E+02, 5.113203605551E+02);
    csum_ref[15] = dcmplx(5.126691062020E+02, 5.113735928093E+02);
    csum_ref[16] = dcmplx(5.126064276004E+02, 5.114218460548E+02);
    csum_ref[17] = dcmplx(5.125504076570E+02, 5.114656139760E+02);
    csum_ref[18] = dcmplx(5.125002331720E+02, 5.115053595966E+02);
    csum_ref[19] = dcmplx(5.124551951846E+02, 5.115415130407E+02);
    csum_ref[20] = dcmplx(5.124146770029E+02, 5.115744692211E+02);

  } else if (d1 == 512 && d2 == 512 && d3 == 512 && nt == 20) {
    //---------------------------------------------------------------------
    //   Class C size reference checksums
    //---------------------------------------------------------------------
    *Class = 'C';
    csum_ref[1]  = dcmplx(5.195078707457E+02, 5.149019699238E+02);
    csum_ref[2]  = dcmplx(5.155422171134E+02, 5.127578201997E+02);
    csum_ref[3]  = dcmplx(5.144678022222E+02, 5.122251847514E+02);
    csum_ref[4]  = dcmplx(5.140150594328E+02, 5.121090289018E+02);
    csum_ref[5]  = dcmplx(5.137550426810E+02, 5.121143685824E+02);
    csum_ref[6]  = dcmplx(5.135811056728E+02, 5.121496764568E+02);
    csum_ref[7]  = dcmplx(5.134569343165E+02, 5.121870921893E+02);
    csum_ref[8]  = dcmplx(5.133651975661E+02, 5.122193250322E+02);
    csum_ref[9]  = dcmplx(5.132955192805E+02, 5.122454735794E+02);
    csum_ref[10] = dcmplx(5.132410471738E+02, 5.122663649603E+02);
    csum_ref[11] = dcmplx(5.131971141679E+02, 5.122830879827E+02);
    csum_ref[12] = dcmplx(5.131605205716E+02, 5.122965869718E+02);
    csum_ref[13] = dcmplx(5.131290734194E+02, 5.123075927445E+02);
    csum_ref[14] = dcmplx(5.131012720314E+02, 5.123166486553E+02);
    csum_ref[15] = dcmplx(5.130760908195E+02, 5.123241541685E+02);
    csum_ref[16] = dcmplx(5.130528295923E+02, 5.123304037599E+02);
    csum_ref[17] = dcmplx(5.130310107773E+02, 5.123356167976E+02);
    csum_ref[18] = dcmplx(5.130103090133E+02, 5.123399592211E+02);
    csum_ref[19] = dcmplx(5.129905029333E+02, 5.123435588985E+02);
    csum_ref[20] = dcmplx(5.129714421109E+02, 5.123465164008E+02);

  } else if (d1 == 2048 && d2 == 1024 && d3 == 1024 && nt == 25) {
    //---------------------------------------------------------------------
    //   Class D size reference checksums
    //---------------------------------------------------------------------
    *Class = 'D';
    csum_ref[1]  = dcmplx(5.122230065252E+02, 5.118534037109E+02);
    csum_ref[2]  = dcmplx(5.120463975765E+02, 5.117061181082E+02);
    csum_ref[3]  = dcmplx(5.119865766760E+02, 5.117096364601E+02);
    csum_ref[4]  = dcmplx(5.119518799488E+02, 5.117373863950E+02);
    csum_ref[5]  = dcmplx(5.119269088223E+02, 5.117680347632E+02);
    csum_ref[6]  = dcmplx(5.119082416858E+02, 5.117967875532E+02);
    csum_ref[7]  = dcmplx(5.118943814638E+02, 5.118225281841E+02);
    csum_ref[8]  = dcmplx(5.118842385057E+02, 5.118451629348E+02);
    csum_ref[9]  = dcmplx(5.118769435632E+02, 5.118649119387E+02);
    csum_ref[10] = dcmplx(5.118718203448E+02, 5.118820803844E+02);
    csum_ref[11] = dcmplx(5.118683569061E+02, 5.118969781011E+02);
    csum_ref[12] = dcmplx(5.118661708593E+02, 5.119098918835E+02);
    csum_ref[13] = dcmplx(5.118649768950E+02, 5.119210777066E+02);
    csum_ref[14] = dcmplx(5.118645605626E+02, 5.119307604484E+02);
    csum_ref[15] = dcmplx(5.118647586618E+02, 5.119391362671E+02);
    csum_ref[16] = dcmplx(5.118654451572E+02, 5.119463757241E+02);
    csum_ref[17] = dcmplx(5.118665212451E+02, 5.119526269238E+02);
    csum_ref[18] = dcmplx(5.118679083821E+02, 5.119580184108E+02);
    csum_ref[19] = dcmplx(5.118695433664E+02, 5.119626617538E+02);
    csum_ref[20] = dcmplx(5.118713748264E+02, 5.119666538138E+02);
    csum_ref[21] = dcmplx(5.118733606701E+02, 5.119700787219E+02);
    csum_ref[22] = dcmplx(5.118754661974E+02, 5.119730095953E+02);
    csum_ref[23] = dcmplx(5.118776626738E+02, 5.119755100241E+02);
    csum_ref[24] = dcmplx(5.118799262314E+02, 5.119776353561E+02);
    csum_ref[25] = dcmplx(5.118822370068E+02, 5.119794338060E+02);

  } else if (d1 == 4096 && d2 == 2048 && d3 == 2048 && nt == 25) {
    //---------------------------------------------------------------------
    //   Class E size reference checksums
    //---------------------------------------------------------------------
    *Class = 'E';
    csum_ref[1]  = dcmplx(5.121601045346E+02, 5.117395998266E+02);
    csum_ref[2]  = dcmplx(5.120905403678E+02, 5.118614716182E+02);
    csum_ref[3]  = dcmplx(5.120623229306E+02, 5.119074203747E+02);
    csum_ref[4]  = dcmplx(5.120438418997E+02, 5.119345900733E+02);
    csum_ref[5]  = dcmplx(5.120311521872E+02, 5.119551325550E+02);
    csum_ref[6]  = dcmplx(5.120226088809E+02, 5.119720179919E+02);
    csum_ref[7]  = dcmplx(5.120169296534E+02, 5.119861371665E+02);
    csum_ref[8]  = dcmplx(5.120131225172E+02, 5.119979364402E+02);
    csum_ref[9]  = dcmplx(5.120104767108E+02, 5.120077674092E+02);
    csum_ref[10] = dcmplx(5.120085127969E+02, 5.120159443121E+02);
    csum_ref[11] = dcmplx(5.120069224127E+02, 5.120227453670E+02);
    csum_ref[12] = dcmplx(5.120055158164E+02, 5.120284096041E+02);
    csum_ref[13] = dcmplx(5.120041820159E+02, 5.120331373793E+02);
    csum_ref[14] = dcmplx(5.120028605402E+02, 5.120370938679E+02);
    csum_ref[15] = dcmplx(5.120015223011E+02, 5.120404138831E+02);
    csum_ref[16] = dcmplx(5.120001570022E+02, 5.120432068837E+02);
    csum_ref[17] = dcmplx(5.119987650555E+02, 5.120455615860E+02);
    csum_ref[18] = dcmplx(5.119973525091E+02, 5.120475499442E+02);
    csum_ref[19] = dcmplx(5.119959279472E+02, 5.120492304629E+02);
    csum_ref[20] = dcmplx(5.119945006558E+02, 5.120506508902E+02);
    csum_ref[21] = dcmplx(5.119930795911E+02, 5.120518503782E+02);
    csum_ref[22] = dcmplx(5.119916728462E+02, 5.120528612016E+02);
    csum_ref[23] = dcmplx(5.119902874185E+02, 5.120537101195E+02);
    csum_ref[24] = dcmplx(5.119889291565E+02, 5.120544194514E+02);
    csum_ref[25] = dcmplx(5.119876028049E+02, 5.120550079284E+02);
  }

  if (*Class != 'U') {
    *verified = true;
    for (i = 1; i <= nt; i++) {
      err = dcmplx_abs(dcmplx_div(dcmplx_sub(sums[i], csum_ref[i]),
                                  csum_ref[i]));
      if (!(err <= epsilon)) {
        *verified = false;
        break;
      }
    }
  }

  if (*Class != 'U') {
    if (*verified) {
      printf(" Result verification successful\n");
    } else {
      printf(" Result verification failed\n");
    }
  }
  printf(" class = %c\n", *Class);
}


########## NEXT FILE ##########
blts.c:::
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB LU code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS LU code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

#include "applu.incl"

//---------------------------------------------------------------------
// 
// compute the regular-sparse, block lower triangular solution:
// 
// v <-- ( L-inv ) * v
// 
//---------------------------------------------------------------------
//---------------------------------------------------------------------
// To improve cache performance, second two dimensions padded by 1 
// for even number sizes only.  Only needed in v.
//---------------------------------------------------------------------
void blts (int ldmx, int ldmy, int ldmz, int nx, int ny, int nz, int l,
    double omega)
{
  //---------------------------------------------------------------------
  // local variables
  //---------------------------------------------------------------------
  int i, j, k, m, n;
  double tmp, tmp1;
  int npl = np[l];

#pragma acc data present(indxp,jndxp,np,a,b,c,d,rsd,tmat,tv)
{
  #pragma acc parallel loop gang vector num_gangs((npl+127)/128) \
                        num_workers(1) vector_length(128)
  for (n = 1; n <= npl; n++) {
  	j = jndxp[l][n];
	i = indxp[l][n];
	k = l - i - j;
      for (m = 0; m < 5; m++) {
        rsd[m][k][j][i] =  rsd[m][k][j][i]
          - omega * (  a[0][m][n] * rsd[0][k-1][j][i]
                     + a[1][m][n] * rsd[1][k-1][j][i]
                     + a[2][m][n] * rsd[2][k-1][j][i]
                     + a[3][m][n] * rsd[3][k-1][j][i]
                     + a[4][m][n] * rsd[4][k-1][j][i] );
      }
  }

  #pragma acc parallel loop gang vector num_gangs((npl+127)/128) \
                        num_workers(1) vector_length(128)
  for (n = 1; n <= npl; n++) {
  	j = jndxp[l][n];
	i = indxp[l][n];
	k = l - i - j;
      for (m = 0; m < 5; m++) {
        tv[m][n] =  rsd[m][k][j][i]
          - omega * ( b[0][m][n] * rsd[0][k][j-1][i]
                    + c[0][m][n] * rsd[0][k][j][i-1]
                    + b[1][m][n] * rsd[1][k][j-1][i]
                    + c[1][m][n] * rsd[1][k][j][i-1]
                    + b[2][m][n] * rsd[2][k][j-1][i]
                    + c[2][m][n] * rsd[2][k][j][i-1]
                    + b[3][m][n] * rsd[3][k][j-1][i]
                    + c[3][m][n] * rsd[3][k][j][i-1]
                    + b[4][m][n] * rsd[4][k][j-1][i]
                    + c[4][m][n] * rsd[4][k][j][i-1] );
      }

      //---------------------------------------------------------------------
      // diagonal block inversion
      // 
      // forward elimination
      //---------------------------------------------------------------------
      for (m = 0; m < 5; m++) {
        tmat[m][0][n] = d[0][m][n];
        tmat[m][1][n] = d[1][m][n];
        tmat[m][2][n] = d[2][m][n];
        tmat[m][3][n] = d[3][m][n];
        tmat[m][4][n] = d[4][m][n];
      }

      tmp1 = 1.0 / tmat[0][0][n];
      tmp = tmp1 * tmat[1][0][n];
      tmat[1][1][n] =  tmat[1][1][n] - tmp * tmat[0][1][n];
      tmat[1][2][n] =  tmat[1][2][n] - tmp * tmat[0][2][n];
      tmat[1][3][n] =  tmat[1][3][n] - tmp * tmat[0][3][n];
      tmat[1][4][n] =  tmat[1][4][n] - tmp * tmat[0][4][n];
      tv[1][n] = tv[1][n] - tv[0][n] * tmp;

      tmp = tmp1 * tmat[2][0][n];
      tmat[2][1][n] =  tmat[2][1][n] - tmp * tmat[0][1][n];
      tmat[2][2][n] =  tmat[2][2][n] - tmp * tmat[0][2][n];
      tmat[2][3][n] =  tmat[2][3][n] - tmp * tmat[0][3][n];
      tmat[2][4][n] =  tmat[2][4][n] - tmp * tmat[0][4][n];
      tv[2][n] = tv[2][n] - tv[0][n] * tmp;

      tmp = tmp1 * tmat[3][0][n];
      tmat[3][1][n] =  tmat[3][1][n] - tmp * tmat[0][1][n];
      tmat[3][2][n] =  tmat[3][2][n] - tmp * tmat[0][2][n];
      tmat[3][3][n] =  tmat[3][3][n] - tmp * tmat[0][3][n];
      tmat[3][4][n] =  tmat[3][4][n] - tmp * tmat[0][4][n];
      tv[3][n] = tv[3][n] - tv[0][n] * tmp;

      tmp = tmp1 * tmat[4][0][n];
      tmat[4][1][n] =  tmat[4][1][n] - tmp * tmat[0][1][n];
      tmat[4][2][n] =  tmat[4][2][n] - tmp * tmat[0][2][n];
      tmat[4][3][n] =  tmat[4][3][n] - tmp * tmat[0][3][n];
      tmat[4][4][n] =  tmat[4][4][n] - tmp * tmat[0][4][n];
      tv[4][n] = tv[4][n] - tv[0][n] * tmp;

      tmp1 = 1.0 / tmat[1][1][n];
      tmp = tmp1 * tmat[2][1][n];
      tmat[2][2][n] =  tmat[2][2][n] - tmp * tmat[1][2][n];
      tmat[2][3][n] =  tmat[2][3][n] - tmp * tmat[1][3][n];
      tmat[2][4][n] =  tmat[2][4][n] - tmp * tmat[1][4][n];
      tv[2][n] = tv[2][n] - tv[1][n] * tmp;

      tmp = tmp1 * tmat[3][1][n];
      tmat[3][2][n] =  tmat[3][2][n] - tmp * tmat[1][2][n];
      tmat[3][3][n] =  tmat[3][3][n] - tmp * tmat[1][3][n];
      tmat[3][4][n] =  tmat[3][4][n] - tmp * tmat[1][4][n];
      tv[3][n] = tv[3][n] - tv[1][n] * tmp;

      tmp = tmp1 * tmat[4][1][n];
      tmat[4][2][n] =  tmat[4][2][n] - tmp * tmat[1][2][n];
      tmat[4][3][n] =  tmat[4][3][n] - tmp * tmat[1][3][n];
      tmat[4][4][n] =  tmat[4][4][n] - tmp * tmat[1][4][n];
      tv[4][n] = tv[4][n] - tv[1][n] * tmp;

      tmp1 = 1.0 / tmat[2][2][n];
      tmp = tmp1 * tmat[3][2][n];
      tmat[3][3][n] =  tmat[3][3][n] - tmp * tmat[2][3][n];
      tmat[3][4][n] =  tmat[3][4][n] - tmp * tmat[2][4][n];
      tv[3][n] = tv[3][n] - tv[2][n] * tmp;

      tmp = tmp1 * tmat[4][2][n];
      tmat[4][3][n] =  tmat[4][3][n] - tmp * tmat[2][3][n];
      tmat[4][4][n] =  tmat[4][4][n] - tmp * tmat[2][4][n];
      tv[4][n] = tv[4][n] - tv[2][n] * tmp;

      tmp1 = 1.0 / tmat[3][3][n];
      tmp = tmp1 * tmat[4][3][n];
      tmat[4][4][n] =  tmat[4][4][n] - tmp * tmat[3][4][n];
      tv[4][n] = tv[4][n] - tv[3][n] * tmp;

      //---------------------------------------------------------------------
      // back substitution
      //---------------------------------------------------------------------
      rsd[4][k][j][i] = tv[4][n] / tmat[4][4][n];

      tv[3][n] = tv[3][n] 
        - tmat[3][4][n] * rsd[4][k][j][i];
      rsd[3][k][j][i] = tv[3][n] / tmat[3][3][n];

      tv[2][n] = tv[2][n]
        - tmat[2][3][n] * rsd[3][k][j][i]
        - tmat[2][4][n] * rsd[4][k][j][i];
      rsd[2][k][j][i] = tv[2][n] / tmat[2][2][n];

      tv[1][n] = tv[1][n]
        - tmat[1][2][n] * rsd[2][k][j][i]
        - tmat[1][3][n] * rsd[3][k][j][i]
        - tmat[1][4][n] * rsd[4][k][j][i];
      rsd[1][k][j][i] = tv[1][n] / tmat[1][1][n];

      tv[0][n] = tv[0][n]
        - tmat[0][1][n] * rsd[1][k][j][i]
        - tmat[0][2][n] * rsd[2][k][j][i]
        - tmat[0][3][n] * rsd[3][k][j][i]
        - tmat[0][4][n] * rsd[4][k][j][i];
      rsd[0][k][j][i] = tv[0][n] / tmat[0][0][n];
  }
 }/*end acc data*/
}


########## NEXT FILE ##########
buts.c:::
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB LU code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS LU code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

#include "applu.incl"
//---------------------------------------------------------------------
// 
// compute the regular-sparse, block upper triangular solution:
// 
// v <-- ( U-inv ) * v
// 
//---------------------------------------------------------------------
//---------------------------------------------------------------------
// To improve cache performance, second two dimensions padded by 1 
// for even number sizes only.  Only needed in v.
//---------------------------------------------------------------------
void buts(int ldmx, int ldmy, int ldmz, int nx, int ny, int nz, int l,
    double omega)
{
  //---------------------------------------------------------------------
  // local variables
  //---------------------------------------------------------------------
  int i, j, k, m, n;
  double tmp, tmp1;
  unsigned int npl = np[l];
	
#pragma acc data present(indxp,jndxp,np,a,b,c,d,rsd,tmat,tv)
{
  #pragma acc parallel loop gang worker vector num_gangs((npl+127)/128) \
                            num_workers(1) vector_length(128)
  for (n = 1; n <= npl; n++) {
  	j = jndxp[l][n];
	i = indxp[l][n];
	k = l - i - j;
      for (m = 0; m < 5; m++) {
        tv[m][n] = 
          omega * (  c[0][m][n] * rsd[0][k+1][j][i]
                   + c[1][m][n] * rsd[1][k+1][j][i]
                   + c[2][m][n] * rsd[2][k+1][j][i]
                   + c[3][m][n] * rsd[3][k+1][j][i]
                   + c[4][m][n] * rsd[4][k+1][j][i] );
      }
  }

  #pragma acc parallel loop gang worker vector num_gangs((npl+127)/128) \
                            num_workers(1) vector_length(128)
  for (n = 1; n <= npl; n++) {
  	j = jndxp[l][n];
	i = indxp[l][n];
	k = l - i - j;
      for (m = 0; m < 5; m++) {
        tv[m][n] = tv[m][n]
          + omega * ( b[0][m][n] * rsd[0][k][j+1][i]
                    + a[0][m][n] * rsd[0][k][j][i+1]
                    + b[1][m][n] * rsd[1][k][j+1][i]
                    + a[1][m][n] * rsd[1][k][j][i+1]
                    + b[2][m][n] * rsd[2][k][j+1][i]
                    + a[2][m][n] * rsd[2][k][j][i+1]
                    + b[3][m][n] * rsd[3][k][j+1][i]
                    + a[3][m][n] * rsd[3][k][j][i+1]
                    + b[4][m][n] * rsd[4][k][j+1][i]
                    + a[4][m][n] * rsd[4][k][j][i+1] );
      }

      //---------------------------------------------------------------------
      // diagonal block inversion
      //---------------------------------------------------------------------
      for (m = 0; m < 5; m++) {
        tmat[m][0][n] = d[0][m][n];
        tmat[m][1][n] = d[1][m][n];
        tmat[m][2][n] = d[2][m][n];
        tmat[m][3][n] = d[3][m][n];
        tmat[m][4][n] = d[4][m][n];
      }

      tmp1 = 1.0 / tmat[0][0][n];
      tmp = tmp1 * tmat[1][0][n];
      tmat[1][1][n] =  tmat[1][1][n] - tmp * tmat[0][1][n];
      tmat[1][2][n] =  tmat[1][2][n] - tmp * tmat[0][2][n];
      tmat[1][3][n] =  tmat[1][3][n] - tmp * tmat[0][3][n];
      tmat[1][4][n] =  tmat[1][4][n] - tmp * tmat[0][4][n];
      tv[1][n] = tv[1][n] - tv[0][n] * tmp;

      tmp = tmp1 * tmat[2][0][n];
      tmat[2][1][n] =  tmat[2][1][n] - tmp * tmat[0][1][n];
      tmat[2][2][n] =  tmat[2][2][n] - tmp * tmat[0][2][n];
      tmat[2][3][n] =  tmat[2][3][n] - tmp * tmat[0][3][n];
      tmat[2][4][n] =  tmat[2][4][n] - tmp * tmat[0][4][n];
      tv[2][n] = tv[2][n] - tv[0][n] * tmp;

      tmp = tmp1 * tmat[3][0][n];
      tmat[3][1][n] =  tmat[3][1][n] - tmp * tmat[0][1][n];
      tmat[3][2][n] =  tmat[3][2][n] - tmp * tmat[0][2][n];
      tmat[3][3][n] =  tmat[3][3][n] - tmp * tmat[0][3][n];
      tmat[3][4][n] =  tmat[3][4][n] - tmp * tmat[0][4][n];
      tv[3][n] = tv[3][n] - tv[0][n] * tmp;

      tmp = tmp1 * tmat[4][0][n];
      tmat[4][1][n] =  tmat[4][1][n] - tmp * tmat[0][1][n];
      tmat[4][2][n] =  tmat[4][2][n] - tmp * tmat[0][2][n];
      tmat[4][3][n] =  tmat[4][3][n] - tmp * tmat[0][3][n];
      tmat[4][4][n] =  tmat[4][4][n] - tmp * tmat[0][4][n];
      tv[4][n] = tv[4][n] - tv[0][n] * tmp;

      tmp1 = 1.0 / tmat[1][1][n];
      tmp = tmp1 * tmat[2][1][n];
      tmat[2][2][n] =  tmat[2][2][n] - tmp * tmat[1][2][n];
      tmat[2][3][n] =  tmat[2][3][n] - tmp * tmat[1][3][n];
      tmat[2][4][n] =  tmat[2][4][n] - tmp * tmat[1][4][n];
      tv[2][n] = tv[2][n] - tv[1][n] * tmp;

      tmp = tmp1 * tmat[3][1][n];
      tmat[3][2][n] =  tmat[3][2][n] - tmp * tmat[1][2][n];
      tmat[3][3][n] =  tmat[3][3][n] - tmp * tmat[1][3][n];
      tmat[3][4][n] =  tmat[3][4][n] - tmp * tmat[1][4][n];
      tv[3][n] = tv[3][n] - tv[1][n] * tmp;

      tmp = tmp1 * tmat[4][1][n];
      tmat[4][2][n] =  tmat[4][2][n] - tmp * tmat[1][2][n];
      tmat[4][3][n] =  tmat[4][3][n] - tmp * tmat[1][3][n];
      tmat[4][4][n] =  tmat[4][4][n] - tmp * tmat[1][4][n];
      tv[4][n] = tv[4][n] - tv[1][n] * tmp;

      tmp1 = 1.0 / tmat[2][2][n];
      tmp = tmp1 * tmat[3][2][n];
      tmat[3][3][n] =  tmat[3][3][n] - tmp * tmat[2][3][n];
      tmat[3][4][n] =  tmat[3][4][n] - tmp * tmat[2][4][n];
      tv[3][n] = tv[3][n] - tv[2][n] * tmp;

      tmp = tmp1 * tmat[4][2][n];
      tmat[4][3][n] =  tmat[4][3][n] - tmp * tmat[2][3][n];
      tmat[4][4][n] =  tmat[4][4][n] - tmp * tmat[2][4][n];
      tv[4][n] = tv[4][n] - tv[2][n] * tmp;

      tmp1 = 1.0 / tmat[3][3][n];
      tmp = tmp1 * tmat[4][3][n];
      tmat[4][4][n] =  tmat[4][4][n] - tmp * tmat[3][4][n];
      tv[4][n] = tv[4][n] - tv[3][n] * tmp;

      //---------------------------------------------------------------------
      // back substitution
      //---------------------------------------------------------------------
      tv[4][n] = tv[4][n] / tmat[4][4][n];

      tv[3][n] = tv[3][n] - tmat[3][4][n] * tv[4][n];
      tv[3][n] = tv[3][n] / tmat[3][3][n];

      tv[2][n] = tv[2][n]
        - tmat[2][3][n] * tv[3][n]
        - tmat[2][4][n] * tv[4][n];
      tv[2][n] = tv[2][n] / tmat[2][2][n];

      tv[1][n] = tv[1][n]
        - tmat[1][2][n] * tv[2][n]
        - tmat[1][3][n] * tv[3][n]
        - tmat[1][4][n] * tv[4][n];
      tv[1][n] = tv[1][n] / tmat[1][1][n];

      tv[0][n] = tv[0][n]
        - tmat[0][1][n] * tv[1][n]
        - tmat[0][2][n] * tv[2][n]
        - tmat[0][3][n] * tv[3][n]
        - tmat[0][4][n] * tv[4][n];
      tv[0][n] = tv[0][n] / tmat[0][0][n];

      rsd[0][k][j][i] = rsd[0][k][j][i] - tv[0][n];
      rsd[1][k][j][i] = rsd[1][k][j][i] - tv[1][n];
      rsd[2][k][j][i] = rsd[2][k][j][i] - tv[2][n];
      rsd[3][k][j][i] = rsd[3][k][j][i] - tv[3][n];
      rsd[4][k][j][i] = rsd[4][k][j][i] - tv[4][n];
  }
 }/*end acc data*/
}


########## NEXT FILE ##########
calcnp.c:::

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS LU code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

#include "applu.incl"
#include <stdio.h>

void calcnp(int lst, int lend)
{
	int i, j, k, l;

  //#pragma acc kernels present(indxp, jndxp, np)
  {
    //#pragma acc loop private(i,j,k)
	for(l = lst; l <= lend; l++)
	{
		int n = 0;
		for(j = max(1, l-nx-nz+2); j <= min(ny-2, l-2); j++)
		{
			for(i = max(1, l-j-nz+2); i <= min(nx-2, l-j-1); i++)
			{
				k = l - i - j;
				if(k >= 1 && k < nz - 1)
				{
					n = n + 1;
					indxp[l][n] = i;
					jndxp[l][n] = j;
				}
			}
		}
		np[l] = n;
	}
  }
}

########## NEXT FILE ##########
erhs.c:::
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB LU code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS LU code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

#include "applu.incl"

//---------------------------------------------------------------------
//
// compute the right hand side based on exact solution
//
//---------------------------------------------------------------------
void erhs()
{
  //---------------------------------------------------------------------
  // local variables
  //---------------------------------------------------------------------
  int i, j, k, m;
  double xi, eta, zeta;
  double q;
  double u21, u31, u41;
  double tmp;
  double u21i, u31i, u41i, u51i;
  double u21j, u31j, u41j, u51j;
  double u21k, u31k, u41k, u51k;
  double u21im1, u31im1, u41im1, u51im1;
  double u21jm1, u31jm1, u41jm1, u51jm1;
  double u21km1, u31km1, u41km1, u51km1;
  //unsigned int num_workers = 0;

#pragma acc data copyin(ce) present(flux_G,frct,rsd)
{
  #pragma acc parallel loop gang num_gangs(nz) num_workers(8) vector_length(32)
  for (k = 0; k < nz; k++) {
  #pragma acc loop worker
    for (j = 0; j < ny; j++) {
    #pragma acc loop vector
      for (i = 0; i < nx; i++) {
        for (m = 0; m < 5; m++) {
          frct[m][k][j][i] = 0.0;
        }
      }
    }
  }

  #pragma acc parallel loop gang num_gangs(nz) num_workers(8) vector_length(32)
  for (k = 0; k < nz; k++) {
    zeta = ( (double)k ) / ( nz - 1 );
  #pragma acc loop worker
    for (j = 0; j < ny; j++) {
      eta = ( (double)j ) / ( ny0 - 1 );
  #pragma acc loop vector
      for (i = 0; i < nx; i++) {
        xi = ( (double)i ) / ( nx0 - 1 );
        for (m = 0; m < 5; m++) {
          rsd[m][k][j][i] =  ce[m][0]
            + (ce[m][1]
            + (ce[m][4]
            + (ce[m][7]
            +  ce[m][10] * xi) * xi) * xi) * xi
            + (ce[m][2]
            + (ce[m][5]
            + (ce[m][8]
            +  ce[m][11] * eta) * eta) * eta) * eta
            + (ce[m][3]
            + (ce[m][6]
            + (ce[m][9]
            +  ce[m][12] * zeta) * zeta) * zeta) * zeta;
        }
      }
    }
  }

  //---------------------------------------------------------------------
  // xi-direction flux differences
  //---------------------------------------------------------------------
  #pragma acc parallel loop gang num_gangs(nz-2) num_workers(8) vector_length(32)
  for (k = 1; k < nz - 1; k++) {
  #pragma acc loop worker
    for (j = jst; j <= jend; j++) {
    #pragma acc loop vector
      for (i = 0; i < nx; i++) {
        flux_G[0][k][j][i] = rsd[1][k][j][i];
        u21 = rsd[1][k][j][i] / rsd[0][k][j][i];
        q = 0.50 * (  rsd[1][k][j][i] * rsd[1][k][j][i]
                    + rsd[2][k][j][i] * rsd[2][k][j][i]
                    + rsd[3][k][j][i] * rsd[3][k][j][i] )
                 / rsd[0][k][j][i];
        flux_G[1][k][j][i] = rsd[1][k][j][i] * u21 + C2 * ( rsd[4][k][j][i] - q );
        flux_G[2][k][j][i] = rsd[2][k][j][i] * u21;
        flux_G[3][k][j][i] = rsd[3][k][j][i] * u21;
        flux_G[4][k][j][i] = ( C1 * rsd[4][k][j][i] - C2 * q ) * u21;
      }
     }
   }

  #pragma acc parallel loop gang num_gangs(nz-2) num_workers(8) vector_length(32)
  for (k = 1; k < nz - 1; k++) {
  #pragma acc loop worker
    for (j = jst; j <= jend; j++) {
    #pragma acc loop vector
      for (i = ist; i <= iend; i++) {
        for (m = 0; m < 5; m++) {
          frct[m][k][j][i] =  frct[m][k][j][i]
                    - tx2 * ( flux_G[m][k][j][i+1] - flux_G[m][k][j][i-1] );
        }
      }
    }
  }
      
  #pragma acc parallel loop gang num_gangs(nz-2) num_workers(8) vector_length(32)
  for (k = 1; k < nz - 1; k++) {
  #pragma acc loop worker
    for (j = jst; j <= jend; j++) {
  #pragma acc loop vector
      for (i = ist; i < nx; i++) {
        tmp = 1.0 / rsd[0][k][j][i];

        u21i = tmp * rsd[1][k][j][i];
        u31i = tmp * rsd[2][k][j][i];
        u41i = tmp * rsd[3][k][j][i];
        u51i = tmp * rsd[4][k][j][i];

        tmp = 1.0 / rsd[0][k][j][i-1];

        u21im1 = tmp * rsd[1][k][j][i-1];
        u31im1 = tmp * rsd[2][k][j][i-1];
        u41im1 = tmp * rsd[3][k][j][i-1];
        u51im1 = tmp * rsd[4][k][j][i-1];

        flux_G[1][k][j][i] = (4.0/3.0) * tx3 * ( u21i - u21im1 );
        flux_G[2][k][j][i] = tx3 * ( u31i - u31im1 );
        flux_G[3][k][j][i] = tx3 * ( u41i - u41im1 );
        flux_G[4][k][j][i] = 0.50 * ( 1.0 - C1*C5 )
          * tx3 * ( ( u21i*u21i     + u31i*u31i     + u41i*u41i )
                  - ( u21im1*u21im1 + u31im1*u31im1 + u41im1*u41im1 ) )
          + (1.0/6.0)
          * tx3 * ( u21i*u21i - u21im1*u21im1 )
          + C1 * C5 * tx3 * ( u51i - u51im1 );
      }
    }
  }

  #pragma acc parallel loop gang num_gangs(nz-2) num_workers(8) vector_length(32)
  for (k = 1; k < nz - 1; k++) {
  #pragma acc loop worker
    for (j = jst; j <= jend; j++) {
  #pragma acc loop vector
      for (i = ist; i <= iend; i++) {
        frct[0][k][j][i] = frct[0][k][j][i]
          + dx1 * tx1 * (        rsd[0][k][j][i-1]
                         - 2.0 * rsd[0][k][j][i]
                         +       rsd[0][k][j][i+1] );
        frct[1][k][j][i] = frct[1][k][j][i]
          + tx3 * C3 * C4 * ( flux_G[1][k][j][i+1] - flux_G[1][k][j][i] )
          + dx2 * tx1 * (        rsd[1][k][j][i-1]
                         - 2.0 * rsd[1][k][j][i]
                         +       rsd[1][k][j][i+1] );
        frct[2][k][j][i] = frct[2][k][j][i]
          + tx3 * C3 * C4 * ( flux_G[2][k][j][i+1] - flux_G[2][k][j][i] )
          + dx3 * tx1 * (        rsd[2][k][j][i-1]
                         - 2.0 * rsd[2][k][j][i]
                         +       rsd[2][k][j][i+1] );
        frct[3][k][j][i] = frct[3][k][j][i]
          + tx3 * C3 * C4 * ( flux_G[3][k][j][i+1] - flux_G[3][k][j][i] )
          + dx4 * tx1 * (        rsd[3][k][j][i-1]
                         - 2.0 * rsd[3][k][j][i]
                         +       rsd[3][k][j][i+1] );
        frct[4][k][j][i] = frct[4][k][j][i]
          + tx3 * C3 * C4 * ( flux_G[4][k][j][i+1] - flux_G[4][k][j][i] )
          + dx5 * tx1 * (        rsd[4][k][j][i-1]
                         - 2.0 * rsd[4][k][j][i]
                         +       rsd[4][k][j][i+1] );
      }
     }
    }

      //---------------------------------------------------------------------
      // Fourth-order dissipation
      //---------------------------------------------------------------------
      //num_workers = (jend-jst+1)/32;
  #pragma acc parallel loop gang num_gangs(nz-2) num_workers(8) vector_length(32)
  for (k = 1; k < nz - 1; k++) {
  #pragma acc loop worker vector
    for (j = jst; j <= jend; j++) {
      for (m = 0; m < 5; m++) {
        frct[m][k][j][1] = frct[m][k][j][1]
          - dssp * ( + 5.0 * rsd[m][k][j][1]
                     - 4.0 * rsd[m][k][j][2]
                     +       rsd[m][k][j][3] );
        frct[m][k][j][2] = frct[m][k][j][2]
          - dssp * ( - 4.0 * rsd[m][k][j][1]
                     + 6.0 * rsd[m][k][j][2]
                     - 4.0 * rsd[m][k][j][3]
                     +       rsd[m][k][j][4] );
      }
     }
   }

  #pragma acc parallel loop gang num_gangs(nz-2) num_workers(8) vector_length(32)
  for (k = 1; k < nz - 1; k++) {
  #pragma acc loop worker vector
    for (j = jst; j <= jend; j++) {
      for (i = 3; i < nx - 3; i++) {
        for (m = 0; m < 5; m++) {
          frct[m][k][j][i] = frct[m][k][j][i]
            - dssp * (        rsd[m][k][j][i-2]
                      - 4.0 * rsd[m][k][j][i-1]
                      + 6.0 * rsd[m][k][j][i]
                      - 4.0 * rsd[m][k][j][i+1]
                      +       rsd[m][k][j][i+2] );
        }
      }
     }
    }

  #pragma acc parallel loop gang num_gangs(nz-2) num_workers(8) vector_length(32)
  for (k = 1; k < nz - 1; k++) {
  #pragma acc loop worker vector
    for (j = jst; j <= jend; j++) {
      for (m = 0; m < 5; m++) {
        frct[m][k][j][nx-3] = frct[m][k][j][nx-3]
          - dssp * (        rsd[m][k][j][nx-5]
                    - 4.0 * rsd[m][k][j][nx-4]
                    + 6.0 * rsd[m][k][j][nx-3]
                    - 4.0 * rsd[m][k][j][nx-2] );
        frct[m][k][j][nx-2] = frct[m][k][j][nx-2]
          - dssp * (        rsd[m][k][j][nx-4]
                    - 4.0 * rsd[m][k][j][nx-3]
                    + 5.0 * rsd[m][k][j][nx-2] );
      }
    }
  }

  //---------------------------------------------------------------------
  // eta-direction flux differences
  //---------------------------------------------------------------------
  #pragma acc parallel loop gang num_gangs(nz-2) num_workers(8) vector_length(32)
  for (k = 1; k < nz - 1; k++) {
    #pragma acc loop worker
    for (i = ist; i <= iend; i++) {
      #pragma acc loop vector
      for (j = 0; j < ny; j++) {
        flux_G[0][k][i][j] = rsd[2][k][j][i];
        u31 = rsd[2][k][j][i] / rsd[0][k][j][i];
        q = 0.50 * (  rsd[1][k][j][i] * rsd[1][k][j][i]
                    + rsd[2][k][j][i] * rsd[2][k][j][i]
                    + rsd[3][k][j][i] * rsd[3][k][j][i] )
                 / rsd[0][k][j][i];
        flux_G[1][k][i][j] = rsd[1][k][j][i] * u31;
        flux_G[2][k][i][j] = rsd[2][k][j][i] * u31 + C2 * ( rsd[4][k][j][i] - q );
        flux_G[3][k][i][j] = rsd[3][k][j][i] * u31;
        flux_G[4][k][i][j] = ( C1 * rsd[4][k][j][i] - C2 * q ) * u31;
      }
     }
    }

  #pragma acc parallel loop gang num_gangs(nz-2) num_workers(8) vector_length(32)
  for (k = 1; k < nz - 1; k++) {
    #pragma acc loop worker
    for (i = ist; i <= iend; i++) {
      #pragma acc loop vector
      for (j = jst; j <= jend; j++) {
        for (m = 0; m < 5; m++) {
          frct[m][k][j][i] =  frct[m][k][j][i]
            - ty2 * ( flux_G[m][k][i][j+1] - flux_G[m][k][i][j-1] );
        }
      }
     }
    }

  #pragma acc parallel loop gang num_gangs(nz-2) num_workers(8) vector_length(32)
  for (k = 1; k < nz - 1; k++) {
    #pragma acc loop worker
    for (i = ist; i <= iend; i++) {
      #pragma acc loop vector
      for (j = jst; j < ny; j++) {
        tmp = 1.0 / rsd[0][k][j][i];

        u21j = tmp * rsd[1][k][j][i];
        u31j = tmp * rsd[2][k][j][i];
        u41j = tmp * rsd[3][k][j][i];
        u51j = tmp * rsd[4][k][j][i];

        tmp = 1.0 / rsd[0][k][j-1][i];

        u21jm1 = tmp * rsd[1][k][j-1][i];
        u31jm1 = tmp * rsd[2][k][j-1][i];
        u41jm1 = tmp * rsd[3][k][j-1][i];
        u51jm1 = tmp * rsd[4][k][j-1][i];

        flux_G[1][k][i][j] = ty3 * ( u21j - u21jm1 );
        flux_G[2][k][i][j] = (4.0/3.0) * ty3 * ( u31j - u31jm1 );
        flux_G[3][k][i][j] = ty3 * ( u41j - u41jm1 );
        flux_G[4][k][i][j] = 0.50 * ( 1.0 - C1*C5 )
          * ty3 * ( ( u21j*u21j     + u31j*u31j     + u41j*u41j )
                  - ( u21jm1*u21jm1 + u31jm1*u31jm1 + u41jm1*u41jm1 ) )
          + (1.0/6.0)
          * ty3 * ( u31j*u31j - u31jm1*u31jm1 )
          + C1 * C5 * ty3 * ( u51j - u51jm1 );
      }
     }
    }


  #pragma acc parallel loop gang num_gangs(nz-2) num_workers(8) vector_length(32)
  for (k = 1; k < nz - 1; k++) {
    #pragma acc loop worker
    for (i = ist; i <= iend; i++) {
      #pragma acc loop vector
      for (j = jst; j <= jend; j++) {
        frct[0][k][j][i] = frct[0][k][j][i]
          + dy1 * ty1 * (        rsd[0][k][j-1][i]
                         - 2.0 * rsd[0][k][j][i]
                         +       rsd[0][k][j+1][i] );
        frct[1][k][j][i] = frct[1][k][j][i]
          + ty3 * C3 * C4 * ( flux_G[1][k][i][j+1] - flux_G[1][k][i][j] )
          + dy2 * ty1 * (        rsd[1][k][j-1][i]
                         - 2.0 * rsd[1][k][j][i]
                         +       rsd[1][k][j+1][i] );
        frct[2][k][j][i] = frct[2][k][j][i]
          + ty3 * C3 * C4 * ( flux_G[2][k][i][j+1] - flux_G[2][k][i][j] )
          + dy3 * ty1 * (        rsd[2][k][j-1][i]
                         - 2.0 * rsd[2][k][j][i]
                         +       rsd[2][k][j+1][i] );
        frct[3][k][j][i] = frct[3][k][j][i]
          + ty3 * C3 * C4 * ( flux_G[3][k][i][j+1] - flux_G[3][k][i][j] )
          + dy4 * ty1 * (        rsd[3][k][j-1][i]
                         - 2.0 * rsd[3][k][j][i]
                         +       rsd[3][k][j+1][i] );
        frct[4][k][j][i] = frct[4][k][j][i]
          + ty3 * C3 * C4 * ( flux_G[4][k][i][j+1] - flux_G[4][k][i][j] )
          + dy5 * ty1 * (        rsd[4][k][j-1][i]
                         - 2.0 * rsd[4][k][j][i]
                         +       rsd[4][k][j+1][i] );
      }
     }
    }

      //---------------------------------------------------------------------
      // fourth-order dissipation
      //---------------------------------------------------------------------
      
      //num_workers = (iend-ist+1)/32;
  #pragma acc parallel loop gang num_gangs(nz-2) num_workers(8) vector_length(32)
  for (k = 1; k < nz - 1; k++) {
    #pragma acc loop worker vector
    for (i = ist; i <= iend; i++) {
      for (m = 0; m < 5; m++) {
        frct[m][k][1][i] = frct[m][k][1][i]
          - dssp * ( + 5.0 * rsd[m][k][1][i]
                     - 4.0 * rsd[m][k][2][i]
                     +       rsd[m][k][3][i] );
        frct[m][k][2][i] = frct[m][k][2][i]
          - dssp * ( - 4.0 * rsd[m][k][1][i]
                     + 6.0 * rsd[m][k][2][i]
                     - 4.0 * rsd[m][k][3][i]
                     +       rsd[m][k][4][i] );
      }
     }
    }


  #pragma acc parallel loop gang num_gangs(nz-2) num_workers(8) vector_length(32)
  for (k = 1; k < nz - 1; k++) {
    #pragma acc loop worker
    for (i = ist; i <= iend; i++) {
    #pragma acc loop vector
      for (j = 3; j < ny - 3; j++) {
        for (m = 0; m < 5; m++) {
          frct[m][k][j][i] = frct[m][k][j][i]
            - dssp * (        rsd[m][k][j-2][i]
                      - 4.0 * rsd[m][k][j-1][i]
                      + 6.0 * rsd[m][k][j][i]
                      - 4.0 * rsd[m][k][j+1][i]
                      +       rsd[m][k][j+2][i] );
        }
      }
     }
    }

  #pragma acc parallel loop gang num_gangs(nz-2) num_workers(8) vector_length(32)
  for (k = 1; k < nz - 1; k++) {
    #pragma acc loop worker vector
    for (i = ist; i <= iend; i++) {
      for (m = 0; m < 5; m++) {
        frct[m][k][ny-3][i] = frct[m][k][ny-3][i]
          - dssp * (        rsd[m][k][ny-5][i]
                    - 4.0 * rsd[m][k][ny-4][i]
                    + 6.0 * rsd[m][k][ny-3][i]
                    - 4.0 * rsd[m][k][ny-2][i] );
        frct[m][k][ny-2][i] = frct[m][k][ny-2][i]
          - dssp * (        rsd[m][k][ny-4][i]
                    - 4.0 * rsd[m][k][ny-3][i]
                    + 5.0 * rsd[m][k][ny-2][i] );
      }
    }
  }

  //---------------------------------------------------------------------
  // zeta-direction flux differences
  //---------------------------------------------------------------------
  #pragma acc parallel loop gang num_gangs(jend-jst+1) num_workers(8) vector_length(32)
  for (j = jst; j <= jend; j++) {
    #pragma acc loop worker
    for (i = ist; i <= iend; i++) {
    #pragma acc loop vector
      for (k = 0; k < nz; k++) {
        flux_G[0][j][i][k] = rsd[3][k][j][i];
        u41 = rsd[3][k][j][i] / rsd[0][k][j][i];
        q = 0.50 * (  rsd[1][k][j][i] * rsd[1][k][j][i]
                    + rsd[2][k][j][i] * rsd[2][k][j][i]
                    + rsd[3][k][j][i] * rsd[3][k][j][i] )
                 / rsd[0][k][j][i];
        flux_G[1][j][i][k] = rsd[1][k][j][i] * u41;
        flux_G[2][j][i][k] = rsd[2][k][j][i] * u41; 
        flux_G[3][j][i][k] = rsd[3][k][j][i] * u41 + C2 * ( rsd[4][k][j][i] - q );
        flux_G[4][j][i][k] = ( C1 * rsd[4][k][j][i] - C2 * q ) * u41;
      }
     }
    }

  #pragma acc parallel loop gang num_gangs(jend-jst+1) num_workers(8) vector_length(32)
  for (j = jst; j <= jend; j++) {
    #pragma acc loop worker
    for (i = ist; i <= iend; i++) {
    #pragma acc loop vector
      for (k = 1; k < nz - 1; k++) {
        for (m = 0; m < 5; m++) {
          frct[m][k][j][i] =  frct[m][k][j][i]
            - tz2 * ( flux_G[m][j][i][k+1] - flux_G[m][j][i][k-1] );
        }
      }
     }
   }

  #pragma acc parallel loop gang num_gangs(jend-jst+1) num_workers(8) vector_length(32)
  for (j = jst; j <= jend; j++) {
    #pragma acc loop worker
    for (i = ist; i <= iend; i++) {
    #pragma acc loop vector
      for (k = 1; k < nz; k++) {
        tmp = 1.0 / rsd[0][k][j][i];

        u21k = tmp * rsd[1][k][j][i];
        u31k = tmp * rsd[2][k][j][i];
        u41k = tmp * rsd[3][k][j][i];
        u51k = tmp * rsd[4][k][j][i];

        tmp = 1.0 / rsd[0][k-1][j][i];

        u21km1 = tmp * rsd[1][k-1][j][i];
        u31km1 = tmp * rsd[2][k-1][j][i];
        u41km1 = tmp * rsd[3][k-1][j][i];
        u51km1 = tmp * rsd[4][k-1][j][i];

        flux_G[1][j][i][k] = tz3 * ( u21k - u21km1 );
        flux_G[2][j][i][k] = tz3 * ( u31k - u31km1 );
        flux_G[3][j][i][k] = (4.0/3.0) * tz3 * ( u41k - u41km1 );
        flux_G[4][j][i][k] = 0.50 * ( 1.0 - C1*C5 )
          * tz3 * ( ( u21k*u21k     + u31k*u31k     + u41k*u41k )
                  - ( u21km1*u21km1 + u31km1*u31km1 + u41km1*u41km1 ) )
          + (1.0/6.0)
          * tz3 * ( u41k*u41k - u41km1*u41km1 )
          + C1 * C5 * tz3 * ( u51k - u51km1 );
      }
     }
    }

  #pragma acc parallel loop gang num_gangs(jend-jst+1) num_workers(8) vector_length(32)
  for (j = jst; j <= jend; j++) {
    #pragma acc loop worker
    for (i = ist; i <= iend; i++) {
    #pragma acc loop vector
      for (k = 1; k < nz - 1; k++) {
        frct[0][k][j][i] = frct[0][k][j][i]
          + dz1 * tz1 * (        rsd[0][k+1][j][i]
                         - 2.0 * rsd[0][k][j][i]
                         +       rsd[0][k-1][j][i] );
        frct[1][k][j][i] = frct[1][k][j][i]
          + tz3 * C3 * C4 * ( flux_G[1][j][i][k+1] - flux_G[1][j][i][k] )
          + dz2 * tz1 * (        rsd[1][k+1][j][i]
                         - 2.0 * rsd[1][k][j][i]
                         +       rsd[1][k-1][j][i] );
        frct[2][k][j][i] = frct[2][k][j][i]
          + tz3 * C3 * C4 * ( flux_G[2][j][i][k+1] - flux_G[2][j][i][k] )
          + dz3 * tz1 * (        rsd[2][k+1][j][i]
                         - 2.0 * rsd[2][k][j][i]
                         +       rsd[2][k-1][j][i] );
        frct[3][k][j][i] = frct[3][k][j][i]
          + tz3 * C3 * C4 * ( flux_G[3][j][i][k+1] - flux_G[3][j][i][k] )
          + dz4 * tz1 * (        rsd[3][k+1][j][i]
                         - 2.0 * rsd[3][k][j][i]
                         +       rsd[3][k-1][j][i] );
        frct[4][k][j][i] = frct[4][k][j][i]
          + tz3 * C3 * C4 * ( flux_G[4][j][i][k+1] - flux_G[4][j][i][k] )
          + dz5 * tz1 * (        rsd[4][k+1][j][i]
                         - 2.0 * rsd[4][k][j][i]
                         +       rsd[4][k-1][j][i] );
      }
     }
    }

      //---------------------------------------------------------------------
      // fourth-order dissipation
      //---------------------------------------------------------------------
  #pragma acc parallel loop gang num_gangs(jend-jst+1) num_workers(8) vector_length(32)
  for (j = jst; j <= jend; j++) {
    #pragma acc loop worker vector
    for (i = ist; i <= iend; i++) {
      for (m = 0; m < 5; m++) {
        frct[m][1][j][i] = frct[m][1][j][i]
          - dssp * ( + 5.0 * rsd[m][1][j][i]
                     - 4.0 * rsd[m][2][j][i]
                     +       rsd[m][3][j][i] );
        frct[m][2][j][i] = frct[m][2][j][i]
          - dssp * ( - 4.0 * rsd[m][1][j][i]
                     + 6.0 * rsd[m][2][j][i]
                     - 4.0 * rsd[m][3][j][i]
                     +       rsd[m][4][j][i] );
      }
     }
    }

  #pragma acc parallel loop gang num_gangs(jend-jst+1) num_workers(8) vector_length(32)
  for (j = jst; j <= jend; j++) {
    #pragma acc loop worker
    for (i = ist; i <= iend; i++) {
    #pragma acc loop vector
      for (k = 3; k < nz - 3; k++) {
        for (m = 0; m < 5; m++) {
          frct[m][k][j][i] = frct[m][k][j][i]
            - dssp * (        rsd[m][k-2][j][i]
                      - 4.0 * rsd[m][k-1][j][i]
                      + 6.0 * rsd[m][k][j][i]
                      - 4.0 * rsd[m][k+1][j][i]
                      +       rsd[m][k+2][j][i] );
        }
      }
     }
    }

  #pragma acc parallel loop gang num_gangs(jend-jst+1) num_workers(8) vector_length(32)
  for (j = jst; j <= jend; j++) {
    #pragma acc loop worker vector
    for (i = ist; i <= iend; i++) {
      for (m = 0; m < 5; m++) {
        frct[m][nz-3][j][i] = frct[m][nz-3][j][i]
          - dssp * (        rsd[m][nz-5][j][i]
                    - 4.0 * rsd[m][nz-4][j][i]
                    + 6.0 * rsd[m][nz-3][j][i]
                    - 4.0 * rsd[m][nz-2][j][i] );
        frct[m][nz-2][j][i] = frct[m][nz-2][j][i]
          - dssp * (        rsd[m][nz-4][j][i]
                    - 4.0 * rsd[m][nz-3][j][i]
                    + 5.0 * rsd[m][nz-2][j][i] );
      }
    }
  }
 }/*end acc data*/
}


########## NEXT FILE ##########
jacld.c:::
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB LU code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS LU code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

#include "applu.incl"

//---------------------------------------------------------------------
// compute the lower triangular part of the jacobian matrix
//---------------------------------------------------------------------
void jacld(int l)
{
  //---------------------------------------------------------------------
  // local variables
  //---------------------------------------------------------------------
  int i, j, k, n;
  double r43;
  double c1345;
  double c34;
  double tmp1, tmp2, tmp3;
  int npl = np[l];

  r43 = ( 4.0 / 3.0 );
  c1345 = C1 * C3 * C4 * C5;
  c34 = C3 * C4;
#pragma acc data present(indxp,jndxp,np,a,b,c,d,rho_i,qs,u)
{
  #pragma acc parallel loop gang worker vector num_gangs((npl+127)/128) \
                        num_workers(1) vector_length(128)
  for (n = 1; n <= npl; n++) {
  	j = jndxp[l][n];
	i = indxp[l][n];
	k = l - i - j;
      //---------------------------------------------------------------------
      // form the block daigonal
      //---------------------------------------------------------------------
      tmp1 = rho_i[k][j][i];
      tmp2 = tmp1 * tmp1;
      tmp3 = tmp1 * tmp2;

      d[0][0][n] =  1.0 + dt * 2.0 * ( tx1 * dx1 + ty1 * dy1 + tz1 * dz1 );
      d[1][0][n] =  0.0;
      d[2][0][n] =  0.0;
      d[3][0][n] =  0.0;
      d[4][0][n] =  0.0;

      d[0][1][n] = -dt * 2.0
        * ( tx1 * r43 + ty1 + tz1 ) * c34 * tmp2 * u[1][k][j][i];
      d[1][1][n] =  1.0
        + dt * 2.0 * c34 * tmp1 * ( tx1 * r43 + ty1 + tz1 )
        + dt * 2.0 * ( tx1 * dx2 + ty1 * dy2 + tz1 * dz2 );
      d[2][1][n] = 0.0;
      d[3][1][n] = 0.0;
      d[4][1][n] = 0.0;

      d[0][2][n] = -dt * 2.0 
        * ( tx1 + ty1 * r43 + tz1 ) * c34 * tmp2 * u[2][k][j][i];
      d[1][2][n] = 0.0;
      d[2][2][n] = 1.0
        + dt * 2.0 * c34 * tmp1 * ( tx1 + ty1 * r43 + tz1 )
        + dt * 2.0 * ( tx1 * dx3 + ty1 * dy3 + tz1 * dz3 );
      d[3][2][n] = 0.0;
      d[4][2][n] = 0.0;

      d[0][3][n] = -dt * 2.0
        * ( tx1 + ty1 + tz1 * r43 ) * c34 * tmp2 * u[3][k][j][i];
      d[1][3][n] = 0.0;
      d[2][3][n] = 0.0;
      d[3][3][n] = 1.0
        + dt * 2.0 * c34 * tmp1 * ( tx1 + ty1 + tz1 * r43 )
        + dt * 2.0 * ( tx1 * dx4 + ty1 * dy4 + tz1 * dz4 );
      d[4][3][n] = 0.0;

      d[0][4][n] = -dt * 2.0
        * ( ( ( tx1 * ( r43*c34 - c1345 )
                + ty1 * ( c34 - c1345 )
                + tz1 * ( c34 - c1345 ) ) * ( u[1][k][j][i]*u[1][k][j][i] )
              + ( tx1 * ( c34 - c1345 )
                + ty1 * ( r43*c34 - c1345 )
                + tz1 * ( c34 - c1345 ) ) * ( u[2][k][j][i]*u[2][k][j][i] )
              + ( tx1 * ( c34 - c1345 )
                + ty1 * ( c34 - c1345 )
                + tz1 * ( r43*c34 - c1345 ) ) * (u[3][k][j][i]*u[3][k][j][i])
            ) * tmp3
            + ( tx1 + ty1 + tz1 ) * c1345 * tmp2 * u[4][k][j][i] );

      d[1][4][n] = dt * 2.0 * tmp2 * u[1][k][j][i]
        * ( tx1 * ( r43*c34 - c1345 )
          + ty1 * (     c34 - c1345 )
          + tz1 * (     c34 - c1345 ) );
      d[2][4][n] = dt * 2.0 * tmp2 * u[2][k][j][i]
        * ( tx1 * ( c34 - c1345 )
          + ty1 * ( r43*c34 -c1345 )
          + tz1 * ( c34 - c1345 ) );
      d[3][4][n] = dt * 2.0 * tmp2 * u[3][k][j][i]
        * ( tx1 * ( c34 - c1345 )
          + ty1 * ( c34 - c1345 )
          + tz1 * ( r43*c34 - c1345 ) );
      d[4][4][n] = 1.0
        + dt * 2.0 * ( tx1  + ty1 + tz1 ) * c1345 * tmp1
        + dt * 2.0 * ( tx1 * dx5 +  ty1 * dy5 +  tz1 * dz5 );

      //---------------------------------------------------------------------
      // form the first block sub-diagonal
      //---------------------------------------------------------------------
      tmp1 = rho_i[k-1][j][i];
      tmp2 = tmp1 * tmp1;
      tmp3 = tmp1 * tmp2;

      a[0][0][n] = - dt * tz1 * dz1;
      a[1][0][n] =   0.0;
      a[2][0][n] =   0.0;
      a[3][0][n] = - dt * tz2;
      a[4][0][n] =   0.0;

      a[0][1][n] = - dt * tz2
        * ( - ( u[1][k-1][j][i]*u[3][k-1][j][i] ) * tmp2 )
        - dt * tz1 * ( - c34 * tmp2 * u[1][k-1][j][i] );
      a[1][1][n] = - dt * tz2 * ( u[3][k-1][j][i] * tmp1 )
        - dt * tz1 * c34 * tmp1
        - dt * tz1 * dz2;
      a[2][1][n] = 0.0;
      a[3][1][n] = - dt * tz2 * ( u[1][k-1][j][i] * tmp1 );
      a[4][1][n] = 0.0;

      a[0][2][n] = - dt * tz2
        * ( - ( u[2][k-1][j][i]*u[3][k-1][j][i] ) * tmp2 )
        - dt * tz1 * ( - c34 * tmp2 * u[2][k-1][j][i] );
      a[1][2][n] = 0.0;
      a[2][2][n] = - dt * tz2 * ( u[3][k-1][j][i] * tmp1 )
        - dt * tz1 * ( c34 * tmp1 )
        - dt * tz1 * dz3;
      a[3][2][n] = - dt * tz2 * ( u[2][k-1][j][i] * tmp1 );
      a[4][2][n] = 0.0;

      a[0][3][n] = - dt * tz2
        * ( - ( u[3][k-1][j][i] * tmp1 ) * ( u[3][k-1][j][i] * tmp1 )
            + C2 * qs[k-1][j][i] * tmp1 )
        - dt * tz1 * ( - r43 * c34 * tmp2 * u[3][k-1][j][i] );
      a[1][3][n] = - dt * tz2
        * ( - C2 * ( u[1][k-1][j][i] * tmp1 ) );
      a[2][3][n] = - dt * tz2
        * ( - C2 * ( u[2][k-1][j][i] * tmp1 ) );
      a[3][3][n] = - dt * tz2 * ( 2.0 - C2 )
        * ( u[3][k-1][j][i] * tmp1 )
        - dt * tz1 * ( r43 * c34 * tmp1 )
        - dt * tz1 * dz4;
      a[4][3][n] = - dt * tz2 * C2;

      a[0][4][n] = - dt * tz2
        * ( ( C2 * 2.0 * qs[k-1][j][i] - C1 * u[4][k-1][j][i] )
            * u[3][k-1][j][i] * tmp2 )
        - dt * tz1
        * ( - ( c34 - c1345 ) * tmp3 * (u[1][k-1][j][i]*u[1][k-1][j][i])
            - ( c34 - c1345 ) * tmp3 * (u[2][k-1][j][i]*u[2][k-1][j][i])
            - ( r43*c34 - c1345 )* tmp3 * (u[3][k-1][j][i]*u[3][k-1][j][i])
            - c1345 * tmp2 * u[4][k-1][j][i] );
      a[1][4][n] = - dt * tz2
        * ( - C2 * ( u[1][k-1][j][i]*u[3][k-1][j][i] ) * tmp2 )
        - dt * tz1 * ( c34 - c1345 ) * tmp2 * u[1][k-1][j][i];
      a[2][4][n] = - dt * tz2
        * ( - C2 * ( u[2][k-1][j][i]*u[3][k-1][j][i] ) * tmp2 )
        - dt * tz1 * ( c34 - c1345 ) * tmp2 * u[2][k-1][j][i];
      a[3][4][n] = - dt * tz2
        * ( C1 * ( u[4][k-1][j][i] * tmp1 )
          - C2 * ( qs[k-1][j][i] * tmp1
                 + u[3][k-1][j][i]*u[3][k-1][j][i] * tmp2 ) )
        - dt * tz1 * ( r43*c34 - c1345 ) * tmp2 * u[3][k-1][j][i];
      a[4][4][n] = - dt * tz2
        * ( C1 * ( u[3][k-1][j][i] * tmp1 ) )
        - dt * tz1 * c1345 * tmp1
        - dt * tz1 * dz5;

      //---------------------------------------------------------------------
      // form the second block sub-diagonal
      //---------------------------------------------------------------------
      tmp1 = rho_i[k][j-1][i];
      tmp2 = tmp1 * tmp1;
      tmp3 = tmp1 * tmp2;

      b[0][0][n] = - dt * ty1 * dy1;
      b[1][0][n] =   0.0;
      b[2][0][n] = - dt * ty2;
      b[3][0][n] =   0.0;
      b[4][0][n] =   0.0;

      b[0][1][n] = - dt * ty2
        * ( - ( u[1][k][j-1][i]*u[2][k][j-1][i] ) * tmp2 )
        - dt * ty1 * ( - c34 * tmp2 * u[1][k][j-1][i] );
      b[1][1][n] = - dt * ty2 * ( u[2][k][j-1][i] * tmp1 )
        - dt * ty1 * ( c34 * tmp1 )
        - dt * ty1 * dy2;
      b[2][1][n] = - dt * ty2 * ( u[1][k][j-1][i] * tmp1 );
      b[3][1][n] = 0.0;
      b[4][1][n] = 0.0;

      b[0][2][n] = - dt * ty2
        * ( - ( u[2][k][j-1][i] * tmp1 ) * ( u[2][k][j-1][i] * tmp1 )
            + C2 * ( qs[k][j-1][i] * tmp1 ) )
        - dt * ty1 * ( - r43 * c34 * tmp2 * u[2][k][j-1][i] );
      b[1][2][n] = - dt * ty2
        * ( - C2 * ( u[1][k][j-1][i] * tmp1 ) );
      b[2][2][n] = - dt * ty2 * ( (2.0 - C2) * (u[2][k][j-1][i] * tmp1) )
        - dt * ty1 * ( r43 * c34 * tmp1 )
        - dt * ty1 * dy3;
      b[3][2][n] = - dt * ty2 * ( - C2 * ( u[3][k][j-1][i] * tmp1 ) );
      b[4][2][n] = - dt * ty2 * C2;

      b[0][3][n] = - dt * ty2
        * ( - ( u[2][k][j-1][i]*u[3][k][j-1][i] ) * tmp2 )
        - dt * ty1 * ( - c34 * tmp2 * u[3][k][j-1][i] );
      b[1][3][n] = 0.0;
      b[2][3][n] = - dt * ty2 * ( u[3][k][j-1][i] * tmp1 );
      b[3][3][n] = - dt * ty2 * ( u[2][k][j-1][i] * tmp1 )
        - dt * ty1 * ( c34 * tmp1 )
        - dt * ty1 * dy4;
      b[4][3][n] = 0.0;

      b[0][4][n] = - dt * ty2
        * ( ( C2 * 2.0 * qs[k][j-1][i] - C1 * u[4][k][j-1][i] )
            * ( u[2][k][j-1][i] * tmp2 ) )
        - dt * ty1
        * ( - (     c34 - c1345 )*tmp3*(u[1][k][j-1][i]*u[1][k][j-1][i])
            - ( r43*c34 - c1345 )*tmp3*(u[2][k][j-1][i]*u[2][k][j-1][i])
            - (     c34 - c1345 )*tmp3*(u[3][k][j-1][i]*u[3][k][j-1][i])
            - c1345*tmp2*u[4][k][j-1][i] );
      b[1][4][n] = - dt * ty2
        * ( - C2 * ( u[1][k][j-1][i]*u[2][k][j-1][i] ) * tmp2 )
        - dt * ty1 * ( c34 - c1345 ) * tmp2 * u[1][k][j-1][i];
      b[2][4][n] = - dt * ty2
        * ( C1 * ( u[4][k][j-1][i] * tmp1 )
          - C2 * ( qs[k][j-1][i] * tmp1
                 + u[2][k][j-1][i]*u[2][k][j-1][i] * tmp2 ) )
        - dt * ty1 * ( r43*c34 - c1345 ) * tmp2 * u[2][k][j-1][i];
      b[3][4][n] = - dt * ty2
        * ( - C2 * ( u[2][k][j-1][i]*u[3][k][j-1][i] ) * tmp2 )
        - dt * ty1 * ( c34 - c1345 ) * tmp2 * u[3][k][j-1][i];
      b[4][4][n] = - dt * ty2
        * ( C1 * ( u[2][k][j-1][i] * tmp1 ) )
        - dt * ty1 * c1345 * tmp1
        - dt * ty1 * dy5;

      //---------------------------------------------------------------------
      // form the third block sub-diagonal
      //---------------------------------------------------------------------
      tmp1 = rho_i[k][j][i-1];
      tmp2 = tmp1 * tmp1;
      tmp3 = tmp1 * tmp2;

      c[0][0][n] = - dt * tx1 * dx1;
      c[1][0][n] = - dt * tx2;
      c[2][0][n] =   0.0;
      c[3][0][n] =   0.0;
      c[4][0][n] =   0.0;

      c[0][1][n] = - dt * tx2
        * ( - ( u[1][k][j][i-1] * tmp1 ) * ( u[1][k][j][i-1] * tmp1 )
            + C2 * qs[k][j][i-1] * tmp1 )
        - dt * tx1 * ( - r43 * c34 * tmp2 * u[1][k][j][i-1] );
      c[1][1][n] = - dt * tx2
        * ( ( 2.0 - C2 ) * ( u[1][k][j][i-1] * tmp1 ) )
        - dt * tx1 * ( r43 * c34 * tmp1 )
        - dt * tx1 * dx2;
      c[2][1][n] = - dt * tx2
        * ( - C2 * ( u[2][k][j][i-1] * tmp1 ) );
      c[3][1][n] = - dt * tx2
        * ( - C2 * ( u[3][k][j][i-1] * tmp1 ) );
      c[4][1][n] = - dt * tx2 * C2;

      c[0][2][n] = - dt * tx2
        * ( - ( u[1][k][j][i-1] * u[2][k][j][i-1] ) * tmp2 )
        - dt * tx1 * ( - c34 * tmp2 * u[2][k][j][i-1] );
      c[1][2][n] = - dt * tx2 * ( u[2][k][j][i-1] * tmp1 );
      c[2][2][n] = - dt * tx2 * ( u[1][k][j][i-1] * tmp1 )
        - dt * tx1 * ( c34 * tmp1 )
        - dt * tx1 * dx3;
      c[3][2][n] = 0.0;
      c[4][2][n] = 0.0;

      c[0][3][n] = - dt * tx2
        * ( - ( u[1][k][j][i-1]*u[3][k][j][i-1] ) * tmp2 )
        - dt * tx1 * ( - c34 * tmp2 * u[3][k][j][i-1] );
      c[1][3][n] = - dt * tx2 * ( u[3][k][j][i-1] * tmp1 );
      c[2][3][n] = 0.0;
      c[3][3][n] = - dt * tx2 * ( u[1][k][j][i-1] * tmp1 )
        - dt * tx1 * ( c34 * tmp1 ) - dt * tx1 * dx4;
      c[4][3][n] = 0.0;

      c[0][4][n] = - dt * tx2
        * ( ( C2 * 2.0 * qs[k][j][i-1] - C1 * u[4][k][j][i-1] )
            * u[1][k][j][i-1] * tmp2 )
        - dt * tx1
        * ( - ( r43*c34 - c1345 ) * tmp3 * ( u[1][k][j][i-1]*u[1][k][j][i-1] )
            - (     c34 - c1345 ) * tmp3 * ( u[2][k][j][i-1]*u[2][k][j][i-1] )
            - (     c34 - c1345 ) * tmp3 * ( u[3][k][j][i-1]*u[3][k][j][i-1] )
            - c1345 * tmp2 * u[4][k][j][i-1] );
      c[1][4][n] = - dt * tx2
        * ( C1 * ( u[4][k][j][i-1] * tmp1 )
          - C2 * ( u[1][k][j][i-1]*u[1][k][j][i-1] * tmp2
                 + qs[k][j][i-1] * tmp1 ) )
        - dt * tx1 * ( r43*c34 - c1345 ) * tmp2 * u[1][k][j][i-1];
      c[2][4][n] = - dt * tx2
        * ( - C2 * ( u[2][k][j][i-1]*u[1][k][j][i-1] ) * tmp2 )
        - dt * tx1 * (  c34 - c1345 ) * tmp2 * u[2][k][j][i-1];
      c[3][4][n] = - dt * tx2
        * ( - C2 * ( u[3][k][j][i-1]*u[1][k][j][i-1] ) * tmp2 )
        - dt * tx1 * (  c34 - c1345 ) * tmp2 * u[3][k][j][i-1];
      c[4][4][n] = - dt * tx2
        * ( C1 * ( u[1][k][j][i-1] * tmp1 ) )
        - dt * tx1 * c1345 * tmp1
        - dt * tx1 * dx5;
  }
 }/*end acc data*/
}


########## NEXT FILE ##########
jacu.c:::
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB LU code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS LU code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

#include "applu.incl"

//---------------------------------------------------------------------
// compute the upper triangular part of the jacobian matrix
//---------------------------------------------------------------------
void jacu(int l)
{
  //---------------------------------------------------------------------
  // local variables
  //---------------------------------------------------------------------
  int i, j, k, n;
  double r43;
  double c1345;
  double c34;
  double tmp1, tmp2, tmp3;
  int npl = np[l];

  r43 = ( 4.0 / 3.0 );
  c1345 = C1 * C3 * C4 * C5;
  c34 = C3 * C4;

#pragma acc data present(indxp,jndxp,np,a,b,c,d,rho_i,qs,u)
{
  #pragma acc parallel loop gang worker vector num_gangs((npl+127)/128) \
                            num_workers(1) vector_length(128)
  for (n = 1; n <= npl; n++) {
  	j = jndxp[l][n];
	i = indxp[l][n];
	k = l - i - j;
      //---------------------------------------------------------------------
      // form the block daigonal
      //---------------------------------------------------------------------
      tmp1 = rho_i[k][j][i];
      tmp2 = tmp1 * tmp1;
      tmp3 = tmp1 * tmp2;

      d[0][0][n] = 1.0 + dt * 2.0 * ( tx1 * dx1 + ty1 * dy1 + tz1 * dz1 );
      d[1][0][n] = 0.0;
      d[2][0][n] = 0.0;
      d[3][0][n] = 0.0;
      d[4][0][n] = 0.0;

      d[0][1][n] =  dt * 2.0
        * ( - tx1 * r43 - ty1 - tz1 )
        * ( c34 * tmp2 * u[1][k][j][i] );
      d[1][1][n] =  1.0
        + dt * 2.0 * c34 * tmp1 
        * (  tx1 * r43 + ty1 + tz1 )
        + dt * 2.0 * ( tx1 * dx2 + ty1 * dy2 + tz1 * dz2 );
      d[2][1][n] = 0.0;
      d[3][1][n] = 0.0;
      d[4][1][n] = 0.0;

      d[0][2][n] = dt * 2.0
        * ( - tx1 - ty1 * r43 - tz1 )
        * ( c34 * tmp2 * u[2][k][j][i] );
      d[1][2][n] = 0.0;
      d[2][2][n] = 1.0
        + dt * 2.0 * c34 * tmp1
        * (  tx1 + ty1 * r43 + tz1 )
        + dt * 2.0 * ( tx1 * dx3 + ty1 * dy3 + tz1 * dz3 );
      d[3][2][n] = 0.0;
      d[4][2][n] = 0.0;

      d[0][3][n] = dt * 2.0
        * ( - tx1 - ty1 - tz1 * r43 )
        * ( c34 * tmp2 * u[3][k][j][i] );
      d[1][3][n] = 0.0;
      d[2][3][n] = 0.0;
      d[3][3][n] = 1.0
        + dt * 2.0 * c34 * tmp1
        * (  tx1 + ty1 + tz1 * r43 )
        + dt * 2.0 * ( tx1 * dx4 + ty1 * dy4 + tz1 * dz4 );
      d[4][3][n] = 0.0;

      d[0][4][n] = -dt * 2.0
        * ( ( ( tx1 * ( r43*c34 - c1345 )
                + ty1 * ( c34 - c1345 )
                + tz1 * ( c34 - c1345 ) ) * ( u[1][k][j][i]*u[1][k][j][i] )
              + ( tx1 * ( c34 - c1345 )
                + ty1 * ( r43*c34 - c1345 )
                + tz1 * ( c34 - c1345 ) ) * ( u[2][k][j][i]*u[2][k][j][i] )
              + ( tx1 * ( c34 - c1345 )
                + ty1 * ( c34 - c1345 )
                + tz1 * ( r43*c34 - c1345 ) ) * (u[3][k][j][i]*u[3][k][j][i])
            ) * tmp3
            + ( tx1 + ty1 + tz1 ) * c1345 * tmp2 * u[4][k][j][i] );

      d[1][4][n] = dt * 2.0
        * ( tx1 * ( r43*c34 - c1345 )
          + ty1 * (     c34 - c1345 )
          + tz1 * (     c34 - c1345 ) ) * tmp2 * u[1][k][j][i];
      d[2][4][n] = dt * 2.0
        * ( tx1 * ( c34 - c1345 )
          + ty1 * ( r43*c34 -c1345 )
          + tz1 * ( c34 - c1345 ) ) * tmp2 * u[2][k][j][i];
      d[3][4][n] = dt * 2.0
        * ( tx1 * ( c34 - c1345 )
          + ty1 * ( c34 - c1345 )
          + tz1 * ( r43*c34 - c1345 ) ) * tmp2 * u[3][k][j][i];
      d[4][4][n] = 1.0
        + dt * 2.0 * ( tx1 + ty1 + tz1 ) * c1345 * tmp1
        + dt * 2.0 * ( tx1 * dx5 + ty1 * dy5 + tz1 * dz5 );

      //---------------------------------------------------------------------
      // form the first block sub-diagonal
      //---------------------------------------------------------------------
      tmp1 = rho_i[k][j][i+1];
      tmp2 = tmp1 * tmp1;
      tmp3 = tmp1 * tmp2;

      a[0][0][n] = - dt * tx1 * dx1;
      a[1][0][n] =   dt * tx2;
      a[2][0][n] =   0.0;
      a[3][0][n] =   0.0;
      a[4][0][n] =   0.0;

      a[0][1][n] =  dt * tx2
        * ( - ( u[1][k][j][i+1] * tmp1 ) * ( u[1][k][j][i+1] * tmp1 )
            + C2 * qs[k][j][i+1] * tmp1 )
        - dt * tx1 * ( - r43 * c34 * tmp2 * u[1][k][j][i+1] );
      a[1][1][n] =  dt * tx2
        * ( ( 2.0 - C2 ) * ( u[1][k][j][i+1] * tmp1 ) )
        - dt * tx1 * ( r43 * c34 * tmp1 )
        - dt * tx1 * dx2;
      a[2][1][n] =  dt * tx2
        * ( - C2 * ( u[2][k][j][i+1] * tmp1 ) );
      a[3][1][n] =  dt * tx2
        * ( - C2 * ( u[3][k][j][i+1] * tmp1 ) );
      a[4][1][n] =  dt * tx2 * C2 ;

      a[0][2][n] =  dt * tx2
        * ( - ( u[1][k][j][i+1] * u[2][k][j][i+1] ) * tmp2 )
        - dt * tx1 * ( - c34 * tmp2 * u[2][k][j][i+1] );
      a[1][2][n] =  dt * tx2 * ( u[2][k][j][i+1] * tmp1 );
      a[2][2][n] =  dt * tx2 * ( u[1][k][j][i+1] * tmp1 )
        - dt * tx1 * ( c34 * tmp1 )
        - dt * tx1 * dx3;
      a[3][2][n] = 0.0;
      a[4][2][n] = 0.0;

      a[0][3][n] = dt * tx2
        * ( - ( u[1][k][j][i+1]*u[3][k][j][i+1] ) * tmp2 )
        - dt * tx1 * ( - c34 * tmp2 * u[3][k][j][i+1] );
      a[1][3][n] = dt * tx2 * ( u[3][k][j][i+1] * tmp1 );
      a[2][3][n] = 0.0;
      a[3][3][n] = dt * tx2 * ( u[1][k][j][i+1] * tmp1 )
        - dt * tx1 * ( c34 * tmp1 )
        - dt * tx1 * dx4;
      a[4][3][n] = 0.0;

      a[0][4][n] = dt * tx2
        * ( ( C2 * 2.0 * qs[k][j][i+1]
            - C1 * u[4][k][j][i+1] )
        * ( u[1][k][j][i+1] * tmp2 ) )
        - dt * tx1
        * ( - ( r43*c34 - c1345 ) * tmp3 * ( u[1][k][j][i+1]*u[1][k][j][i+1] )
            - (     c34 - c1345 ) * tmp3 * ( u[2][k][j][i+1]*u[2][k][j][i+1] )
            - (     c34 - c1345 ) * tmp3 * ( u[3][k][j][i+1]*u[3][k][j][i+1] )
            - c1345 * tmp2 * u[4][k][j][i+1] );
      a[1][4][n] = dt * tx2
        * ( C1 * ( u[4][k][j][i+1] * tmp1 )
            - C2
            * ( u[1][k][j][i+1]*u[1][k][j][i+1] * tmp2
              + qs[k][j][i+1] * tmp1 ) )
        - dt * tx1
        * ( r43*c34 - c1345 ) * tmp2 * u[1][k][j][i+1];
      a[2][4][n] = dt * tx2
        * ( - C2 * ( u[2][k][j][i+1]*u[1][k][j][i+1] ) * tmp2 )
        - dt * tx1
        * (  c34 - c1345 ) * tmp2 * u[2][k][j][i+1];
      a[3][4][n] = dt * tx2
        * ( - C2 * ( u[3][k][j][i+1]*u[1][k][j][i+1] ) * tmp2 )
        - dt * tx1
        * (  c34 - c1345 ) * tmp2 * u[3][k][j][i+1];
      a[4][4][n] = dt * tx2
        * ( C1 * ( u[1][k][j][i+1] * tmp1 ) )
        - dt * tx1 * c1345 * tmp1
        - dt * tx1 * dx5;

      //---------------------------------------------------------------------
      // form the second block sub-diagonal
      //---------------------------------------------------------------------
      tmp1 = rho_i[k][j+1][i];
      tmp2 = tmp1 * tmp1;
      tmp3 = tmp1 * tmp2;

      b[0][0][n] = - dt * ty1 * dy1;
      b[1][0][n] =   0.0;
      b[2][0][n] =  dt * ty2;
      b[3][0][n] =   0.0;
      b[4][0][n] =   0.0;

      b[0][1][n] =  dt * ty2
        * ( - ( u[1][k][j+1][i]*u[2][k][j+1][i] ) * tmp2 )
        - dt * ty1 * ( - c34 * tmp2 * u[1][k][j+1][i] );
      b[1][1][n] =  dt * ty2 * ( u[2][k][j+1][i] * tmp1 )
        - dt * ty1 * ( c34 * tmp1 )
        - dt * ty1 * dy2;
      b[2][1][n] =  dt * ty2 * ( u[1][k][j+1][i] * tmp1 );
      b[3][1][n] = 0.0;
      b[4][1][n] = 0.0;

      b[0][2][n] =  dt * ty2
        * ( - ( u[2][k][j+1][i] * tmp1 ) * ( u[2][k][j+1][i] * tmp1 )
            + C2 * ( qs[k][j+1][i] * tmp1 ) )
        - dt * ty1 * ( - r43 * c34 * tmp2 * u[2][k][j+1][i] );
      b[1][2][n] =  dt * ty2
        * ( - C2 * ( u[1][k][j+1][i] * tmp1 ) );
      b[2][2][n] =  dt * ty2 * ( ( 2.0 - C2 )
          * ( u[2][k][j+1][i] * tmp1 ) )
        - dt * ty1 * ( r43 * c34 * tmp1 )
        - dt * ty1 * dy3;
      b[3][2][n] =  dt * ty2
        * ( - C2 * ( u[3][k][j+1][i] * tmp1 ) );
      b[4][2][n] =  dt * ty2 * C2;

      b[0][3][n] =  dt * ty2
        * ( - ( u[2][k][j+1][i]*u[3][k][j+1][i] ) * tmp2 )
        - dt * ty1 * ( - c34 * tmp2 * u[3][k][j+1][i] );
      b[1][3][n] = 0.0;
      b[2][3][n] =  dt * ty2 * ( u[3][k][j+1][i] * tmp1 );
      b[3][3][n] =  dt * ty2 * ( u[2][k][j+1][i] * tmp1 )
        - dt * ty1 * ( c34 * tmp1 )
        - dt * ty1 * dy4;
      b[4][3][n] = 0.0;

      b[0][4][n] =  dt * ty2
        * ( ( C2 * 2.0 * qs[k][j+1][i]
            - C1 * u[4][k][j+1][i] )
        * ( u[2][k][j+1][i] * tmp2 ) )
        - dt * ty1
        * ( - (     c34 - c1345 )*tmp3*(u[1][k][j+1][i]*u[1][k][j+1][i])
            - ( r43*c34 - c1345 )*tmp3*(u[2][k][j+1][i]*u[2][k][j+1][i])
            - (     c34 - c1345 )*tmp3*(u[3][k][j+1][i]*u[3][k][j+1][i])
            - c1345*tmp2*u[4][k][j+1][i] );
      b[1][4][n] =  dt * ty2
        * ( - C2 * ( u[1][k][j+1][i]*u[2][k][j+1][i] ) * tmp2 )
        - dt * ty1
        * ( c34 - c1345 ) * tmp2 * u[1][k][j+1][i];
      b[2][4][n] =  dt * ty2
        * ( C1 * ( u[4][k][j+1][i] * tmp1 )
            - C2 
            * ( qs[k][j+1][i] * tmp1
              + u[2][k][j+1][i]*u[2][k][j+1][i] * tmp2 ) )
        - dt * ty1
        * ( r43*c34 - c1345 ) * tmp2 * u[2][k][j+1][i];
      b[3][4][n] =  dt * ty2
        * ( - C2 * ( u[2][k][j+1][i]*u[3][k][j+1][i] ) * tmp2 )
        - dt * ty1 * ( c34 - c1345 ) * tmp2 * u[3][k][j+1][i];
      b[4][4][n] =  dt * ty2
        * ( C1 * ( u[2][k][j+1][i] * tmp1 ) )
        - dt * ty1 * c1345 * tmp1
        - dt * ty1 * dy5;

      //---------------------------------------------------------------------
      // form the third block sub-diagonal
      //---------------------------------------------------------------------
      tmp1 = rho_i[k+1][j][i];
      tmp2 = tmp1 * tmp1;
      tmp3 = tmp1 * tmp2;

      c[0][0][n] = - dt * tz1 * dz1;
      c[1][0][n] =   0.0;
      c[2][0][n] =   0.0;
      c[3][0][n] = dt * tz2;
      c[4][0][n] =   0.0;

      c[0][1][n] = dt * tz2
        * ( - ( u[1][k+1][j][i]*u[3][k+1][j][i] ) * tmp2 )
        - dt * tz1 * ( - c34 * tmp2 * u[1][k+1][j][i] );
      c[1][1][n] = dt * tz2 * ( u[3][k+1][j][i] * tmp1 )
        - dt * tz1 * c34 * tmp1
        - dt * tz1 * dz2;
      c[2][1][n] = 0.0;
      c[3][1][n] = dt * tz2 * ( u[1][k+1][j][i] * tmp1 );
      c[4][1][n] = 0.0;

      c[0][2][n] = dt * tz2
        * ( - ( u[2][k+1][j][i]*u[3][k+1][j][i] ) * tmp2 )
        - dt * tz1 * ( - c34 * tmp2 * u[2][k+1][j][i] );
      c[1][2][n] = 0.0;
      c[2][2][n] = dt * tz2 * ( u[3][k+1][j][i] * tmp1 )
        - dt * tz1 * ( c34 * tmp1 )
        - dt * tz1 * dz3;
      c[3][2][n] = dt * tz2 * ( u[2][k+1][j][i] * tmp1 );
      c[4][2][n] = 0.0;

      c[0][3][n] = dt * tz2
        * ( - ( u[3][k+1][j][i] * tmp1 ) * ( u[3][k+1][j][i] * tmp1 )
            + C2 * ( qs[k+1][j][i] * tmp1 ) )
        - dt * tz1 * ( - r43 * c34 * tmp2 * u[3][k+1][j][i] );
      c[1][3][n] = dt * tz2
        * ( - C2 * ( u[1][k+1][j][i] * tmp1 ) );
      c[2][3][n] = dt * tz2
        * ( - C2 * ( u[2][k+1][j][i] * tmp1 ) );
      c[3][3][n] = dt * tz2 * ( 2.0 - C2 )
        * ( u[3][k+1][j][i] * tmp1 )
        - dt * tz1 * ( r43 * c34 * tmp1 )
        - dt * tz1 * dz4;
      c[4][3][n] = dt * tz2 * C2;

      c[0][4][n] = dt * tz2
        * ( ( C2 * 2.0 * qs[k+1][j][i]
            - C1 * u[4][k+1][j][i] )
                 * ( u[3][k+1][j][i] * tmp2 ) )
        - dt * tz1
        * ( - ( c34 - c1345 ) * tmp3 * (u[1][k+1][j][i]*u[1][k+1][j][i])
            - ( c34 - c1345 ) * tmp3 * (u[2][k+1][j][i]*u[2][k+1][j][i])
            - ( r43*c34 - c1345 )* tmp3 * (u[3][k+1][j][i]*u[3][k+1][j][i])
            - c1345 * tmp2 * u[4][k+1][j][i] );
      c[1][4][n] = dt * tz2
        * ( - C2 * ( u[1][k+1][j][i]*u[3][k+1][j][i] ) * tmp2 )
        - dt * tz1 * ( c34 - c1345 ) * tmp2 * u[1][k+1][j][i];
      c[2][4][n] = dt * tz2
        * ( - C2 * ( u[2][k+1][j][i]*u[3][k+1][j][i] ) * tmp2 )
        - dt * tz1 * ( c34 - c1345 ) * tmp2 * u[2][k+1][j][i];
      c[3][4][n] = dt * tz2
        * ( C1 * ( u[4][k+1][j][i] * tmp1 )
            - C2
            * ( qs[k+1][j][i] * tmp1
              + u[3][k+1][j][i]*u[3][k+1][j][i] * tmp2 ) )
        - dt * tz1 * ( r43*c34 - c1345 ) * tmp2 * u[3][k+1][j][i];
      c[4][4][n] = dt * tz2
        * ( C1 * ( u[3][k+1][j][i] * tmp1 ) )
        - dt * tz1 * c1345 * tmp1
        - dt * tz1 * dz5;
  }
 }/*end acc data*/
}


########## NEXT FILE ##########
l2norm.c:::
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB LU code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS LU code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

#include <math.h>
#include "applu.incl"

//---------------------------------------------------------------------
// to compute the l2-norm of vector v.
//---------------------------------------------------------------------
//---------------------------------------------------------------------
// To improve cache performance, second two dimensions padded by 1 
// for even number sizes only.  Only needed in v.
//---------------------------------------------------------------------
void l2norm (int ldx, int ldy, int ldz, int nx0, int ny0, int nz0,
     int ist, int iend, int jst, int jend)
{
  //---------------------------------------------------------------------
  // local variables
  //---------------------------------------------------------------------
  int i, j, k, m;
  double rsdnm0, rsdnm1, rsdnm2, rsdnm3, rsdnm4;
  
  rsdnm0 = (double)0.0;
  rsdnm1 = (double)0.0;
  rsdnm2 = (double)0.0;
  rsdnm3 = (double)0.0;
  rsdnm4 = (double)0.0;

#pragma acc data present(rsd,rsdnm)
{
  #pragma acc parallel loop num_gangs(1) num_workers(1) vector_length(32)
  for (m = 0; m < 5; m++) {
    rsdnm[m] = 0.0;
  }

 #pragma acc parallel loop gang reduction(+:rsdnm0,rsdnm1,rsdnm2,rsdnm3,rsdnm4) \
                num_gangs(nz0-2) num_workers(8) vector_length(32)
  for (k = 1; k < nz0-1; k++) {
  #pragma acc loop worker
    for (j = jst; j <= jend; j++) {
  	 #pragma acc loop vector 
      for (i = ist; i <= iend; i++) {
			rsdnm0 = rsdnm0 + rsd[0][k][j][i] * rsd[0][k][j][i];
			rsdnm1 = rsdnm1 + rsd[1][k][j][i] * rsd[1][k][j][i];
			rsdnm2 = rsdnm2 + rsd[2][k][j][i] * rsd[2][k][j][i];
			rsdnm3 = rsdnm3 + rsd[3][k][j][i] * rsd[3][k][j][i];
			rsdnm4 = rsdnm4 + rsd[4][k][j][i] * rsd[4][k][j][i];
      }
    }
  }
  
  #pragma acc parallel num_gangs(1) num_workers(1) vector_length(1)
  {
    rsdnm[0] = rsdnm0;
    rsdnm[1] = rsdnm1;
    rsdnm[2] = rsdnm2;
    rsdnm[3] = rsdnm3;
    rsdnm[4] = rsdnm4;
  }

  #pragma acc parallel loop gang vector num_gangs(1) num_workers(1) vector_length(32)
  for (m = 0; m < 5; m++) {
    rsdnm[m] = sqrt ( rsdnm[m] / ( (nx0-2)*(ny0-2)*(nz0-2) ) );
  }
 }
}


########## NEXT FILE ##########
lu.c:::
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB LU code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS LU code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

//---------------------------------------------------------------------
//   program applu
//---------------------------------------------------------------------

//---------------------------------------------------------------------
//
//   driver for the performance evaluation of the solver for
//   five coupled parabolic/elliptic partial differential equations.
//
//---------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include "applu.incl"
#include "timers.h"
#include "print_results.h"
#include <openacc.h>

//---------------------------------------------------------------------
// grid
//---------------------------------------------------------------------
/* common/cgcon/ */
double dxi, deta, dzeta;
double tx1, tx2, tx3;
double ty1, ty2, ty3;
double tz1, tz2, tz3;
int nx, ny, nz;
int nx0, ny0, nz0;
int ist, iend;
int jst, jend;
int ii1, ii2;
int ji1, ji2;
int ki1, ki2;

//---------------------------------------------------------------------
// dissipation
//---------------------------------------------------------------------
/* common/disp/ */
double dx1, dx2, dx3, dx4, dx5;
double dy1, dy2, dy3, dy4, dy5;
double dz1, dz2, dz3, dz4, dz5;
double dssp;

//---------------------------------------------------------------------
// field variables and residuals
// to improve cache performance, second two dimensions padded by 1 
// for even number sizes only.
// Note: corresponding array (called "v") in routines blts, buts, 
// and l2norm are similarly padded
//---------------------------------------------------------------------
/* common/cvar/ */
double u[5][ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1];
double rsd[5][ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1];
double frct[5][ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1];
double flux_G[5][ISIZ3][ISIZ2][ISIZ1];
double qs   [ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1];
double rho_i[ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1];

//---------------------------------------------------------------------
// output control parameters
//---------------------------------------------------------------------
/* common/cprcon/ */
int ipr, inorm;

//---------------------------------------------------------------------
// newton-raphson iteration control parameters
//---------------------------------------------------------------------
/* common/ctscon/ */
double dt, omega, tolrsd[5], rsdnm[5], errnm[5], frc, ttotal;
int itmax, invert;

/* common/cjac/ */
double a[5][5][ISIZ1*ISIZ2];
double b[5][5][ISIZ1*ISIZ2];
double c[5][5][ISIZ1*ISIZ2];
double d[5][5][ISIZ1*ISIZ2];

int np[ISIZ1+ISIZ2+ISIZ3-5];
int indxp[ISIZ1+ISIZ2+ISIZ3-5][ISIZ1*ISIZ2*3/4];
int jndxp[ISIZ1+ISIZ2+ISIZ3-5][ISIZ1*ISIZ2*3/4];
double tmat[5][5][ISIZ1*ISIZ2*3/4];
double tv[5][ISIZ1*ISIZ2*3/4];
double utmp_G[6][ISIZ2][ISIZ1][ISIZ3];
double rtmp_G[5][ISIZ2][ISIZ1][ISIZ3];

//---------------------------------------------------------------------
// coefficients of the exact solution
//---------------------------------------------------------------------
/* common/cexact/ */
double ce[5][13];


//---------------------------------------------------------------------
// timers
//---------------------------------------------------------------------
/* common/timer/ */
double maxtime;
logical timeron;


int main(int argc, char *argv[])
{
  char Class;
  logical verified;
  double mflops;

  double t, tmax, trecs[t_last+1];
  int i;
  char *t_names[t_last+1];
  acc_init(acc_device_default);

  //---------------------------------------------------------------------
  // Setup info for timers
  //---------------------------------------------------------------------
  FILE *fp;
  if ((fp = fopen("timer.flag", "r")) != NULL) {
    timeron = true;
    t_names[t_total] = "total";
    t_names[t_rhsx] = "rhsx";
    t_names[t_rhsy] = "rhsy";
    t_names[t_rhsz] = "rhsz";
    t_names[t_rhs] = "rhs";
    t_names[t_jacld] = "jacld";
    t_names[t_blts] = "blts";
    t_names[t_jacu] = "jacu";
    t_names[t_buts] = "buts";
    t_names[t_add] = "add";
    t_names[t_l2norm] = "l2norm";
    fclose(fp);
  } else {
    timeron = false;
  }

  //---------------------------------------------------------------------
  // read input data
  //---------------------------------------------------------------------
  read_input();
  //---------------------------------------------------------------------
  // set up domain sizes
  //---------------------------------------------------------------------
  domain();

  //---------------------------------------------------------------------
  // set up coefficients
  //---------------------------------------------------------------------
  setcoeff();

#pragma acc data create(a,b,c,d,flux_G,indxp,jndxp,np,rho_i,frct,qs,rsd,u,tmat,tv,utmp_G,rtmp_G) \
			     copyout(rsdnm)
{
  //---------------------------------------------------------------------
  // set the boundary values for dependent variables
  //---------------------------------------------------------------------
  setbv();

  //---------------------------------------------------------------------
  // set the initial values for dependent variables
  //---------------------------------------------------------------------
  setiv();
  #pragma acc update device(u)
  //---------------------------------------------------------------------
  // compute the forcing term based on prescribed exact solution
  //---------------------------------------------------------------------
  erhs();

  //---------------------------------------------------------------------
  // perform one SSOR iteration to touch all pages
  //---------------------------------------------------------------------
  ssor(1);

  //---------------------------------------------------------------------
  // reset the boundary and initial values
  //---------------------------------------------------------------------
  setbv();
  setiv();
  #pragma acc update device(u)

  //---------------------------------------------------------------------
  // perform the SSOR iterations
  //---------------------------------------------------------------------
  ssor(itmax);


  //---------------------------------------------------------------------
  // compute the solution error
  //---------------------------------------------------------------------
  #pragma acc update host(u)
  error();

  //---------------------------------------------------------------------
  // compute the surface integral
  //---------------------------------------------------------------------
  pintgr();
}/*end acc data*/
  //---------------------------------------------------------------------
  // verification test
  //---------------------------------------------------------------------
  verify ( rsdnm, errnm, frc, &Class, &verified );
  mflops = (double)itmax * (1984.77 * (double)nx0
      * (double)ny0
      * (double)nz0
      - 10923.3 * pow(((double)(nx0+ny0+nz0)/3.0), 2.0) 
      + 27770.9 * (double)(nx0+ny0+nz0)/3.0
      - 144010.0)
    / (maxtime*1000000.0);

  print_results("LU", Class, nx0,
                ny0, nz0, itmax,
                maxtime, mflops, "          floating point", verified, 
                NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, 
                "(none)");

  //---------------------------------------------------------------------
  // More timers
  //---------------------------------------------------------------------
  if (timeron) {
    for (i = 1; i <= t_last; i++) {
      trecs[i] = timer_read(i);
    }
    tmax = maxtime;
    if (tmax == 0.0) tmax = 1.0;

    printf("  SECTION     Time (secs)\n");
    for (i = 1; i <= t_last; i++) {
      printf("  %-8s:%9.3f  (%6.2f%%)\n",
          t_names[i], trecs[i], trecs[i]*100./tmax);
      if (i == t_rhs) {
        t = trecs[t_rhsx] + trecs[t_rhsy] + trecs[t_rhsz];
        printf("     --> %8s:%9.3f  (%6.2f%%)\n", "sub-rhs", t, t*100./tmax);
        t = trecs[i] - t;
        printf("     --> %8s:%9.3f  (%6.2f%%)\n", "rest-rhs", t, t*100./tmax);
      }
    }
  }

  acc_shutdown(acc_device_default);
  return 0;
}


########## NEXT FILE ##########
rhs.c:::
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB LU code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS LU code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

#include "applu.incl"
#include "timers.h"

//---------------------------------------------------------------------
// compute the right hand sides
//---------------------------------------------------------------------
void rhs()
{
  //---------------------------------------------------------------------
  // local variables
  //---------------------------------------------------------------------
  int i, j, k, m;
  double q;
  double tmp;
  double u21, u31, u41;
  double u21i, u31i, u41i, u51i;
  double u21j, u31j, u41j, u51j;
  double u21k, u31k, u41k, u51k;
  double u21im1, u31im1, u41im1, u51im1;
  double u21jm1, u31jm1, u41jm1, u51jm1;
  double u21km1, u31km1, u41km1, u51km1;
  unsigned num_workers3 = 0;
  unsigned num_workers2 = 0;

#pragma acc data present(flux_G,rho_i,frct,qs,rsd,u,utmp_G,rtmp_G)
{
  if (timeron) timer_start(t_rhs);
  #pragma acc parallel loop gang num_gangs(nz) num_workers(8) vector_length(128)
  for (k = 0; k < nz; k++) {
  #pragma acc loop worker 
    for (j = 0; j < ny; j++) {
  #pragma acc loop vector
      for (i = 0; i < nx; i++) {
        for (m = 0; m < 5; m++) {
          rsd[m][k][j][i] = - frct[m][k][j][i];
        }
        tmp = 1.0 / u[0][k][j][i];
        rho_i[k][j][i] = tmp;
        qs[k][j][i] = 0.50 * (  u[1][k][j][i] * u[1][k][j][i]
                              + u[2][k][j][i] * u[2][k][j][i]
                              + u[3][k][j][i] * u[3][k][j][i] )
                           * tmp;
      }
    }
  }

  if (timeron) timer_start(t_rhsx);
  if(((jend-jst+1))<32)
	num_workers3 = (jend-jst+1);
  else
	num_workers3 = 32;
  //---------------------------------------------------------------------
  // xi-direction flux differences
  //---------------------------------------------------------------------
  #pragma acc parallel loop gang num_gangs(nz-2) num_workers(num_workers3) vector_length(32)
  for (k = 1; k < nz - 1; k++) {
  #pragma acc loop worker
    for (j = jst; j <= jend; j++) {
     #pragma acc loop vector
      for (i = 0; i < nx; i++) {
        flux_G[0][k][j][i] = u[1][k][j][i];
        u21 = u[1][k][j][i] * rho_i[k][j][i];

        q = qs[k][j][i];

        flux_G[1][k][j][i] = u[1][k][j][i] * u21 + C2 * ( u[4][k][j][i] - q );
        flux_G[2][k][j][i] = u[2][k][j][i] * u21;
        flux_G[3][k][j][i] = u[3][k][j][i] * u21;
        flux_G[4][k][j][i] = ( C1 * u[4][k][j][i] - C2 * q ) * u21;
      }
     }
    }

 #pragma acc parallel loop gang num_gangs(nz-2) num_workers(num_workers3) vector_length(32)
  for (k = 1; k < nz - 1; k++) {
 #pragma acc loop worker 
    for (j = jst; j <= jend; j++) {
 #pragma acc loop vector
      for (i = ist; i <= iend; i++) {
        for (m = 0; m < 5; m++) {
          rsd[m][k][j][i] =  rsd[m][k][j][i]
            - tx2 * ( flux_G[m][k][j][i+1] - flux_G[m][k][j][i-1] );
        }
      }
    }
  }

#pragma acc parallel loop gang num_gangs(nz-2) num_workers(num_workers3) vector_length(32)
  for (k = 1; k < nz - 1; k++) {
#pragma acc loop worker 
    for (j = jst; j <= jend; j++) {
#pragma acc loop vector
      for (i = ist; i < nx; i++) {
        tmp = rho_i[k][j][i];

        u21i = tmp * u[1][k][j][i];
        u31i = tmp * u[2][k][j][i];
        u41i = tmp * u[3][k][j][i];
        u51i = tmp * u[4][k][j][i];

        tmp = rho_i[k][j][i-1];

        u21im1 = tmp * u[1][k][j][i-1];
        u31im1 = tmp * u[2][k][j][i-1];
        u41im1 = tmp * u[3][k][j][i-1];
        u51im1 = tmp * u[4][k][j][i-1];

        flux_G[1][k][j][i] = (4.0/3.0) * tx3 * (u21i-u21im1);
        flux_G[2][k][j][i] = tx3 * ( u31i - u31im1 );
        flux_G[3][k][j][i] = tx3 * ( u41i - u41im1 );
        flux_G[4][k][j][i] = 0.50 * ( 1.0 - C1*C5 )
          * tx3 * ( ( u21i*u21i     + u31i*u31i     + u41i*u41i )
                  - ( u21im1*u21im1 + u31im1*u31im1 + u41im1*u41im1 ) )
          + (1.0/6.0)
          * tx3 * ( u21i*u21i - u21im1*u21im1 )
          + C1 * C5 * tx3 * ( u51i - u51im1 );
      }
     }
    }

#pragma acc parallel loop gang num_gangs(nz-2) num_workers(num_workers3) vector_length(32)
  for (k = 1; k < nz - 1; k++) {
#pragma acc loop worker
    for (j = jst; j <= jend; j++) {
#pragma acc loop vector
      for (i = ist; i <= iend; i++) {
        rsd[0][k][j][i] = rsd[0][k][j][i]
          + dx1 * tx1 * (        u[0][k][j][i-1]
                         - 2.0 * u[0][k][j][i]
                         +       u[0][k][j][i+1] );
        rsd[1][k][j][i] = rsd[1][k][j][i]
          + tx3 * C3 * C4 * ( flux_G[1][k][j][i+1] - flux_G[1][k][j][i] )
          + dx2 * tx1 * (        u[1][k][j][i-1]
                         - 2.0 * u[1][k][j][i]
                         +       u[1][k][j][i+1] );
        rsd[2][k][j][i] = rsd[2][k][j][i]
          + tx3 * C3 * C4 * ( flux_G[2][k][j][i+1] - flux_G[2][k][j][i] )
          + dx3 * tx1 * (        u[2][k][j][i-1]
                         - 2.0 * u[2][k][j][i]
                         +       u[2][k][j][i+1] );
        rsd[3][k][j][i] = rsd[3][k][j][i]
          + tx3 * C3 * C4 * ( flux_G[3][k][j][i+1] - flux_G[3][k][j][i] )
          + dx4 * tx1 * (        u[3][k][j][i-1]
                         - 2.0 * u[3][k][j][i]
                         +       u[3][k][j][i+1] );
        rsd[4][k][j][i] = rsd[4][k][j][i]
          + tx3 * C3 * C4 * ( flux_G[4][k][j][i+1] - flux_G[4][k][j][i] )
          + dx5 * tx1 * (        u[4][k][j][i-1]
                         - 2.0 * u[4][k][j][i]
                         +       u[4][k][j][i+1] );
       }
     }
   }

      //---------------------------------------------------------------------
      // Fourth-order dissipation
      //---------------------------------------------------------------------
  if(((jend-jst+1)/32)<32)
     num_workers2 = (jend-jst+1)/32;
  else
     num_workers2 = 32;
#pragma acc parallel loop gang num_gangs(nz-2) num_workers(num_workers2) vector_length(32)
  for (k = 1; k < nz - 1; k++) {
#pragma acc loop worker vector
    for (j = jst; j <= jend; j++) {
      for (m = 0; m < 5; m++) {
        rsd[m][k][j][1] = rsd[m][k][j][1]
          - dssp * ( + 5.0 * u[m][k][j][1]
                     - 4.0 * u[m][k][j][2]
                     +       u[m][k][j][3] );
        rsd[m][k][j][2] = rsd[m][k][j][2]
          - dssp * ( - 4.0 * u[m][k][j][1]
                     + 6.0 * u[m][k][j][2]
                     - 4.0 * u[m][k][j][3]
                     +       u[m][k][j][4] );
      }
    }
  }
  
#pragma acc parallel loop gang num_gangs(nz-2) num_workers(num_workers3) vector_length(32)
  for (k = 1; k < nz - 1; k++) {
#pragma acc loop worker 
    for (j = jst; j <= jend; j++) {
#pragma acc loop vector
      for (i = 3; i < nx - 3; i++) {
        for (m = 0; m < 5; m++) {
          rsd[m][k][j][i] = rsd[m][k][j][i]
            - dssp * (         u[m][k][j][i-2]
                       - 4.0 * u[m][k][j][i-1]
                       + 6.0 * u[m][k][j][i]
                       - 4.0 * u[m][k][j][i+1]
                       +       u[m][k][j][i+2] );
        }
      }
    }
  }

#pragma acc parallel loop gang num_gangs(nz-2) num_workers(num_workers2) vector_length(32)
  for (k = 1; k < nz - 1; k++) {
#pragma acc loop worker vector
    for (j = jst; j <= jend; j++) {
      for (m = 0; m < 5; m++) {
        rsd[m][k][j][nx-3] = rsd[m][k][j][nx-3]
          - dssp * (         u[m][k][j][nx-5]
                     - 4.0 * u[m][k][j][nx-4]
                     + 6.0 * u[m][k][j][nx-3]
                     - 4.0 * u[m][k][j][nx-2] );
        rsd[m][k][j][nx-2] = rsd[m][k][j][nx-2]
          - dssp * (         u[m][k][j][nx-4]
                     - 4.0 * u[m][k][j][nx-3]
                     + 5.0 * u[m][k][j][nx-2] );
      }

    }
  }
  if (timeron) timer_stop(t_rhsx);

  if (timeron) timer_start(t_rhsy);
  //---------------------------------------------------------------------
  // eta-direction flux differences
  //---------------------------------------------------------------------
  if(((jend-jst+1))<32)
     num_workers3 = (iend-ist+1);
  else
     num_workers3 = 32;
  #pragma acc parallel loop gang num_gangs(nz-2) num_workers(num_workers3) vector_length(32)
  for (k = 1; k < nz - 1; k++) {
  #pragma acc loop worker
    for (i = ist; i <= iend; i++) {
  #pragma acc loop vector
      for (j = 0; j < ny; j++) {
        flux_G[0][k][i][j] = u[2][k][j][i];
        u31 = u[2][k][j][i] * rho_i[k][j][i];

        q = qs[k][j][i];

        flux_G[1][k][i][j] = u[1][k][j][i] * u31;
        flux_G[2][k][i][j] = u[2][k][j][i] * u31 + C2 * (u[4][k][j][i]-q);
        flux_G[3][k][i][j] = u[3][k][j][i] * u31;
        flux_G[4][k][i][j] = ( C1 * u[4][k][j][i] - C2 * q ) * u31;
      }
     }
    }

  #pragma acc parallel loop gang num_gangs(nz-2) num_workers(num_workers3) vector_length(32)
  for (k = 1; k < nz - 1; k++) {
  #pragma acc loop worker
    for (i = ist; i <= iend; i++) {
  #pragma acc loop vector
      for (j = jst; j <= jend; j++) {
        for (m = 0; m < 5; m++) {
          rsd[m][k][j][i] =  rsd[m][k][j][i]
            - ty2 * ( flux_G[m][k][i][j+1] - flux_G[m][k][i][j-1] );
        }
      }
     }
   }

  #pragma acc parallel loop gang num_gangs(nz-2) num_workers(num_workers3) vector_length(32)
  for (k = 1; k < nz - 1; k++) {
  #pragma acc loop worker
    for (i = ist; i <= iend; i++) {
  #pragma acc loop vector
      for (j = jst; j < ny; j++) {
        tmp = rho_i[k][j][i];

        u21j = tmp * u[1][k][j][i];
        u31j = tmp * u[2][k][j][i];
        u41j = tmp * u[3][k][j][i];
        u51j = tmp * u[4][k][j][i];

        tmp = rho_i[k][j-1][i];
        u21jm1 = tmp * u[1][k][j-1][i];
        u31jm1 = tmp * u[2][k][j-1][i];
        u41jm1 = tmp * u[3][k][j-1][i];
        u51jm1 = tmp * u[4][k][j-1][i];

        flux_G[1][k][i][j] = ty3 * ( u21j - u21jm1 );
        flux_G[2][k][i][j] = (4.0/3.0) * ty3 * (u31j-u31jm1);
        flux_G[3][k][i][j] = ty3 * ( u41j - u41jm1 );
        flux_G[4][k][i][j] = 0.50 * ( 1.0 - C1*C5 )
          * ty3 * ( ( u21j*u21j     + u31j*u31j     + u41j*u41j )
                  - ( u21jm1*u21jm1 + u31jm1*u31jm1 + u41jm1*u41jm1 ) )
          + (1.0/6.0)
          * ty3 * ( u31j*u31j - u31jm1*u31jm1 )
          + C1 * C5 * ty3 * ( u51j - u51jm1 );
      }
     }
    }

#pragma acc parallel loop gang num_gangs(nz-2) num_workers(num_workers3) vector_length(32)
  for (k = 1; k < nz - 1; k++) {
#pragma acc loop worker
      for (i = ist; i <= iend; i++) {
     #pragma acc loop vector
      for (j = jst; j <= jend; j++) {
        rsd[0][k][j][i] = rsd[0][k][j][i]
          + dy1 * ty1 * (         u[0][k][j-1][i]
                          - 2.0 * u[0][k][j][i]
                          +       u[0][k][j+1][i] );

        rsd[1][k][j][i] = rsd[1][k][j][i]
          + ty3 * C3 * C4 * ( flux_G[1][k][i][j+1] - flux_G[1][k][i][j] )
          + dy2 * ty1 * (         u[1][k][j-1][i]
                          - 2.0 * u[1][k][j][i]
                          +       u[1][k][j+1][i] );

        rsd[2][k][j][i] = rsd[2][k][j][i]
          + ty3 * C3 * C4 * ( flux_G[2][k][i][j+1] - flux_G[2][k][i][j] )
          + dy3 * ty1 * (         u[2][k][j-1][i]
                          - 2.0 * u[2][k][j][i]
                          +       u[2][k][j+1][i] );

        rsd[3][k][j][i] = rsd[3][k][j][i]
          + ty3 * C3 * C4 * ( flux_G[3][k][i][j+1] - flux_G[3][k][i][j] )
          + dy4 * ty1 * (         u[3][k][j-1][i]
                          - 2.0 * u[3][k][j][i]
                          +       u[3][k][j+1][i] );

        rsd[4][k][j][i] = rsd[4][k][j][i]
          + ty3 * C3 * C4 * ( flux_G[4][k][i][j+1] - flux_G[4][k][i][j] )
          + dy5 * ty1 * (         u[4][k][j-1][i]
                          - 2.0 * u[4][k][j][i]
                          +       u[4][k][j+1][i] );
      }
    }
  }

    //---------------------------------------------------------------------
    // fourth-order dissipation
    //---------------------------------------------------------------------
  if(((jend-jst+1)/32)<32)
     num_workers2 = (iend-ist+1)/32;
  else
     num_workers2 = 32;
  #pragma acc parallel loop gang num_gangs(nz-2) num_workers(num_workers2) vector_length(32)
  for (k = 1; k < nz - 1; k++) {
  #pragma acc loop worker vector
    for (i = ist; i <= iend; i++) {
      for (m = 0; m < 5; m++) {
        rsd[m][k][1][i] = rsd[m][k][1][i]
          - dssp * ( + 5.0 * u[m][k][1][i]
                     - 4.0 * u[m][k][2][i]
                     +       u[m][k][3][i] );
        rsd[m][k][2][i] = rsd[m][k][2][i]
          - dssp * ( - 4.0 * u[m][k][1][i]
                     + 6.0 * u[m][k][2][i]
                     - 4.0 * u[m][k][3][i]
                     +       u[m][k][4][i] );
      }
    }
  }

  unsigned int num_workers4 = 0;
  if((ny-6)<8)
  	num_workers4 = ny-6;
  else
  	num_workers4 = 8;
  	
#pragma acc parallel loop gang num_gangs(nz-2) num_workers(num_workers4) vector_length(128)
  for (k = 1; k < nz - 1; k++) {
#pragma acc loop worker
    for (j = 3; j < ny - 3; j++) {
#pragma acc loop vector
      for (i = ist; i <= iend; i++) {
        for (m = 0; m < 5; m++) {
          rsd[m][k][j][i] = rsd[m][k][j][i]
            - dssp * (         u[m][k][j-2][i]
                       - 4.0 * u[m][k][j-1][i]
                       + 6.0 * u[m][k][j][i]
                       - 4.0 * u[m][k][j+1][i]
                       +       u[m][k][j+2][i] );
        }
      }
    }
  }

#pragma acc parallel loop gang num_gangs(nz-2) num_workers(num_workers2) vector_length(32)
  for (k = 1; k < nz - 1; k++) {
#pragma acc loop worker vector
    for (i = ist; i <= iend; i++) {
      for (m = 0; m < 5; m++) {
        rsd[m][k][ny-3][i] = rsd[m][k][ny-3][i]
          - dssp * (         u[m][k][ny-5][i]
                     - 4.0 * u[m][k][ny-4][i]
                     + 6.0 * u[m][k][ny-3][i]
                     - 4.0 * u[m][k][ny-2][i] );
        rsd[m][k][ny-2][i] = rsd[m][k][ny-2][i]
          - dssp * (         u[m][k][ny-4][i]
                     - 4.0 * u[m][k][ny-3][i]
                     + 5.0 * u[m][k][ny-2][i] );
      }
    }

  }
  if (timeron) timer_stop(t_rhsy);

  if (timeron) timer_start(t_rhsz);
  //---------------------------------------------------------------------
  // zeta-direction flux differences
  //---------------------------------------------------------------------
  #pragma acc parallel loop gang num_gangs(jend-jst+1) num_workers(num_workers3) vector_length(32)
  for (j = jst; j <= jend; j++) {
   #pragma acc loop worker
    for (i = ist; i <= iend; i++) {
      #pragma acc loop vector
      for (k = 0; k < nz; k++) {
        utmp_G[0][j][i][k] = u[0][k][j][i];
        utmp_G[1][j][i][k] = u[1][k][j][i];
        utmp_G[2][j][i][k] = u[2][k][j][i];
        utmp_G[3][j][i][k] = u[3][k][j][i];
        utmp_G[4][j][i][k] = u[4][k][j][i];
        utmp_G[5][j][i][k] = rho_i[k][j][i];
      }
    }
  }
  #pragma acc parallel loop gang num_gangs(jend-jst+1) num_workers(num_workers3) vector_length(32)
  for (j = jst; j <= jend; j++) {
   #pragma acc loop worker
    for (i = ist; i <= iend; i++) {
      #pragma acc loop vector
      for (k = 0; k < nz; k++) {
        flux_G[0][j][i][k] = utmp_G[3][j][i][k];
        u41 = utmp_G[3][j][i][k] * utmp_G[5][j][i][k];

        q = qs[k][j][i];

        flux_G[1][j][i][k] = utmp_G[1][j][i][k] * u41;
        flux_G[2][j][i][k] = utmp_G[2][j][i][k] * u41;
        flux_G[3][j][i][k] = utmp_G[3][j][i][k] * u41 + C2 * (utmp_G[4][j][i][k]-q);
        flux_G[4][j][i][k] = ( C1 * utmp_G[4][j][i][k] - C2 * q ) * u41;
      }
     }
    }

  #pragma acc parallel loop  gang num_gangs(jend-jst+1) num_workers(num_workers3) vector_length(32)
  for (j = jst; j <= jend; j++) {
   #pragma acc loop worker
    for (i = ist; i <= iend; i++) {
      #pragma acc loop vector
      for (k = 1; k < nz - 1; k++) {
        for (m = 0; m < 5; m++) {
          rtmp_G[m][j][i][k] =  rsd[m][k][j][i]
            - tz2 * ( flux_G[m][j][i][k+1] - flux_G[m][j][i][k-1] );
        }
      }
     }
    }

   #pragma acc parallel loop  gang num_gangs(jend-jst+1) num_workers(num_workers3) vector_length(32)
   for (j = jst; j <= jend; j++) {
   #pragma acc loop worker
    for (i = ist; i <= iend; i++) {
      #pragma acc loop vector
      for (k = 1; k < nz; k++) {
        tmp = utmp_G[5][j][i][k];

        u21k = tmp * utmp_G[1][j][i][k];
        u31k = tmp * utmp_G[2][j][i][k];
        u41k = tmp * utmp_G[3][j][i][k];
        u51k = tmp * utmp_G[4][j][i][k];

        tmp = utmp_G[5][j][i][k-1];

        u21km1 = tmp * utmp_G[1][j][i][k-1];
        u31km1 = tmp * utmp_G[2][j][i][k-1];
        u41km1 = tmp * utmp_G[3][j][i][k-1];
        u51km1 = tmp * utmp_G[4][j][i][k-1];

        flux_G[1][j][i][k] = tz3 * ( u21k - u21km1 );
        flux_G[2][j][i][k] = tz3 * ( u31k - u31km1 );
        flux_G[3][j][i][k] = (4.0/3.0) * tz3 * (u41k-u41km1);
        flux_G[4][j][i][k] = 0.50 * ( 1.0 - C1*C5 )
          * tz3 * ( ( u21k*u21k     + u31k*u31k     + u41k*u41k )
                  - ( u21km1*u21km1 + u31km1*u31km1 + u41km1*u41km1 ) )
          + (1.0/6.0)
          * tz3 * ( u41k*u41k - u41km1*u41km1 )
          + C1 * C5 * tz3 * ( u51k - u51km1 );
      }
     }
    }

#pragma acc parallel loop gang num_gangs(jend-jst+1) num_workers(num_workers3) vector_length(32)
   for (j = jst; j <= jend; j++) {
   #pragma acc loop worker
    for (i = ist; i <= iend; i++) {
      #pragma acc loop vector
      for (k = 1; k < nz - 1; k++) {
        rtmp_G[0][j][i][k] = rtmp_G[0][j][i][k]
          + dz1 * tz1 * (         utmp_G[0][j][i][k-1]
                          - 2.0 * utmp_G[0][j][i][k]
                          +       utmp_G[0][j][i][k+1] );
        rtmp_G[1][j][i][k] = rtmp_G[1][j][i][k]
          + tz3 * C3 * C4 * ( flux_G[1][j][i][k+1] - flux_G[1][j][i][k] )
          + dz2 * tz1 * (         utmp_G[1][j][i][k-1]
                          - 2.0 * utmp_G[1][j][i][k]
                          +       utmp_G[1][j][i][k+1] );
        rtmp_G[2][j][i][k] = rtmp_G[2][j][i][k]
          + tz3 * C3 * C4 * ( flux_G[2][j][i][k+1] - flux_G[2][j][i][k] )
          + dz3 * tz1 * (         utmp_G[2][j][i][k-1]
                          - 2.0 * utmp_G[2][j][i][k]
                          +       utmp_G[2][j][i][k+1] );
        rtmp_G[3][j][i][k] = rtmp_G[3][j][i][k]
          + tz3 * C3 * C4 * ( flux_G[3][j][i][k+1] - flux_G[3][j][i][k] )
          + dz4 * tz1 * (         utmp_G[3][j][i][k-1]
                          - 2.0 * utmp_G[3][j][i][k]
                          +       utmp_G[3][j][i][k+1] );
        rtmp_G[4][j][i][k] = rtmp_G[4][j][i][k]
          + tz3 * C3 * C4 * ( flux_G[4][j][i][k+1] - flux_G[4][j][i][k] )
          + dz5 * tz1 * (         utmp_G[4][j][i][k-1]
                          - 2.0 * utmp_G[4][j][i][k]
                          +       utmp_G[4][j][i][k+1] );
      }
     }
    }

      //---------------------------------------------------------------------
      // fourth-order dissipation
      //---------------------------------------------------------------------
   #pragma acc parallel loop  gang num_gangs(jend-jst+1) num_workers(num_workers3) vector_length(32)
   for (j = jst; j <= jend; j++) {
   #pragma acc loop worker
    for (i = ist; i <= iend; i++) {
      #pragma acc loop vector
      for (m = 0; m < 5; m++) {
        rsd[m][1][j][i] = rtmp_G[m][j][i][1]
          - dssp * ( + 5.0 * utmp_G[m][j][i][1]
                     - 4.0 * utmp_G[m][j][i][2]
                     +       utmp_G[m][j][i][3] );
        rsd[m][2][j][i] = rtmp_G[m][j][i][2]
          - dssp * ( - 4.0 * utmp_G[m][j][i][1]
                     + 6.0 * utmp_G[m][j][i][2]
                     - 4.0 * utmp_G[m][j][i][3]
                     +       utmp_G[m][j][i][4] );
      }
     }
    }

   #pragma acc parallel loop  gang num_gangs(jend-jst+1) num_workers(num_workers3) vector_length(32)
   for (j = jst; j <= jend; j++) {
   #pragma acc loop worker
    for (i = ist; i <= iend; i++) {
      #pragma acc loop vector
      for (k = 3; k < nz - 3; k++) {
        for (m = 0; m < 5; m++) {
          rsd[m][k][j][i] = rtmp_G[m][j][i][k]
            - dssp * (         utmp_G[m][j][i][k-2]
                       - 4.0 * utmp_G[m][j][i][k-1]
                       + 6.0 * utmp_G[m][j][i][k]
                       - 4.0 * utmp_G[m][j][i][k+1]
                       +       utmp_G[m][j][i][k+2] );
        }
      }
     }
    }

   #pragma acc parallel loop  gang num_gangs(jend-jst+1) num_workers(num_workers2) vector_length(32)
   for (j = jst; j <= jend; j++) {
   #pragma acc loop worker vector
    for (i = ist; i <= iend; i++) {
      for (m = 0; m < 5; m++) {
        rsd[m][nz-3][j][i] = rtmp_G[m][j][i][nz-3]
          - dssp * (         utmp_G[m][j][i][nz-5]
                     - 4.0 * utmp_G[m][j][i][nz-4]
                     + 6.0 * utmp_G[m][j][i][nz-3]
                     - 4.0 * utmp_G[m][j][i][nz-2] );
        rsd[m][nz-2][j][i] = rtmp_G[m][j][i][nz-2]
          - dssp * (         utmp_G[m][j][i][nz-4]
                     - 4.0 * utmp_G[m][j][i][nz-3]
                     + 5.0 * utmp_G[m][j][i][nz-2] );
      }
    }
  }
  if (timeron) timer_stop(t_rhsz);
  if (timeron) timer_stop(t_rhs);
}/*end acc data*/
}


########## NEXT FILE ##########
ssor.c:::
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB LU code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS LU code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

#include <stdio.h>
#include "applu.incl"
#include "timers.h"


//---------------------------------------------------------------------
// to perform pseudo-time stepping SSOR iterations
// for five nonlinear pde's.
//---------------------------------------------------------------------
void ssor(int niter)
{
  //---------------------------------------------------------------------
  // local variables
  //---------------------------------------------------------------------
  int i, j, k, m, n;
  int istep;
  double tmp;
  double delunm[5];

  int l, lst, lend;
  unsigned int num_workers = 0, num_gangs = 0;


  //---------------------------------------------------------------------
  // begin pseudo-time stepping iterations
  //---------------------------------------------------------------------
  tmp = 1.0 / ( omega * ( 2.0 - omega ) );
  lst = ist + jst + 1;
  lend = iend + jend + nz -2;

  //---------------------------------------------------------------------
  // initialize a,b,c,d to zero (guarantees that page tables have been
  // formed, if applicable on given architecture, before timestepping).
  //---------------------------------------------------------------------
  num_gangs = (ISIZ1*ISIZ2)/1024;
#pragma acc parallel loop gang worker vector present(a,b,c,d) \
                     num_gangs(num_gangs) num_workers(32) vector_length(32)
  for (l = 0; l < ISIZ1*ISIZ2; l++) {
      for (n = 0; n < 5; n++) {
        for (m = 0; m < 5; m++) {
          a[n][m][l] = 0.0;
          b[n][m][l] = 0.0;
          c[n][m][l] = 0.0;
          d[n][m][l] = 0.0;
        }
      }
  }
  for (i = 1; i <= t_last; i++) {
    timer_clear(i);
  }

  //---------------------------------------------------------------------
  // compute the steady-state residuals
  //---------------------------------------------------------------------
  rhs();

  //---------------------------------------------------------------------
  // compute the L2 norms of newton iteration residuals
  //---------------------------------------------------------------------
  //#pragma acc update host(rsd) 
  l2norm( ISIZ1, ISIZ2, ISIZ3, nx0, ny0, nz0,
          ist, iend, jst, jend);
      #pragma acc update host(rsdnm)


  /*
  if ( ipr == 1 ) {
    printf("           Initial residual norms\n");
    printf("\n");
    printf(" \n RMS-norm of steady-state residual for "
           "first pde  = %12.5E\n"
           " RMS-norm of steady-state residual for "
           "second pde = %12.5E\n"
           " RMS-norm of steady-state residual for "
           "third pde  = %12.5E\n"
           " RMS-norm of steady-state residual for "
           "fourth pde = %12.5E\n"
           " RMS-norm of steady-state residual for "
           "fifth pde  = %12.5E\n", 
           rsdnm[0], rsdnm[1], rsdnm[2], rsdnm[3], rsdnm[4]);
    printf("\nIteration RMS-residual of 5th PDE\n");
  }
  */
 
  for (i = 1; i <= t_last; i++) {
    timer_clear(i);
  }

	calcnp(lst, lend);
	#pragma acc update device(indxp,jndxp,np)
  timer_start(1);
  //---------------------------------------------------------------------
  // the timestep loop
  //---------------------------------------------------------------------
  for (istep = 1; istep <= niter; istep++) {
    //if ( ( (istep % inorm) == 0 ) && ipr == 1 ) {
    //  printf(" \n     pseudo-time SSOR iteration no.=%4d\n\n", istep);
    //}
    if ((istep % 20) == 0 || istep == itmax || istep == 1) {
      if (niter > 1) printf(" Time step %4d\n", istep);
    }

    //---------------------------------------------------------------------
    // perform SSOR iteration
    //---------------------------------------------------------------------
    if (timeron) timer_start(t_rhs);
    if((jend-jst+1)<32)
    	num_workers = jend-jst+1;
    else
    	num_workers = 32;
	#pragma acc parallel loop gang present(rsd) num_gangs(nz-2) \
                      num_workers(num_workers) vector_length(32)
    for (k = 1; k < nz - 1; k++) {
    #pragma acc loop worker
      for (j = jst; j <= jend; j++) {
      #pragma acc loop vector
        for (i = ist; i <= iend; i++) {
          for (m = 0; m < 5; m++) {
            rsd[m][k][j][i] = dt * rsd[m][k][j][i];
          }
        }
      }
    }
    if (timeron) timer_stop(t_rhs);

	for(l = lst; l <= lend; l++)
	{
		jacld(l);

		blts(ISIZ1, ISIZ2, ISIZ3, 
			 nx, ny, nz, l,
			 omega); 
	}


	for(l = lend; l >= lst; l--)
	{
		
		jacu(l);

		buts(ISIZ1, ISIZ2, ISIZ3, 
			 nx, ny, nz, l,
			 omega);
	}

    //---------------------------------------------------------------------
    // update the variables
    //---------------------------------------------------------------------
    if (timeron) timer_start(t_add);
	#pragma acc parallel loop gang present(u,rsd) num_gangs(nz-2) \
                      num_workers(num_workers/2) vector_length(64)
    for (k = 1; k < nz-1; k++) {
	#pragma acc loop worker
      for (j = jst; j <= jend; j++) {
	#pragma acc loop vector
        for (i = ist; i <= iend; i++) {
          //for (m = 0; m < 5; m++) 
          {
            u[0][k][j][i] = u[0][k][j][i] + tmp * rsd[0][k][j][i];
	    u[1][k][j][i] = u[1][k][j][i] + tmp * rsd[1][k][j][i];
	    u[2][k][j][i] = u[2][k][j][i] + tmp * rsd[2][k][j][i];
	    u[3][k][j][i] = u[3][k][j][i] + tmp * rsd[3][k][j][i];
	    u[4][k][j][i] = u[4][k][j][i] + tmp * rsd[4][k][j][i];
          }
        }
      }
    }
    if (timeron) timer_stop(t_add);

    //---------------------------------------------------------------------
    // compute the max-norms of newton iteration corrections
    //---------------------------------------------------------------------
    if ( (istep % inorm) == 0 ) {
      if (timeron) timer_start(t_l2norm);
	  /*
      l2norm( ISIZ1, ISIZ2, ISIZ3, nx0, ny0, nz0,
              ist, iend, jst, jend,
              rsd, delunm );
	  */
      if (timeron) timer_stop(t_l2norm);
      /*
      if ( ipr == 1 ) {
        printf(" \n RMS-norm of SSOR-iteration correction "
               "for first pde  = %12.5E\n"
               " RMS-norm of SSOR-iteration correction "
               "for second pde = %12.5E\n"
               " RMS-norm of SSOR-iteration correction "
               "for third pde  = %12.5E\n"
               " RMS-norm of SSOR-iteration correction "
               "for fourth pde = %12.5E\n",
               " RMS-norm of SSOR-iteration correction "
               "for fifth pde  = %12.5E\n", 
               delunm[0], delunm[1], delunm[2], delunm[3], delunm[4]); 
      } else if ( ipr == 2 ) {
        printf("(%5d,%15.6f)\n", istep, delunm[4]);
      }
      */
    }
 
    //---------------------------------------------------------------------
    // compute the steady-state residuals
    //---------------------------------------------------------------------
    rhs();
 
    //---------------------------------------------------------------------
    // compute the max-norms of newton iteration residuals
    //---------------------------------------------------------------------
    if ( ((istep % inorm ) == 0 ) || ( istep == itmax ) ) {
      if (timeron) timer_start(t_l2norm);
      l2norm( ISIZ1, ISIZ2, ISIZ3, nx0, ny0, nz0,
              ist, iend, jst, jend);
      #pragma acc update host(rsdnm)
      if (timeron) timer_stop(t_l2norm);
      /*
      if ( ipr == 1 ) {
        printf(" \n RMS-norm of steady-state residual for "
               "first pde  = %12.5E\n"
               " RMS-norm of steady-state residual for "
               "second pde = %12.5E\n"
               " RMS-norm of steady-state residual for "
               "third pde  = %12.5E\n"
               " RMS-norm of steady-state residual for "
               "fourth pde = %12.5E\n"
               " RMS-norm of steady-state residual for "
               "fifth pde  = %12.5E\n", 
               rsdnm[0], rsdnm[1], rsdnm[2], rsdnm[3], rsdnm[4]);
      }
      */
    }

    //---------------------------------------------------------------------
    // check the newton-iteration residuals against the tolerance levels
    //---------------------------------------------------------------------
    if ( ( rsdnm[0] < tolrsd[0] ) && ( rsdnm[1] < tolrsd[1] ) &&
         ( rsdnm[2] < tolrsd[2] ) && ( rsdnm[3] < tolrsd[3] ) &&
         ( rsdnm[4] < tolrsd[4] ) ) {
      //if (ipr == 1 ) {
      printf(" \n convergence was achieved after %4d pseudo-time steps\n",
          istep);
      //}
      break;
    }
  }

  timer_stop(1);
  maxtime = timer_read(1);
}


########## NEXT FILE ##########
mg.c:::
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB MG code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS MG code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

//---------------------------------------------------------------------
//  program mg
//---------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include "globals.h"
//#include "randdp.h"
#include "timers.h"
#include "print_results.h"
#include <openacc.h>

#define I3D(array,n1,n2,i3,i2,i1) (array[(i3)*n2*n1 + (i2)*n1 + (i1)])

static void setup(int *n1, int *n2, int *n3);
static void mg3P(double u[], double v[], double r[],
                 double a[4], double c[4], int n1, int n2, int n3);
static void psinv(double *or, double *ou, int n1, int n2, int n3,
                  double c[4], int k);
static void resid(double *ou, double *ov, double *or, int n1, int n2, int n3,
                  double a[4], int k);
static void rprj3(double *or, int m1k, int m2k, int m3k,
                  double *os, int m1j, int m2j, int m3j, int k);
static void interp(double *oz, int mm1, int mm2, int mm3,
                   double *ou, int n1, int n2, int n3, int k);
static void norm2u3(double *or, int n1, int n2, int n3,
                    double *rnm2, double *rnmu,
                    int nx, int ny, int nz);
static void rep_nrm(double *u, int n1, int n2, int n3, char *title, int kk);
static void comm3(double *ou, int n1, int n2, int n3, int kk);
static void zran3(double *oz, int n1, int n2, int n3, int nx, int ny, int k);
static void showall(double *oz, int n1, int n2, int n3);
static double power(double a, int n);
static void bubble(double ten[][2], int j1[][2], int j2[][2], int j3[][2],
                   int m, int ind);
static void zero3(double *oz, int n1, int n2, int n3);


//-------------------------------------------------------------------------c
// These arrays are in common because they are quite large
// and probably shouldn't be allocated on the stack. They
// are always passed as subroutine args. 
//-------------------------------------------------------------------------c
/* commcon /noautom/ */
static double u[NR];
static double v[NR];
static double r[NR];
int gnr = NR;

/* common /grid/ */
static int is1, is2, is3, ie1, ie2, ie3;


int main()
{
  //-------------------------------------------------------------------------c
  // k is the current level. It is passed down through subroutine args
  // and is NOT global. it is the current iteration
  //-------------------------------------------------------------------------c
  int k, it;
  double t, tinit, mflops;

  double a[4], c[4];

  double rnm2, rnmu, old2, oldu, epsilon;
  int n1, n2, n3, nit;
  double nn, verify_value, err;
  logical verified;

  int i;
  char *t_names[T_last];
  double tmax;

  for (i = T_init; i < T_last; i++) {
    timer_clear(i);
  }
  acc_init(acc_device_default);
  timer_start(T_init);

  //---------------------------------------------------------------------
  // Read in and broadcast input data
  //---------------------------------------------------------------------
  FILE *fp;
  if ((fp = fopen("timer.flag", "r")) != NULL) {
    timeron = true;
    t_names[T_init] = "init";
    t_names[T_bench] = "benchmk";
    t_names[T_mg3P] = "mg3P";
    t_names[T_psinv] = "psinv";
    t_names[T_resid] = "resid";
    t_names[T_rprj3] = "rprj3";
    t_names[T_interp] = "interp";
    t_names[T_norm2] = "norm2";
    t_names[T_comm3] = "comm3";
    fclose(fp);
  } else {
    timeron = false;
  }

  printf("\n\n NAS Parallel Benchmarks (NPB3.3-ACC-C) - MG Benchmark\n\n");

  if ((fp = fopen("mg.input", "r")) != NULL) {
    int result;
    printf(" Reading from input file mg.input\n");
    result = fscanf(fp, "%d\n", &lt);
    while (fgetc(fp) != '\n');
    result = fscanf(fp, "%d%d%d", &nx[lt], &ny[lt], &nz[lt]);
    while (fgetc(fp) != '\n');
    result = fscanf(fp, "%d", &nit);
    while (fgetc(fp) != '\n');
    for (i = 0; i <= 7; i++) {
      result = fscanf(fp, "%d", &debug_vec[i]);
    }
    fclose(fp);
  } else {
    printf(" No input file. Using compiled defaults \n");
    lt = LT_DEFAULT;
    nit = NIT_DEFAULT;
    nx[lt] = NX_DEFAULT;
    ny[lt] = NY_DEFAULT;
    nz[lt] = NZ_DEFAULT;
	//  debug_vec[0] = 1;
    for (i = 0; i <= 7; i++) {
      debug_vec[i] = DEBUG_DEFAULT;
    }
  }

  if ( (nx[lt] != ny[lt]) || (nx[lt] != nz[lt]) ) {
    Class = 'U';
  } else if ( nx[lt] == 32 && nit == 4 ) {
    Class = 'S';
  } else if ( nx[lt] == 128 && nit == 4 ) {
    Class = 'W';
  } else if ( nx[lt] == 256 && nit == 4 ) {  
    Class = 'A';
  } else if ( nx[lt] == 256 && nit == 20 ) {
    Class = 'B';
  } else if ( nx[lt] == 512 && nit == 20 ) {  
    Class = 'C';
  } else if ( nx[lt] == 1024 && nit == 50 ) {  
    Class = 'D';
  } else if ( nx[lt] == 2048 && nit == 50 ) {  
    Class = 'E';
  } else {
    Class = 'U';
  }

  //---------------------------------------------------------------------
  // Use these for debug info:
  //---------------------------------------------------------------------
  //    debug_vec(0) = 1 !=> report all norms
  //    debug_vec(1) = 1 !=> some setup information
  //    debug_vec(1) = 2 !=> more setup information
  //    debug_vec(2) = k => at level k or below, show result of resid
  //    debug_vec(3) = k => at level k or below, show result of psinv
  //    debug_vec(4) = k => at level k or below, show result of rprj
  //    debug_vec(5) = k => at level k or below, show result of interp
  //    debug_vec(6) = 1 => (unused)
  //    debug_vec(7) = 1 => (unused)
  //---------------------------------------------------------------------
  a[0] = -8.0/3.0;
  a[1] =  0.0;
  a[2] =  1.0/6.0;
  a[3] =  1.0/12.0;
      
  if (Class == 'A' || Class == 'S' || Class =='W') {
    //---------------------------------------------------------------------
    // Coefficients for the S(a) smoother
    //---------------------------------------------------------------------
    c[0] =  -3.0/8.0;
    c[1] =  +1.0/32.0;
    c[2] =  -1.0/64.0;
    c[3] =   0.0;
  } else {
    //---------------------------------------------------------------------
    // Coefficients for the S(b) smoother
    //---------------------------------------------------------------------
    c[0] =  -3.0/17.0;
    c[1] =  +1.0/33.0;
    c[2] =  -1.0/61.0;
    c[3] =   0.0;
  }
  lb = 1;
  k  = lt;
//  printf("NR=%u\n", NR);

#pragma acc data create(u[0:gnr],v[0:gnr],r[0:gnr])
{
  setup(&n1, &n2, &n3);
  zero3(u, n1, n2, n3);
  zran3(v, n1, n2, n3, nx[lt], ny[lt], k);

  norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);

  printf(" Size: %4dx%4dx%4d  (class %c)\n", nx[lt], ny[lt], nz[lt], Class);
  printf(" Iterations: %3d\n", nit);
  printf("\n");

  resid(u, v, r, n1, n2, n3, a, k);
  norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
  old2 = rnm2;
  oldu = rnmu;

  //---------------------------------------------------------------------
  // One iteration for startup
  //---------------------------------------------------------------------
  mg3P(u, v, r, a, c, n1, n2, n3);
  resid(u, v, r, n1, n2, n3, a, k);
  setup(&n1, &n2, &n3);
  zero3(u, n1, n2, n3);
  zran3(v, n1, n2, n3, nx[lt], ny[lt], k);

  timer_stop(T_init);
  tinit = timer_read(T_init);

  printf(" Initialization time: %15.3f seconds\n\n", tinit);

  for (i = T_bench; i < T_last; i++) {
    timer_clear(i);
  }

  timer_start(T_bench);

  resid(u, v, r, n1, n2, n3, a, k);
  norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
  old2 = rnm2;
  oldu = rnmu;

  for (it = 1; it <= nit; it++) {
    if ((it == 1) || (it == nit) || ((it % 100) == 0)) {
      printf("  iter %3d\n", it);
    }
    mg3P(u, v, r, a, c, n1, n2, n3);
    resid(u, v, r, n1, n2, n3, a, k);
  }

  norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
}/*end acc data*/
  timer_stop(T_bench);

  t = timer_read(T_bench);

  verified = false;
  verify_value = 0.0;

  printf("\n Benchmark completed\n");

  epsilon = 1.0e-8;
  if (Class != 'U') {
    if (Class == 'S') {
      verify_value = 0.5307707005734e-04;
    } else if (Class == 'W') {
      verify_value = 0.6467329375339e-05;
    } else if (Class == 'A') {
      verify_value = 0.2433365309069e-05;
    } else if (Class == 'B') {
      verify_value = 0.1800564401355e-05;
    } else if (Class == 'C') {
      verify_value = 0.5706732285740e-06;
    } else if (Class == 'D') {
      verify_value = 0.1583275060440e-09;
    } else if (Class == 'E') {
      verify_value = 0.8157592357404e-10;
    }

    err = fabs( rnm2 - verify_value ) / verify_value;
    // err = fabs( rnm2 - verify_value );
    if (err <= epsilon) {
      verified = true;
      printf(" VERIFICATION SUCCESSFUL\n");
      printf(" L2 Norm is %20.13E\n", rnm2);
      printf(" Error is   %20.13E\n", err);
    } else {
      verified = false;
      printf(" VERIFICATION FAILED\n");
      printf(" L2 Norm is             %20.13E\n", rnm2);
      printf(" The correct L2 Norm is %20.13E\n", verify_value);
    }
  } else {
    verified = false;
    printf(" Problem size unknown\n");
    printf(" NO VERIFICATION PERFORMED\n");
    printf(" L2 Norm is %20.13E\n", rnm2);
  }

  nn = 1.0 * nx[lt] * ny[lt] * nz[lt];

  if (t != 0.0) {
    mflops = 58.0 * nit * nn * 1.0e-6 / t;
  } else {
    mflops = 0.0;
  }

  print_results("MG", Class, nx[lt], ny[lt], nz[lt], 
                nit, t,
                mflops, "          floating point", 
                verified, NPBVERSION, COMPILETIME,
                CS1, CS2, CS3, CS4, CS5, CS6, CS7);

  //---------------------------------------------------------------------
  // More timers
  //---------------------------------------------------------------------
  if (timeron) {
    tmax = timer_read(T_bench);
    if (tmax == 0.0) tmax = 1.0;

    printf("  SECTION   Time (secs)\n");
    for (i = T_bench; i < T_last; i++) {
      t = timer_read(i);
      if (i == T_resid2) {
        t = timer_read(T_resid) - t;
        printf("    --> %8s:%9.3f  (%6.2f%%)\n", "mg-resid", t, t*100./tmax);
      } else {
        printf("  %-8s:%9.3f  (%6.2f%%)\n", t_names[i], t, t*100./tmax);
      }
    }
  }
  acc_shutdown(acc_device_default);
  return 0;
}


static void setup(int *n1, int *n2, int *n3)
{
  int k, j;

  int ax, mi[MAXLEVEL+1][3];
  int ng[MAXLEVEL+1][3];

  ng[lt][0] = nx[lt];
  ng[lt][1] = ny[lt];
  ng[lt][2] = nz[lt];
  for (k = lt-1; k >= 1; k--) {
    for (ax = 0; ax < 3; ax++) {
      ng[k][ax] = ng[k+1][ax]/2;
    }
  }
  for (k = lt; k >= 1; k--) {
    nx[k] = ng[k][0];
    ny[k] = ng[k][1];
    nz[k] = ng[k][2];
  }

  for (k = lt; k >= 1; k--) {
    for (ax = 0; ax < 3; ax++) {
      mi[k][ax] = 2 + ng[k][ax];
    }

    m1[k] = mi[k][0];
    m2[k] = mi[k][1];
    m3[k] = mi[k][2];
  }

  k = lt;
  is1 = 2 + ng[k][0] - ng[lt][0];
  ie1 = 1 + ng[k][0];
  *n1 = 3 + ie1 - is1;
  is2 = 2 + ng[k][1] - ng[lt][1];
  ie2 = 1 + ng[k][1];
  *n2 = 3 + ie2 - is2;
  is3 = 2 + ng[k][2] - ng[lt][2];
  ie3 = 1 + ng[k][2];
  *n3 = 3 + ie3 - is3;

  ir[lt] = 0;
  for (j = lt-1; j >= 1; j--) {
    ir[j] = ir[j+1]+ONE*m1[j+1]*m2[j+1]*m3[j+1];
  }

  if (debug_vec[1] >= 1) {
    printf(" in setup, \n");
    printf(" k  lt  nx  ny  nz  n1  n2  n3 is1 is2 is3 ie1 ie2 ie3\n");
    printf("%4d%4d%4d%4d%4d%4d%4d%4d%4d%4d%4d%4d%4d%4d\n", 
        k,lt,ng[k][0],ng[k][1],ng[k][2],*n1,*n2,*n3,is1,is2,is3,ie1,ie2,ie3);
  }
}


//---------------------------------------------------------------------
// multigrid V-cycle routine
//---------------------------------------------------------------------
static void mg3P(double u[], double v[], double r[],
                 double a[4], double c[4], int n1, int n2, int n3)
{
  int j, k;

  //---------------------------------------------------------------------
  // down cycle.
  // restrict the residual from the find grid to the coarse
  //---------------------------------------------------------------------
  for (k = lt; k >= lb+1; k--) {
    j = k - 1;
    rprj3(&r[ir[k]], m1[k], m2[k], m3[k], 
          &r[ir[j]], m1[j], m2[j], m3[j], k);
  }
  
  k = lb;
  //---------------------------------------------------------------------
  // compute an approximate solution on the coarsest grid
  //---------------------------------------------------------------------
  zero3(&u[ir[k]], m1[k], m2[k], m3[k]);
  psinv(&r[ir[k]], &u[ir[k]], m1[k], m2[k], m3[k], c, k);

  for (k = lb+1; k <= lt-1; k++) {
    j = k - 1;

    //---------------------------------------------------------------------
    // prolongate from level k-1  to k
    //---------------------------------------------------------------------
    zero3(&u[ir[k]], m1[k], m2[k], m3[k]);
    interp(&u[ir[j]], m1[j], m2[j], m3[j], &u[ir[k]], m1[k], m2[k], m3[k], k);

    //---------------------------------------------------------------------
    // compute residual for level k
    //---------------------------------------------------------------------
    resid(&u[ir[k]], &r[ir[k]], &r[ir[k]], m1[k], m2[k], m3[k], a, k);

    //---------------------------------------------------------------------
    // apply smoother
    //---------------------------------------------------------------------
    psinv(&r[ir[k]], &u[ir[k]], m1[k], m2[k], m3[k], c, k);
  }

  j = lt - 1;
  k = lt;
  interp(&u[ir[j]], m1[j], m2[j], m3[j], u, n1, n2, n3, k);
  resid(u, v, r, n1, n2, n3, a, k);
  psinv(r, u, n1, n2, n3, c, k);
}


//---------------------------------------------------------------------
// psinv applies an approximate inverse as smoother:  u = u + Cr
//
// This  implementation costs  15A + 4M per result, where
// A and M denote the costs of Addition and Multiplication.  
// Presuming coefficient c(3) is zero (the NPB assumes this,
// but it is thus not a general case), 2A + 1M may be eliminated,
// resulting in 13A + 3M.
// Note that this vectorizes, and is also fine for cache 
// based machines.  
//---------------------------------------------------------------------
static void psinv(double * __restrict__ or, double * __restrict__ ou, int n1, int n2, int n3, double c[4], int k)
{
/*
  double (*r)[n2][n1] = (double (*)[n2][n1])or;
  double (*u)[n2][n1] = (double (*)[n2][n1])ou;
*/
  int i3, i2, i1;
  double c0, c1, c2;

  //double r1[M], r2[M];
  double * __restrict__ r1, * __restrict__ r2;

  c0 = c[0];
  c1 = c[1];
  c2 = c[2];

  #ifdef _OPENACC
  	r1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
  	r2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
  #else
  	r1 = (double*)malloc(n3*n2*n1*sizeof(double));
  	r2 = (double*)malloc(n3*n2*n1*sizeof(double));
  #endif


  if (timeron) timer_start(T_psinv);
  #pragma acc data deviceptr(r1,r2) \
  		   present(ou[0:n3*n2*n1]) \
		   present(or[0:n3*n2*n1])  
 {
  #pragma acc parallel loop gang num_gangs(n3-2) num_workers(16) vector_length(64)
  for (i3 = 1; i3 < n3-1; i3++) {
    #pragma acc loop worker
    for (i2 = 1; i2 < n2-1; i2++) {
      #pragma acc loop vector
      for (i1 = 0; i1 < n1; i1++) {
	  /*
        r1[i1] = r[i3][i2-1][i1] + r[i3][i2+1][i1]
               + r[i3-1][i2][i1] + r[i3+1][i2][i1];
        r2[i1] = r[i3-1][i2-1][i1] + r[i3-1][i2+1][i1]
               + r[i3+1][i2-1][i1] + r[i3+1][i2+1][i1];
	  */
        I3D(r1, n1, n2, i3, i2, i1) = I3D(or, n1, n2, i3, i2-1, i1) + I3D(or, n1, n2, i3, i2+1, i1)
			   + I3D(or, n1, n2, i3-1, i2, i1) + I3D(or, n1, n2, i3+1, i2, i1);
		I3D(r2, n1, n2, i3, i2, i1) = I3D(or, n1, n2, i3-1, i2-1, i1) + I3D(or, n1, n2, i3-1, i2+1, i1)
			   + I3D(or, n1, n2, i3+1, i2-1, i1) + I3D(or, n1, n2, i3+1, i2+1, i1);

      }
    }
  }
  #pragma acc parallel loop gang num_gangs(n3-2) num_workers(16) vector_length(64)
  for (i3 = 1; i3 < n3-1; i3++) {
    #pragma acc loop worker
    for (i2 = 1; i2 < n2-1; i2++) {
    #pragma acc loop vector
      for (i1 = 1; i1 < n1-1; i1++) {
	  /*
        u[i3][i2][i1] = u[i3][i2][i1]
                      + c[0] * r[i3][i2][i1]
                      + c[1] * ( r[i3][i2][i1-1] + r[i3][i2][i1+1]
                               + r1[i1] )
                      + c[2] * ( r2[i1] + r1[i1-1] + r1[i1+1] );
	  */
		I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
									+ c0 * I3D(or, n1, n2, i3, i2, i1)
									+ c1 * ( I3D(or, n1, n2, i3, i2, i1-1)
									         + I3D(or, n1, n2, i3, i2, i1+1)
											 + I3D(r1, n1, n2, i3, i2, i1) )
									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
									         + I3D(r1, n1, n2, i3, i2, i1-1)
											 + I3D(r1, n1, n2, i3, i2, i1+1));
								    //+ c[2] * ( r2[i1] + r1[i1-1] + r1[i1+1] );

        //--------------------------------------------------------------------
        // Assume c[3] = 0    (Enable line below if c[3] not= 0)
        //--------------------------------------------------------------------
        //            + c[3] * ( r2[i1-1] + r2[i1+1] )
        //--------------------------------------------------------------------
      }
    }
  }
  }/*end acc parallel*/
  if (timeron) timer_stop(T_psinv);
  #ifdef _OPENACC
  	acc_free(r1);
  	acc_free(r2);
  #else
  	free(r1);
  	free(r2);
  #endif

  //---------------------------------------------------------------------
  // exchange boundary points
  //---------------------------------------------------------------------
  //comm3(u, n1, n2, n3, k);
  comm3(ou, n1, n2, n3, k);

  if (debug_vec[0] >= 1) {
    //rep_nrm(u, n1, n2, n3, "   psinv", k);
    rep_nrm(ou, n1, n2, n3, "   psinv", k);
  }

  if (debug_vec[3] >= k) {
    //showall(u, n1, n2, n3);
    showall(ou, n1, n2, n3);
  }
}


//---------------------------------------------------------------------
// resid computes the residual:  r = v - Au
//
// This  implementation costs  15A + 4M per result, where
// A and M denote the costs of Addition (or Subtraction) and 
// Multiplication, respectively. 
// Presuming coefficient a(1) is zero (the NPB assumes this,
// but it is thus not a general case), 3A + 1M may be eliminated,
// resulting in 12A + 3M.
// Note that this vectorizes, and is also fine for cache 
// based machines.  
//---------------------------------------------------------------------
static void resid(double * ou, double * ov, double * or, int n1, int n2, int n3,
                  double a[4], int k)
{
/*
  double (*u)[n2][n1] = (double (*)[n2][n1])ou;
  double (*v)[n2][n1] = (double (*)[n2][n1])ov;
  double (*r)[n2][n1] = (double (*)[n2][n1])or;
*/
  int i3, i2, i1;
  double a0, a2, a3;
  //double u1[M], u2[M];
  double * __restrict__ u1, * __restrict__ u2;

  a0 = a[0];
  a2 = a[2];
  a3 = a[3];

  if (timeron) timer_start(T_resid);
  #ifdef _OPENACC
  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
  #else
  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
  #endif

//	printf("n1=%d, n2=%d, n3=%d\n", n1, n2, n3);
  #pragma acc data deviceptr(u1,u2)  \
  		   present(ou[0:n3*n2*n1]) \
		   present(ov[0:n3*n2*n1], or[0:n3*n2*n1])
  {
#pragma acc parallel num_gangs(n3-2) num_workers(8) vector_length(128) 
{ 
  #pragma acc loop gang
  for (i3 = 1; i3 < n3-1; i3++) {
  #pragma acc loop worker
    for (i2 = 1; i2 < n2-1; i2++) {
  #pragma acc loop vector
      for (i1 = 0; i1 < n1; i1++) {
	  /*
        u1[i1] = u[i3][i2-1][i1] + u[i3][i2+1][i1]
               + u[i3-1][i2][i1] + u[i3+1][i2][i1];
        u2[i1] = u[i3-1][i2-1][i1] + u[i3-1][i2+1][i1]
               + u[i3+1][i2-1][i1] + u[i3+1][i2+1][i1];
	  */
        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);

      }
    }
  }
}
#pragma acc parallel num_gangs(n3-2) num_workers(8) vector_length(128)
{
  #pragma acc loop gang
  for (i3 = 1; i3 < n3-1; i3++) {
  #pragma acc loop worker
    for (i2 = 1; i2 < n2-1; i2++) {
  #pragma acc loop vector
      for (i1 = 1; i1 < n1-1; i1++) {
	  /*
        r[i3][i2][i1] = v[i3][i2][i1]
                      - a[0] * u[i3][i2][i1]
	  */
		I3D(or, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
							 -a0 * I3D(ou, n1, n2, i3, i2, i1)

        //-------------------------------------------------------------------
        //  Assume a[1] = 0      (Enable 2 lines below if a[1] not= 0)
        //-------------------------------------------------------------------
        //            - a[1] * ( u[i3][i2][i1-1] + u[i3][i2][i1+1]
        //                     + u1[i1] )
        //-------------------------------------------------------------------
                     // - a[2] * ( u2[i3][i2][i1] + u1[i3][i2][i1-1] + u1[i3][i2][i1+1] )
                     // - a[3] * ( u2[i3][i2][i1-1] + u2[i3][i2][i1+1] );
					 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
					 			+ I3D(u1, n1, n2, i3, i2, i1+1))
					 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
      }
    }
  }
  } /*end acc parallel */
  } /*end acc data */
  
  #ifdef _OPENACC
  	acc_free(u1);
  	acc_free(u2);
  #else
  	free(u1);
  	free(u2);
  #endif
  if (timeron) timer_stop(T_resid);

  //---------------------------------------------------------------------
  // exchange boundary data
  //---------------------------------------------------------------------
  //comm3(r, n1, n2, n3, k);
  comm3(or, n1, n2, n3, k);

  if (debug_vec[0] >= 1) {
    //rep_nrm(r, n1, n2, n3, "   resid", k);
    rep_nrm(or, n1, n2, n3, "   resid", k);
  }

  if (debug_vec[2] >= k) {
    //showall(r, n1, n2, n3);
    showall(or, n1, n2, n3);
  }
}


//---------------------------------------------------------------------
// rprj3 projects onto the next coarser grid, 
// using a trilinear Finite Element projection:  s = r' = P r
//     
// This  implementation costs  20A + 4M per result, where
// A and M denote the costs of Addition and Multiplication.  
// Note that this vectorizes, and is also fine for cache 
// based machines.  
//---------------------------------------------------------------------
static void rprj3(double *or, int m1k, int m2k, int m3k,
                  double *os, int m1j, int m2j, int m3j, int k)
{
/*
  double (*r)[m2k][m1k] = (double (*)[m2k][m1k])or;
  double (*s)[m2j][m1j] = (double (*)[m2j][m1j])os;
*/
  int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;

  //double x1[M], y1[M], x2, y2;
  double *x1, *y1, x2, y2;
  #ifdef _OPENACC
  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
  #else
  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
  #endif

  if (timeron) timer_start(T_rprj3);
  if (m1k == 3) {
    d1 = 2;
  } else {
    d1 = 1;
  }

  if (m2k == 3) {
    d2 = 2;
  } else {
    d2 = 1;
  }

  if (m3k == 3) {
    d3 = 2;
  } else {
    d3 = 1;
  }

  #pragma acc data deviceptr(x1,y1) \
  		   present(or[0:m3k*m2k*m1k]) \
		   present(os[0:m3j*m2j*m1j])
  {
  #pragma acc parallel loop gang num_gangs(m3j-2) num_workers(8) vector_length(128)
  for (j3 = 1; j3 < m3j-1; j3++) {
    i3 = 2*j3-d3;
      #pragma acc loop worker
    for (j2 = 1; j2 < m2j-1; j2++) {
      i2 = 2*j2-d2;
      #pragma acc loop vector
      for (j1 = 1; j1 < m1j; j1++) {
        i1 = 2*j1-d1;
		/*
        x1[i1] = r[i3+1][i2  ][i1] + r[i3+1][i2+2][i1]
               + r[i3  ][i2+1][i1] + r[i3+2][i2+1][i1];
        y1[i1] = r[i3  ][i2  ][i1] + r[i3+2][i2  ][i1]
               + r[i3  ][i2+2][i1] + r[i3+2][i2+2][i1];
	    */
		I3D(x1, m1k, m2k, i3, i2, i1) = I3D(or, m1k, m2k, i3+1, i2, i1) + I3D(or, m1k, m2k, i3+1, i2+2, i1)
		       + I3D(or, m1k, m2k, i3, i2+1, i1) + I3D(or, m1k, m2k, i3+2, i2+1, i1);
		I3D(y1, m1k, m2k, i3, i2, i1) = I3D(or, m1k, m2k, i3, i2, i1)   + I3D(or, m1k, m2k, i3+2, i2, i1)
		       + I3D(or, m1k, m2k, i3, i2+2, i1) + I3D(or, m1k, m2k, i3+2, i2+2, i1);
				
      }
    }
  }
  #pragma acc parallel loop gang num_gangs(m3j-2) num_workers(8) vector_length(128)
  for (j3 = 1; j3 < m3j-1; j3++) {
    i3 = 2*j3-d3;
      #pragma acc loop worker
    for (j2 = 1; j2 < m2j-1; j2++) {
      i2 = 2*j2-d2;
      #pragma acc loop vector
      for (j1 = 1; j1 < m1j-1; j1++) {
        i1 = 2*j1-d1;
		/*
        y2 = r[i3  ][i2  ][i1+1] + r[i3+2][i2  ][i1+1]
           + r[i3  ][i2+2][i1+1] + r[i3+2][i2+2][i1+1];
        x2 = r[i3+1][i2  ][i1+1] + r[i3+1][i2+2][i1+1]
           + r[i3  ][i2+1][i1+1] + r[i3+2][i2+1][i1+1];
        s[j3][j2][j1] =
                0.5 * r[i3+1][i2+1][i1+1]
              + 0.25 * (r[i3+1][i2+1][i1] + r[i3+1][i2+1][i1+2] + x2)
              + 0.125 * (x1[i1] + x1[i1+2] + y2)
              + 0.0625 * (y1[i1] + y1[i1+2]);
	    */
		y2 = I3D(or, m1k, m2k, i3, i2, i1+1)   + I3D(or, m1k, m2k, i3+2, i2, i1+1)
		   + I3D(or, m1k, m2k, i3, i2+2, i1+1) + I3D(or, m1k, m2k, i3+2, i2+2, i1+1);
		x2 = I3D(or, m1k, m2k, i3+1, i2, i1+1) + I3D(or, m1k, m2k, i3+1, i2+2, i1+1)
		   + I3D(or, m1k, m2k, i3, i2+1, i1+1) + I3D(or, m1k, m2k, i3+2, i2+1, i1+1);
		I3D(os, m1j, m2j, j3, j2, j1) = 
				0.5 * I3D(or, m1k, m2k, i3+1, i2+1, i1+1)
			  + 0.25 * (I3D(or, m1k, m2k, i3+1, i2+1, i1) + I3D(or, m1k, m2k, i3+1, i2+1, i1+2) + x2)
              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
      }
    }
  }
  }/*end acc parallel*/
  if (timeron) timer_stop(T_rprj3);

  j = k-1;
  //comm3(s, m1j, m2j, m3j, j);
  comm3(os, m1j, m2j, m3j, j);

  if (debug_vec[0] >= 1) {
    //rep_nrm(s, m1j, m2j, m3j, "   rprj3", k-1);
    rep_nrm(os, m1j, m2j, m3j, "   rprj3", k-1);
  }

  if (debug_vec[4] >= k) {
    //showall(s, m1j, m2j, m3j);
    showall(os, m1j, m2j, m3j);
  }
  #ifdef _OPENACC
  	acc_free(x1);
  	acc_free(y1);
  #else
  	free(x1);
	free(y1);
  #endif
}


//---------------------------------------------------------------------
// interp adds the trilinear interpolation of the correction
// from the coarser grid to the current approximation:  u = u + Qu'
//     
// Observe that this  implementation costs  16A + 4M, where
// A and M denote the costs of Addition and Multiplication.  
// Note that this vectorizes, and is also fine for cache 
// based machines.  Vector machines may get slightly better 
// performance however, with 8 separate "do i1" loops, rather than 4.
//---------------------------------------------------------------------
static void interp(double *oz, int mm1, int mm2, int mm3,
                   double *ou, int n1, int n2, int n3, int k)
{
/*
  double (*z)[mm2][mm1] = (double (*)[mm2][mm1])oz;
  double (*u)[n2][n1] = (double (*)[n2][n1])ou;
*/
  int i3, i2, i1, d1, d2, d3, t1, t2, t3;

  // note that m = 1037 in globals.h but for this only need to be
  // 535 to handle up to 1024^3
  //      integer m
  //      parameter( m=535 )
  //double z1[M], z2[M], z3[M];
  static double *z1, *z2, *z3;

  #ifdef _OPENACC
	//if(z1==NULL)
  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
	//if(z2==NULL)
  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
	//if(z3 == NULL)
  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
  #else
  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
  #endif

  if (timeron) timer_start(T_interp);

  #pragma acc data deviceptr(z1,z2,z3) \
  		   present(oz[0:mm3*mm2*mm1]) \
		   present(ou[0:n3*n2*n1])
  {

  if (n1 != 3 && n2 != 3 && n3 != 3) {

    #pragma acc parallel loop gang num_gangs(mm3-1) num_workers(8) vector_length(128)
    for (i3 = 0; i3 < mm3-1; i3++) {
    #pragma acc loop worker
      for (i2 = 0; i2 < mm2-1; i2++) {
        #pragma acc loop vector
        for (i1 = 0; i1 < mm1; i1++) {
		/*
          z1[i1] = z[i3][i2+1][i1] + z[i3][i2][i1];
          z2[i1] = z[i3+1][i2][i1] + z[i3][i2][i1];
          z3[i1] = z[i3+1][i2+1][i1] + z[i3+1][i2][i1] + z1[i1];
		*/
          I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
		  I3D(z3, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2+1, i1) 
		  								+ I3D(oz, mm1, mm2, i3+1, i2, i1)
										+ I3D(z1, mm1, mm2, i3, i2, i1);

        }
      }
    }
#pragma acc parallel loop gang num_gangs(mm3-1) num_workers(8) vector_length(128)
    for (i3 = 0; i3 < mm3-1; i3++) {
    #pragma acc loop worker
      for (i2 = 0; i2 < mm2-1; i2++) {
	  #pragma acc loop vector
        for (i1 = 0; i1 < mm1-1; i1++) {
		/*
          u[2*i3][2*i2][2*i1] = u[2*i3][2*i2][2*i1]
                              + z[i3][i2][i1];
          u[2*i3][2*i2][2*i1+1] = u[2*i3][2*i2][2*i1+1]
                                + 0.5 * (z[i3][i2][i1+1] + z[i3][i2][i1]);
	    */
		  I3D(ou, n1, n2, 2*i3, 2*i2, 2*i1)   = I3D(ou, n1, n2, 2*i3, 2*i2, 2*i1)
		  									  + I3D(oz, mm1, mm2, i3, i2, i1);
		  I3D(ou, n1, n2, 2*i3, 2*i2, 2*i1+1) = I3D(ou, n1, n2, 2*i3, 2*i2, 2*i1+1)
		  									  + 0.5*(I3D(oz, mm1, mm2, i3, i2, i1+1)
											       + I3D(oz, mm1, mm2, i3, i2, i1));
        }
      }
    }

#pragma acc parallel loop gang num_gangs(mm3-1) num_workers(8) vector_length(128)
    for (i3 = 0; i3 < mm3-1; i3++) {
    #pragma acc loop worker
      for (i2 = 0; i2 < mm2-1; i2++) {
        #pragma acc loop vector
        for (i1 = 0; i1 < mm1-1; i1++) {
		/*
          u[2*i3][2*i2+1][2*i1] = u[2*i3][2*i2+1][2*i1]
                                + 0.5 * z1[i1];
          u[2*i3][2*i2+1][2*i1+1] = u[2*i3][2*i2+1][2*i1+1]
                                  + 0.25 * (z1[i1] + z1[i1+1]);
	    */
		  I3D(ou, n1, n2, 2*i3, 2*i2+1, 2*i1) = I3D(ou, n1, n2, 2*i3, 2*i2+1, 2*i1)
											+ 0.5 * I3D(z1, mm1, mm2, i3, i2, i1);
		  I3D(ou, n1, n2, 2*i3, 2*i2+1, 2*i1+1) = I3D(ou, n1, n2, 2*i3, 2*i2+1, 2*i1+1)
		  										+ 0.25 * (I3D(z1, mm1, mm2, i3, i2, i1)
														+ I3D(z1, mm1, mm2, i3, i2, i1+1));
        }
      }
    }
#pragma acc parallel loop gang num_gangs(mm3-1) num_workers(8) vector_length(128)
    for (i3 = 0; i3 < mm3-1; i3++) {
    #pragma acc loop worker
      for (i2 = 0; i2 < mm2-1; i2++) {
	    #pragma acc loop vector
        for (i1 = 0; i1 < mm1-1; i1++) {
		/*
          u[2*i3+1][2*i2][2*i1] = u[2*i3+1][2*i2][2*i1]
                                  + 0.5 * z2[i1];
          u[2*i3+1][2*i2][2*i1+1] = u[2*i3+1][2*i2][2*i1+1]
                                  + 0.25 * (z2[i1] + z2[i1+1]);
		*/
		  I3D(ou, n1, n2, 2*i3+1, 2*i2, 2*i1) = I3D(ou, n1, n2, 2*i3+1, 2*i2, 2*i1)
		  									  + 0.5 * I3D(z2, mm1, mm2, i3, i2, i1);
		  I3D(ou, n1, n2, 2*i3+1, 2*i2, 2*i1+1) = I3D(ou, n1, n2, 2*i3+1, 2*i2, 2*i1+1)
		  										+ 0.25 * (I3D(z2, mm1, mm2, i3, i2, i1)
														+ I3D(z2, mm1, mm2, i3, i2, i1+1));
         }
       }
     }
 
#pragma acc parallel loop gang num_gangs(mm3-1) num_workers(8) vector_length(128)
    for (i3 = 0; i3 < mm3-1; i3++) {
    #pragma acc loop worker
      for (i2 = 0; i2 < mm2-1; i2++) {
	   #pragma acc loop vector
        for (i1 = 0; i1 < mm1-1; i1++) {
		/*
          u[2*i3+1][2*i2+1][2*i1] = u[2*i3+1][2*i2+1][2*i1]
                                  + 0.25 * z3[i1];
          u[2*i3+1][2*i2+1][2*i1+1] = u[2*i3+1][2*i2+1][2*i1+1]
                                    + 0.125 * (z3[i1] + z3[i1+1]);
		*/
		  I3D(ou, n1, n2, 2*i3+1, 2*i2+1, 2*i1) = I3D(ou, n1, n2, 2*i3+1, 2*i2+1, 2*i1)
		  										+ 0.25 * I3D(z3, mm1, mm2, i3, i2, i1);
		  I3D(ou, n1, n2, 2*i3+1, 2*i2+1, 2*i1+1) = I3D(ou, n1, n2, 2*i3+1, 2*i2+1, 2*i1+1)
		  										  + 0.125 * (I3D(z3, mm1, mm2, i3, i2, i1)
												  		   + I3D(z3, mm1, mm2, i3, i2, i1+1));
        }
      }
    }
  } else {
    if (n1 == 3) {
      d1 = 2;
      t1 = 1;
    } else {
      d1 = 1;
      t1 = 0;
    }

    if (n2 == 3) {
      d2 = 2;
      t2 = 1;
    } else {
      d2 = 1;
      t2 = 0;
    }

    if (n3 == 3) {
      d3 = 2;
      t3 = 1;
    } else {
      d3 = 1;
      t3 = 0;
    }

    #pragma acc parallel loop gang num_gangs(mm3-d3) num_workers(8) vector_length(128)
    for (i3 = d3; i3 <= mm3-1; i3++) {
    #pragma acc loop worker
      for (i2 = d2; i2 <= mm2-1; i2++) {
        #pragma acc loop vector
        for (i1 = d1; i1 <= mm1-1; i1++) {
		/*
          u[2*i3-d3-1][2*i2-d2-1][2*i1-d1-1] = 
            u[2*i3-d3-1][2*i2-d2-1][2*i1-d1-1]
            + z[i3-1][i2-1][i1-1];
		*/
		 I3D(ou, n1, n2, 2*i3-d3-1, 2*i2-d2-1, 2*i1-d1-1) = 
		 	I3D(ou, n1, n2, 2*i3-d3-1, 2*i2-d2-1, 2*i1-d1-1)
			+ I3D(ou, mm1, mm2, i3-1, i2-1, i1-1);
        }
       }
    }
    #pragma acc parallel loop gang num_gangs(mm3-d3) num_workers(8) vector_length(128)
    for (i3 = d3; i3 <= mm3-1; i3++) {
    #pragma acc loop worker
      for (i2 = d2; i2 <= mm2-1; i2++) {
        #pragma acc loop vector
        for (i1 = 1; i1 <= mm1-1; i1++) {
		/*
          u[2*i3-d3-1][2*i2-d2-1][2*i1-t1-1] = 
            u[2*i3-d3-1][2*i2-d2-1][2*i1-t1-1]
            + 0.5 * (z[i3-1][i2-1][i1] + z[i3-1][i2-1][i1-1]);
		*/
		  I3D(ou, n1, n2, 2*i3-d3-1, 2*i2-d2-1, 2*i1-t1-1) = 
		  	I3D(ou, n1, n2, 2*i3-d3-1, 2*i2-d2-1, 2*i1-t1-1)
			+ 0.5 * (I3D(oz, mm1, mm2, i3-1, i2-1, i1) 
				   + I3D(oz, mm1, mm2, i3-1, i2-1, i1-1));
        }
      }
    }
    #pragma acc parallel loop gang num_gangs(mm3-d3) num_workers(8) vector_length(128)
    for (i3 = d3; i3 <= mm3-1; i3++) {
      #pragma acc loop worker
      for (i2 = 1; i2 <= mm2-1; i2++) {
        #pragma acc loop vector
        for (i1 = d1; i1 <= mm1-1; i1++) {
		/*
          u[2*i3-d3-1][2*i2-t2-1][2*i1-d1-1] = 
            u[2*i3-d3-1][2*i2-t2-1][2*i1-d1-1]
            + 0.5 * (z[i3-1][i2][i1-1] + z[i3-1][i2-1][i1-1]);
		*/
		  I3D(ou, n1, n2, 2*i3-d3-1, 2*i2-t2-1, 2*i1-d1-1) = 
		    I3D(ou, n1, n2, 2*i3-d3-1, 2*i2-t2-1, 2*i1-d1-1)
			+ 0.5 * (I3D(oz, mm1, mm2, i3-1, i2,   i1-1)
				   + I3D(oz, mm1, mm2, i3-1, i2-1, i1-1));
        }
	  }
	 }
    #pragma acc parallel loop gang num_gangs(mm3-d3) num_workers(8) vector_length(128)
    for (i3 = d3; i3 <= mm3-1; i3++) {
      #pragma acc loop worker
      for (i2 = 1; i2 <= mm2-1; i2++) {
        #pragma acc loop vector
        for (i1 = 1; i1 <= mm1-1; i1++) {
		/*
          u[2*i3-d3-1][2*i2-t2-1][2*i1-t1-1] = 
            u[2*i3-d3-1][2*i2-t2-1][2*i1-t1-1]
            + 0.25 * (z[i3-1][i2][i1] + z[i3-1][i2-1][i1]
                    + z[i3-1][i2][i1-1] + z[i3-1][i2-1][i1-1]);
		*/
		  I3D(ou, n1, n2, 2*i3-d3-1, 2*i2-t2-1, 2*i1-t1-1) = 
		    I3D(ou, n1, n2, 2*i3-d3-1, 2*i2-t2-1, 2*i1-t1-1)
			+ 0.25 * (I3D(oz, mm1, mm2, i3-1, i2,   i1)
			        + I3D(oz, mm1, mm2, i3-1, i2-1, i1)
					+ I3D(oz, mm1, mm2, i3-1, i2,   i1-1)
					+ I3D(oz, mm1, mm2, i3-1, i2-1, i1-1));
        }
      }
    }

    #pragma acc parallel loop gang num_gangs(mm3-1) num_workers(8) vector_length(128)
    for (i3 = 1; i3 <= mm3-1; i3++) {
      #pragma acc loop worker
      for (i2 = d2; i2 <= mm2-1; i2++) {
	#pragma acc loop vector
        for (i1 = d1; i1 <= mm1-1; i1++) {
		/*
          u[2*i3-t3-1][2*i2-d2-1][2*i1-d1-1] = 
            u[2*i3-t3-1][2*i2-d2-1][2*i1-d1-1]
            + 0.5 * (z[i3][i2-1][i1-1] + z[i3-1][i2-1][i1-1]);
		*/
		  I3D(ou, n1, n2, 2*i3-t3-1, 2*i2-d2-1, 2*i1-d1-1) =
		    I3D(ou, n1, n2, 2*i3-t3-1, 2*i2-d2-1, 2*i1-d1-1)
			+ 0.5 * (I3D(oz, mm1, mm2, i3,   i2-1, i1-1)
			       + I3D(oz, mm1, mm2, i3-1, i2-1, i1-1));
        }
      }
    }
    #pragma acc parallel loop gang num_gangs(mm3-1) num_workers(8) vector_length(128)
    for (i3 = 1; i3 <= mm3-1; i3++) {
      #pragma acc loop worker
      for (i2 = d2; i2 <= mm2-1; i2++) {
	#pragma acc loop vector
        for (i1 = 1; i1 <= mm1-1; i1++) {
		/*
          u[2*i3-t3-1][2*i2-d2-1][2*i1-t1-1] = 
            u[2*i3-t3-1][2*i2-d2-1][2*i1-t1-1]
            + 0.25 * (z[i3  ][i2-1][i1] + z[i3  ][i2-1][i1-1]
                    + z[i3-1][i2-1][i1] + z[i3-1][i2-1][i1-1]);
		*/
		  I3D(ou, n1, n2, 2*i3-t3-1, 2*i2-d2-1, 2*i1-t1-1) =
		    I3D(ou, n1, n2, 2*i3-t3-1, 2*i2-d2-1, 2*i1-t1-1)
			+ 0.25 * (I3D(oz, mm1, mm2, i3,   i2-1, i1)
			        + I3D(oz, mm1, mm2, i3,   i2-1, i1-1)
					+ I3D(oz, mm1, mm2, i3-1, i2-1, i1)
					+ I3D(oz, mm1, mm2, i3-1, i2-1, i1-1));
        }
      }
    }
    #pragma acc parallel loop gang num_gangs(mm3-1) num_workers(8) vector_length(128)
    for (i3 = 1; i3 <= mm3-1; i3++) {
      #pragma acc loop worker
      for (i2 = 1; i2 <= mm2-1; i2++) {
	#pragma acc loop vector
        for (i1 = d1; i1 <= mm1-1; i1++) {
		/*
          u[2*i3-t3-1][2*i2-t2-1][2*i1-d1-1] = 
            u[2*i3-t3-1][2*i2-t2-1][2*i1-d1-1]
            + 0.25 * (z[i3  ][i2][i1-1] + z[i3  ][i2-1][i1-1]
                    + z[i3-1][i2][i1-1] + z[i3-1][i2-1][i1-1]);
		*/
		  I3D(ou, n1, n2, 2*i3-t3-1, 2*i2-t2-1, 2*i1-d1-1) = 
		    I3D(ou, n1, n2, 2*i3-t3-1, 2*i2-t2-1, 2*i1-d1-1)
			+ 0.25 * (I3D(oz, mm1, mm2, i3,   i2,   i1-1)
			        + I3D(oz, mm1, mm2, i3,   i2-1, i1-1)
					+ I3D(oz, mm1, mm2, i3-1, i2,   i1-1)
					+ I3D(oz, mm1, mm2, i3-1, i2-1, i1-1));
        }
       }
     }
    #pragma acc parallel loop gang num_gangs(mm3-1) num_workers(8) vector_length(128)
    for (i3 = 1; i3 <= mm3-1; i3++) {
      #pragma acc loop worker
      for (i2 = 1; i2 <= mm2-1; i2++) {
	#pragma acc loop vector
        for (i1 = 1; i1 <= mm1-1; i1++) {
		/*
          u[2*i3-t3-1][2*i2-t2-1][2*i1-t1-1] = 
            u[2*i3-t3-1][2*i2-t2-1][2*i1-t1-1]
            + 0.125 * (z[i3  ][i2][i1  ] + z[i3  ][i2-1][i1  ]
                     + z[i3  ][i2][i1-1] + z[i3  ][i2-1][i1-1]
                     + z[i3-1][i2][i1  ] + z[i3-1][i2-1][i1  ]
                     + z[i3-1][i2][i1-1] + z[i3-1][i2-1][i1-1]);
		*/
		  I3D(ou, n1, n2, 2*i3-t3-1, 2*i2-t2-1, 2*i1-t1-1) = 
		    I3D(ou, n1, n2, 2*i3-t3-1, 2*i2-t2-1, 2*i1-t1-1)
			+ 0.125 * (I3D(oz, mm1, mm2, i3,   i2,   i1)
			         + I3D(oz, mm1, mm2, i3,   i2-1, i1)
					 + I3D(oz, mm1, mm2, i3,   i2,   i1-1)
					 + I3D(oz, mm1, mm2, i3,   i2-1, i1-1)
					 + I3D(oz, mm1, mm2, i3-1, i2,   i1)
					 + I3D(oz, mm1, mm2, i3-1, i2-1, i1)
					 + I3D(oz, mm1, mm2, i3-1, i2,   i1-1)
					 + I3D(oz, mm1, mm2, i3-1, i2-1, i1-1));
        }
      }
    }

  }
   }/*end acc data */

  #ifdef _OPENACC
  	acc_free(z1);
  	acc_free(z2);
  	acc_free(z3);
  #else
  	free(z1);
	free(z2);
	free(z3);
  #endif
  if (timeron) timer_stop(T_interp);

  if (debug_vec[0] >= 1) {
    //rep_nrm(z, mm1, mm2, mm3, "z: inter", k-1);
    //rep_nrm(u, n1, n2, n3, "u: inter", k);
    rep_nrm(oz, mm1, mm2, mm3, "z: inter", k-1);
    rep_nrm(ou, n1, n2, n3, "u: inter", k);
  }

  if (debug_vec[5] >= k) {
    //showall(z, mm1, mm2, mm3);
    //showall(u, n1, n2, n3);
    showall(oz, mm1, mm2, mm3);
    showall(ou, n1, n2, n3);
  }
}


//---------------------------------------------------------------------
// norm2u3 evaluates approximations to the L2 norm and the
// uniform (or L-infinity or Chebyshev) norm, under the
// assumption that the boundaries are periodic or zero.  Add the
// boundaries in with half weight (quarter weight on the edges
// and eighth weight at the corners) for inhomogeneous boundaries.
//---------------------------------------------------------------------
static void norm2u3(double *or, int n1, int n2, int n3,
                    double *rnm2, double *rnmu,
                    int nx, int ny, int nz)
{
  //double (*r)[n2][n1] = (double (*)[n2][n1])or;

  double s, a;
  double temp;
  int i3, i2, i1;

  double dn;

  if (timeron) timer_start(T_norm2);
  dn = 1.0*nx*ny*nz;

  s = 0.0;
  *rnmu = 0.0;
  temp = *rnmu;
#pragma acc data pcopyin(or[0:n3*n2*n1])
{
 #pragma acc parallel loop gang reduction(+:s) reduction(max:temp) \
                    num_gangs(n3-2) num_workers(8) vector_length(128)
  for (i3 = 1; i3 < n3-1; i3++) {
   #pragma acc loop worker
    for (i2 = 1; i2 < n2-1; i2++) {
     #pragma acc loop vector 
      for (i1 = 1; i1 < n1-1; i1++) {
        //s = s + pow(r[i3][i2][i1], 2.0);
        //a = fabs(r[i3][i2][i1]);
        s = s + pow(I3D(or, n1, n2, i3, i2, i1), 2.0);
        a = fabs(I3D(or, n1, n2, i3, i2, i1));
        //if (a > temp) temp = a;
        temp = max(temp, a);
      }
    }
  }
}/*end acc data*/
  *rnmu = temp;
  *rnm2 = sqrt(s / dn);
  if (timeron) timer_stop(T_norm2);
}


//---------------------------------------------------------------------
// report on norm
//---------------------------------------------------------------------
static void rep_nrm(double *u, int n1, int n2, int n3, char *title, int kk)
{
  double rnm2, rnmu;

  norm2u3(u, n1, n2, n3, &rnm2, &rnmu, nx[kk], ny[kk], nz[kk]);
  printf(" Level%2d in %8s: norms =%21.14E%21.14E\n", kk, title, rnm2, rnmu);
}


//---------------------------------------------------------------------
// comm3 organizes the communication on all borders 
//---------------------------------------------------------------------
static void comm3(double *ou, int n1, int n2, int n3, int kk)
{
//  double (*u)[n2][n1] = (double (*)[n2][n1])ou;

  int i1, i2, i3;
  if (timeron) timer_start(T_comm3);
  #pragma acc data present(ou[0:n3*n2*n1])
  {
  #pragma acc parallel loop gang num_gangs(n3-2) vector_length(128)
  for (i3 = 1; i3 < n3-1; i3++) {
    #pragma acc loop vector
    for (i2 = 1; i2 < n2-1; i2++) {
	/*
      u[i3][i2][   0] = u[i3][i2][n1-2];
      u[i3][i2][n1-1] = u[i3][i2][   1];
	*/
	  I3D(ou, n1, n2, i3, i2, 0)    = I3D(ou, n1, n2, i3, i2, n1-2);
	  I3D(ou, n1, n2, i3, i2, n1-1) = I3D(ou, n1, n2, i3, i2, 1);
    }
  }

  #pragma acc parallel loop gang num_gangs(n3-2) vector_length(128)
  for (i3 = 1; i3 < n3-1; i3++) {
    #pragma acc loop vector
    for (i1 = 0; i1 < n1; i1++) {
	/*
      u[i3][   0][i1] = u[i3][n2-2][i1];
      u[i3][n2-1][i1] = u[i3][   1][i1];
	*/
	 I3D(ou, n1, n2, i3, 0, i1)    = I3D(ou, n1, n2, i3, n2-2, i1);
	 I3D(ou, n1, n2, i3, n2-1, i1) = I3D(ou, n1, n2, i3, 1, i1);
    }
  }

  #pragma acc parallel loop gang num_gangs(n2) vector_length(128)
  for (i2 = 0; i2 < n2; i2++) {
    #pragma acc loop vector
    for (i1 = 0; i1 < n1; i1++) {
	/*
      u[   0][i2][i1] = u[n3-2][i2][i1];
      u[n3-1][i2][i1] = u[   1][i2][i1];
	*/
	  I3D(ou, n1, n2, 0, i2, i1) = I3D(ou, n1, n2, n3-2, i2, i1);
	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
    }
  }
  } /* end acc data */
  if (timeron) timer_stop(T_comm3);
}


inline double randlc( double *x, double a )
{
  const double r23 = 1.1920928955078125e-07;
  const double r46 = r23 * r23;
  const double t23 = 8.388608e+06;
  const double t46 = t23 * t23;

  double t1, t2, t3, t4, a1, a2, x1, x2, z;
  double r;
  t1 = r23 * a;
  a1 = (int) t1;
  a2 = a - t23 * a1;
  
  t1 = r23 * (*x);
  x1 = (int) t1;
  x2 = *x - t23 * x1;
  t1 = a1 * x2 + a2 * x1;
  t2 = (int) (r23 * t1);
  z = t1 - t23 * t2;
  t3 = t23 * z + a2 * x2;
  t4 = (int) (r46 * t3);
  *x = t3 - t46 * t4;
  r = r46 * (*x);
  
  return r;
}

inline void vranlc( int n, double *x, double a, double y[] )
{
	
  const double r23 = 1.1920928955078125e-07;
  const double r46 = r23 * r23;
  const double t23 = 8.388608e+06;
  const double t46 = t23 * t23;

  double t1, t2, t3, t4, a1, a2, x1, x2, z;

  int i;
  t1 = r23 * a;
  a1 = (int) t1;
  a2 = a - t23 * a1;
  for ( i = 0; i < n; i++ ) {
    t1 = r23 * (*x);
    x1 = (int) t1;
    x2 = *x - t23 * x1;
    t1 = a1 * x2 + a2 * x1;
    t2 = (int) (r23 * t1);
    z = t1 - t23 * t2;
    t3 = t23 * z + a2 * x2;
    t4 = (int) (r46 * t3) ;
    *x = t3 - t46 * t4;
    y[i] = r46 * (*x);
  }
}

//---------------------------------------------------------------------
// zran3  loads +1 at ten randomly chosen points,
// loads -1 at a different ten random points,
// and zero elsewhere.
//---------------------------------------------------------------------
static void zran3(double *oz, int n1, int n2, int n3, int nx, int ny, int k)
{
  //double (*z)[n2][n1] = (double (*)[n2][n1])oz;

  int i0, m0, m1;

  int i1, i2, i3, d1, e1, e2, e3;
  double xx, x0, x1, a1, a2, ai;

  const int mm = 10;
  const double a = pow(5.0, 13.0);
  const double x = 314159265.0;
  double ten[mm][2], best;
  int i, j1[mm][2], j2[mm][2], j3[mm][2];
  int jg[4][mm][2];

  double rdummy;

  a1 = power(a, nx);
  a2 = power(a, nx*ny);

  //zero3(z, n1, n2, n3);
  zero3(oz, n1, n2, n3);
  //#pragma acc update host(oz[0:n3*n2*n1])
  i = is1-2+nx*(is2-2+ny*(is3-2));

  ai = power(a, i);
  d1 = ie1 - is1 + 1;
  e1 = ie1 - is1 + 2;
  e2 = ie2 - is2 + 2;
  e3 = ie3 - is3 + 2;
  x0 = x;
  rdummy = randlc(&x0, ai);

  for (i3 = 1; i3 < e3; i3++) {
    x1 = x0;
    for (i2 = 1; i2 < e2; i2++) {
      xx = x1;
      //vranlc(d1, &xx, a, &(z[i3][i2][1]));
      vranlc(d1, &xx, a, &(I3D(oz, n1, n2, i3, i2, 1)));
      rdummy = randlc(&x1,a1);
    }
    rdummy = randlc(&x0, a2);
  }

  //---------------------------------------------------------------------
  // comm3(z,n1,n2,n3);
  // showall(z,n1,n2,n3);
  //---------------------------------------------------------------------

  //---------------------------------------------------------------------
  // each processor looks for twenty candidates
  //---------------------------------------------------------------------
  for (i = 0; i < mm; i++) {
    ten[i][1] = 0.0;
    j1[i][1] = 0;
    j2[i][1] = 0;
    j3[i][1] = 0;
    ten[i][0] = 1.0;
    j1[i][0] = 0;
    j2[i][0] = 0;
    j3[i][0] = 0;
  }
  
  for (i3 = 1; i3 < n3-1; i3++) {
    for (i2 = 1; i2 < n2-1; i2++) {
      for (i1 = 1; i1 < n1-1; i1++) {
        //if (z[i3][i2][i1] > ten[0][1]) {
		if(I3D(oz, n1, n2, i3, i2, i1) > ten[0][1]){
          //ten[0][1] = z[i3][i2][i1];
          ten[0][1] = I3D(oz, n1, n2, i3, i2, i1);
          j1[0][1] = i1;
          j2[0][1] = i2;
          j3[0][1] = i3;
          bubble(ten, j1, j2, j3, mm, 1);
        }
        //if (z[i3][i2][i1] < ten[0][0]) {
        if (I3D(oz, n1, n2, i3, i2, i1) < ten[0][0]) {
          //ten[0][0] = z[i3][i2][i1];
          ten[0][0] = I3D(oz, n1, n2, i3, i2, i1);
          j1[0][0] = i1;
          j2[0][0] = i2;
          j3[0][0] = i3;
          bubble(ten, j1, j2, j3, mm, 0);
        }
      }
    }
  }


  //---------------------------------------------------------------------
  // Now which of these are globally best?
  //---------------------------------------------------------------------
  i1 = mm - 1;
  i0 = mm - 1; 
  for (i = mm - 1; i >= 0; i--) {
    best = 0.0;
    if (best < ten[i1][1]) {
      jg[0][i][1] = 0;
      jg[1][i][1] = is1 - 2 + j1[i1][1];
      jg[2][i][1] = is2 - 2 + j2[i1][1];
      jg[3][i][1] = is3 - 2 + j3[i1][1];
      i1 = i1-1;
    } else {
      jg[0][i][1] = 0;
      jg[1][i][1] = 0;
      jg[2][i][1] = 0;
      jg[3][i][1] = 0;
    }

    best = 1.0;
    if (best > ten[i0][0]) {
      jg[0][i][0] = 0;
      jg[1][i][0] = is1 - 2 + j1[i0][0];
      jg[2][i][0] = is2 - 2 + j2[i0][0];
      jg[3][i][0] = is3 - 2 + j3[i0][0];
      i0 = i0-1;
    } else {
      jg[0][i][0] = 0;
      jg[1][i][0] = 0;
      jg[2][i][0] = 0;
      jg[3][i][0] = 0;
    }

  }
  //  m1 = i1+1;
  //  m0 = i0+1;
  m1 = 0;
  m0 = 0;

  /*
  int cnt = 0;
  printf("  \n");
  printf("  negative charges at\n");
  for (i = 0; i < mm; i++) {
    printf(" (%3d,%3d,%3d)", jg[1][i][0], jg[2][i][0], jg[3][i][0]);
    if (++cnt % 5 == 0) printf("\n");
  }

  cnt = 0;
  printf("  positive charges at\n");
  for (i = 0; i < mm; i++) {
    printf(" (%3d,%3d,%3d)", jg[1][i][1], jg[2][i][1], jg[3][i][1]);
    if (++cnt % 5 == 0) printf("\n");
  }

  cnt = 0;
  printf("  small random numbers were\n");
  for (i = mm-1; i >= 0; i--) {
    printf(" %15.8E", ten[i][0]);
    if (++cnt % 5 == 0) printf("\n");
  }

  cnt = 0;
  printf("  and they were found on processor number\n");
  for (i = mm-1; i >= 0; i--) {
    printf(" %4d", jg[0][i][0]);
    if (++cnt % 10 == 0) printf("\n");
  }

  cnt = 0;
  printf("  large random numbers were\n");
  for (i = mm-1; i >= 0; i--) {
    printf(" %15.8E", ten[i][1]);
    if (++cnt % 5 == 0) printf("\n");
  }

  cnt = 0;
  printf("  and they were found on processor number\n");
  for (i = mm-1; i >= 0; i--) {
    printf(" %4d", jg[0][i][1]);
    if (++cnt % 10 == 0) printf("\n");
  }
  */

  for (i3 = 0; i3 < n3; i3++) {
    for (i2 = 0; i2 < n2; i2++) {
      for (i1 = 0; i1 < n1; i1++) {
        //z[i3][i2][i1] = 0.0;
        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
      }
    }
  }
  
  for (i = mm-1; i >= m0; i--) {
    //z[jg[3][i][0]][jg[2][i][0]][jg[1][i][0]] = -1.0;
	i3 = jg[3][i][0];
	i2 = jg[2][i][0];
	i1 = jg[1][i][0];
    I3D(oz, n1, n2, i3, i2, i1) = -1.0;
  }

  for (i = mm-1; i >= m1; i--) {
    //z[jg[3][i][1]][jg[2][i][1]][jg[1][i][1]] = +1.0;
	i3 = jg[3][i][1];
	i2 = jg[2][i][1];
	i1 = jg[1][i][1];
    I3D(oz, n1, n2, i3, i2, i1) = +1.0;
  }
  #pragma acc update device(oz[0:n3*n2*n1])

  //comm3(z, n1, n2, n3, k);
  comm3(oz, n1, n2, n3, k);

  //---------------------------------------------------------------------
  // showall(z,n1,n2,n3);
  //---------------------------------------------------------------------
}


static void showall(double *oz, int n1, int n2, int n3)
{
  //double (*z)[n2][n1] = (double (*)[n2][n1])oz;

  int i1, i2, i3;
  int m1, m2, m3;

  m1 = min(n1, 18);
  m2 = min(n2, 14);
  m3 = min(n3, 18);

  printf("   \n");
  for (i3 = 0; i3 < m3; i3++) {
    for (i1 = 0; i1 < m1; i1++) {
      for (i2 = 0; i2 < m2; i2++) {
    //    printf("%6.3f", z[i3][i2][i1]);
		  printf("%6.3f", I3D(oz, n1, n2, i3, i2, i2));
      }
      printf("\n");
    }
    printf("  - - - - - - - \n");
  }
  printf("   \n");
}


//---------------------------------------------------------------------
// power  raises an integer, disguised as a double
// precision real, to an integer power
//---------------------------------------------------------------------
static double power(double a, int n)
{
  double aj;
  int nj;
  double rdummy;
  double power;

  power = 1.0;
  nj = n;
  aj = a;

  while (nj != 0) {
    if ((nj % 2) == 1) rdummy = randlc(&power, aj);
    rdummy = randlc(&aj, aj);
    nj = nj/2;
  }

  return power;
}


//---------------------------------------------------------------------
// bubble        does a bubble sort in direction dir
//---------------------------------------------------------------------
static void bubble(double ten[][2], int j1[][2], int j2[][2], int j3[][2],
                   int m, int ind)
{
  double temp;
  int i, j_temp;

  if (ind == 1) {
    for (i = 0; i < m-1; i++) {
      if (ten[i][ind] > ten[i+1][ind]) {
        temp = ten[i+1][ind];
        ten[i+1][ind] = ten[i][ind];
        ten[i][ind] = temp;

        j_temp = j1[i+1][ind];
        j1[i+1][ind] = j1[i][ind];
        j1[i][ind] = j_temp;

        j_temp = j2[i+1][ind];
        j2[i+1][ind] = j2[i][ind];
        j2[i][ind] = j_temp;

        j_temp = j3[i+1][ind];
        j3[i+1][ind] = j3[i][ind];
        j3[i][ind] = j_temp;
      } else {
        return;
      }
    }
  } else {
    for (i = 0; i < m-1; i++) {
      if (ten[i][ind] < ten[i+1][ind]) {

        temp = ten[i+1][ind];
        ten[i+1][ind] = ten[i][ind];
        ten[i][ind] = temp;

        j_temp = j1[i+1][ind];
        j1[i+1][ind] = j1[i][ind];
        j1[i][ind] = j_temp;

        j_temp = j2[i+1][ind];
        j2[i+1][ind] = j2[i][ind];
        j2[i][ind] = j_temp;

        j_temp = j3[i+1][ind];
        j3[i+1][ind] = j3[i][ind];
        j3[i][ind] = j_temp;
      } else {
        return;
      }
    }
  }
}


static void zero3(double *oz, int n1, int n2, int n3)
{
  //double (*z)[n2][n1] = (double (*)[n2][n1])oz;

  int i1, i2, i3;

#pragma acc parallel present(oz[0:n3*n2*n1]) num_gangs(n3) num_workers(8) vector_length(128)
{
  #pragma acc loop gang
  for (i3 = 0; i3 < n3; i3++) {
    #pragma acc loop worker
    for (i2 = 0; i2 < n2; i2++) {
      #pragma acc loop vector
      for (i1 = 0; i1 < n1; i1++) {
   //     z[i3][i2][i1] = 0.0;
   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
      }
    }
  }
}
}


########## NEXT FILE ##########
add.c:::
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB SP code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS SP code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

#include "header.h"

//---------------------------------------------------------------------
// addition of update to the vector u
//---------------------------------------------------------------------
void add()
{
  int i, j, k, m;

//  if (timeron) timer_start(t_add);
#pragma acc parallel present(rhs,u) num_gangs(nz2) num_workers(8) vector_length(32)
{
  #pragma acc loop gang
  for (k = 1; k <= nz2; k++) {
    #pragma acc loop worker
    for (j = 1; j <= ny2; j++) {
      #pragma acc loop vector
      for (i = 1; i <= nx2; i++) {
        /*
        for (m = 0; m < 5; m++) {
          u[m][k][j][i] = u[m][k][j][i] + rhs[m][k][j][i];
        }
        */
          u[0][k][j][i] = u[0][k][j][i] + rhs[0][k][j][i];
          u[1][k][j][i] = u[1][k][j][i] + rhs[1][k][j][i];
          u[2][k][j][i] = u[2][k][j][i] + rhs[2][k][j][i];
          u[3][k][j][i] = u[3][k][j][i] + rhs[3][k][j][i];
          u[4][k][j][i] = u[4][k][j][i] + rhs[4][k][j][i];
      }
    }
  }
}
//  if (timeron) timer_stop(t_add);
}

########## NEXT FILE ##########
adi.c:::
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB SP code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS SP code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

#include "header.h"

void adi()
{
  compute_rhs();
  
  txinvr();

  x_solve();

  y_solve();

  z_solve();
  
  add();
}


void ninvr()
{
  int i, j, k;
  double r1, r2, r3, r4, r5, t1, t2;

#pragma acc parallel present(rhs) num_gangs(nz2) num_workers(8) vector_length(32)
{
  #pragma acc loop gang
  for (k = 1; k <= nz2; k++) {
  #pragma acc loop worker
    for (j = 1; j <= ny2; j++) {
  #pragma acc loop vector
      for (i = 1; i <= nx2; i++) {
        r1 = rhs[0][k][j][i];
        r2 = rhs[1][k][j][i];
        r3 = rhs[2][k][j][i];
        r4 = rhs[3][k][j][i];
        r5 = rhs[4][k][j][i];

        t1 = bt * r3;
        t2 = 0.5 * ( r4 + r5 );

        rhs[0][k][j][i] = -r2;
        rhs[1][k][j][i] =  r1;
        rhs[2][k][j][i] = bt * ( r4 - r5 );
        rhs[3][k][j][i] = -t1 + t2;
        rhs[4][k][j][i] =  t1 + t2;
      }
    }
  }
} /*end parallel*/

}

void pinvr()
{
  int i, j, k;
  double r1, r2, r3, r4, r5, t1, t2;

#pragma acc parallel present(rhs) num_gangs(nz2) num_workers(8) vector_length(32)
{
  #pragma acc loop gang
  for (k = 1; k <= nz2; k++) {
  #pragma acc loop worker
    for (j = 1; j <= ny2; j++) {
  #pragma acc loop vector
      for (i = 1; i <= nx2; i++) {
        r1 = rhs[0][k][j][i];
        r2 = rhs[1][k][j][i];
        r3 = rhs[2][k][j][i];
        r4 = rhs[3][k][j][i];
        r5 = rhs[4][k][j][i];

        t1 = bt * r1;
        t2 = 0.5 * ( r4 + r5 );

        rhs[0][k][j][i] =  bt * ( r4 - r5 );
        rhs[1][k][j][i] = -r3;
        rhs[2][k][j][i] =  r2;
        rhs[3][k][j][i] = -t1 + t2;
        rhs[4][k][j][i] =  t1 + t2;
      }
    }
  }
}

}

void tzetar()
{
  int i, j, k;
  double t1, t2, t3, ac, xvel, yvel, zvel, r1, r2, r3, r4, r5;
  double btuz, ac2u, uzik1;

#pragma acc parallel present(us,vs,ws,qs,u,speed,rhs) num_gangs(nz2) num_workers(8) vector_length(32)
{
  #pragma acc loop gang
  for (k = 1; k <= nz2; k++) {
  #pragma acc loop worker
    for (j = 1; j <= ny2; j++) {
  #pragma acc loop vector
      for (i = 1; i <= nx2; i++) {
        xvel = us[k][j][i];
        yvel = vs[k][j][i];
        zvel = ws[k][j][i];
        ac   = speed[k][j][i];

        ac2u = ac*ac;

        r1 = rhs[0][k][j][i];
        r2 = rhs[1][k][j][i];
        r3 = rhs[2][k][j][i];
        r4 = rhs[3][k][j][i];
        r5 = rhs[4][k][j][i];     

        uzik1 = u[0][k][j][i];
        btuz  = bt * uzik1;

        t1 = btuz/ac * (r4 + r5);
        t2 = r3 + t1;
        t3 = btuz * (r4 - r5);

        rhs[0][k][j][i] = t2;
        rhs[1][k][j][i] = -uzik1*r2 + xvel*t2;
        rhs[2][k][j][i] =  uzik1*r1 + yvel*t2;
        rhs[3][k][j][i] =  zvel*t2  + t3;
        rhs[4][k][j][i] =  uzik1*(-xvel*r2 + yvel*r1) + 
                           qs[k][j][i]*t2 + c2iv*ac2u*t1 + zvel*t3;
      }
    }
  }
}/*end parallel*/

}

void x_solve()
{
  int i, j, k, i1, i2, m;
  int gp01,gp02,gp03,gp04;
  double ru1, fac1, fac2;
  double lhsX[5][nz2+1][IMAXP+1][IMAXP+1];
  double lhspX[5][nz2+1][IMAXP+1][IMAXP+1];
  double lhsmX[5][nz2+1][IMAXP+1][IMAXP+1];
  double rhonX[nz2+1][IMAXP+1][PROBLEM_SIZE];
  double rhsX[5][nz2+1][IMAXP+1][JMAXP+1];

  int ni=nx2+1;
  gp01=grid_points[0]-1;
  gp02=grid_points[0]-2;
  gp03=grid_points[0]-3;
  gp04=grid_points[0]-4;
  

#pragma acc data present(rho_i,us,speed,rhs) create(lhsX,lhspX,lhsmX,rhonX,rhsX)
{  

#pragma acc parallel loop gang num_gangs(nz2+1) num_workers(8) vector_length(32)
  for (k = 0; k <= nz2; k++) {
   #pragma acc loop worker
    for (j = 0; j <= JMAXP; j++) {
	  #pragma acc loop vector
      for (i = 0; i <= IMAXP; i++) {
	  rhsX[0][k][i][j] = rhs[0][k][j][i];
	  rhsX[1][k][i][j] = rhs[1][k][j][i];
	  rhsX[2][k][i][j] = rhs[2][k][j][i];
	  rhsX[3][k][i][j] = rhs[3][k][j][i];
	  rhsX[4][k][i][j] = rhs[4][k][j][i];
      }
    }
  }

  #pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= nz2; k++) {
    #pragma acc loop worker vector
    for (j = 1; j <= ny2; j++) {
      for (m = 0; m < 5; m++) {
		lhsX[m][k][0][j] = 0.0;
		lhspX[m][k][0][j] = 0.0;
		lhsmX[m][k][0][j] = 0.0;
		lhsX[m][k][ni][j] = 0.0;
		lhspX[m][k][ni][j] = 0.0;
		lhsmX[m][k][ni][j] = 0.0;
      }
      lhsX[2][k][0][j] = 1.0;
      lhspX[2][k][0][j] = 1.0;
      lhsmX[2][k][0][j] = 1.0;
      lhsX[2][k][ni][j] = 1.0;
      lhspX[2][k][ni][j] = 1.0;
      lhsmX[2][k][ni][j] = 1.0;
    }
  }
    //---------------------------------------------------------------------
    // Computes the left hand side for the three x-factors  
    //---------------------------------------------------------------------
  
    //---------------------------------------------------------------------
    // first fill the lhs for the u-eigenvalue                   
    //---------------------------------------------------------------------
  #pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= nz2; k++) {
    #pragma acc loop worker vector
    for (j = 1; j <= ny2; j++) {
      for (i = 0; i <= gp01; i++) {
        ru1 = c3c4*rho_i[k][j][i];
        //cv[i] = us[k][j][i];
        rhonX[k][j][i] = max(max(dx2+con43*ru1,dx5+c1c5*ru1), max(dxmax+ru1,dx1));
      }

      for (i = 1; i <= nx2; i++) {
        lhsX[0][k][i][j] =  0.0;
	//      lhsX[1][k][i][j] = -dttx2 * cv[i-1] - dttx1 * rhon[i-1];
        lhsX[1][k][i][j] = -dttx2 * us[k][j][i-1] - dttx1 * rhonX[k][j][i-1];
        lhsX[2][k][i][j] =  1.0 + c2dttx1 * rhonX[k][j][i];
	//       lhsX[3][k][i][j] =  dttx2 * cv[i+1] - dttx1 * rhon[i+1];
        lhsX[3][k][i][j] =  dttx2 * us[k][j][i+1] - dttx1 * rhonX[k][j][i+1];
        lhsX[4][k][i][j] =  0.0;
      }
    }
  }

    //---------------------------------------------------------------------
    // add fourth order dissipation                             
    //---------------------------------------------------------------------
  i = 1;
  #pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= nz2; k++) {
    #pragma acc loop worker vector
    for (j = 1; j <= ny2; j++) {
      lhsX[2][k][i][j] = lhsX[2][k][i][j] + comz5;
      lhsX[3][k][i][j] = lhsX[3][k][i][j] - comz4;
      lhsX[4][k][i][j] = lhsX[4][k][i][j] + comz1;

      lhsX[1][k][i+1][j] = lhsX[1][k][i+1][j] - comz4;
      lhsX[2][k][i+1][j] = lhsX[2][k][i+1][j] + comz6;
      lhsX[3][k][i+1][j] = lhsX[3][k][i+1][j] - comz4;
      lhsX[4][k][i+1][j] = lhsX[4][k][i+1][j] + comz1;
    }
  }

  #pragma acc parallel loop gang  num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= nz2; k++) {
    #pragma acc loop worker vector
    for (j = 1; j <= ny2; j++) {
      for (i = 3; i <= gp04; i++) {
        lhsX[0][k][i][j] = lhsX[0][k][i][j] + comz1;
        lhsX[1][k][i][j] = lhsX[1][k][i][j] - comz4;
        lhsX[2][k][i][j] = lhsX[2][k][i][j] + comz6;
        lhsX[3][k][i][j] = lhsX[3][k][i][j] - comz4;
        lhsX[4][k][i][j] = lhsX[4][k][i][j] + comz1;
      }
    }
  }

  i = gp03;
  #pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= nz2; k++) {
    #pragma acc loop worker vector
    for (j = 1; j <= ny2; j++) {
      lhsX[0][k][i][j] = lhsX[0][k][i][j] + comz1;
      lhsX[1][k][i][j] = lhsX[1][k][i][j] - comz4;
      lhsX[2][k][i][j] = lhsX[2][k][i][j] + comz6;
      lhsX[3][k][i][j] = lhsX[3][k][i][j] - comz4;

      lhsX[0][k][i+1][j] = lhsX[0][k][i+1][j] + comz1;
      lhsX[1][k][i+1][j] = lhsX[1][k][i+1][j] - comz4;
      lhsX[2][k][i+1][j] = lhsX[2][k][i+1][j] + comz5;
    }
  }

    //---------------------------------------------------------------------
    // subsequently, fill the other factors (u+c), (u-c) by adding to 
    // the first  
    //---------------------------------------------------------------------
  #pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= nz2; k++) {
    #pragma acc loop worker
    for (j = 1; j <= ny2; j++) {
	  #pragma acc loop vector
      for (i = 1; i <= nx2; i++) {
        lhspX[0][k][i][j] = lhsX[0][k][i][j];
        lhspX[1][k][i][j] = lhsX[1][k][i][j] - dttx2 * speed[k][j][i-1];
        lhspX[2][k][i][j] = lhsX[2][k][i][j];
        lhspX[3][k][i][j] = lhsX[3][k][i][j] + dttx2 * speed[k][j][i+1];
        lhspX[4][k][i][j] = lhsX[4][k][i][j];
        lhsmX[0][k][i][j] = lhsX[0][k][i][j];
        lhsmX[1][k][i][j] = lhsX[1][k][i][j] + dttx2 * speed[k][j][i-1];
        lhsmX[2][k][i][j] = lhsX[2][k][i][j];
        lhsmX[3][k][i][j] = lhsX[3][k][i][j] - dttx2 * speed[k][j][i+1];
        lhsmX[4][k][i][j] = lhsX[4][k][i][j];
      }
    }
  }

    //---------------------------------------------------------------------
    // FORWARD ELIMINATION  
    //---------------------------------------------------------------------

    //---------------------------------------------------------------------
    // perform the Thomas algorithm; first, FORWARD ELIMINATION     
    //---------------------------------------------------------------------
  #pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= nz2; k++) {
    #pragma acc loop worker vector
    for (j = 1; j <= ny2; j++) {
      for (i = 0; i <= gp03; i++) {
        i1 = i + 1;
        i2 = i + 2;
        fac1 = 1.0/lhsX[2][k][i][j];
        lhsX[3][k][i][j] = fac1*lhsX[3][k][i][j];
        lhsX[4][k][i][j] = fac1*lhsX[4][k][i][j];
        /*
        for (m = 0; m < 3; m++) {
          rhsX[m][k][i][j] = fac1*rhsX[m][k][i][j];
        }
        */
          rhsX[0][k][i][j] = fac1*rhsX[0][k][i][j];
          rhsX[1][k][i][j] = fac1*rhsX[1][k][i][j];
          rhsX[2][k][i][j] = fac1*rhsX[2][k][i][j];
        lhsX[2][k][i1][j] = lhsX[2][k][i1][j] - lhsX[1][k][i1][j]*lhsX[3][k][i][j];
        lhsX[3][k][i1][j] = lhsX[3][k][i1][j] - lhsX[1][k][i1][j]*lhsX[4][k][i][j];
        /*
        for (m = 0; m < 3; m++) {
          rhsX[m][k][i1][j] = rhsX[m][k][i1][j] - lhsX[1][k][i1][j]*rhsX[m][k][i][j];
        }
        */
          rhsX[0][k][i1][j] = rhsX[0][k][i1][j] - lhsX[1][k][i1][j]*rhsX[0][k][i][j];
          rhsX[1][k][i1][j] = rhsX[1][k][i1][j] - lhsX[1][k][i1][j]*rhsX[1][k][i][j];
          rhsX[2][k][i1][j] = rhsX[2][k][i1][j] - lhsX[1][k][i1][j]*rhsX[2][k][i][j];
        lhsX[1][k][i2][j] = lhsX[1][k][i2][j] - lhsX[0][k][i2][j]*lhsX[3][k][i][j];
        lhsX[2][k][i2][j] = lhsX[2][k][i2][j] - lhsX[0][k][i2][j]*lhsX[4][k][i][j];
        /*
        for (m = 0; m < 3; m++) {
          rhsX[m][k][i2][j] = rhsX[m][k][i2][j] - lhsX[0][k][i2][j]*rhsX[m][k][i][j];
        }
        */
          rhsX[0][k][i2][j] = rhsX[0][k][i2][j] - lhsX[0][k][i2][j]*rhsX[0][k][i][j];
          rhsX[1][k][i2][j] = rhsX[1][k][i2][j] - lhsX[0][k][i2][j]*rhsX[1][k][i][j];
          rhsX[2][k][i2][j] = rhsX[2][k][i2][j] - lhsX[0][k][i2][j]*rhsX[2][k][i][j];
      }
    }
  }

    //---------------------------------------------------------------------
    // The last two rows in this grid block are a bit different, 
    // since they for (not have two more rows available for the
    // elimination of off-diagonal entries
    //---------------------------------------------------------------------
  i  = gp02;
  i1 = gp01;
  #pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= nz2; k++) {
    #pragma acc loop worker vector
    for (j = 1; j <= ny2; j++) {
      fac1 = 1.0/lhsX[2][k][i][j];
      lhsX[3][k][i][j] = fac1*lhsX[3][k][i][j];
      lhsX[4][k][i][j] = fac1*lhsX[4][k][i][j];
    /*
      for (m = 0; m < 3; m++) {
        rhsX[m][k][i][j] = fac1*rhsX[m][k][i][j];
      }
    */
        rhsX[0][k][i][j] = fac1*rhsX[0][k][i][j];
        rhsX[1][k][i][j] = fac1*rhsX[1][k][i][j];
        rhsX[2][k][i][j] = fac1*rhsX[2][k][i][j];
      lhsX[2][k][i1][j] = lhsX[2][k][i1][j] - lhsX[1][k][i1][j]*lhsX[3][k][i][j];
      lhsX[3][k][i1][j] = lhsX[3][k][i1][j] - lhsX[1][k][i1][j]*lhsX[4][k][i][j];
     /*
      for (m = 0; m < 3; m++) {
        rhsX[m][k][i1][j] = rhsX[m][k][i1][j] - lhsX[1][k][i1][j]*rhsX[m][k][i][j];
      }
      */
        rhsX[0][k][i1][j] = rhsX[0][k][i1][j] - lhsX[1][k][i1][j]*rhsX[0][k][i][j];
        rhsX[1][k][i1][j] = rhsX[1][k][i1][j] - lhsX[1][k][i1][j]*rhsX[1][k][i][j];
        rhsX[2][k][i1][j] = rhsX[2][k][i1][j] - lhsX[1][k][i1][j]*rhsX[2][k][i][j];
      //---------------------------------------------------------------------
      // scale the last row immediately 
      //---------------------------------------------------------------------
      fac2 = 1.0/lhsX[2][k][i1][j];
    /*
      for (m = 0; m < 3; m++) {
        rhsX[m][k][i1][j] = fac2*rhsX[m][k][i1][j];
      }
    */
        rhsX[0][k][i1][j] = fac2*rhsX[0][k][i1][j];
        rhsX[1][k][i1][j] = fac2*rhsX[1][k][i1][j];
        rhsX[2][k][i1][j] = fac2*rhsX[2][k][i1][j];
    }
  }

    //---------------------------------------------------------------------
    // for (the u+c and the u-c factors                 
    //---------------------------------------------------------------------
#pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= nz2; k++) {
    #pragma acc loop worker vector
    for (j = 1; j <= ny2; j++) {
      for (i = 0; i <= gp03; i++) {
        i1 = i + 1;
        i2 = i + 2;
        m = 3;
        fac1 = 1.0/lhspX[2][k][i][j];
        lhspX[3][k][i][j]    = fac1*lhspX[3][k][i][j];
        lhspX[4][k][i][j]    = fac1*lhspX[4][k][i][j];
        rhsX[m][k][i][j]  = fac1*rhsX[m][k][i][j];
        lhspX[2][k][i1][j]   = lhspX[2][k][i1][j] - lhspX[1][k][i1][j]*lhspX[3][k][i][j];
        lhspX[3][k][i1][j]   = lhspX[3][k][i1][j] - lhspX[1][k][i1][j]*lhspX[4][k][i][j];
        rhsX[m][k][i1][j] = rhsX[m][k][i1][j] - lhspX[1][k][i1][j]*rhsX[m][k][i][j];
        lhspX[1][k][i2][j]   = lhspX[1][k][i2][j] - lhspX[0][k][i2][j]*lhspX[3][k][i][j];
        lhspX[2][k][i2][j]   = lhspX[2][k][i2][j] - lhspX[0][k][i2][j]*lhspX[4][k][i][j];
        rhsX[m][k][i2][j] = rhsX[m][k][i2][j] - lhspX[0][k][i2][j]*rhsX[m][k][i][j];
 
        m = 4;
        fac1 = 1.0/lhsmX[2][k][i][j];
        lhsmX[3][k][i][j]    = fac1*lhsmX[3][k][i][j];
        lhsmX[4][k][i][j]    = fac1*lhsmX[4][k][i][j];
        rhsX[m][k][i][j]  = fac1*rhsX[m][k][i][j];
        lhsmX[2][k][i1][j]   = lhsmX[2][k][i1][j] - lhsmX[1][k][i1][j]*lhsmX[3][k][i][j];
        lhsmX[3][k][i1][j]   = lhsmX[3][k][i1][j] - lhsmX[1][k][i1][j]*lhsmX[4][k][i][j];
        rhsX[m][k][i1][j] = rhsX[m][k][i1][j] - lhsmX[1][k][i1][j]*rhsX[m][k][i][j];
        lhsmX[1][k][i2][j]   = lhsmX[1][k][i2][j] - lhsmX[0][k][i2][j]*lhsmX[3][k][i][j];
        lhsmX[2][k][i2][j]   = lhsmX[2][k][i2][j] - lhsmX[0][k][i2][j]*lhsmX[4][k][i][j];
        rhsX[m][k][i2][j] = rhsX[m][k][i2][j] - lhsmX[0][k][i2][j]*rhsX[m][k][i][j];
      }
    }
  }

    //---------------------------------------------------------------------
    // And again the last two rows separately
    //---------------------------------------------------------------------
  i  = gp02;
  i1 = gp01;
  #pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= nz2; k++) {
    #pragma acc loop worker vector
    for (j = 1; j <= ny2; j++) {

      m = 3;
      fac1 = 1.0/lhspX[2][k][i][j];
      lhspX[3][k][i][j]    = fac1*lhspX[3][k][i][j];
      lhspX[4][k][i][j]    = fac1*lhspX[4][k][i][j];
      rhsX[m][k][i][j]  = fac1*rhsX[m][k][i][j];
      lhspX[2][k][i1][j]   = lhspX[2][k][i1][j] - lhspX[1][k][i1][j]*lhspX[3][k][i][j];
      lhspX[3][k][i1][j]   = lhspX[3][k][i1][j] - lhspX[1][k][i1][j]*lhspX[4][k][i][j];
      rhsX[m][k][i1][j] = rhsX[m][k][i1][j] - lhspX[1][k][i1][j]*rhsX[m][k][i][j];

      m = 4;
      fac1 = 1.0/lhsmX[2][k][i][j];
      lhsmX[3][k][i][j]    = fac1*lhsmX[3][k][i][j];
      lhsmX[4][k][i][j]    = fac1*lhsmX[4][k][i][j];
      rhsX[m][k][i][j]  = fac1*rhsX[m][k][i][j];
      lhsmX[2][k][i1][j]   = lhsmX[2][k][i1][j] - lhsmX[1][k][i1][j]*lhsmX[3][k][i][j];
      lhsmX[3][k][i1][j]   = lhsmX[3][k][i1][j] - lhsmX[1][k][i1][j]*lhsmX[4][k][i][j];
      rhsX[m][k][i1][j] = rhsX[m][k][i1][j] - lhsmX[1][k][i1][j]*rhsX[m][k][i][j];

      //---------------------------------------------------------------------
      // Scale the last row immediately
      //---------------------------------------------------------------------
      rhsX[3][k][i1][j] = rhsX[3][k][i1][j]/lhspX[2][k][i1][j];
      rhsX[4][k][i1][j] = rhsX[4][k][i1][j]/lhsmX[2][k][i1][j];
    }
  }

    //---------------------------------------------------------------------
    // BACKSUBSTITUTION 
    //---------------------------------------------------------------------
  i  = gp02;
  i1 = gp01;
  #pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= nz2; k++) {
    #pragma acc loop worker vector
    for (j = 1; j <= ny2; j++) {
     /*
      for (m = 0; m < 3; m++) {
        rhsX[m][k][i][j] = rhsX[m][k][i][j] - lhsX[3][k][i][j]*rhsX[m][k][i1][j];
      }
      */
        rhsX[0][k][i][j] = rhsX[0][k][i][j] - lhsX[3][k][i][j]*rhsX[0][k][i1][j];
        rhsX[1][k][i][j] = rhsX[1][k][i][j] - lhsX[3][k][i][j]*rhsX[1][k][i1][j];
        rhsX[2][k][i][j] = rhsX[2][k][i][j] - lhsX[3][k][i][j]*rhsX[2][k][i1][j];
      rhsX[3][k][i][j] = rhsX[3][k][i][j] - lhspX[3][k][i][j]*rhsX[3][k][i1][j];
      rhsX[4][k][i][j] = rhsX[4][k][i][j] - lhsmX[3][k][i][j]*rhsX[4][k][i1][j];
    }
  }

    //---------------------------------------------------------------------
    // The first three factors
    //---------------------------------------------------------------------
  #pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= nz2; k++) {
    #pragma acc loop worker vector
    for (j = 1; j <= ny2; j++) {
      for (i = gp03; i >= 0; i--) {
        i1 = i + 1;
        i2 = i + 2;
        /*
        for (m = 0; m < 3; m++) {
          rhsX[m][k][i][j] = rhsX[m][k][i][j] - 
                            lhsX[3][k][i][j]*rhsX[m][k][i1][j] -
                            lhsX[4][k][i][j]*rhsX[m][k][i2][j];
        }
        */
          rhsX[0][k][i][j] = rhsX[0][k][i][j] - 
                            lhsX[3][k][i][j]*rhsX[0][k][i1][j] -
                            lhsX[4][k][i][j]*rhsX[0][k][i2][j];
          rhsX[1][k][i][j] = rhsX[1][k][i][j] - 
                            lhsX[3][k][i][j]*rhsX[1][k][i1][j] -
                            lhsX[4][k][i][j]*rhsX[1][k][i2][j];
          rhsX[2][k][i][j] = rhsX[2][k][i][j] - 
                            lhsX[3][k][i][j]*rhsX[2][k][i1][j] -
                            lhsX[4][k][i][j]*rhsX[2][k][i2][j];
        //-------------------------------------------------------------------
        // And the remaining two
        //-------------------------------------------------------------------
        rhsX[3][k][i][j] = rhsX[3][k][i][j] - 
                          lhspX[3][k][i][j]*rhsX[3][k][i1][j] -
                          lhspX[4][k][i][j]*rhsX[3][k][i2][j];
        rhsX[4][k][i][j] = rhsX[4][k][i][j] - 
                          lhsmX[3][k][i][j]*rhsX[4][k][i1][j] -
                          lhsmX[4][k][i][j]*rhsX[4][k][i2][j];
      }
    }
  }  

#pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32) 
  for (k = 0; k <= nz2; k++) {
    #pragma acc loop worker
    for (j = 0; j <= JMAXP; j++) {
	  #pragma acc loop vector
      for (i = 0; i <= IMAXP; i++) {
	  rhs[0][k][j][i] = rhsX[0][k][i][j];
	  rhs[1][k][j][i] = rhsX[1][k][i][j];
	  rhs[2][k][j][i] = rhsX[2][k][i][j];
	  rhs[3][k][j][i] = rhsX[3][k][i][j];
	  rhs[4][k][j][i] = rhsX[4][k][i][j];
      }
    }
  }

  //---------------------------------------------------------------------
  // Do the block-diagonal inversion          
  //---------------------------------------------------------------------
  ninvr();
}/* end acc data */
}

void y_solve()
{
  int i, j, k, j1, j2, m;
  int gp0, gp1, gp2;
  double ru1, fac1, fac2;
  double lhsY[5][nz2+1][IMAXP+1][IMAXP+1];
  double lhspY[5][nz2+1][IMAXP+1][IMAXP+1];
  double lhsmY[5][nz2+1][IMAXP+1][IMAXP+1];
  double rhoqY[nz2+1][IMAXP+1][PROBLEM_SIZE];

  int ni=ny2+1;
  gp0=grid_points[0];
  gp1=grid_points[1];
  gp2=grid_points[2];

#pragma acc data present(rho_i,vs,speed,rhs) create(lhsY,lhspY,lhsmY,rhoqY)
{
  #pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= nz2; k++) {
    #pragma acc loop worker vector
    for (i = 1; i <= nx2; i++) {
      for (m = 0; m < 5; m++) {
        lhsY[m][k][0][i] = 0.0;
      	lhspY[m][k][0][i] = 0.0;
      	lhsmY[m][k][0][i] = 0.0;
      	lhsY[m][k][ni][i] = 0.0;
      	lhspY[m][k][ni][i] = 0.0;
      	lhsmY[m][k][ni][i] = 0.0;
      }
      lhsY[2][k][0][i] = 1.0;
      lhspY[2][k][0][i] = 1.0;
      lhsmY[2][k][0][i] = 1.0;
      lhsY[2][k][ni][i] = 1.0;
      lhspY[2][k][ni][i] = 1.0;
      lhsmY[2][k][ni][i] = 1.0;
    }
  }

    //---------------------------------------------------------------------
    // Computes the left hand side for the three y-factors   
    //---------------------------------------------------------------------

    //---------------------------------------------------------------------
    // first fill the lhs for the u-eigenvalue         
    //---------------------------------------------------------------------
  #pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= nz2; k++) {
    #pragma acc loop worker vector
    for (i = 1; i <= gp0-2; i++) {
      for (j = 0; j <= gp1-1; j++) {
        ru1 = c3c4*rho_i[k][j][i];
   //     cv[j] = vs[k][j][i];
        rhoqY[k][j][i] = max(max(dy3+con43*ru1, dy5+c1c5*ru1), max(dymax+ru1, dy1));
      }

      for (j = 1; j <= gp1-2; j++) {
        lhsY[0][k][j][i] =  0.0;
       // lhsY[1][k][j][i] = -dtty2 * cv[j-1] - dtty1 * rhoqY[j-1];
        lhsY[1][k][j][i] = -dtty2 * vs[k][j-1][i] - dtty1 * rhoqY[k][j-1][i];
        lhsY[2][k][j][i] =  1.0 + c2dtty1 * rhoqY[k][j][i];
       // lhsY[3][k][j][i] =  dtty2 * cv[j+1] - dtty1 * rhoq[j+1];
        lhsY[3][k][j][i] =  dtty2 * vs[k][j+1][i] - dtty1 * rhoqY[k][j+1][i];
        lhsY[4][k][j][i] =  0.0;
      }
    }
  }

    //---------------------------------------------------------------------
    // add fourth order dissipation                             
    //---------------------------------------------------------------------
  j = 1;
  #pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= gp2-2; k++) {
    #pragma acc loop worker vector
    for (i = 1; i <= gp0-2; i++) {
      lhsY[2][k][j][i] = lhsY[2][k][j][i] + comz5;
      lhsY[3][k][j][i] = lhsY[3][k][j][i] - comz4;
      lhsY[4][k][j][i] = lhsY[4][k][j][i] + comz1;

      lhsY[1][k][j+1][i] = lhsY[1][k][j+1][i] - comz4;
      lhsY[2][k][j+1][i] = lhsY[2][k][j+1][i] + comz6;
      lhsY[3][k][j+1][i] = lhsY[3][k][j+1][i] - comz4;
      lhsY[4][k][j+1][i] = lhsY[4][k][j+1][i] + comz1;
    }
  }

  #pragma acc parallel loop gang num_gangs(gp2-2) num_workers(8) vector_length(32)
  for (k = 1; k <= gp2-2; k++) {
    #pragma acc loop worker
    for (j = 3; j <= gp1-4; j++) {
    #pragma acc loop vector
      for (i = 1; i <= gp0-2; i++) {
        lhsY[0][k][j][i] = lhsY[0][k][j][i] + comz1;
        lhsY[1][k][j][i] = lhsY[1][k][j][i] - comz4;
        lhsY[2][k][j][i] = lhsY[2][k][j][i] + comz6;
        lhsY[3][k][j][i] = lhsY[3][k][j][i] - comz4;
        lhsY[4][k][j][i] = lhsY[4][k][j][i] + comz1;
      }
    }
  }

  j = gp1-3;
  #pragma acc parallel loop gang num_gangs(gp2-2) num_workers(8) vector_length(32)
  for (k = 1; k <= gp2-2; k++) {
    #pragma acc loop worker vector
    for (i = 1; i <= gp0-2; i++) {
      lhsY[0][k][j][i] = lhsY[0][k][j][i] + comz1;
      lhsY[1][k][j][i] = lhsY[1][k][j][i] - comz4;
      lhsY[2][k][j][i] = lhsY[2][k][j][i] + comz6;
      lhsY[3][k][j][i] = lhsY[3][k][j][i] - comz4;

      lhsY[0][k][j+1][i] = lhsY[0][k][j+1][i] + comz1;
      lhsY[1][k][j+1][i] = lhsY[1][k][j+1][i] - comz4;
      lhsY[2][k][j+1][i] = lhsY[2][k][j+1][i] + comz5;
    }
  }

    //---------------------------------------------------------------------
    // subsequently, for (the other two factors                    
    //---------------------------------------------------------------------
  #pragma acc parallel loop gang num_gangs(gp2-2) num_workers(8) vector_length(32)
  for (k = 1; k <= gp2-2; k++) {
    #pragma acc loop worker
    for (j = 1; j <= gp1-2; j++) {
    #pragma acc loop vector
      for (i = 1; i <= gp0-2; i++) {
        lhspY[0][k][j][i] = lhsY[0][k][j][i];
        lhspY[1][k][j][i] = lhsY[1][k][j][i] - dtty2 * speed[k][j-1][i];
        lhspY[2][k][j][i] = lhsY[2][k][j][i];
        lhspY[3][k][j][i] = lhsY[3][k][j][i] + dtty2 * speed[k][j+1][i];
        lhspY[4][k][j][i] = lhsY[4][k][j][i];
        lhsmY[0][k][j][i] = lhsY[0][k][j][i];
        lhsmY[1][k][j][i] = lhsY[1][k][j][i] + dtty2 * speed[k][j-1][i];
        lhsmY[2][k][j][i] = lhsY[2][k][j][i];
        lhsmY[3][k][j][i] = lhsY[3][k][j][i] - dtty2 * speed[k][j+1][i];
        lhsmY[4][k][j][i] = lhsY[4][k][j][i];
      }
    }
  }


    //---------------------------------------------------------------------
    // FORWARD ELIMINATION  
    //---------------------------------------------------------------------
  #pragma acc parallel loop gang num_gangs(gp2-2) num_workers(8) vector_length(32)
  for (k = 1; k <= gp2-2; k++) {
      #pragma acc loop worker vector
      for (i = 1; i <= gp0-2; i++) {
    for (j = 0; j <= gp1-3; j++) {
      j1 = j + 1;
      j2 = j + 2;
      //for (i = 1; i <= gp0-2; i++) {
        fac1 = 1.0/lhsY[2][k][j][i];
        lhsY[3][k][j][i] = fac1*lhsY[3][k][j][i];
        lhsY[4][k][j][i] = fac1*lhsY[4][k][j][i];
        /*
        for (m = 0; m < 3; m++) {
          rhs[m][k][j][i] = fac1*rhs[m][k][j][i];
        }
        */
          rhs[0][k][j][i] = fac1*rhs[0][k][j][i];
          rhs[1][k][j][i] = fac1*rhs[1][k][j][i];
          rhs[2][k][j][i] = fac1*rhs[2][k][j][i];
        lhsY[2][k][j1][i] = lhsY[2][k][j1][i] - lhsY[1][k][j1][i]*lhsY[3][k][j][i];
        lhsY[3][k][j1][i] = lhsY[3][k][j1][i] - lhsY[1][k][j1][i]*lhsY[4][k][j][i];
        /*
        for (m = 0; m < 3; m++) {
          rhs[m][k][j1][i] = rhs[m][k][j1][i] - lhsY[1][k][j1][i]*rhs[m][k][j][i];
        }
        */
          rhs[0][k][j1][i] = rhs[0][k][j1][i] - lhsY[1][k][j1][i]*rhs[0][k][j][i];
          rhs[1][k][j1][i] = rhs[1][k][j1][i] - lhsY[1][k][j1][i]*rhs[1][k][j][i];
          rhs[2][k][j1][i] = rhs[2][k][j1][i] - lhsY[1][k][j1][i]*rhs[2][k][j][i];
        lhsY[1][k][j2][i] = lhsY[1][k][j2][i] - lhsY[0][k][j2][i]*lhsY[3][k][j][i];
        lhsY[2][k][j2][i] = lhsY[2][k][j2][i] - lhsY[0][k][j2][i]*lhsY[4][k][j][i];
        /*
        for (m = 0; m < 3; m++) {
          rhs[m][k][j2][i] = rhs[m][k][j2][i] - lhsY[0][k][j2][i]*rhs[m][k][j][i];
        }
        */
          rhs[0][k][j2][i] = rhs[0][k][j2][i] - lhsY[0][k][j2][i]*rhs[0][k][j][i];
          rhs[1][k][j2][i] = rhs[1][k][j2][i] - lhsY[0][k][j2][i]*rhs[1][k][j][i];
          rhs[2][k][j2][i] = rhs[2][k][j2][i] - lhsY[0][k][j2][i]*rhs[2][k][j][i];
      }
    }
  }

    //---------------------------------------------------------------------
    // The last two rows in this grid block are a bit different, 
    // since they for (not have two more rows available for the
    // elimination of off-diagonal entries
    //---------------------------------------------------------------------
  j  = gp1-2;
  j1 = gp1-1;
  #pragma acc parallel loop gang num_gangs(gp2-2) num_workers(8) vector_length(32)
  for (k = 1; k <= gp2-2; k++) {
    #pragma acc loop worker vector
    for (i = 1; i <= gp0-2; i++) {
      fac1 = 1.0/lhsY[2][k][j][i];
      lhsY[3][k][j][i] = fac1*lhsY[3][k][j][i];
      lhsY[4][k][j][i] = fac1*lhsY[4][k][j][i];
     /*
      for (m = 0; m < 3; m++) {
        rhs[m][k][j][i] = fac1*rhs[m][k][j][i];
      }
     */
        rhs[0][k][j][i] = fac1*rhs[0][k][j][i];
        rhs[1][k][j][i] = fac1*rhs[1][k][j][i];
        rhs[2][k][j][i] = fac1*rhs[2][k][j][i];
      lhsY[2][k][j1][i] = lhsY[2][k][j1][i] - lhsY[1][k][j1][i]*lhsY[3][k][j][i];
      lhsY[3][k][j1][i] = lhsY[3][k][j1][i] - lhsY[1][k][j1][i]*lhsY[4][k][j][i];
     /*
      for (m = 0; m < 3; m++) {
        rhs[m][k][j1][i] = rhs[m][k][j1][i] - lhsY[1][k][j1][i]*rhs[m][k][j][i];
      }
      */
        rhs[0][k][j1][i] = rhs[0][k][j1][i] - lhsY[1][k][j1][i]*rhs[0][k][j][i];
        rhs[1][k][j1][i] = rhs[1][k][j1][i] - lhsY[1][k][j1][i]*rhs[1][k][j][i];
        rhs[2][k][j1][i] = rhs[2][k][j1][i] - lhsY[1][k][j1][i]*rhs[2][k][j][i];
      //---------------------------------------------------------------------
      // scale the last row immediately 
      //---------------------------------------------------------------------
      fac2 = 1.0/lhsY[2][k][j1][i];
      /*
      for (m = 0; m < 3; m++) {
        rhs[m][k][j1][i] = fac2*rhs[m][k][j1][i];
      }
      */
        rhs[0][k][j1][i] = fac2*rhs[0][k][j1][i];
        rhs[1][k][j1][i] = fac2*rhs[1][k][j1][i];
        rhs[2][k][j1][i] = fac2*rhs[2][k][j1][i];
    }
  }

    //---------------------------------------------------------------------
    // for (the u+c and the u-c factors                 
    //---------------------------------------------------------------------
#pragma acc parallel loop gang num_gangs(gp2-2) num_workers(8) vector_length(32)
  for (k = 1; k <= gp2-2; k++) {
    //#pragma acc loop gang(8) vector(32)
    #pragma acc loop worker vector
    for (i = 1; i <= gp0-2; i++) {
      for (j = 0; j <= gp1-3; j++) {
	j1 = j + 1;
	j2 = j + 2;
        m = 3;
        fac1 = 1.0/lhspY[2][k][j][i];
        lhspY[3][k][j][i]    = fac1*lhspY[3][k][j][i];
        lhspY[4][k][j][i]    = fac1*lhspY[4][k][j][i];
        rhs[m][k][j][i]  = fac1*rhs[m][k][j][i];
        lhspY[2][k][j1][i]   = lhspY[2][k][j1][i] - lhspY[1][k][j1][i]*lhspY[3][k][j][i];
        lhspY[3][k][j1][i]   = lhspY[3][k][j1][i] - lhspY[1][k][j1][i]*lhspY[4][k][j][i];
        rhs[m][k][j1][i] = rhs[m][k][j1][i] - lhspY[1][k][j1][i]*rhs[m][k][j][i];
        lhspY[1][k][j2][i]   = lhspY[1][k][j2][i] - lhspY[0][k][j2][i]*lhspY[3][k][j][i];
        lhspY[2][k][j2][i]   = lhspY[2][k][j2][i] - lhspY[0][k][j2][i]*lhspY[4][k][j][i];
        rhs[m][k][j2][i] = rhs[m][k][j2][i] - lhspY[0][k][j2][i]*rhs[m][k][j][i];

        m = 4;
        fac1 = 1.0/lhsmY[2][k][j][i];
        lhsmY[3][k][j][i]    = fac1*lhsmY[3][k][j][i];
        lhsmY[4][k][j][i]    = fac1*lhsmY[4][k][j][i];
        rhs[m][k][j][i]  = fac1*rhs[m][k][j][i];
        lhsmY[2][k][j1][i]   = lhsmY[2][k][j1][i] - lhsmY[1][k][j1][i]*lhsmY[3][k][j][i];
        lhsmY[3][k][j1][i]   = lhsmY[3][k][j1][i] - lhsmY[1][k][j1][i]*lhsmY[4][k][j][i];
        rhs[m][k][j1][i] = rhs[m][k][j1][i] - lhsmY[1][k][j1][i]*rhs[m][k][j][i];
        lhsmY[1][k][j2][i]   = lhsmY[1][k][j2][i] - lhsmY[0][k][j2][i]*lhsmY[3][k][j][i];
        lhsmY[2][k][j2][i]   = lhsmY[2][k][j2][i] - lhsmY[0][k][j2][i]*lhsmY[4][k][j][i];
        rhs[m][k][j2][i] = rhs[m][k][j2][i] - lhsmY[0][k][j2][i]*rhs[m][k][j][i];
      }
    }
  }

    //---------------------------------------------------------------------
    // And again the last two rows separately
    //---------------------------------------------------------------------
  j  = gp1-2;
  j1 = gp1-1;
  #pragma acc parallel loop gang num_gangs(gp2-2) num_workers(8) vector_length(32)
  for (k = 1; k <= gp2-2; k++) {
    #pragma acc loop worker vector
    for (i = 1; i <= gp0-2; i++) {
      m = 3;
      fac1 = 1.0/lhspY[2][k][j][i];
      lhspY[3][k][j][i]    = fac1*lhspY[3][k][j][i];
      lhspY[4][k][j][i]    = fac1*lhspY[4][k][j][i];
      rhs[m][k][j][i]  = fac1*rhs[m][k][j][i];
      lhspY[2][k][j1][i]   = lhspY[2][k][j1][i] - lhspY[1][k][j1][i]*lhspY[3][k][j][i];
      lhspY[3][k][j1][i]   = lhspY[3][k][j1][i] - lhspY[1][k][j1][i]*lhspY[4][k][j][i];
      rhs[m][k][j1][i] = rhs[m][k][j1][i] - lhspY[1][k][j1][i]*rhs[m][k][j][i];

      m = 4;
      fac1 = 1.0/lhsmY[2][k][j][i];
      lhsmY[3][k][j][i]    = fac1*lhsmY[3][k][j][i];
      lhsmY[4][k][j][i]    = fac1*lhsmY[4][k][j][i];
      rhs[m][k][j][i]  = fac1*rhs[m][k][j][i];
      lhsmY[2][k][j1][i]   = lhsmY[2][k][j1][i] - lhsmY[1][k][j1][i]*lhsmY[3][k][j][i];
      lhsmY[3][k][j1][i]   = lhsmY[3][k][j1][i] - lhsmY[1][k][j1][i]*lhsmY[4][k][j][i];
      rhs[m][k][j1][i] = rhs[m][k][j1][i] - lhsmY[1][k][j1][i]*rhs[m][k][j][i];

      //---------------------------------------------------------------------
      // Scale the last row immediately 
      //---------------------------------------------------------------------
      rhs[3][k][j1][i]   = rhs[3][k][j1][i]/lhspY[2][k][j1][i];
      rhs[4][k][j1][i]   = rhs[4][k][j1][i]/lhsmY[2][k][j1][i];
    }
  }


    //---------------------------------------------------------------------
    // BACKSUBSTITUTION 
    //---------------------------------------------------------------------
  j  = gp1-2;
  j1 = gp1-1;
  #pragma acc parallel loop gang num_gangs(gp2-2) num_workers(8) vector_length(32)
  for (k = 1; k <= gp2-2; k++) {
    #pragma acc loop worker vector
    for (i = 1; i <= gp0-2; i++) {
      for (m = 0; m < 3; m++) {
        rhs[m][k][j][i] = rhs[m][k][j][i] - lhsY[3][k][j][i]*rhs[m][k][j1][i];
      }

      rhs[3][k][j][i] = rhs[3][k][j][i] - lhspY[3][k][j][i]*rhs[3][k][j1][i];
      rhs[4][k][j][i] = rhs[4][k][j][i] - lhsmY[3][k][j][i]*rhs[4][k][j1][i];
    }
  }

    //---------------------------------------------------------------------
    // The first three factors
    //---------------------------------------------------------------------
  #pragma acc parallel loop gang num_gangs(gp2-2) num_workers(8) vector_length(32)
  for (k = 1; k <= gp2-2; k++) {
    #pragma acc loop worker vector
    for (i = 1; i <= gp0-2; i++) {
      for (j = gp1-3; j >= 0; j--) {
	j1 = j + 1;
	j2 = j + 2;
        /*
        for (m = 0; m < 3; m++) {
          rhs[m][k][j][i] = rhs[m][k][j][i] - 
                            lhsY[3][k][j][i]*rhs[m][k][j1][i] -
                            lhsY[4][k][j][i]*rhs[m][k][j2][i];
        }
        */
          rhs[0][k][j][i] = rhs[0][k][j][i] - 
                            lhsY[3][k][j][i]*rhs[0][k][j1][i] -
                            lhsY[4][k][j][i]*rhs[0][k][j2][i];
          rhs[1][k][j][i] = rhs[1][k][j][i] - 
                            lhsY[3][k][j][i]*rhs[1][k][j1][i] -
                            lhsY[4][k][j][i]*rhs[1][k][j2][i];
          rhs[2][k][j][i] = rhs[2][k][j][i] - 
                            lhsY[3][k][j][i]*rhs[2][k][j1][i] -
                            lhsY[4][k][j][i]*rhs[2][k][j2][i];
        //-------------------------------------------------------------------
        // And the remaining two
        //-------------------------------------------------------------------
        rhs[3][k][j][i] = rhs[3][k][j][i] - 
                          lhspY[3][k][j][i]*rhs[3][k][j1][i] -
                          lhspY[4][k][j][i]*rhs[3][k][j2][i];
        rhs[4][k][j][i] = rhs[4][k][j][i] - 
                          lhsmY[3][k][j][i]*rhs[4][k][j1][i] -
                          lhsmY[4][k][j][i]*rhs[4][k][j2][i];
      }
    }
  }

  
  pinvr();
}/* end acc data */
}

void z_solve()
{
  int i, j, k, k1, k2, m;
  int gp21,gp22,gp23;
  double ru1, fac1, fac2;
  double lhsZ[5][ny2+1][IMAXP+1][IMAXP+1];
  double lhspZ[5][ny2+1][IMAXP+1][IMAXP+1];
  double lhsmZ[5][ny2+1][IMAXP+1][IMAXP+1];
  double rhosZ[ny2+1][IMAXP+1][PROBLEM_SIZE];

  int ni=nz2+1;
  gp21=grid_points[2]-1;
  gp22=grid_points[2]-2;
  gp23=grid_points[2]-3;
  
#pragma acc data present(rho_i,ws,speed,rhs) create(lhsZ,lhspZ,lhsmZ,rhosZ)
{
 #pragma acc parallel loop gang num_gangs(ny2) num_workers(8) vector_length(32)
  for (j = 1; j <= ny2; j++) {
    #pragma acc loop worker vector
    for (i = 1; i <= nx2; i++) {
      for (m = 0; m < 5; m++) {
        lhsZ[m][j][0][i] = 0.0;
        lhspZ[m][j][0][i] = 0.0;
        lhsmZ[m][j][0][i] = 0.0;
        lhsZ[m][j][ni][i] = 0.0;
        lhspZ[m][j][ni][i] = 0.0;
        lhsmZ[m][j][ni][i] = 0.0;
      }
      lhsZ[2][j][0][i] = 1.0;
      lhspZ[2][j][0][i] = 1.0;
      lhsmZ[2][j][0][i] = 1.0;
      lhsZ[2][j][ni][i] = 1.0;
      lhspZ[2][j][ni][i] = 1.0;
      lhsmZ[2][j][ni][i] = 1.0;
    }
  }

    //---------------------------------------------------------------------
    // Computes the left hand side for the three z-factors   
    //---------------------------------------------------------------------

    //---------------------------------------------------------------------
    // first fill the lhs for the u-eigenvalue                          
    //---------------------------------------------------------------------
 #pragma acc parallel loop gang num_gangs(ny2) num_workers(8) vector_length(32)
  for (j = 1; j <= ny2; j++) {
    #pragma acc loop worker
    for (i = 1; i <= nx2; i++) {
    #pragma acc loop vector
      for (k = 0; k <= nz2+1; k++) {
        ru1 = c3c4*rho_i[k][j][i];
     //   cv[k] = ws[k][j][i];
        rhosZ[j][i][k] = max(max(dz4+con43*ru1, dz5+c1c5*ru1), max(dzmax+ru1, dz1));
      }
    }
  }

 #pragma acc parallel loop gang num_gangs(ny2) num_workers(8) vector_length(32)
  for (j = 1; j <= ny2; j++) {
    #pragma acc loop worker
    for (i = 1; i <= nx2; i++) {
    #pragma acc loop vector
      for (k = 1; k <= nz2; k++) {
        lhsZ[0][j][k][i] =  0.0;
      //  lhs[k][i][1] = -dttz2 * cv[k-1] - dttz1 * rhos[k-1];
        lhsZ[1][j][k][i] = -dttz2 * ws[k-1][j][i] - dttz1 * rhosZ[j][i][k-1];
        lhsZ[2][j][k][i] =  1.0 + c2dttz1 * rhosZ[j][i][k];
      //  lhs[k][i][3] =  dttz2 * cv[k+1] - dttz1 * rhos[k+1];
        lhsZ[3][j][k][i] =  dttz2 * ws[k+1][j][i] - dttz1 * rhosZ[j][i][k+1];
        lhsZ[4][j][k][i] =  0.0;
      }
    }
  }

    //---------------------------------------------------------------------
    // add fourth order dissipation                                  
    //---------------------------------------------------------------------
 #pragma acc parallel loop gang num_gangs(ny2) num_workers(8) vector_length(32)
  for (j = 1; j <= ny2; j++) {
    #pragma acc loop worker vector
    for (i = 1; i <= nx2; i++) {
      k = 1;
      lhsZ[2][j][k][i] = lhsZ[2][j][k][i] + comz5;
      lhsZ[3][j][k][i] = lhsZ[3][j][k][i] - comz4;
      lhsZ[4][j][k][i] = lhsZ[4][j][k][i] + comz1;

      k = 2;
      lhsZ[1][j][k][i] = lhsZ[1][j][k][i] - comz4;
      lhsZ[2][j][k][i] = lhsZ[2][j][k][i] + comz6;
      lhsZ[3][j][k][i] = lhsZ[3][j][k][i] - comz4;
      lhsZ[4][j][k][i] = lhsZ[4][j][k][i] + comz1;
    }
  }

 #pragma acc parallel loop gang num_gangs(ny2) num_workers(8) vector_length(32)
  for (j = 1; j <= ny2; j++) {
    #pragma acc loop worker
    for (k = 3; k <= nz2-2; k++) {
    #pragma acc loop vector
      for (i = 1; i <= nx2; i++) {
        lhsZ[0][j][k][i] = lhsZ[0][j][k][i] + comz1;
        lhsZ[1][j][k][i] = lhsZ[1][j][k][i] - comz4;
        lhsZ[2][j][k][i] = lhsZ[2][j][k][i] + comz6;
        lhsZ[3][j][k][i] = lhsZ[3][j][k][i] - comz4;
        lhsZ[4][j][k][i] = lhsZ[4][j][k][i] + comz1;
      }
    }
  }

 #pragma acc parallel loop gang num_gangs(ny2) num_workers(8) vector_length(32)
  for (j = 1; j <= ny2; j++) {
    #pragma acc loop worker vector
    for (i = 1; i <= nx2; i++) {
      k = nz2-1;
      lhsZ[0][j][k][i] = lhsZ[0][j][k][i] + comz1;
      lhsZ[1][j][k][i] = lhsZ[1][j][k][i] - comz4;
      lhsZ[2][j][k][i] = lhsZ[2][j][k][i] + comz6;
      lhsZ[3][j][k][i] = lhsZ[3][j][k][i] - comz4;

      k = nz2;
      lhsZ[0][j][k][i] = lhsZ[0][j][k][i] + comz1;
      lhsZ[1][j][k][i] = lhsZ[1][j][k][i] - comz4;
      lhsZ[2][j][k][i] = lhsZ[2][j][k][i] + comz5;
    }
  }

    //---------------------------------------------------------------------
    // subsequently, fill the other factors (u+c), (u-c) 
    //---------------------------------------------------------------------
 #pragma acc parallel loop gang num_gangs(ny2) num_workers(8) vector_length(32)
  for (j = 1; j <= ny2; j++) {
    #pragma acc loop worker
    for (k = 1; k <= nz2; k++) {
    #pragma acc loop vector
      for (i = 1; i <= nx2; i++) {
        lhspZ[0][j][k][i] = lhsZ[0][j][k][i];
        lhspZ[1][j][k][i] = lhsZ[1][j][k][i] - dttz2 * speed[k-1][j][i];
        lhspZ[2][j][k][i] = lhsZ[2][j][k][i];
        lhspZ[3][j][k][i] = lhsZ[3][j][k][i] + dttz2 * speed[k+1][j][i];
        lhspZ[4][j][k][i] = lhsZ[4][j][k][i];
        lhsmZ[0][j][k][i] = lhsZ[0][j][k][i];
        lhsmZ[1][j][k][i] = lhsZ[1][j][k][i] + dttz2 * speed[k-1][j][i];
        lhsmZ[2][j][k][i] = lhsZ[2][j][k][i];
        lhsmZ[3][j][k][i] = lhsZ[3][j][k][i] - dttz2 * speed[k+1][j][i];
        lhsmZ[4][j][k][i] = lhsZ[4][j][k][i];
      }
    }
  }


    //---------------------------------------------------------------------
    // FORWARD ELIMINATION  
    //---------------------------------------------------------------------
 #pragma acc parallel loop gang num_gangs(ny2) num_workers(8) vector_length(32)
  for (j = 1; j <= ny2; j++) {
    #pragma acc loop worker vector
    for (i = 1; i <= nx2; i++) {
      for (k = 0; k <= gp23; k++) {
	k1 = k + 1;
	k2 = k + 2;
        fac1 = 1.0/lhsZ[2][j][k][i];
        lhsZ[3][j][k][i] = fac1*lhsZ[3][j][k][i];
        lhsZ[4][j][k][i] = fac1*lhsZ[4][j][k][i];
       /*
        for (m = 0; m < 3; m++) {
          rhs[m][k][j][i] = fac1*rhs[m][k][j][i];
        }
        */
          rhs[0][k][j][i] = fac1*rhs[0][k][j][i];
          rhs[1][k][j][i] = fac1*rhs[1][k][j][i];
          rhs[2][k][j][i] = fac1*rhs[2][k][j][i];
        lhsZ[2][j][k1][i] = lhsZ[2][j][k1][i] - lhsZ[1][j][k1][i]*lhsZ[3][j][k][i];
        lhsZ[3][j][k1][i] = lhsZ[3][j][k1][i] - lhsZ[1][j][k1][i]*lhsZ[4][j][k][i];
        /*
        for (m = 0; m < 3; m++) {
          rhs[m][k1][j][i] = rhs[m][k1][j][i] - lhsZ[1][j][k1][i]*rhs[m][k][j][i];
        }
        */
          rhs[0][k1][j][i] = rhs[0][k1][j][i] - lhsZ[1][j][k1][i]*rhs[0][k][j][i];
          rhs[1][k1][j][i] = rhs[1][k1][j][i] - lhsZ[1][j][k1][i]*rhs[1][k][j][i];
          rhs[2][k1][j][i] = rhs[2][k1][j][i] - lhsZ[1][j][k1][i]*rhs[2][k][j][i];
        lhsZ[1][j][k2][i] = lhsZ[1][j][k2][i] - lhsZ[0][j][k2][i]*lhsZ[3][j][k][i];
        lhsZ[2][j][k2][i] = lhsZ[2][j][k2][i] - lhsZ[0][j][k2][i]*lhsZ[4][j][k][i];
        /*
        for (m = 0; m < 3; m++) {
          rhs[m][k2][j][i] = rhs[m][k2][j][i] - lhsZ[0][j][k2][i]*rhs[m][k][j][i];
        }
        */
          rhs[0][k2][j][i] = rhs[0][k2][j][i] - lhsZ[0][j][k2][i]*rhs[0][k][j][i];
          rhs[1][k2][j][i] = rhs[1][k2][j][i] - lhsZ[0][j][k2][i]*rhs[1][k][j][i];
          rhs[2][k2][j][i] = rhs[2][k2][j][i] - lhsZ[0][j][k2][i]*rhs[2][k][j][i];
      }
    }
  }

    //---------------------------------------------------------------------
    // The last two rows in this grid block are a bit different, 
    // since they for (not have two more rows available for the
    // elimination of off-diagonal entries
    //---------------------------------------------------------------------
    k  = gp22;
    k1 = gp21;
 #pragma acc parallel loop gang num_gangs(ny2) num_workers(8) vector_length(32)
  for (j = 1; j <= ny2; j++) {
    #pragma acc loop worker vector
    for (i = 1; i <= nx2; i++) {
      fac1 = 1.0/lhsZ[2][j][k][i];
      lhsZ[3][j][k][i] = fac1*lhsZ[3][j][k][i];
      lhsZ[4][j][k][i] = fac1*lhsZ[4][j][k][i];
      /*
      for (m = 0; m < 3; m++) {
        rhs[m][k][j][i] = fac1*rhs[m][k][j][i];
      }
      */
        rhs[0][k][j][i] = fac1*rhs[0][k][j][i];
        rhs[1][k][j][i] = fac1*rhs[1][k][j][i];
        rhs[2][k][j][i] = fac1*rhs[2][k][j][i];
      lhsZ[2][j][k1][i] = lhsZ[2][j][k1][i] - lhsZ[1][j][k1][i]*lhsZ[3][j][k][i];
      lhsZ[3][j][k1][i] = lhsZ[3][j][k1][i] - lhsZ[1][j][k1][i]*lhsZ[4][j][k][i];
      /*
      for (m = 0; m < 3; m++) {
        rhs[m][k1][j][i] = rhs[m][k1][j][i] - lhsZ[1][j][k1][i]*rhs[m][k][j][i];
      }
      */
        rhs[0][k1][j][i] = rhs[0][k1][j][i] - lhsZ[1][j][k1][i]*rhs[0][k][j][i];
        rhs[1][k1][j][i] = rhs[1][k1][j][i] - lhsZ[1][j][k1][i]*rhs[1][k][j][i];
        rhs[2][k1][j][i] = rhs[2][k1][j][i] - lhsZ[1][j][k1][i]*rhs[2][k][j][i];
      //---------------------------------------------------------------------
      // scale the last row immediately
      //---------------------------------------------------------------------
      fac2 = 1.0/lhsZ[2][j][k1][i];
      /*
      for (m = 0; m < 3; m++) {
        rhs[m][k1][j][i] = fac2*rhs[m][k1][j][i];
      }
      */
        rhs[0][k1][j][i] = fac2*rhs[0][k1][j][i];
        rhs[1][k1][j][i] = fac2*rhs[1][k1][j][i];
        rhs[2][k1][j][i] = fac2*rhs[2][k1][j][i];
    }
  }

    //---------------------------------------------------------------------
    // for (the u+c and the u-c factors               
    //---------------------------------------------------------------------
#pragma acc parallel loop gang num_gangs(ny2) num_workers(8) vector_length(32)
  for (j = 1; j <= ny2; j++) {
    #pragma acc loop worker vector
    for (i = 1; i <= nx2; i++) {
      for (k = 0; k <= gp23; k++) {
      k1 = k + 1;
      k2 = k + 2;
        m = 3;
        fac1 = 1.0/lhspZ[2][j][k][i];
        lhspZ[3][j][k][i]    = fac1*lhspZ[3][j][k][i];
        lhspZ[4][j][k][i]    = fac1*lhspZ[4][j][k][i];
        rhs[m][k][j][i]  = fac1*rhs[m][k][j][i];
        lhspZ[2][j][k1][i]   = lhspZ[2][j][k1][i] - lhspZ[1][j][k1][i]*lhspZ[3][j][k][i];
        lhspZ[3][j][k1][i]   = lhspZ[3][j][k1][i] - lhspZ[1][j][k1][i]*lhspZ[4][j][k][i];
        rhs[m][k1][j][i] = rhs[m][k1][j][i] - lhspZ[1][j][k1][i]*rhs[m][k][j][i];
        lhspZ[1][j][k2][i]   = lhspZ[1][j][k2][i] - lhspZ[0][j][k2][i]*lhspZ[3][j][k][i];
        lhspZ[2][j][k2][i]   = lhspZ[2][j][k2][i] - lhspZ[0][j][k2][i]*lhspZ[4][j][k][i];
        rhs[m][k2][j][i] = rhs[m][k2][j][i] - lhspZ[0][j][k2][i]*rhs[m][k][j][i];

        m = 4;
        fac1 = 1.0/lhsmZ[2][j][k][i];
        lhsmZ[3][j][k][i]    = fac1*lhsmZ[3][j][k][i];
        lhsmZ[4][j][k][i]    = fac1*lhsmZ[4][j][k][i];
        rhs[m][k][j][i]  = fac1*rhs[m][k][j][i];
        lhsmZ[2][j][k1][i]   = lhsmZ[2][j][k1][i] - lhsmZ[1][j][k1][i]*lhsmZ[3][j][k][i];
        lhsmZ[3][j][k1][i]   = lhsmZ[3][j][k1][i] - lhsmZ[1][j][k1][i]*lhsmZ[4][j][k][i];
        rhs[m][k1][j][i] = rhs[m][k1][j][i] - lhsmZ[1][j][k1][i]*rhs[m][k][j][i];
        lhsmZ[1][j][k2][i]   = lhsmZ[1][j][k2][i] - lhsmZ[0][j][k2][i]*lhsmZ[3][j][k][i];
        lhsmZ[2][j][k2][i]   = lhsmZ[2][j][k2][i] - lhsmZ[0][j][k2][i]*lhsmZ[4][j][k][i];
        rhs[m][k2][j][i] = rhs[m][k2][j][i] - lhsmZ[0][j][k2][i]*rhs[m][k][j][i];
      }
    }
  }

    //---------------------------------------------------------------------
    // And again the last two rows separately
    //---------------------------------------------------------------------
    k  = gp22;
    k1 = gp21;
 #pragma acc parallel loop gang num_gangs(ny2) num_workers(8) vector_length(32)
  for (j = 1; j <= ny2; j++) {
    #pragma acc loop worker vector
    for (i = 1; i <= nx2; i++) {
      m = 3;
      fac1 = 1.0/lhspZ[2][j][k][i];
      lhspZ[3][j][k][i]    = fac1*lhspZ[3][j][k][i];
      lhspZ[4][j][k][i]    = fac1*lhspZ[4][j][k][i];
      rhs[m][k][j][i]  = fac1*rhs[m][k][j][i];
      lhspZ[2][j][k1][i]   = lhspZ[2][j][k1][i] - lhspZ[1][j][k1][i]*lhspZ[3][j][k][i];
      lhspZ[3][j][k1][i]   = lhspZ[3][j][k1][i] - lhspZ[1][j][k1][i]*lhspZ[4][j][k][i];
      rhs[m][k1][j][i] = rhs[m][k1][j][i] - lhspZ[1][j][k1][i]*rhs[m][k][j][i];

      m = 4;
      fac1 = 1.0/lhsmZ[2][j][k][i];
      lhsmZ[3][j][k][i]    = fac1*lhsmZ[3][j][k][i];
      lhsmZ[4][j][k][i]    = fac1*lhsmZ[4][j][k][i];
      rhs[m][k][j][i]  = fac1*rhs[m][k][j][i];
      lhsmZ[2][j][k1][i]   = lhsmZ[2][j][k1][i] - lhsmZ[1][j][k1][i]*lhsmZ[3][j][k][i];
      lhsmZ[3][j][k1][i]   = lhsmZ[3][j][k1][i] - lhsmZ[1][j][k1][i]*lhsmZ[4][j][k][i];
      rhs[m][k1][j][i] = rhs[m][k1][j][i] - lhsmZ[1][j][k1][i]*rhs[m][k][j][i];

      //---------------------------------------------------------------------
      // Scale the last row immediately (some of this is overkill
      // if this is the last cell)
      //---------------------------------------------------------------------
      rhs[3][k1][j][i] = rhs[3][k1][j][i]/lhspZ[2][j][k1][i];
      rhs[4][k1][j][i] = rhs[4][k1][j][i]/lhsmZ[2][j][k1][i];
    }
  }


    //---------------------------------------------------------------------
    // BACKSUBSTITUTION 
    //---------------------------------------------------------------------
    k  = gp22;
    k1 = gp21;
 #pragma acc parallel loop gang num_gangs(ny2) num_workers(8) vector_length(32)
  for (j = 1; j <= ny2; j++) {
    #pragma acc loop worker vector
    for (i = 1; i <= nx2; i++) {
     /*
      for (m = 0; m < 3; m++) {
        rhs[m][k][j][i] = rhs[m][k][j][i] - lhsZ[3][j][k][i]*rhs[m][k1][j][i];
      }
      */
        rhs[0][k][j][i] = rhs[0][k][j][i] - lhsZ[3][j][k][i]*rhs[0][k1][j][i];
        rhs[1][k][j][i] = rhs[1][k][j][i] - lhsZ[3][j][k][i]*rhs[1][k1][j][i];
        rhs[2][k][j][i] = rhs[2][k][j][i] - lhsZ[3][j][k][i]*rhs[2][k1][j][i];
      rhs[3][k][j][i] = rhs[3][k][j][i] - lhspZ[3][j][k][i]*rhs[3][k1][j][i];
      rhs[4][k][j][i] = rhs[4][k][j][i] - lhsmZ[3][j][k][i]*rhs[4][k1][j][i];
    }
  }

    //---------------------------------------------------------------------
    // Whether or not this is the last processor, we always have
    // to complete the back-substitution 
    //---------------------------------------------------------------------

    //---------------------------------------------------------------------
    // The first three factors
    //---------------------------------------------------------------------
#pragma acc parallel loop gang num_gangs(ny2) num_workers(8) vector_length(32)
  for (j = 1; j <= ny2; j++) {
    #pragma acc loop worker vector
    for (i = 1; i <= nx2; i++) {
      for (k = gp23; k >= 0; k--) {
	k1 = k + 1;
	k2 = k + 2;
       /*
        for (m = 0; m < 3; m++) {
          rhs[m][k][j][i] = rhs[m][k][j][i] - 
                            lhsZ[3][j][k][i]*rhs[m][k1][j][i] -
                            lhsZ[4][j][k][i]*rhs[m][k2][j][i];
        }
        */
          rhs[0][k][j][i] = rhs[0][k][j][i] - 
                            lhsZ[3][j][k][i]*rhs[0][k1][j][i] -
                            lhsZ[4][j][k][i]*rhs[0][k2][j][i];
          rhs[1][k][j][i] = rhs[1][k][j][i] - 
                            lhsZ[3][j][k][i]*rhs[1][k1][j][i] -
                            lhsZ[4][j][k][i]*rhs[1][k2][j][i];
          rhs[2][k][j][i] = rhs[2][k][j][i] - 
                            lhsZ[3][j][k][i]*rhs[2][k1][j][i] -
                            lhsZ[4][j][k][i]*rhs[2][k2][j][i];
        //-------------------------------------------------------------------
        // And the remaining two
        //-------------------------------------------------------------------
        rhs[3][k][j][i] = rhs[3][k][j][i] - 
                          lhspZ[3][j][k][i]*rhs[3][k1][j][i] -
                          lhspZ[4][j][k][i]*rhs[3][k2][j][i];
        rhs[4][k][j][i] = rhs[4][k][j][i] - 
                          lhsmZ[3][j][k][i]*rhs[4][k1][j][i] -
                          lhsmZ[4][j][k][i]*rhs[4][k2][j][i];
      }
    }
  }

  
  tzetar();
}/* end acc data */
}

########## NEXT FILE ##########
error.c:::
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB SP code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS SP code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

#include "header.h"
#include <math.h>

//---------------------------------------------------------------------
// this function computes the norm of the difference between the
// computed solution and the exact solution
//---------------------------------------------------------------------
void error_norm(double rms[5])
{
  int i, j, k, m, d;
  double xi, eta, zeta, u_exact[5], add;

  for (m = 0; m < 5; m++) {
    rms[m] = 0.0;
  }

  for (k = 0; k <= grid_points[2]-1; k++) {
    zeta = (double)k * dnzm1;
    for (j = 0; j <= grid_points[1]-1; j++) {
      eta = (double)j * dnym1;
      for (i = 0; i <= grid_points[0]-1; i++) {
        xi = (double)i * dnxm1;
        exact_solution(xi, eta, zeta, u_exact);

        for (m = 0; m < 5; m++) {
          add = u[m][k][j][i]-u_exact[m];
          rms[m] = rms[m] + add*add;
        }
      }
    }
  }

  for (m = 0; m < 5; m++) {
    for (d = 0; d < 3; d++) {
      rms[m] = rms[m] / (double)(grid_points[d]-2);
    }
    rms[m] = sqrt(rms[m]);
  }
}


void rhs_norm(double rms[5])
{
  int i, j, k, d, m;
  double add;
  double rms0, rms1,rms2,rms3,rms4;

  rms0=0.0;
  rms1=0.0;
  rms2=0.0;
  rms3=0.0;
  rms4=0.0;
 
  #pragma acc update host(rhs)
//#pragma acc kernels loop present(rhs)
  for (k = 1; k <= nz2; k++) {
    for (j = 1; j <= ny2; j++) {
      for (i = 1; i <= nx2; i++) {
	add = rhs[0][k][j][i];
	rms0 = rms0 + add*add;
	add = rhs[1][k][j][i];
	rms1 = rms1 + add*add;
	add = rhs[2][k][j][i];
	rms2 = rms2 + add*add;
	add = rhs[3][k][j][i];
	rms3 = rms3 + add*add;
	add = rhs[4][k][j][i];
	rms4 = rms4 + add*add;
      } 
    } 
  }

  rms[0]=rms0;
  rms[1]=rms1;
  rms[2]=rms2;
  rms[3]=rms3;
  rms[4]=rms4;
  for (m = 0; m < 5; m++) {
    for (d = 0; d < 3; d++) {
      rms[m] = rms[m] / (double)(grid_points[d]-2);
    }
    rms[m] = sqrt(rms[m]);
  }

  

}


########## NEXT FILE ##########
rhs.c:::
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB SP code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS SP code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

#include <math.h>
#include "header.h"

void compute_rhs()
{
  int i, j, k, m;
  double aux, rho_inv, uijk, up1, um1, vijk, vp1, vm1, wijk, wp1, wm1;
  int gp0, gp1, gp2;

  gp0 = grid_points[0];
  gp1 = grid_points[1];
  gp2 = grid_points[2];

  //---------------------------------------------------------------------
  // compute the reciprocal of density, and the kinetic energy, 
  // and the speed of sound. 
  //---------------------------------------------------------------------
#pragma acc data present(rho_i,u,qs,square,speed,rhs,forcing,us,vs,ws) 
{
/*get the value of rho_i,qs,square,us,vs,ws,speed*/
#pragma acc parallel loop gang num_gangs(gp2) num_workers(8) vector_length(32)
  for (k = 0; k <= gp2-1; k++) {
#pragma acc loop worker
    for (j = 0; j <= gp1-1; j++) {
#pragma acc loop vector
      for (i = 0; i <= gp0-1; i++) {
        rho_inv = 1.0/u[0][k][j][i];
        rho_i[k][j][i] = rho_inv;
        us[k][j][i] = u[1][k][j][i] * rho_inv;
        vs[k][j][i] = u[2][k][j][i] * rho_inv;
        ws[k][j][i] = u[3][k][j][i] * rho_inv;
        square[k][j][i] = 0.5* (
            u[1][k][j][i]*u[1][k][j][i] + 
            u[2][k][j][i]*u[2][k][j][i] +
            u[3][k][j][i]*u[3][k][j][i] ) * rho_inv;
        qs[k][j][i] = square[k][j][i] * rho_inv;
        //-------------------------------------------------------------------
        // (don't need speed and ainx until the lhs computation)
        //-------------------------------------------------------------------
        aux = c1c2*rho_inv* (u[4][k][j][i] - square[k][j][i]);
        speed[k][j][i] = sqrt(aux);
      }
    }
  }


  //---------------------------------------------------------------------
  // copy the exact forcing term to the right hand side;  because 
  // this forcing term is known, we can store it on the whole grid
  // including the boundary                   
  //---------------------------------------------------------------------
#pragma acc parallel loop gang num_gangs(gp2) num_workers(8) vector_length(32)
  for (k = 0; k <= gp2-1; k++) {
#pragma acc loop worker
    for (j = 0; j <= gp1-1; j++) {
#pragma acc loop vector
      for (i = 0; i <= gp0-1; i++) {
        for (m = 0; m < 5; m++) {
          rhs[m][k][j][i] = forcing[m][k][j][i];
        }
      }
    }
  }

  //---------------------------------------------------------------------
  // compute xi-direction fluxes 
  //---------------------------------------------------------------------
#pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= nz2; k++) {
#pragma acc loop worker
    for (j = 1; j <= ny2; j++) {
#pragma acc loop vector
      for (i = 1; i <= nx2; i++) {
        uijk = us[k][j][i];
        up1  = us[k][j][i+1];
        um1  = us[k][j][i-1];

        rhs[0][k][j][i] = rhs[0][k][j][i] + dx1tx1 * 
          (u[0][k][j][i+1] - 2.0*u[0][k][j][i] + u[0][k][j][i-1]) -
          tx2 * (u[1][k][j][i+1] - u[1][k][j][i-1]);

        rhs[1][k][j][i] = rhs[1][k][j][i] + dx2tx1 * 
          (u[1][k][j][i+1] - 2.0*u[1][k][j][i] + u[1][k][j][i-1]) +
          xxcon2*con43 * (up1 - 2.0*uijk + um1) -
          tx2 * (u[1][k][j][i+1]*up1 - u[1][k][j][i-1]*um1 +
                (u[4][k][j][i+1] - square[k][j][i+1] -
                 u[4][k][j][i-1] + square[k][j][i-1]) * c2);

        rhs[2][k][j][i] = rhs[2][k][j][i] + dx3tx1 * 
          (u[2][k][j][i+1] - 2.0*u[2][k][j][i] + u[2][k][j][i-1]) +
          xxcon2 * (vs[k][j][i+1] - 2.0*vs[k][j][i] + vs[k][j][i-1]) -
          tx2 * (u[2][k][j][i+1]*up1 - u[2][k][j][i-1]*um1);

        rhs[3][k][j][i] = rhs[3][k][j][i] + dx4tx1 * 
          (u[3][k][j][i+1] - 2.0*u[3][k][j][i] + u[3][k][j][i-1]) +
          xxcon2 * (ws[k][j][i+1] - 2.0*ws[k][j][i] + ws[k][j][i-1]) -
          tx2 * (u[3][k][j][i+1]*up1 - u[3][k][j][i-1]*um1);

        rhs[4][k][j][i] = rhs[4][k][j][i] + dx5tx1 * 
          (u[4][k][j][i+1] - 2.0*u[4][k][j][i] + u[4][k][j][i-1]) +
          xxcon3 * (qs[k][j][i+1] - 2.0*qs[k][j][i] + qs[k][j][i-1]) +
          xxcon4 * (up1*up1 -       2.0*uijk*uijk + um1*um1) +
          xxcon5 * (u[4][k][j][i+1]*rho_i[k][j][i+1] - 
                2.0*u[4][k][j][i]*rho_i[k][j][i] +
                    u[4][k][j][i-1]*rho_i[k][j][i-1]) -
          tx2 * ( (c1*u[4][k][j][i+1] - c2*square[k][j][i+1])*up1 -
                  (c1*u[4][k][j][i-1] - c2*square[k][j][i-1])*um1 );
      }
    }

  } /*end k*/
  
    //---------------------------------------------------------------------
    // add fourth order xi-direction dissipation               
    //---------------------------------------------------------------------
  i = 1;
#pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= nz2; k++){
#pragma acc loop worker vector
    for (j = 1; j <= ny2; j++) {
      for (m = 0; m < 5; m++) {
        rhs[m][k][j][i] = rhs[m][k][j][i]- dssp * 
          (5.0*u[m][k][j][i] - 4.0*u[m][k][j][i+1] + u[m][k][j][i+2]);
      }
    }
  }
      
  i = 2;
#pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= nz2; k++){
#pragma acc loop worker vector
    for (j = 1; j <= ny2; j++) {
      for (m = 0; m < 5; m++) {
        rhs[m][k][j][i] = rhs[m][k][j][i] - dssp * 
          (-4.0*u[m][k][j][i-1] + 6.0*u[m][k][j][i] -
            4.0*u[m][k][j][i+1] + u[m][k][j][i+2]);
      }
    }
  }
    
#pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= nz2; k++){
#pragma acc loop worker
	for (j = 1; j <= ny2; j++) {
#pragma acc loop vector
      for (i = 3; i <= nx2-2; i++) {
        for (m = 0; m < 5; m++) {
          rhs[m][k][j][i] = rhs[m][k][j][i] - dssp * 
            ( u[m][k][j][i-2] - 4.0*u[m][k][j][i-1] + 
            6.0*u[m][k][j][i] - 4.0*u[m][k][j][i+1] + 
              u[m][k][j][i+2] );
        }
      }
    }
  }
    
 i = nx2-1;
#pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= nz2; k++){
#pragma acc loop worker vector
	for (j = 1; j <= ny2; j++) {
      for (m = 0; m < 5; m++) {
        rhs[m][k][j][i] = rhs[m][k][j][i] - dssp *
          ( u[m][k][j][i-2] - 4.0*u[m][k][j][i-1] + 
          6.0*u[m][k][j][i] - 4.0*u[m][k][j][i+1] );
      }
	}
  }
      
  i = nx2;
#pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= nz2; k++){
#pragma acc loop worker vector
	for (j = 1; j <= ny2; j++) {
      for (m = 0; m < 5; m++) {
        rhs[m][k][j][i] = rhs[m][k][j][i] - dssp *
          ( u[m][k][j][i-2] - 4.0*u[m][k][j][i-1] + 5.0*u[m][k][j][i] );
      }
	}
  }

  //---------------------------------------------------------------------
  // compute eta-direction fluxes 
  //---------------------------------------------------------------------

#pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= nz2; k++) {
#pragma acc loop worker
    for (j = 1; j <= ny2; j++) {
#pragma acc loop vector
      for (i = 1; i <= nx2; i++) {
        vijk = vs[k][j][i];
        vp1  = vs[k][j+1][i];
        vm1  = vs[k][j-1][i];

        rhs[0][k][j][i] = rhs[0][k][j][i] + dy1ty1 * 
          (u[0][k][j+1][i] - 2.0*u[0][k][j][i] + u[0][k][j-1][i]) -
          ty2 * (u[2][k][j+1][i] - u[2][k][j-1][i]);

        rhs[1][k][j][i] = rhs[1][k][j][i] + dy2ty1 * 
          (u[1][k][j+1][i] - 2.0*u[1][k][j][i] + u[1][k][j-1][i]) +
          yycon2 * (us[k][j+1][i] - 2.0*us[k][j][i] + us[k][j-1][i]) -
          ty2 * (u[1][k][j+1][i]*vp1 - u[1][k][j-1][i]*vm1);

        rhs[2][k][j][i] = rhs[2][k][j][i] + dy3ty1 * 
          (u[2][k][j+1][i] - 2.0*u[2][k][j][i] + u[2][k][j-1][i]) +
          yycon2*con43 * (vp1 - 2.0*vijk + vm1) -
          ty2 * (u[2][k][j+1][i]*vp1 - u[2][k][j-1][i]*vm1 +
                (u[4][k][j+1][i] - square[k][j+1][i] - 
                 u[4][k][j-1][i] + square[k][j-1][i]) * c2);

        rhs[3][k][j][i] = rhs[3][k][j][i] + dy4ty1 * 
          (u[3][k][j+1][i] - 2.0*u[3][k][j][i] + u[3][k][j-1][i]) +
          yycon2 * (ws[k][j+1][i] - 2.0*ws[k][j][i] + ws[k][j-1][i]) -
          ty2 * (u[3][k][j+1][i]*vp1 - u[3][k][j-1][i]*vm1);

        rhs[4][k][j][i] = rhs[4][k][j][i] + dy5ty1 * 
          (u[4][k][j+1][i] - 2.0*u[4][k][j][i] + u[4][k][j-1][i]) +
          yycon3 * (qs[k][j+1][i] - 2.0*qs[k][j][i] + qs[k][j-1][i]) +
          yycon4 * (vp1*vp1       - 2.0*vijk*vijk + vm1*vm1) +
          yycon5 * (u[4][k][j+1][i]*rho_i[k][j+1][i] - 
                  2.0*u[4][k][j][i]*rho_i[k][j][i] +
                    u[4][k][j-1][i]*rho_i[k][j-1][i]) -
          ty2 * ((c1*u[4][k][j+1][i] - c2*square[k][j+1][i]) * vp1 -
                 (c1*u[4][k][j-1][i] - c2*square[k][j-1][i]) * vm1);
      }
    }

  }
    
	//---------------------------------------------------------------------
    // add fourth order eta-direction dissipation         
    //---------------------------------------------------------------------
  j = 1;
#pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= nz2; k++) {
#pragma acc loop worker vector
    for (i = 1; i <= nx2; i++) {
      for (m = 0; m < 5; m++) {
        rhs[m][k][j][i] = rhs[m][k][j][i]- dssp * 
          ( 5.0*u[m][k][j][i] - 4.0*u[m][k][j+1][i] + u[m][k][j+2][i]);
      }
    }
  }

  j = 2;
#pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= nz2; k++) {
#pragma acc loop worker vector
    for (i = 1; i <= nx2; i++) {
      for (m = 0; m < 5; m++) {
        rhs[m][k][j][i] = rhs[m][k][j][i] - dssp * 
          (-4.0*u[m][k][j-1][i] + 6.0*u[m][k][j][i] -
            4.0*u[m][k][j+1][i] + u[m][k][j+2][i]);
      }
    }
  }
    
#pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= nz2; k++) {
#pragma acc loop worker
	for (j = 3; j <= ny2-2; j++) {
#pragma acc loop vector
      for (i = 1; i <= nx2; i++) {
        for (m = 0; m < 5; m++) {
          rhs[m][k][j][i] = rhs[m][k][j][i] - dssp * 
            ( u[m][k][j-2][i] - 4.0*u[m][k][j-1][i] + 
            6.0*u[m][k][j][i] - 4.0*u[m][k][j+1][i] + 
              u[m][k][j+2][i] );
        }
      }
    }
  }
    
  j = ny2-1;
#pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= nz2; k++) {
#pragma acc loop worker vector
    for (i = 1; i <= nx2; i++) {
      for (m = 0; m < 5; m++) {
        rhs[m][k][j][i] = rhs[m][k][j][i] - dssp *
          ( u[m][k][j-2][i] - 4.0*u[m][k][j-1][i] + 
          6.0*u[m][k][j][i] - 4.0*u[m][k][j+1][i] );
      }
    }
  }
    
  j = ny2;
#pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= nz2; k++) {
#pragma acc loop worker vector
    for (i = 1; i <= nx2; i++) {
      for (m = 0; m < 5; m++) {
        rhs[m][k][j][i] = rhs[m][k][j][i] - dssp *
          ( u[m][k][j-2][i] - 4.0*u[m][k][j-1][i] + 5.0*u[m][k][j][i] );
      }
    }
  }

  //---------------------------------------------------------------------
  // compute zeta-direction fluxes 
  //---------------------------------------------------------------------
#pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= nz2; k++) {
#pragma acc loop worker
    for (j = 1; j <= ny2; j++) {
#pragma acc loop vector
      for (i = 1; i <= nx2; i++) {
        wijk = ws[k][j][i];
        wp1  = ws[k+1][j][i];
        wm1  = ws[k-1][j][i];

        rhs[0][k][j][i] = rhs[0][k][j][i] + dz1tz1 * 
          (u[0][k+1][j][i] - 2.0*u[0][k][j][i] + u[0][k-1][j][i]) -
          tz2 * (u[3][k+1][j][i] - u[3][k-1][j][i]);

        rhs[1][k][j][i] = rhs[1][k][j][i] + dz2tz1 * 
          (u[1][k+1][j][i] - 2.0*u[1][k][j][i] + u[1][k-1][j][i]) +
          zzcon2 * (us[k+1][j][i] - 2.0*us[k][j][i] + us[k-1][j][i]) -
          tz2 * (u[1][k+1][j][i]*wp1 - u[1][k-1][j][i]*wm1);

        rhs[2][k][j][i] = rhs[2][k][j][i] + dz3tz1 * 
          (u[2][k+1][j][i] - 2.0*u[2][k][j][i] + u[2][k-1][j][i]) +
          zzcon2 * (vs[k+1][j][i] - 2.0*vs[k][j][i] + vs[k-1][j][i]) -
          tz2 * (u[2][k+1][j][i]*wp1 - u[2][k-1][j][i]*wm1);

        rhs[3][k][j][i] = rhs[3][k][j][i] + dz4tz1 * 
          (u[3][k+1][j][i] - 2.0*u[3][k][j][i] + u[3][k-1][j][i]) +
          zzcon2*con43 * (wp1 - 2.0*wijk + wm1) -
          tz2 * (u[3][k+1][j][i]*wp1 - u[3][k-1][j][i]*wm1 +
                (u[4][k+1][j][i] - square[k+1][j][i] - 
                 u[4][k-1][j][i] + square[k-1][j][i]) * c2);

        rhs[4][k][j][i] = rhs[4][k][j][i] + dz5tz1 * 
          (u[4][k+1][j][i] - 2.0*u[4][k][j][i] + u[4][k-1][j][i]) +
          zzcon3 * (qs[k+1][j][i] - 2.0*qs[k][j][i] + qs[k-1][j][i]) +
          zzcon4 * (wp1*wp1 - 2.0*wijk*wijk + wm1*wm1) +
          zzcon5 * (u[4][k+1][j][i]*rho_i[k+1][j][i] - 
                  2.0*u[4][k][j][i]*rho_i[k][j][i] +
                    u[4][k-1][j][i]*rho_i[k-1][j][i]) -
          tz2 * ((c1*u[4][k+1][j][i] - c2*square[k+1][j][i])*wp1 -
                 (c1*u[4][k-1][j][i] - c2*square[k-1][j][i])*wm1);
      }
    }
  }

  //---------------------------------------------------------------------
  // add fourth order zeta-direction dissipation                
  //---------------------------------------------------------------------
  k = 1;
  #pragma acc parallel loop gang num_gangs(ny2) num_workers(8) vector_length(32)
  for (j = 1; j <= ny2; j++) {
    #pragma acc loop worker vector
    for (i = 1; i <= nx2; i++) {
      for (m = 0; m < 5; m++) {
        rhs[m][k][j][i] = rhs[m][k][j][i]- dssp * 
          (5.0*u[m][k][j][i] - 4.0*u[m][k+1][j][i] + u[m][k+2][j][i]);
      }
    }
  }

  k = 2;
#pragma acc parallel loop gang num_gangs(ny2) num_workers(8) vector_length(32)
  for (j = 1; j <= ny2; j++) {
#pragma acc loop worker vector
    for (i = 1; i <= nx2; i++) {
      for (m = 0; m < 5; m++) {
        rhs[m][k][j][i] = rhs[m][k][j][i] - dssp * 
          (-4.0*u[m][k-1][j][i] + 6.0*u[m][k][j][i] -
            4.0*u[m][k+1][j][i] + u[m][k+2][j][i]);
      }
    }
  }

#pragma acc parallel loop gang num_gangs(nz2-4) num_workers(8) vector_length(32)
  for (k = 3; k <= nz2-2; k++) {
#pragma acc loop worker
    for (j = 1; j <= ny2; j++) {
#pragma acc loop vector
      for (i = 1; i <= nx2; i++) {
        for (m = 0; m < 5; m++) {
          rhs[m][k][j][i] = rhs[m][k][j][i] - dssp * 
            ( u[m][k-2][j][i] - 4.0*u[m][k-1][j][i] + 
            6.0*u[m][k][j][i] - 4.0*u[m][k+1][j][i] + 
              u[m][k+2][j][i] );
        }
      }
    }
  }

  k = nz2-1;
#pragma acc parallel loop gang num_gangs(ny2) num_workers(8) vector_length(32)
  for (j = 1; j <= ny2; j++) {
#pragma acc loop worker vector
    for (i = 1; i <= nx2; i++) {
     /*
      for (m = 0; m < 5; m++) {
        rhs[m][k][j][i] = rhs[m][k][j][i] - dssp *
          ( u[m][k-2][j][i] - 4.0*u[m][k-1][j][i] + 
          6.0*u[m][k][j][i] - 4.0*u[m][k+1][j][i] );
      }
     */
        rhs[0][k][j][i] = rhs[0][k][j][i] - dssp *
          ( u[0][k-2][j][i] - 4.0*u[0][k-1][j][i] + 
          6.0*u[0][k][j][i] - 4.0*u[0][k+1][j][i] );
        rhs[1][k][j][i] = rhs[1][k][j][i] - dssp *
          ( u[1][k-2][j][i] - 4.0*u[1][k-1][j][i] + 
          6.0*u[1][k][j][i] - 4.0*u[1][k+1][j][i] );
        rhs[2][k][j][i] = rhs[2][k][j][i] - dssp *
          ( u[2][k-2][j][i] - 4.0*u[2][k-1][j][i] + 
          6.0*u[2][k][j][i] - 4.0*u[2][k+1][j][i] );
        rhs[3][k][j][i] = rhs[3][k][j][i] - dssp *
          ( u[3][k-2][j][i] - 4.0*u[3][k-1][j][i] + 
          6.0*u[3][k][j][i] - 4.0*u[3][k+1][j][i] );
        rhs[4][k][j][i] = rhs[4][k][j][i] - dssp *
          ( u[4][k-2][j][i] - 4.0*u[4][k-1][j][i] + 
          6.0*u[4][k][j][i] - 4.0*u[4][k+1][j][i] );
    }
  }

  k = nz2;
  #pragma acc parallel loop gang num_gangs(ny2) num_workers(8) vector_length(32)
  for (j = 1; j <= ny2; j++) {
    #pragma acc loop worker vector
    for (i = 1; i <= nx2; i++) {
    /*
      for (m = 0; m < 5; m++) {
        rhs[m][k][j][i] = rhs[m][k][j][i] - dssp *
          ( u[m][k-2][j][i] - 4.0*u[m][k-1][j][i] + 5.0*u[m][k][j][i] );
      }
    */
        rhs[0][k][j][i] = rhs[0][k][j][i] - dssp *
          ( u[0][k-2][j][i] - 4.0*u[0][k-1][j][i] + 5.0*u[0][k][j][i] );
        rhs[1][k][j][i] = rhs[1][k][j][i] - dssp *
          ( u[1][k-2][j][i] - 4.0*u[1][k-1][j][i] + 5.0*u[1][k][j][i] );
        rhs[2][k][j][i] = rhs[2][k][j][i] - dssp *
          ( u[2][k-2][j][i] - 4.0*u[2][k-1][j][i] + 5.0*u[2][k][j][i] );
        rhs[3][k][j][i] = rhs[3][k][j][i] - dssp *
          ( u[3][k-2][j][i] - 4.0*u[3][k-1][j][i] + 5.0*u[3][k][j][i] );
        rhs[4][k][j][i] = rhs[4][k][j][i] - dssp *
          ( u[4][k-2][j][i] - 4.0*u[4][k-1][j][i] + 5.0*u[4][k][j][i] );
    }
  }

#pragma acc parallel loop gang num_gangs(nz2) num_workers(8) vector_length(32)
  for (k = 1; k <= nz2; k++) {
#pragma acc loop worker
    for (j = 1; j <= ny2; j++) {
#pragma acc loop vector
      for (i = 1; i <= nx2; i++) {
        /*
        for (m = 0; m < 5; m++) {
          rhs[m][k][j][i] = rhs[m][k][j][i] * dt;
        }
        */
          rhs[0][k][j][i] = rhs[0][k][j][i] * dt;
          rhs[1][k][j][i] = rhs[1][k][j][i] * dt;
          rhs[2][k][j][i] = rhs[2][k][j][i] * dt;
          rhs[3][k][j][i] = rhs[3][k][j][i] * dt;
          rhs[4][k][j][i] = rhs[4][k][j][i] * dt;
      }
    }
  }
}/* end acc data */

}

########## NEXT FILE ##########
sp.c:::
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB SP code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS SP code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

//---------------------------------------------------------------------
// program SP
//---------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>

#include "header.h"
#include "print_results.h"
#include <openacc.h>

/* common /global/ */
int grid_points[3], nx2, ny2, nz2;
logical timeron;

/* common /constants/ */
double tx1, tx2, tx3, ty1, ty2, ty3, tz1, tz2, tz3, 
       dx1, dx2, dx3, dx4, dx5, dy1, dy2, dy3, dy4, 
       dy5, dz1, dz2, dz3, dz4, dz5, dssp, dt, 
       ce[5][13], dxmax, dymax, dzmax, xxcon1, xxcon2, 
       xxcon3, xxcon4, xxcon5, dx1tx1, dx2tx1, dx3tx1,
       dx4tx1, dx5tx1, yycon1, yycon2, yycon3, yycon4,
       yycon5, dy1ty1, dy2ty1, dy3ty1, dy4ty1, dy5ty1,
       zzcon1, zzcon2, zzcon3, zzcon4, zzcon5, dz1tz1, 
       dz2tz1, dz3tz1, dz4tz1, dz5tz1, dnxm1, dnym1, 
       dnzm1, c1c2, c1c5, c3c4, c1345, conz1, c1, c2, 
       c3, c4, c5, c4dssp, c5dssp, dtdssp, dttx1, bt,
       dttx2, dtty1, dtty2, dttz1, dttz2, c2dttx1, 
       c2dtty1, c2dttz1, comz1, comz4, comz5, comz6, 
       c3c4tx3, c3c4ty3, c3c4tz3, c2iv, con43, con16;

/* common /fields/ */
double u[5][KMAX][JMAXP+1][IMAXP+1];
double us     [KMAX][JMAXP+1][IMAXP+1];
double vs     [KMAX][JMAXP+1][IMAXP+1];
double ws     [KMAX][JMAXP+1][IMAXP+1];
double qs     [KMAX][JMAXP+1][IMAXP+1];
double rho_i  [KMAX][JMAXP+1][IMAXP+1];
double speed  [KMAX][JMAXP+1][IMAXP+1];
double square [KMAX][JMAXP+1][IMAXP+1];
double rhs[5][KMAX][JMAXP+1][IMAXP+1];
double forcing[5][KMAX][JMAXP+1][IMAXP+1];

/* common /work_1d/ */
double cv  [PROBLEM_SIZE];
double rhon[PROBLEM_SIZE];
double rhos[PROBLEM_SIZE];
double rhoq[PROBLEM_SIZE];
double cuf [PROBLEM_SIZE];
double q   [PROBLEM_SIZE];
double ue [PROBLEM_SIZE][5];
double buf[PROBLEM_SIZE][5];

/* common /work_lhs/ */
double lhs [IMAXP+1][IMAXP+1][5];
double lhsp[IMAXP+1][IMAXP+1][5];
double lhsm[IMAXP+1][IMAXP+1][5];


int main(int argc, char *argv[])
{
  int i, niter, step, n3;
  double mflops, t, tmax, trecs[t_last+1];
  logical verified;
  char Class;
  char *t_names[t_last+1];

  //---------------------------------------------------------------------
  // Read input file (if it exists), else take
  // defaults from parameters
  //---------------------------------------------------------------------
  FILE *fp;
  if ((fp = fopen("timer.flag", "r")) != NULL) {
    timeron = true;
    t_names[t_total] = "total";
    t_names[t_rhsx] = "rhsx";
    t_names[t_rhsy] = "rhsy";
    t_names[t_rhsz] = "rhsz";
    t_names[t_rhs] = "rhs";
    t_names[t_xsolve] = "xsolve";
    t_names[t_ysolve] = "ysolve";
    t_names[t_zsolve] = "zsolve";
    t_names[t_rdis1] = "redist1";
    t_names[t_rdis2] = "redist2";
    t_names[t_tzetar] = "tzetar";
    t_names[t_ninvr] = "ninvr";
    t_names[t_pinvr] = "pinvr";
    t_names[t_txinvr] = "txinvr";
    t_names[t_add] = "add";
    fclose(fp);
  } else {
    timeron = false;
  }

  printf("\n\n NAS Parallel Benchmarks (NPB3.3-ACC) - SP Benchmark\n\n");

  if ((fp = fopen("inputsp.data", "r")) != NULL) {
    int result;
    printf(" Reading from input file inputsp.data\n");
    result = fscanf(fp, "%d", &niter);
    while (fgetc(fp) != '\n');
    result = fscanf(fp, "%lf", &dt);
    while (fgetc(fp) != '\n');
    result = fscanf(fp, "%d%d%d", &grid_points[0], &grid_points[1], &grid_points[2]);
    fclose(fp);
  } else {
    printf(" No input file inputsp.data. Using compiled defaults\n");
    niter = NITER_DEFAULT;
    dt    = DT_DEFAULT;
    grid_points[0] = PROBLEM_SIZE;
    grid_points[1] = PROBLEM_SIZE;
    grid_points[2] = PROBLEM_SIZE;
  }


  printf(" Size: %4dx%4dx%4d\n", 
      grid_points[0], grid_points[1], grid_points[2]);
  printf(" Iterations: %4d    dt: %10.6f\n", niter, dt);
  printf("\n");

  if ((grid_points[0] > IMAX) ||
      (grid_points[1] > JMAX) ||
      (grid_points[2] > KMAX) ) {
    printf(" %d, %d, %d\n", grid_points[0], grid_points[1], grid_points[2]);
    printf(" Problem size too big for compiled array sizes\n");
    return 0;
  }
  nx2 = grid_points[0] - 2;
  ny2 = grid_points[1] - 2;
  nz2 = grid_points[2] - 2;

  set_constants();
  
  for (i = 1; i <= t_last; i++) {
    timer_clear(i);
  }
  acc_init(acc_device_default);

#pragma acc data create(u,us,vs,ws,qs,rho_i,speed,square,forcing,rhs)
{
  exact_rhs();
  #pragma acc update device(forcing)

  initialize();
  #pragma acc update device(u)

  //---------------------------------------------------------------------
  // do one time step to touch all code, and reinitialize
  //---------------------------------------------------------------------
  adi();
  initialize();
  #pragma acc update device(u)
  
  for (i = 1; i <= t_last; i++) {
    timer_clear(i);
  }
  timer_start(1);

  for (step = 1; step <= niter; step++) {
    if ((step % 20) == 0 || step == 1) {
      printf(" Time step %4d\n", step);
    }

    adi();
  }
  
  #pragma acc update host(u)
  timer_stop(1);
  tmax = timer_read(1);
  
  verify(niter, &Class, &verified);
  mflops = 0.0;
} /*end acc data*/

  print_results("SP", Class, grid_points[0], 
                grid_points[1], grid_points[2], niter, 
                tmax, mflops, "          floating point", 
                verified, NPBVERSION,COMPILETIME, CS1, CS2, CS3, CS4, CS5, 
                CS6, CS7);

  acc_shutdown(acc_device_default);

  return 0;
}


########## NEXT FILE ##########
txinvr.c:::
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB SP code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS SP code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

#include "header.h"

//---------------------------------------------------------------------
// block-diagonal matrix-vector multiplication                  
//---------------------------------------------------------------------
void txinvr()
{
  int i, j, k;
  double t1, t2, t3, ac, ru1, uu, vv, ww, r1, r2, r3, r4, r5, ac2inv;

//  if (timeron) timer_start(t_txinvr);
#pragma acc parallel present(rho_i,us,vs,ws,rhs,speed,qs) \
            num_gangs(nz2) num_workers(16) vector_length(32)
{
  #pragma acc loop gang
  for (k = 1; k <= nz2; k++) {
    #pragma acc loop worker
    for (j = 1; j <= ny2; j++) {
  	  #pragma acc loop vector
      for (i = 1; i <= nx2; i++) {
        ru1 = rho_i[k][j][i];
        uu = us[k][j][i];
        vv = vs[k][j][i];
        ww = ws[k][j][i];
        ac = speed[k][j][i];
        ac2inv = ac*ac;

        r1 = rhs[0][k][j][i];
        r2 = rhs[1][k][j][i];
        r3 = rhs[2][k][j][i];
        r4 = rhs[3][k][j][i];
        r5 = rhs[4][k][j][i];

        t1 = c2 / ac2inv * ( qs[k][j][i]*r1 - uu*r2  - vv*r3 - ww*r4 + r5 );
        t2 = bt * ru1 * ( uu * r1 - r2 );
        t3 = ( bt * ru1 * ac ) * t1;

        rhs[0][k][j][i] = r1 - t1;
        rhs[1][k][j][i] = - ru1 * ( ww*r1 - r4 );
        rhs[2][k][j][i] =   ru1 * ( vv*r1 - r3 );
        rhs[3][k][j][i] = - t2 + t3;
        rhs[4][k][j][i] =   t2 + t3;
      }
    }
  }
}/*end parallel*/
//  if (timeron) timer_stop(t_txinvr);
}


########## NEXT FILE ##########
acc_async_test.F90:::
#ifndef T1
!T1:runtime,async,construct-independent,V:2.0-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x, y !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e !Data
        INTEGER :: errors
        errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        CALL RANDOM_NUMBER(d)
        c = 0
        e = 0
        
        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) create(c(1:LOOPCOUNT)) async(1)
        !$acc enter data copyin(d(1:LOOPCOUNT)) create(e(1:LOOPCOUNT)) async(2)
        !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT)) async(1)
          !$acc loop
          DO x = 1, LOOPCOUNT
            c(x) = a(x) + b(x)
          END DO
        !$acc end parallel
        !$acc parallel present(c(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) async(1) wait(2)
          !$acc loop
          DO x = 1, LOOPCOUNT
            e(x) = c(x) + d(x)
          END DO
        !$acc end parallel
        !$acc exit data copyout(e(1:LOOPCOUNT)) async(1)


        DO WHILE (acc_async_test(1) .eqv. .FALSE.)
          CONTINUE
        END DO

        DO x = 1, LOOPCOUNT
          IF (abs(e(x) - (a(x) + b(x) + d(x))) .GT. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO
        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif

#ifndef T2
!T2:async,runtime,construct-independent,V:1.0-2.7
      LOGICAL FUNCTION test2()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x, y
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e
        INTEGER :: errors
        errors = 0
        
        !Initialization
        CALL RANDOM_SEED()
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        CALL RANDOM_NUMBER(d)
        c = 0
        e = 0

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT), e(1:LOOPCOUNT))
          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT)) async(1)
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
          !$acc parallel present(c(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) async(1)
            !$acc loop
            DO x = 1, LOOPCOUNT
              e(x) = c(x) + d(x)
            END DO
          !$acc end parallel
          DO WHILE (acc_async_test(1) .eqv. .FALSE.)
            CONTINUE
          END DO
        !$acc end data

        DO x = 1, LOOPCOUNT
          IF (abs(e(x) - (a(x) + b(x) + d(x))) .GT. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif

#ifndef T3
!T3:runtime,async,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test3()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x, y
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e
        INTEGER :: errors, async_val
        INTEGER :: acc_get_default_async
        async_val = acc_get_default_async()
        errors = 0

        !Initialization
        CALL RANDOM_SEED()
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        CALL RANDOM_NUMBER(d)
        c = 0
        e = 0

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT), e(1:LOOPCOUNT))
          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT)) async
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
          !$acc parallel present(c(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) async
            !$acc loop
            DO x = 1, LOOPCOUNT
              e(x) = c(x) + d(x)
            END DO
          !$acc end parallel
          DO WHILE (acc_async_test(async_val) .eqv. .FALSE.)
            CONTINUE
          END DO
        !$acc end data

        DO x = 1, LOOPCOUNT
          IF (abs(e(x) - (a(x) + b(x) + d(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test3 = .FALSE.
        ELSE
          test3 = .TRUE.
        END IF
      END
#endif

      PROGRAM main
      IMPLICIT NONE
      INTEGER :: failcode, testrun
      LOGICAL :: failed
      INCLUDE "acc_testsuite.Fh"
      !Conditionally define test functions
#ifndef T1
      LOGICAL :: test1
#endif
#ifndef T2
      LOGICAL :: test2
#endif
#ifndef T3
      LOGICAL :: test3
#endif
      failcode = 0
      failed = .FALSE.

#ifndef T1
      DO testrun = 1, NUM_TEST_CALLS
        failed = failed .or. test1()
      END DO
      IF (failed) THEN
        failcode = failcode + 2 ** 0
        failed = .FALSE.
      END IF
#endif

#ifndef T2
      DO testrun = 1, NUM_TEST_CALLS
        failed = failed .or. test2()
      END DO
      IF (failed) THEN
        failcode = failcode + 2 ** 1
        failed = .FALSE.
      END IF
#endif

#ifndef T3
      DO testrun = 1, NUM_TEST_CALLS
        failed = failed .or. test3()
      END DO
      IF (failed) THEN
        failcode = failcode + 2 ** 2
        failed = .FALSE.
      END IF
#endif
      CALL EXIT (failcode)
      END PROGRAM

########## NEXT FILE ##########
acc_async_test_all.F90:::
#ifndef T1
!T1:runtime,async,construct-independent,update,V:2.0-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x, y !Iterators
        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c, d, e !Data
        INTEGER :: errors
        errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        CALL RANDOM_NUMBER(d)
        c = 0
        e = 0

        !$acc enter data create(a(1:LOOPCOUNT,1:10), b(1:LOOPCOUNT,1:10), c(1:LOOPCOUNT,1:10), d(1:LOOPCOUNT,1:10), e(1:LOOPCOUNT,1:10))
        DO y = 1, 10
          !$acc update device(a(1:LOOPCOUNT,y:y), b(1:LOOPCOUNT,y:y), d(1:LOOPCOUNT,y:y)) async(y)
          !$acc parallel present(a(1:LOOPCOUNT,y:y), b(1:LOOPCOUNT,y:y), c(1:LOOPCOUNT,y:y)) async(y)
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x, y) = a(x, y) + b(x, y)
            END DO
          !$acc end parallel
          !$acc parallel present(c(1:LOOPCOUNT,y:y), d(1:LOOPCOUNT,y:y),e(1:LOOPCOUNT,y:y)) async(y)
            !$acc loop
            DO x = 1, LOOPCOUNT
              e(x, y) = c(x, y) + d(x, y)
            END DO
          !$acc end parallel
          !$acc update host(e(1:LOOPCOUNT,y:y)) async(y)
        END DO

        DO WHILE (acc_async_test_all() .eqv. .FALSE.)
          CONTINUE
        END DO

        DO y = 1, 10
          DO x = 1, LOOPCOUNT
            IF (abs(e(x, y) - (a(x, y) + b(x, y) + d(x, y))) .GT. PRECISION) THEN
              errors = errors + 1
            END IF
          END DO
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif

#ifndef T2
!T2:async,runtime,construct-independent,V:1.0-2.7
      LOGICAL FUNCTION test2()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x, y !Iterators
        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c, d, e !Data
        INTEGER :: errors
        errors = 0

        !Initialization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        CALL RANDOM_NUMBER(d)
        c = 0
        e = 0

        !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT,1:10), d(1:LOOPCOUNT, 1:10)) copyout(c(1:LOOPCOUNT, 1:10), e(1:LOOPCOUNT, 1:10))
          DO x = 1, 10
            !$acc parallel present(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10), c(1:LOOPCOUNT, 1:10)) async(x)
              !$acc loop
              DO y = 1, LOOPCOUNT
                c(y, x) = a(y, x) + b(y, x)
              END DO
            !$acc end parallel
            !$acc parallel present(c(1:LOOPCOUNT, 1:10), d(1:LOOPCOUNT, 1:10), e(1:LOOPCOUNT, 1:10)) async(x)
              !$acc loop
              DO y = 1, LOOPCOUNT
                e(y, x) = c(y, x) + d(y, x)
              END DO
            !$acc end parallel
          END DO
          DO WHILE (acc_async_test_all() .eqv. .FALSE.)
            CONTINUE
          END DO
        !$acc end data

        DO x = 1, 10
          DO y = 1, LOOPCOUNT
            IF (abs(e(y, x) - (a(y, x) + b(y, x) + d(y, x))) .gt. PRECISION) THEN
              errors = errors + 1
            END IF
          END DO
        END DO

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif

#ifndef T3
!T3:async,runtime,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test3()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x, y !Iterators
        REAL(8),DIMENSION(LOOPCOUNT, 10):: a, b, c, d, e !Data
        INTEGER :: errors
        errors = 0

        !Initialization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        CALL RANDOM_NUMBER(d)
        c = 0
        e = 0

        !$acc data copyin(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10), d(1:LOOPCOUNT, 1:10)) copyout(c(1:LOOPCOUNT, 1:10), e(1:LOOPCOUNT, 1:10))
          DO x = 1, 10
            CALL acc_set_default_async(x)
            !$acc parallel present(a(1:LOOPCOUNT, 1:10), b(1:LOOPCOUNT, 1:10), c(1:LOOPCOUNT, 1:10)) async
              !$acc loop
              DO y = 1, LOOPCOUNT
                c(y, x) = a(y, x) + b(y, x)
              END DO
            !$acc end parallel
            !$acc parallel present(c(1:LOOPCOUNT, 1:10), d(1:LOOPCOUNT, 1:10), e(1:LOOPCOUNT, 1:10)) async
              !$acc loop
              DO y = 1, LOOPCOUNT
                e(y, x) = c(y, x) + d(y, x)
              END DO
            !$acc end parallel
          END DO
          DO WHILE (acc_async_test_all() .eqv. .FALSE.)
            CONTINUE
          END DO
        !$acc end data

        DO x = 1, 10
          DO y = 1, LOOPCOUNT
            IF (abs(e(y, x) - (a(y, x) + b(y, x) + d(y, x))) .gt. PRECISION) THEN
              errors = errors + 1
            END IF
          END DO
        END DO

        IF (errors .eq. 0) THEN
          test3 = .FALSE.
        ELSE
          test3 = .TRUE.
        END IF
      END
#endif

      PROGRAM main
      IMPLICIT NONE
      INTEGER :: failcode, testrun
      LOGICAL :: failed
      INCLUDE "acc_testsuite.Fh"
      !Conditionally define test functions
#ifndef T1
      LOGICAL :: test1
#endif
#ifndef T2
      LOGICAL :: test2
#endif
#ifndef T3
      LOGICAL :: test3
#endif
      failcode = 0
      failed = .FALSE.

#ifndef T1
      DO testrun = 1, NUM_TEST_CALLS
        failed = failed .or. test1()
      END DO
      IF (failed) THEN
        failcode = failcode + 2 ** 0
        failed = .FALSE.
      END IF
#endif
#ifndef T2
      DO testrun = 1, NUM_TEST_CALLS
        failed = failed .or. test2()
      END DO
      IF (failed) THEN
        failcode = failcode + 2 ** 1
        failed = .FALSE.
      END IF
#endif
#ifndef T3
      DO testrun = 1, NUM_TEST_CALLS
        failed = failed .or. test3()
      END DO
      IF (failed) THEN
        failcode = failcode + 2 ** 2
        failed = .FALSE.
      END IF
#endif
      CALL EXIT (failcode)
      END PROGRAM

########## NEXT FILE ##########
acc_copyin.F90:::
#ifndef T1
!T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER :: errors = 0

        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        CALL acc_copyin(a(1:LOOPCOUNT))
        CALL acc_copyin(b(1:LOOPCOUNT))

        !$acc data copy(c(1:LOOPCOUNT))
          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END FUNCTION
#endif

#ifndef T2
!T2:runtime,data,executable-data,construct-independent,V:2.0-2.7
      LOGICAL FUNCTION test2()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER :: errors = 0

        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 1

        CALL acc_copyin(a(1:LOOPCOUNT))
        CALL acc_copyin(b(1:LOOPCOUNT))

        !$acc data copyout(c(1:LOOPCOUNT))
          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        CALL acc_copyout(a(1:LOOPCOUNT))
        CALL acc_copyout(b(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END FUNCTION
#endif

#ifndef T3
!T3:runtime,data,executable-data,devonly,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test3()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_copy, b_copy !Data
        INTEGER :: errors = 0
        LOGICAL,DIMENSION(1):: devtest

        devtest(1) = .TRUE.
        !$acc enter data copyin(devtest(1:1))
        !$acc parallel present(devtest(1:1))
          devtest(1) = .FALSE.
        !$acc end parallel

        IF (devtest(1) .eqv. .TRUE.) THEN
          SEEDDIM(1) = 1
#         ifdef SEED
          SEEDDIM(1) = SEED
#         endif
          CALL RANDOM_SEED(PUT=SEEDDIM)
          CALL RANDOM_NUMBER(a)
          a_copy(:) = a(:)
          CALL RANDOM_NUMBER(b)
          b_copy(:) = b(:)
          c = 0

          CALL acc_copyin(a(1:LOOPCOUNT))
          CALL acc_copyin(b(1:LOOPCOUNT))

          a = 0
          b = 0

          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))
            !$acc parallel
              !$acc loop
              DO x = 1, LOOPCOUNT
                c(x) = a(x) + b(x)
              END DO
            !$acc end parallel
          !$acc end data

          !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT))

          DO x = 1, LOOPCOUNT
            IF (abs(a(x) - a_copy(x)) .gt. PRECISION) THEN
              errors = errors + 1
            END IF
            IF (abs(b(x) - b_copy(x)) .gt. PRECISION) THEN
              errors = errors + 1
            END IF
            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
              errors = errors + 1
            END IF
          END DO
        END IF

        IF (errors .eq. 0) THEN
          test3 = .FALSE.
        ELSE
          test3 = .TRUE.
        END IF
      END
#endif

#ifndef T4
!T4:runtime,executable-data,construct-independent,compatibility-features,V:2.0-2.7
      LOGICAL FUNCTION test4()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER :: errors = 0

        !Initialization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        CALL acc_pcopyin(a(1:LOOPCOUNT))
        CALL acc_pcopyin(b(1:LOOPCOUNT))

        !$acc data copyout(c(1:LOOPCOUNT))
          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test4 = .FALSE.
        ELSE
          test4 = .TRUE.
        END IF
      END
#endif

#ifndef T5
!T5:runtime,executable-data,construct-independent,compatibility-features,V:2.0-2.7
      LOGICAL FUNCTION test5()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER :: errors = 0

        !Initialization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0
        
        CALL acc_present_or_copyin(a(1:LOOPCOUNT))
        CALL acc_present_or_copyin(b(1:LOOPCOUNT))

        !$acc data copyout(c(1:LOOPCOUNT))
          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test5 = .FALSE.
        ELSE
          test5 = .TRUE.
        END IF
      END
#endif

#ifndef T6
!T6:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7
      LOGICAL FUNCTION test6()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER :: errors = 0

        !Initialization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        CALL acc_copyin(a(1:LOOPCOUNT))
        CALL acc_copyin(a(1:LOOPCOUNT))
        CALL acc_copyin(b(1:LOOPCOUNT))
        CALL acc_copyin(b(1:LOOPCOUNT))

        !$acc data copyout(c(1:LOOPCOUNT))
          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test6 = .FALSE.
        ELSE
          test6 = .TRUE.
        END IF
      END
#endif

#ifndef T7
!T7:runtime,data,executable-data,construct-independent,reference-counting,devonly,V:2.5-2.7
      LOGICAL FUNCTION test7()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_copy, b_copy !Data
        INTEGER :: errors = 0
        LOGICAL,DIMENSION(1):: devtest

        devtest(1) = .TRUE.
        !$acc enter data copyin(devtest(1:1))
        !$acc parallel present(devtest(1:1))
          devtest(1) = .FALSE.
        !$acc end parallel

        IF (devtest(1) .eqv. .TRUE.) THEN
          !Initialization
          SEEDDIM(1) = 1
#         ifdef SEED
          SEEDDIM(1) = SEED
#         endif
          CALL RANDOM_SEED(PUT=SEEDDIM)
          CALL RANDOM_NUMBER(a)
          CALL RANDOM_NUMBER(b)
          c = 0
          a_copy = a
          b_copy = b

          CALL acc_copyin(a(1:LOOPCOUNT))
          CALL acc_copyin(b(1:LOOPCOUNT))

          a = 0
          b = 0

          CALL acc_copyin(a(1:LOOPCOUNT))
          CALL acc_copyin(b(1:LOOPCOUNT))

          !$acc data copyout(c(1:LOOPCOUNT))
            !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
              !$acc loop
              DO x = 1, LOOPCOUNT
                c(x) = a(x) + b(x)
              END DO
            !$acc end parallel
          !$acc end data

          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))

          DO x = 1, LOOPCOUNT
            IF (abs(c(x) - (a_copy(x) + b_copy(x))) .gt. PRECISION) THEN
              errors = errors + 1
            END IF
          END DO
        END IF

        IF (errors .eq. 0) THEN
          test7 = .FALSE.
        ELSE
          test7 = .TRUE.
        END IF
      END
#endif
      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
#ifndef T3
        LOGICAL :: test3
#endif
#ifndef T4
        LOGICAL :: test4
#endif
#ifndef T5
        LOGICAL :: test5
#endif
#ifndef T6
        LOGICAL :: test6
#endif
#ifndef T7
        LOGICAL :: test7
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 1
          failed = .FALSE.
        END IF
#endif
#ifndef T3
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test3()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 2
          failed = .FALSE.
        END IF
#endif
#ifndef T4
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test4()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 3
          failed = .FALSE.
        END IF
#endif
#ifndef T5
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test5()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 4
          failed = .FALSE.
        END IF
#endif
#ifndef T6
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test6()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 5
          failed = .FALSE.
        END IF
#endif
#ifndef T7
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test7()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 6
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_copyin_async.F90:::
#ifndef T1
!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_host, b_host !Data
        REAL(8) :: RAND
        INTEGER :: errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0
        a_host = a
        b_host = b

        CALL acc_copyin_async(a(1:LOOPCOUNT), 1)
        CALL acc_copyin_async(b(1:LOOPCOUNT), 2)

        !$acc data copyout(c(1:LOOPCOUNT))
          !$acc parallel async(1) present(a(1:LOOPCOUNT))
            !$acc loop
            DO x = 1, LOOPCOUNT
              a(x) = a(x) * a(x)
            END DO
          !$acc end parallel
          !$acc parallel async(2) present(b(1:LOOPCOUNT))
            !$acc loop
            DO x = 1, LOOPCOUNT
              b(x) = b(x) * b(x)
            END DO
          !$acc end parallel
          !$acc parallel async(2) wait(1) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data
        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a_host(x)*a_host(x) + b_host(x)*b_host(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO
        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif

#ifndef T2
!T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test2()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_host, b_host !Data
        REAL(8) :: RAND
        INTEGER :: errors = 0

        !Initialization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        CALL acc_copyin_async(a(1:LOOPCOUNT), 1)
        CALL acc_copyin_async(b(1:LOOPCOUNT), 2)

        !$acc data copyout(c(1:LOOPCOUNT))
          DO WHILE (acc_async_test_all() .eqv. .FALSE.)
            CONTINUE
          END DO
          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif

#ifndef T3
!T3:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test3()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        REAL(8) :: RAND
        INTEGER :: errors = 0

        !Initialization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        CALL acc_copyin_async(a(1:LOOPCOUNT), 1)
        CALL acc_copyin_async(b(1:LOOPCOUNT), 2)

        !$acc data copyout(c(1:LOOPCOUNT))
          !$acc wait
          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test3 = .FALSE.
        ELSE
          test3 = .TRUE.
        END IF
      END
#endif

#ifndef T4
!T4:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7
      LOGICAL FUNCTION test4()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e !Data
        REAL(8) :: RAND
        INTEGER :: errors = 0

        !Initialization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0
        CALL RANDOM_NUMBER(d)
        e = 0

        !$acc enter data create(c(1:LOOPCOUNT))
        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT)) copyout(e(1:LOOPCOUNT))
          !$acc parallel present(c(1:LOOPCOUNT)) async(1)
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
          CALL acc_copyin_async(c(1:LOOPCOUNT), 1)
          !$acc exit data delete(c(1:LOOPCOUNT))
          !$acc parallel present(c(1:LOOPCOUNT)) async(1)
            !$acc loop
            DO x = 1, LOOPCOUNT
              e(x) = c(x) + d(x)
            END DO
          !$acc end parallel
        !$acc end data
        !$acc exit data copyout(c(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
          IF (abs(e(x) - (a(x) + b(x) + d(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test4 = .FALSE.
        ELSE
          test4 = .TRUE.
        END IF
      END
#endif

#ifndef T5
!T5:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7
      LOGICAL FUNCTION test5()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_copy, b_copy !Data
        REAL(8) :: RAND
        INTEGER :: errors = 0

        !Initialization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        a_copy = a
        CALL RANDOM_NUMBER(b)
        b_copy = b
        c = 0

        CALL acc_copyin_async(a(1:LOOPCOUNT), 1)
        CALL acc_copyin_async(b(1:LOOPCOUNT), 2)

        a = 0
        b = 0

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))
          !$acc wait
          !$acc parallel
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a_copy(x) + b_copy(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test5 = .FALSE.
        ELSE
          test5 = .TRUE.
        END IF
      END
#endif


      PROGRAM main
      IMPLICIT NONE
      INTEGER :: failcode, testrun
      LOGICAL :: failed
      INCLUDE "acc_testsuite.Fh"
      !Conditionally define test functions
#ifndef T1
      LOGICAL :: test1
#endif
#ifndef T2
      LOGICAL :: test2
#endif
#ifndef T3
      LOGICAL :: test3
#endif
#ifndef T4
      LOGICAL :: test4
#endif
#ifndef T5
      LOGICAL :: test5
#endif
      failcode = 0
      failed = .FALSE.

#ifndef T1
      DO testrun = 1, NUM_TEST_CALLS
        failed = failed .or. test1()
      END DO
      IF (failed) THEN
        failcode = failcode + 2 ** 0
        failed = .FALSE.
      END IF
#endif
#ifndef T2
      DO testrun = 1, NUM_TEST_CALLS
        failed = failed .or. test2()
      END DO
      IF (failed) THEN
        failcode = failcode + 2 ** 1
        failed = .FALSE.
      END IF
#endif
#ifndef T3
      DO testrun = 1, NUM_TEST_CALLS
        failed = failed .or. test3()
      END DO
      IF (failed) THEN
        failcode = failcode + 2 ** 2
        failed = .FALSE.
      END IF
#endif
#ifndef T4
      DO testrun = 1, NUM_TEST_CALLS
        failed = failed .or. test4()
      END DO
      IF (failed) THEN
        failcode = failcode + 2 ** 3
        failed = .FALSE.
      END IF
#endif
#ifndef T5
      DO testrun = 1, NUM_TEST_CALLS
        failed = failed .or. test5()
      END DO
      IF (failed) THEN
        failcode = failcode + 2 ** 4
        failed = .FALSE.
      END IF
#endif
      CALL EXIT (failcode)
      END PROGRAM

########## NEXT FILE ##########
acc_copyin_async_with_len.F90:::
#ifndef T1
!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_host, b_host !Data
        INTEGER :: errors
        errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0
        a_host = a
        b_host = b

        CALL acc_copyin_async(a(1), LOOPCOUNT*8, 1)
        CALL acc_copyin_async(b(1), LOOPCOUNT*8, 2)

        !$acc data copyout(c(1:LOOPCOUNT)) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
          !$acc parallel async(1)
            !$acc loop
            DO x = 1, LOOPCOUNT
              a(x) = a(x) * a(x)
            END DO
          !$acc end parallel
          !$acc parallel async(2)
            !$acc loop
            DO x = 1, LOOPCOUNT
              b(x) = b(x) * b(x)
            END DO
          !$acc end parallel
          !$acc parallel wait(1, 2)
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a_host(x)*a_host(x) + b_host(x)*b_host(x))) .gt. 4*PRECISION) THEN
            errors = errors + 1
          END IF
        END DO
        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif

#ifndef T2
!T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test2()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER :: errors
        errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        CALL acc_copyin_async(a(1), LOOPCOUNT*8, 1)
        CALL acc_copyin_async(b(1), LOOPCOUNT*8, 2)

        !$acc data copyout(c(1:LOOPCOUNT))
          DO WHILE (acc_async_test_all() .eqv. .FALSE.)
            CONTINUE
          END DO
          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif

#ifndef T3
!T3:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test3()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER :: errors
        errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        CALL acc_copyin_async(a(1), LOOPCOUNT*8, 1)
        CALL acc_copyin_async(b(1), LOOPCOUNT*8, 2)

        !$acc data copyout(c(1:LOOPCOUNT))
          !$acc wait
          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEn
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test3 = .FALSE.
        ELSE
          test3 = .TRUE.
        END IF
      END
#endif

#ifndef T4
!T4:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7
      LOGICAL FUNCTION test4()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e !Data
        REAL(8) :: RAND
        INTEGER :: errors = 0

        !Initialization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0
        CALL RANDOM_NUMBER(d)
        e = 0

        !$acc enter data create(c(1:LOOPCOUNT))
        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT)) copyout(e(1:LOOPCOUNT))
          !$acc parallel present(c(1:LOOPCOUNT)) async(1)
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
          CALL acc_copyin_async(c(1), LOOPCOUNT*8, 1)
          !$acc exit data delete(c(1:LOOPCOUNT))
          !$acc parallel present(c(1:LOOPCOUNT)) async(1)
            !$acc loop
            DO x = 1, LOOPCOUNT
              e(x) = c(x) + d(x)
            END DO
          !$acc end parallel
        !$acc end data
        !$acc exit data copyout(c(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
          IF (abs(e(x) - (a(x) + b(x) + d(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test4 = .FALSE.
        ELSE
          test4 = .TRUE.
        END IF
      END
#endif

#ifndef T5
!T5:runtime,data,executable-data,async,construct-independent,reference-counting,V:2.5-2.7
      LOGICAL FUNCTION test5()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        REAL(8) :: RAND
        INTEGER :: errors = 0

        !Initialization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        CALL acc_copyin_async(a(1), LOOPCOUNT*8, 1)
        CALL acc_copyin_async(b(1), LOOPCOUNT*8, 2)

        !$acc data create(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))
          !$acc wait
          !$acc parallel
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test5 = .FALSE.
        ELSE
          test5 = .TRUE.
        END IF
      END
#endif

      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
#ifndef T3
        LOGICAL :: test3
#endif
#ifndef T4
        LOGICAL :: test4
#endif
#ifndef T5
        LOGICAL :: test5
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 1
          failed = .FALSE.
        END IF
#endif
#ifndef T3
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test3()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 2
          failed = .FALSE.
        END IF
#endif
#ifndef T4
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test4()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 3
          failed = .FALSE.
        END IF
#endif
#ifndef T5
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test5()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 4
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_copyin_with_len.F90:::
#ifndef T1
!T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        REAL(8) :: RAND
        INTEGER :: errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0
        CALL acc_copyin(a(1), LOOPCOUNT*8)
        CALL acc_copyin(b(1), LOOPCOUNT*8)
        !$acc data copy(c(1:LOOPCOUNT))
          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
            !$acc Loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        CALL acc_copyout(a(1:LOOPCOUNT))
        CALL acc_copyout(b(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END FUNCTION
#endif

#ifndef T2
!T2:runtime,data,executable-data,construct-independent,V:2.0-2.7
      LOGICAL FUNCTION test2()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        REAL(8) :: RAND
        INTEGER :: errors = 0

        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        CALL acc_copyin(a(1), LOOPCOUNT*8)
        CALL acc_copyin(b(1), LOOPCOUNT*8)
        !$acc data copy(c(1:LOOPCOUNT))
          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        !$acc exit data copyout(a(1:LOOPCOUNT), b(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END FUNCTION
#endif

#ifndef T3
!T3:runtime,data,executable-data,devonly,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test3()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_copy, b_copy !Data
        REAL(8) :: RAND
        INTEGER :: errors = 0
        INTEGER,DIMENSION(1) :: devtest

        devtest(1) = 1
        !$acc enter data copyin(devtest(1:1))
        !$acc parallel present(devtest(1:1))
          devtest(1) = 0
        !$acc end parallel

        IF (devtest(1) .eq. 1) THEN
          SEEDDIM(1) = 1
#         ifdef SEED
          SEEDDIM(1) = SEED
#         endif
          CALL RANDOM_SEED(PUT=SEEDDIM)
          CALL RANDOM_NUMBER(a)
          CALL RANDOM_NUMBER(b)
          a_copy = a
          b_copy = b
          c = 0

          CALL acc_copyin(a(1), LOOPCOUNT*8)
          CALL acc_copyin(b(1), LOOPCOUNT*8)

          a = 0
          b = 0

          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copy(c(1:LOOPCOUNT))
            !$acc parallel
              !$acc loop
              DO x = 1, LOOPCOUNT
                c(x) = a(x) + b(x)
              END DO
            !$acc end parallel
          !$acc end data

          CALL acc_copyout(a(1:LOOPCOUNT))
          CALL acc_copyout(b(1:LOOPCOUNT))

          DO x = 1, LOOPCOUNT
            IF (abs(a(x) - a_copy(x)) .gt. PRECISION) THEN
              errors = errors + 1
            END IF
            IF (abs(b(x) - b_copy(x)) .gt. PRECISION) THEN
              errors = errors + 1
            END IF
            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
              errors = errors + 1
            END IF
          END DO
        END IF

        IF (errors .eq. 0) THEN
          test3 = .FALSE.
        ELSE
          test3 = .TRUE.
        END IF
      END FUNCTION
#endif

#ifndef T4
!T4:runtime,compatibility-features,construct-independent,V:2.0-2.7
      LOGICAL FUNCTION test4()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        REAL(8) :: RAND
        INTEGER :: errors = 0

        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        CALL acc_pcopyin(a(1), LOOPCOUNT*8)
        CALL acc_pcopyin(b(1), LOOPCOUNT*8)

        !$acc data copyout(c(1:LOOPCOUNT)) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
          !$acc parallel
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test4 = .FALSE.
        ELSE
          test4 = .TRUE.
        END IF
      END FUNCTION
#endif

#ifndef T5
!T5:runtime,compatibility-features,construct-independent,V:2.0-2.7
      LOGICAL FUNCTION test5()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        REAL(8) :: RAND
        INTEGER :: errors = 0

        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        CALL acc_present_or_copyin(a(1), LOOPCOUNT*8)
        CALL acc_present_or_copyin(b(1), LOOPCOUNT*8)

        !$acc data copyout(c(1:LOOPCOUNT)) present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
          !$acc parallel
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test5 = .FALSE.
        ELSE
          test5 = .TRUE.
        END IF
      END FUNCTION
#endif

#ifndef T6
!T6:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7
      LOGICAL FUNCTION test6()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        REAL(8) :: RAND
        INTEGER :: errors = 0

        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        CALL acc_copyin(a(1), LOOPCOUNT*8)
        CALL acc_copyin(a(1), LOOPCOUNT*8)
        CALL acc_copyin(b(1), LOOPCOUNT*8)
        CALL acc_copyin(b(1), LOOPCOUNT*8)

        !$acc data copyout(c(1:LOOPCOUNT))
          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) + (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test6 = .FALSE.
        ELSE
          test6 = .TRUE.
        END IF
      END
#endif

#ifndef T7
!T7:runtime,data,executable-data,construct-independent,reference-counting,devonly,V:2.5-2.7
      LOGICAL FUNCTION test7()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_copy, b_copy !Data
        REAL(8) :: RAND
        INTEGER :: errors = 0
        LOGICAL,DIMENSION(1):: devtest

        devtest(1) = .TRUE.
        !$acc enter data copyin(devtest(1:1))
        !$acc parallel present(devtest(1:1))
          devtest(1) = .FALSE.
        !$acc end parallel

        IF (devtest(1) .eqv. .TRUE.) THEN
          SEEDDIM(1) = 1
#         ifdef SEED
          SEEDDIM(1) = SEED
#         endif
          CALL RANDOM_SEED(PUT=SEEDDIM)
          CALL RANDOM_NUMBER(a)
          CALL RANDOM_NUMBER(b)
          c = 0
          a_copy = a
          b_copy = b

          CALL acc_copyin(a(1), LOOPCOUNT*8)
          CALL acc_copyin(b(1), LOOPCOUNT*8)

          a = 0
          b = 0

          CALL acc_copyin(a(1), LOOPCOUNT*8)
          CALL acc_copyin(b(1), LOOPCOUNT*8)

          !$acc data copyout(c(1:LOOPCOUNT))
            !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
              !$acc loop
              DO x = 1, LOOPCOUNT
                c(x) = a(x) + b(x)
              END DO
            !$acc end parallel
          !$acc end data

          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))

          DO x = 1, LOOPCOUNT
            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
              errors = errors + 1
            END IF
          END DO
        END IF
        IF (errors .eq. 0) THEN
          test7 = .FALSE.
        ELSE
          test7 = .TRUE.
        END IF
      END
#endif

      PROGRAM main
      IMPLICIT NONE
      INTEGER :: failcode, testrun
      LOGICAL :: failed
      INCLUDE "acc_testsuite.Fh"
      !Conditionally define test functions
#ifndef T1
      LOGICAL :: test1
#endif
#ifndef T2
      LOGICAL :: test2
#endif
#ifndef T3
      LOGICAL :: test3
#endif
#ifndef T4
      LOGICAL :: test4
#endif
#ifndef T5
      LOGICAL :: test5
#endif
#ifndef T6
      LOGICAL :: test6
#endif
#ifndef T7
      LOGICAL :: test7
#endif
      failcode = 0
      failed = .FALSE.

#ifndef T1
      DO testrun = 1, NUM_TEST_CALLS
        failed = failed .or. test1()
      END DO
      IF (failed) THEN
        failcode = failcode + 2 ** 0
        failed = .FALSE.
      END IF
#endif
#ifndef T2
      DO testrun = 1, NUM_TEST_CALLS
        failed = failed .or. test2()
      END DO
      IF (failed) THEN
        failcode = failcode + 2 ** 1
        failed = .FALSE.
      END IF
#endif
#ifndef T3
      DO testrun = 1, NUM_TEST_CALLS
        failed = failed .or. test3()
      END DO
      IF (failed) THEN
        failcode = failcode + 2 ** 2
        failed = .FALSE.
      END IF
#endif
#ifndef T4
      DO testrun = 1, NUM_TEST_CALLS
        failed = failed .or. test4()
      END DO
      IF (failed) THEN
        failcode = failcode + 2 ** 3
        failed = .FALSE.
      END IF
#endif
#ifndef T5
      DO testrun = 1, NUM_TEST_CALLS
        failed = failed .or. test5()
      END DO
      IF (failed) THEN
        failcode = failcode + 2 ** 4
        failed = .FALSE.
      END IF
#endif
#ifndef T6
      DO testrun = 1, NUM_TEST_CALLS
        failed = failed .or. test6()
      END DO
      IF (failed) THEN
        failcode = failcode + 2 ** 5
        failed = .FALSE.
      END IF
#endif
#ifndef T7
      DO testrun = 1, NUM_TEST_CALLS
        failed = failed .or. test7()
      END DO
      IF (failed) THEN
        failcode = failcode + 2 ** 6
        failed = .FALSE.
      END IF
#endif
      CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_copyout.F90:::
#ifndef T1
!T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER :: errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        CALL acc_create(c(1:LOOPCOUNT))

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))
          !$acc parallel
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        CALL acc_copyout(c(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END FUNCTION
#endif

#ifndef T2
!T2:runtime,data,executable-data,construct-independent,V:2.0-2.7
      LOGICAL FUNCTION test2()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c
        INTEGER :: errors = 0

        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        !$acc enter data create(c(1:LOOPCOUNT))

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))
          !$acc parallel
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        CALL acc_copyout(c(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif

#ifndef T3
!T3:runtime,data,executable-data,construct-independent,devonly,reference-counting,V:2.5-2.7
      LOGICAL FUNCTION test3()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c
        INTEGER :: errors = 0
        LOGICAL,DIMENSION(1):: devtest

        devtest(1) = .TRUE.
        !$acc enter data copyin(devtest(1:1))
        !$acc parallel present(devtest(1:1))
          devtest(1) = .FALSE.
        !$acc end parallel

        IF (devtest(1) .eqv. .TRUE.) THEN
          SEEDDIM(1) = 1
#         ifdef SEED
          SEEDDIM(1) = SEED
#         endif
          CALL RANDOM_SEED(PUT=SEEDDIM)
          CALL RANDOM_NUMBER(a)
          CALL RANDOM_NUMBER(b)
          c = 0

          !$acc enter data copyin(c(1:LOOPCOUNT))
          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))
            !$acc parallel
              !$acc loop
              DO x = 1, LOOPCOUNT
                c(x) = a(x) + b(x)
              END DO
            !$acc end parallel
            CALL acc_copyout(c(1:LOOPCOUNT))
          !$acc end data

          DO x = 1, LOOPCOUNT
            IF (abs(c(x)) .gt. PRECISION) THEN
              errors = errors + 1
            END IF
          END DO
        END IF

        IF (errors .eq. 0) THEN
          test3 = .FALSE.
        ELSE
          test3 = .TRUE.
        END IF
      END
#endif

#ifndef T4
!T4:runtime,data,executable-data,construct-independent,reference-counting,V:2.5-2.7
      LOGICAL FUNCTION test4()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c
        INTEGER :: errors = 0

        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        !$acc enter data create(c(1:LOOPCOUNT))
        !$acc enter data create(c(1:LOOPCOUNT))
        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))
          !$acc parallel
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data
        !$acc exit data delete(c(1:LOOPCOUNT))
        CALL acc_copyout(c(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test4 = .FALSE.
        ELSE
          test4 = .TRUE.
        END IF
      END
#endif

#ifndef T5
!T5:runtime,data,executable-data,construct-independent,reference-counting,devonly,V:2.5-2.7
      LOGICAL FUNCTION test5()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c
        INTEGER :: errors = 0
        LOGICAL,DIMENSION(1):: devtest
        devtest(1) = .TRUE.

        !$acc enter data copyin(devtest(1:1))
        !$acc parallel present(devtest(1:1))
          devtest(1) = .FALSE.
        !$acc end parallel

        IF (devtest(1) .eqv. .TRUE.) THEN
          SEEDDIM(1) = 1
#         ifdef SEED
          SEEDDIM(1) = SEED
#         endif
          CALL RANDOM_SEED(PUT=SEEDDIM)
          CALL RANDOM_NUMBER(a)
          CALL RANDOM_NUMBER(b)
          c = 0

          !$acc enter data create(c(1:LOOPCOUNT))
          !$acc enter data create(c(1:LOOPCOUNT))
          !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))
            !$acc parallel
              !$acc loop
              DO x = 1, LOOPCOUNT
                c(x) = a(x) + b(x)
              END DO
            !$acc end parallel
          !$acc end data
          CALL acc_copyout(c(1:LOOPCOUNT))
          !$acc exit data delete(c(1:LOOPCOUNT))

          DO x = 1, LOOPCOUNT
            IF (abs(c(x)) .gt. PRECISION) THEN
              errors = errors + 1
            END IF
          END DO
        END IF

        IF (errors .eq. 0) THEN
          test5 = .FALSE.
        ELSE
          test5 = .TRUE.
        END IF
      END
#endif


      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
#ifndef T3
        LOGICAL :: test3
#endif
#ifndef T4
        LOGICAL :: test4
#endif
#ifndef T5
        LOGICAL :: test5
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 1
          failed = .FALSE.
        END IF
#endif
#ifndef T3
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test3()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 2
          failed = .FALSE.
        END IF
#endif
#ifndef T4
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test4()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 3
          failed = .FALSE.
        END IF
#endif
#ifndef T5
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test5()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 4
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
        END PROGRAM


########## NEXT FILE ##########
acc_copyout_async.F90:::
#ifndef T1
!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data
        REAL(8) :: RAND
        INTEGER :: errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0
        CALL RANDOM_NUMBER(d)
        CALL RANDOM_NUMBER(e)
        f = 0

        !$acc enter data create(c(1:LOOPCOUNT), f(1:LOOPCOUNT))

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) present(c(1:LOOPCOUNT), f(1:LOOPCOUNT))
          !$acc parallel async(1)
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
          !$acc parallel async(2)
            !$acc loop
            DO x = 1, LOOPCOUNT
              f(x) = d(x) + e(x)
            END DO
          !$acc end parallel
          CALL acc_copyout_async(c(1:LOOPCOUNT), 1)
          CALL acc_copyout_async(f(1:LOOPCOUNT), 2)
        !$acc end data
        !$acc wait
        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO
        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif

      PROGRAM main
      IMPLICIT NONE
      INTEGER :: failcode, testrun
      LOGICAL :: failed
      INCLUDE "acc_testsuite.Fh"
      !Conditionally define test functions
#ifndef T1
      LOGICAL :: test1
#endif
      failcode = 0
      failed = .FALSE.

#ifndef T1
      DO testrun = 1, NUM_TEST_CALLS
        failed = failed .or. test1()
      END DO
      IF (failed) THEN
        failcode = failcode + 2 ** 0
        failed = .FALSE.
      END IF
#endif

      CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_copyout_async_with_len.F90:::
#ifndef T1
!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data
        REAL(8) :: RAND
        INTEGER :: errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0
        CALL RANDOM_NUMBER(d)
        CALL RANDOM_NUMBER(e)
        f = 0

        !$acc enter data create(c(1:LOOPCOUNT), f(1:LOOPCOUNT))

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) present(c(1:LOOPCOUNT), f(1:LOOPCOUNT))
          !$acc parallel async(1)
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
          !$acc parallel async(2)
            !$acc loop
            DO x = 1, LOOPCOUNT
              f(x) = d(x) + e(x)
            END DO
          !$acc end parallel
          CALL acc_copyout_async(c(1), LOOPCOUNT*8, 1)
          CALL acc_copyout_async(f(1), LOOPCOUNT*8, 2)
        !$acc end data

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO
        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif

      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif

        CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_copyout_finalize.F90:::
#ifndef T1
!T1:runtime,data,executable-data,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER :: errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        !$acc enter data create(c(1:LOOPCOUNT))
        !$acc enter data create(c(1:LOOPCOUNT))

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))
          !$acc parallel
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        CALL acc_copyout_finalize(c(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif


      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif

        CALL EXIT (failcode)
        END PROGRAM


########## NEXT FILE ##########
acc_copyout_finalize_async.F90:::
#ifndef T1
!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data
        REAL(8) :: RAND
        INTEGER :: errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0
        CALL RANDOM_NUMBER(d)
        CALL RANDOM_NUMBER(e)
        f = 0

        !$acc enter data create(c(1:LOOPCOUNT), f(1:LOOPCOUNT))
        !$acc enter data create(c(1:LOOPCOUNT), f(1:LOOPCOUNT))

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) present(c(1:LOOPCOUNT), f(1:LOOPCOUNT))
          !$acc parallel async(1)
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
          !$acc parallel async(2)
            !$acc loop
            DO x = 1, LOOPCOUNT
              f(x) = d(x) + e(x)
            END DO
          !$acc end parallel
          CALL acc_copyout_finalize_async(c(1:LOOPCOUNT), 1)
          CALL acc_copyout_finalize_async(f(1:LOOPCOUNT), 2)
          !$acc wait
        !$acc end data

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO
        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif


      PROGRAM main
      IMPLICIT NONE
      INTEGER :: failcode, testrun
      LOGICAL :: failed
      INCLUDE "acc_testsuite.Fh"
      !Conditionally define test functions
#ifndef T1
      LOGICAL :: test1
#endif
      failcode = 0
      failed = .FALSE.

#ifndef T1
      DO testrun = 1, NUM_TEST_CALLS
        failed = failed .or. test1()
      END DO
      IF (failed) THEN
        failcode = failcode + 2 ** 0
        failed = .FALSE.
      END IF
#endif

      CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_copyout_finalize_async_with_len.F90:::
#ifndef T1
!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data
        REAL(8) :: RAND
        INTEGER :: errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0
        CALL RANDOM_NUMBER(d)
        CALL RANDOM_NUMBER(e)
        f = 0

        !$acc enter data create(c(1:LOOPCOUNT), f(1:LOOPCOUNT))
        !$acc enter data create(c(1:LOOPCOUNT), f(1:LOOPCOUNT))

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) present(c(1:LOOPCOUNT), f(1:LOOPCOUNT))
          !$acc parallel async(1)
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
          !$acc parallel async(2)
            !$acc loop
            DO x = 1, LOOPCOUNT
              f(x) = d(x) + e(x)
            END DO
          !$acc end parallel
          CALL acc_copyout_finalize_async(c(1), LOOPCOUNT*8, 1)
          CALL acc_copyout_finalize_async(f(1), LOOPCOUNT*8, 2)
          !$acc wait
        !$acc end data

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO
        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif


    PROGRAM main
      IMPLICIT NONE
      INTEGER :: failcode, testrun
      LOGICAL :: failed
      INCLUDE "acc_testsuite.Fh"
      !Conditionally define test functions
#ifndef T1
      LOGICAL :: test1
#endif
      failcode = 0
      failed = .FALSE.

#ifndef T1
      DO testrun = 1, NUM_TEST_CALLS
        failed = failed .or. test1()
      END DO
      IF (failed) THEN
        failcode = failcode + 2 ** 0
        failed = .FALSE.
      END IF
#endif

      CALL EXIT (failcode)
    END PROGRAM


########## NEXT FILE ##########
acc_copyout_finalize_with_len.F90:::
#ifndef T1
!T1:runtime,data,executable-data,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        REAL(8) :: RAND
        INTEGER :: errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        !$acc enter data create(c(1:LOOPCOUNT))
        !$acc enter data create(c(1:LOOPCOUNT))

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))
          !$acc parallel
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        CALL acc_copyout_finalize(c(1), LOOPCOUNT*8)

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif


      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif

        CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_copyout_with_len.F90:::
#ifndef T1
!T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER :: errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        CALL acc_create(c(1:LOOPCOUNT))

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))
          !$acc parallel
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        CALL acc_copyout(c(1), LOOPCOUNT*8)

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif

#ifndef T2
!T2:runtime,data,executable-data,construct-independent,V:2.0-2.7
      LOGICAL FUNCTION test2()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c
        INTEGER :: errors = 0

        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        !$acc enter data create(c(1:LOOPCOUNT))

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))
          !$acc parallel
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        CALL acc_copyout(c(1), LOOPCOUNT*8)

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif


      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2**1
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_create.F90:::
#ifndef T1
!T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER :: errors
        errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        CALL acc_create(c(1:LOOPCOUNT))

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
          !$acc parallel present(c(1:LOOPCOUNT))
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        CALL acc_copyout(c(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif
#ifndef T2
!T2:runtime,data,executable-data,construct-independent,V:2.0-2.7
      LOGICAL FUNCTION test2()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c
        INTEGER:: errors
        errors = 0

        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c= 0

        CALL acc_create(c(1:LOOPCOUNT))

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
          !$acc parallel present(c(1:LOOPCOUNT))
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        !$acc exit data copyout(c(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif
#ifndef T3
!T3:runtime,compatibility-features,construct-independent,V:2.0-2.7
      LOGICAL FUNCTION test3()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER:: x
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c
        INTEGER:: errors
        errors = 0

        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        CALL acc_pcreate(c(1:LOOPCOUNT))

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))
          !$acc parallel
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        !$acc exit data copyout(c(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test3 = .FALSE.
        ELSE
          test3 = .TRUE.
        END IF
      END
#endif
#ifndef T4
!T4:runtime,compatibility-features,construct-independent,V:2.0-2.7
      LOGICAL FUNCTION test4()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER:: x
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c
        INTEGER:: errors
        errors = 0

        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        CALL acc_present_or_create(c(1:LOOPCOUNT))

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))
          !$acc parallel
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        !$acc exit data copyout(c(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test4 = .FALSE.
        ELSE
          test4 = .TRUE.
        END IF
      END
#endif


      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
#ifndef T3
        LOGICAL :: test3
#endif
#ifndef T4
        LOGICAL :: test4
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 1
          failed = .FALSE.
        END IF
#endif
#ifndef T3
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test3()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 2
          failed = .FALSE.
        END IF
#endif
#ifndef T4
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test4()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 3
          failed = .FALSE.
        END IF
#endif

        CALL EXIT (failcode)
        END PROGRAM


########## NEXT FILE ##########
acc_create_async.F90:::
#ifndef T1
!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data
        REAL(8) :: RAND
        INTEGER :: errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0
        CALL RANDOM_NUMBER(d)
        CALL RANDOM_NUMBER(e)
        f = 0

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))
          CALL acc_create_async(c(1:LOOPCOUNT), 1)
          CALL acc_create_async(f(1:LOOPCOUNT), 2)
          !$acc data present(c(1:LOOPCOUNT), f(1:LOOPCOUNT))
            !$acc parallel async(1)
              !$acc loop
              DO x = 1, LOOPCOUNT
                c(x) = a(x) + b(x)
              END DO
            !$acc end parallel
            !$acc parallel async(2)
              !$acc loop
              DO x = 1, LOOPCOUNT
                f(x) = d(x) + e(x)
              END DO
            !$acc end parallel
            !$acc wait
          !$acc end data
        !$acc end data

        !$acc exit data copyout(c(1:LOOPCOUNT), f(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO
        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif


      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif

        CALL EXIT (failcode)
        END PROGRAM


########## NEXT FILE ##########
acc_create_async_with_len.F90:::
#ifndef T1
!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data
        REAL(8) :: RAND
        INTEGER :: errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0
        CALL RANDOM_NUMBER(d)
        CALL RANDOM_NUMBER(e)
        f = 0

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))
          CALL acc_create_async(c(1), LOOPCOUNT*8, 1)
          CALL acc_create_async(f(1), LOOPCOUNT*8, 2)
          !$acc data present(c(1:LOOPCOUNT), f(1:LOOPCOUNT))
            !$acc parallel async(1)
              !$acc loop
              DO x = 1, LOOPCOUNT
                c(x) = a(x) + b(x)
              END DO
            !$acc end parallel
            !$acc parallel async(2)
              !$acc loop
              DO x = 1, LOOPCOUNT
                f(x) = d(x) + e(x)
              END DO
            !$acc end parallel
            !$acc wait
          !$acc end data
        !$acc end data

        !$acc exit data copyout(c(1:LOOPCOUNT), f(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO
        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif

      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif

        CALL EXIT (failcode)
        END PROGRAM


########## NEXT FILE ##########
acc_create_with_len.F90:::
#ifndef T1
!T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER :: errors
        errors = 0

        !Initilization
        SEEDDIM(1) = 1
        #ifdef SEED
        SEEDDIM(1) = SEED
        #endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        CALL acc_create(c(1), LOOPCOUNT*8)

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
          !$acc parallel present(c(1:LOOPCOUNT))
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        CALL acc_copyout(c(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif
#ifndef T2
!T2:runtime,data,executable-data,construct-independent,V:2.0-2.7
      LOGICAL FUNCTION test2()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER:: x
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c
        INTEGER :: errors
        errors = 0

        SEEDDIM(1) = 1
#ifdef SEED
        SEEDDIM(1) = SEED
#endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c= 0

        CALL acc_create(c(1), LOOPCOUNT*8)

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
          !$acc parallel present(c(1:LOOPCOUNT))
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        !$acc exit data copyout(c(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif
#ifndef T3
!T3:runtime,compatibility-features,construct-independent,V:2.0-2.7
      LOGICAL FUNCTION test3()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER:: x
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c
        INTEGER:: errors
        errors = 0

        SEEDDIM(1) = 1
#ifdef SEED
        SEEDDIM(1) = SEED
#endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        CALL acc_pcreate(c(1), LOOPCOUNT*8)

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))
          !$acc parallel
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        !$acc exit data copyout(c(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test3 = .FALSE.
        ELSE
          test3 = .TRUE.
        END IF
      END
#endif
#ifndef T4
!T4:runtime,compatibility-features,construct-independent,V:2.0-2.7
      LOGICAL FUNCTION test4()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER:: x
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c
        INTEGER:: errors
        errors = 0

        SEEDDIM(1) = 1
#ifdef SEED
        SEEDDIM(1) = SEED
#endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        CALL acc_present_or_create(c(1), LOOPCOUNT*8)

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT))
          !$acc parallel
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        !$acc exit data copyout(c(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test4 = .FALSE.
        ELSE
          test4 = .TRUE.
        END IF
      END
#endif



      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
#ifndef T3
        LOGICAL :: test3
#endif
#ifndef T4
        LOGICAL :: test4
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 1
          failed = .FALSE.
        END IF
#endif
#ifndef T3
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test3()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 2
          failed = .FALSE.
        END IF
#endif
#ifndef T4
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test4()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 3
          failed = .FALSE.
        END IF
#endif

        CALL EXIT (failcode)
        END PROGRAM


########## NEXT FILE ##########
acc_delete.F90:::
#ifndef T1
!T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER :: errors
        errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))

        !$acc data copyout(c(1:LOOPCOUNT))
          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        CALL acc_delete(a(1:LOOPCOUNT))
        CALL acc_delete(b(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif
#ifndef T2
!T2:runtime,data,executable-data,construct-independent,V:2.0-2.7
      LOGICAL FUNCTION test2()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER:: x
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c
        INTEGER:: errors
        errors = 0

        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        CALL acc_copyin(a(1:LOOPCOUNT))
        CALL acc_copyin(b(1:LOOPCOUNT))

        !$acc data copyout(c(1:LOOPCOUNT))
          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        CALL acc_delete(a(1:LOOPCOUNT))
        CALL acc_delete(b(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif


      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2**1
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_delete_async.F90:::
#ifndef T1
!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data
        INTEGER :: errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0
        CALL RANDOM_NUMBER(d)
        CALL RANDOM_NUMBER(e)
        f = 0

        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))

        !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT), f(1:LOOPCOUNT))
          !$acc parallel async(1)
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
          !$acc parallel async(2)
            !$acc loop
            DO x = 1, LOOPCOUNT
              f(x) = d(x) + e(x)
            END DO
          !$acc end parallel
          CALL acc_delete_async(a(1:LOOPCOUNT), 1)
          CALL acc_delete_async(b(1:LOOPCOUNT), 1)
          CALL acc_delete_async(d(1:LOOPCOUNT), 2)
          CALL acc_delete_async(e(1:LOOPCOUNT), 2)
          !$acc wait
        !$acc end data

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif
#ifndef T2
!T2:runtime,data,executable-data,devonly,async,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test2()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c!Data
        INTEGER,DIMENSION(1) :: devtest
        INTEGER :: errors = 0

        devtest(1) = 1
        !$acc enter data copyin(devtest(1:1))
        !$acc parallel present(devtest(1:1))
          devtest(1) = 0
        !$acc end parallel

        IF (devtest(1) == 1) THEN
          CALL RANDOM_NUMBER(a)
          CALL RANDOM_NUMBER(b)
          c = 0

          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))
          !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))
            !$acc parallel async(1)
              !$acc loop
              DO x = 1, LOOPCOUNT
                c(x) = a(x) + b(x)
              END DO
            !$acc end parallel
          !$acc end data
          CALL acc_delete_async(c(1:LOOPCOUNT), 1)
          !$acc enter data copyin(c(1:LOOPCOUNT)) async(1)
          !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))
            !$acc parallel async(1)
              !$acc loop
              DO x = 1, LOOPCOUNT
                c(x) = c(x) + a(x) + b(x)
              END DO
            !$acc end parallel
          !$acc end data
          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))

          DO x = 1, LOOPCOUNT
            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
              errors = errors + 1
            END IF
          END DO
        END IF

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif


      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2**1
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_delete_async_with_len.F90:::
#ifndef T1
!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data
        INTEGER :: errors = 0


        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0
        CALL RANDOM_NUMBER(d)
        CALL RANDOM_NUMBER(e)
        f = 0

        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))

        !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT), f(1:LOOPCOUNT))
          !$acc parallel async(1)
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
          !$acc parallel async(2)
            !$acc loop
            DO x = 1, LOOPCOUNT
              f(x) = d(x) + e(x)
            END DO
          !$acc end parallel
          CALL acc_delete_async(a(1), LOOPCOUNT*8, 1)
          CALL acc_delete_async(b(1), LOOPCOUNT*8, 1)
          CALL acc_delete_async(d(1), LOOPCOUNT*8, 2)
          CALL acc_delete_async(e(1), LOOPCOUNT*8, 2)
          !$acc wait
        !$acc end data

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif
#ifndef T2
!T2:runtime,data,executable-data,devonly,async,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test2()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER,DIMENSION(1):: devtest
        INTEGER :: errors = 0

        devtest(1) = 1
        !$acc enter data copyin(devtest(1:1))
        !$acc parallel present(devtest(1:1))
          devtest(1) = 0
        !$acc end parallel
        IF (devtest(1) == 1) THEN
          CALL RANDOM_NUMBER(a)
          CALL RANDOM_NUMBER(b)
          c = 0

          !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))
          !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))
            !$acc parallel async(1)
              !$acc loop
              DO x = 1, LOOPCOUNT
                c(x) = a(x) + b(x)
              END DO
            !$acc end parallel
          !$acc end data
          CALL acc_delete_async(c(1), LOOPCOUNT*8, 1)
          !$acc enter data copyin(c(1:LOOPCOUNT)) async(1)
          !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))
            !$acc parallel async(1)
              !$acc loop
              DO x = 1, LOOPCOUNT
                c(x) = c(x) + a(x) + b(x)
              END DO
            !$acc end parallel
          !$acc end data
          !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))

          DO x = 1, LOOPCOUNT
            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
              errors = errors + 1
            END IF
          END DO
        END IF

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif


      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2**1
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_delete_finalize.F90:::
#ifndef T1
!T1:runtime,data,executable-data,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER :: errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))

        !$acc data copyout(c(1:LOOPCOUNT))
          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        CALL acc_delete_finalize(a(1:LOOPCOUNT))
        CALL acc_delete_finalize(b(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif
#ifndef T2
!T2:runtime,data,executable-data,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test2()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER :: errors = 0

        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        CALL acc_copyin(a(1:LOOPCOUNT))
        CALL acc_copyin(a(1:LOOPCOUNT))
        CALL acc_copyin(b(1:LOOPCOUNT))
        CALL acc_copyin(b(1:LOOPCOUNT))

        !$acc data copyout(c(1:LOOPCOUNT))
          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        CALL acc_delete_finalize(a(1:LOOPCOUNT))
        CALL acc_delete_finalize(b(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif


      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2**1
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_delete_finalize_async.F90:::
#ifndef T1
!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data
        INTEGER :: errors
        errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0
        CALL RANDOM_NUMBER(d)
        CALL RANDOM_NUMBER(e)
        f = 0

        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))
        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))

        !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT), f(1:LOOPCOUNT))
          !$acc parallel async(1)
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
          !$acc parallel async(2)
            !$acc loop
            DO x = 1, LOOPCOUNT
              f(x) = d(x) + e(x)
            END DO
          !$acc end parallel
          CALL acc_delete_finalize_async(a(1:LOOPCOUNT), 1)
          CALL acc_delete_finalize_async(b(1:LOOPCOUNT), 1)
          CALL acc_delete_finalize_async(d(1:LOOPCOUNT), 2)
          CALL acc_delete_finalize_async(e(1:LOOPCOUNT), 2)
          !$acc wait
        !$acc end data

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif
#ifndef T2
!T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test2()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER :: errors
        errors = 0

        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))
        !$acc enter data copyin(c(1:LOOPCOUNT))
        !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))
          !$acc parallel async(1)
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        CALL acc_delete_finalize_async(c(1:LOOPCOUNT), 1)

        !$acc enter data copyin(c(1:LOOPCOUNT)) async(1)
        !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))
          !$acc parallel async(1)
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = c(x) + a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif


      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2**1
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_delete_finalize_async_with_len.F90:::
#ifndef T1
!T1:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f !Data
        INTEGER :: errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0
        CALL RANDOM_NUMBER(d)
        CALL RANDOM_NUMBER(e)
        f = 0

        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))
        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT))

        !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT), f(1:LOOPCOUNT))
          !$acc parallel async(1)
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
          !$acc parallel async(2)
            !$acc loop
            DO x = 1, LOOPCOUNT
              f(x) = d(x) + e(x)
            END DO
          !$acc end parallel
          CALL acc_delete_finalize_async(a(1), LOOPCOUNT*8, 1)
          CALL acc_delete_finalize_async(b(1), LOOPCOUNT*8, 1)
          CALL acc_delete_finalize_async(d(1), LOOPCOUNT*8, 2)
          CALL acc_delete_finalize_async(e(1), LOOPCOUNT*8, 2)
          !$acc wait
        !$acc end data

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
          IF (abs(f(x) - (d(x) + e(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif
#ifndef T2
!T2:runtime,data,executable-data,async,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test2()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER :: errors = 0

        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))
        !$acc enter data copyin(c(1:LOOPCOUNT))
        !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))
          !$acc parallel async(1)
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        CALL acc_delete_finalize_async(c(1), LOOPCOUNT*8, 1)

        !$acc enter data copyin(c(1:LOOPCOUNT)) async(1)
        !$acc data present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT))
          !$acc parallel async(1)
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = c(x) + a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif


      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2**1
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_delete_finalize_with_len.F90:::
#ifndef T1
!T1:runtime,data,executable-data,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER :: errors
        errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))

        !$acc data copyout(c(1:LOOPCOUNT))
          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        CALL acc_delete_finalize(a(1), LOOPCOUNT*8)
        CALL acc_delete_finalize(b(1), LOOPCOUNT*8)

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif
#ifndef T2
!T2:runtime,data,executable-data,construct-independent,V:2.5-2.7
      LOGICAL FUNCTION test2()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER :: errors
        errors = 0

        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        CALL acc_copyin(a(1:LOOPCOUNT))
        CALL acc_copyin(a(1:LOOPCOUNT))
        CALL acc_copyin(b(1:LOOPCOUNT))
        CALL acc_copyin(b(1:LOOPCOUNT))

        !$acc data copyout(c(1:LOOPCOUNT))
          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        CALL acc_delete_finalize(a(1), LOOPCOUNT*8)
        CALL acc_delete_finalize(b(1), LOOPCOUNT*8)

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif

      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2**1
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_delete_with_len.F90:::
#ifndef T1
!T1:runtime,data,executable-data,construct-independent,V:2.0-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER :: errors
        errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        !$acc enter data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))

        !$acc data copyout(c(1:LOOPCOUNT))
          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        CALL acc_delete(a(1), LOOPCOUNT*8)
        CALL acc_delete(b(1), LOOPCOUNT*8)

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif
#ifndef T2
!T2:runtime,data,executable-data,construct-independent,V:2.0-2.7
      LOGICAL FUNCTION test2()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER :: errors
        errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        CALL acc_copyin(a(1:LOOPCOUNT))
        CALL acc_copyin(b(1:LOOPCOUNT))

        !$acc data copyout(c(1:LOOPCOUNT))
          !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        CALL acc_delete(a(1), LOOPCOUNT*8)
        CALL acc_delete(b(1), LOOPCOUNT*8)

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif


      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
        failcode = 0
        failed = .FALSE.
#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2**1
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_deviceptr.F90:::
#ifndef T1
!T1:runtime,data,executable-data,construct-independent,V:3.3
    LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        REAL(8), DIMENSION(LOOPCOUNT) :: a, b, c  !Data
        REAL(8), POINTER, DIMENSION(:) :: a_ptr, b_ptr, d_ptr
        INTEGER :: errors = 0
        INTEGER :: x, i

        !Initilization
        SEEDDIM(1) = 1
        #ifdef SEED
            SEEDDIM(1) = SEED
        #endif
        CALL RANDOM_SEED(PUT=SEEDDIM)

        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)

        DO i = 1, LOOPCOUNT
            c(i) = 0
        END DO

        !$acc enter data copyin(a(1:n), b(1:n)) create(c(1:n))

        a_ptr = acc_deviceptr(a)
        b_ptr = acc_deviceptr(b)
        d_ptr = acc_deviceptr(c)

        !$acc data deviceptr(a_ptr, b_ptr, c_ptr)
            !$acc parallel
                !$acc loop
                DO x = 0, LOOPCOUNT
                    d_ptr(x) = a_ptr(x) + b_ptr(x);
                END DO
                !$acc end loop
            !$acc end parallel
        !$acc end data

        !$acc exit data copyout(c(1:n)) delete(a(1:n), b(1:n))

        DO x = 0, LOOPCOUNT
            IF (ABS(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
                errors = errors + 1
            END IF
        END DO

        IF (errors .eq. 0) THEN
            test1 = .FALSE.
        ELSE
            test1 = .TRUE.
        END IF
    END
#endif

PROGRAM main
    IMPLICIT NONE
    INTEGER :: failcode, testrun
    LOGICAL :: failed
    INCLUDE "acc_testsuite.Fh"
#ifndef T1
    LOGICAL :: test1
#endif
    failed = .FALSE.
    failcode = 0
#ifndef T1
    DO testrun = 1, NUM_TEST_CALLS
      failed = failed .or. test1()
    END DO
    IF (failed) THEN
      failcode = failcode + 2 ** 0
      failed = .FALSE.
    END IF
#endif
    CALL EXIT (failcode)
  END PROGRAM

########## NEXT FILE ##########
acc_free.F90:::
#ifndef T1
!T1:runtime,data,executable-data,V:3.3
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        REAL(8),DIMENSION(LOOPCOUNT):: initial_memory, final_memory !Data
        INTEGER, POINTER :: a(:)
        INTEGER :: errors = 0

        initial_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);
        
        ALLOCATE(a(n))

        CALL acc_free(a)

        final_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory);

        ALLOCATE(a(N))

        IF (final_memory .lt. (initial_memory + size(a))) THEN
            errors = errors + 1
        END IF

        test1 = .FALSE.
      END
#endif


PROGRAM main
    IMPLICIT NONE
    INTEGER :: failcode, testrun
    LOGICAL :: failed
    INCLUDE "acc_testsuite.Fh"
    !Conditionally define test functions
#ifndef T1
    LOGICAL :: test1
#endif
    failcode = 0
    failed = .FALSE.

#ifndef T1
    DO testrun = 1, NUM_TEST_CALLS
      failed = failed .or. test1()
    END DO
    IF (failed) THEN
      failcode = failcode + 2 ** 0
      failed = .FALSE.
    END IF
#endif
    CALL EXIT (failcode)
  END PROGRAM


########## NEXT FILE ##########
acc_get_default_async.F90:::
#ifndef T1
!T1:runtime,async,construct-independent,internal-control-values,V:2.5-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x, holder !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER :: errors
        INTEGER :: acc_get_default_async
        errors = 0
        holder = acc_get_default_async()
        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))
          !$acc parallel async
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
          !$acc wait(holder)
        !$acc end data

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (acc_get_default_async() .lt. 0) THEN
          errors = errors + 1
        END IF

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif


      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_get_device_num.F90:::
#ifndef T1
!T1:runtime,construct-independent,internal-control-values,set,V:1.0-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        INTEGER :: errors
        errors = 0

        IF (acc_get_device_type() .ne. acc_device_none) THEN
          DO x = 1, acc_get_num_devices(acc_get_device_type())
            CALL acc_set_device_num(x, acc_get_device_type())
            IF (acc_get_device_num(acc_get_device_type()) .ne. x) THEN
              errors = errors + 1
            END IF
          END DO
        END IF

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif


      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_get_num_devices.F90:::
#ifndef T1
!T1:runtime,construct-independent,internal-control-values,V:1.0-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: errors
        errors = 0

        IF (acc_get_device_type() .ne. acc_device_none) THEN
          IF (acc_get_num_devices(acc_get_device_type()) .eq. 0) THEN
            errors = errors + 1
          END IF
        END IF

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif


      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_get_property.F90:::
#ifndef T1
!T1:runtime,construct-independent,internal-control-values,nonvalidating,V:2.6-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: output
        IF (acc_get_device_type() .ne. acc_device_none) THEN
          output = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_memory)
          output = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory)
        END IF
        test1 = .FALSE.
      END
#endif


      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_get_property_string.F90:::
#ifndef T1
!T1:runtime,construct-independent,internal-control-values,nonvalidating,V:2.6-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        CHARACTER(len=:),ALLOCATABLE :: output1
        CHARACTER(len=:),ALLOCATABLE :: output2
        CHARACTER(len=:),ALLOCATABLE :: output3
        IF (acc_get_device_type() .ne. acc_device_none) THEN
          ! Hopefully, the string is long enough:
          allocate(character(len=1024) :: output1, output2, output3)
          CALL acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), &
                                                          acc_property_name, output1)
          CALL acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), &
                                                          acc_property_vendor, output2)
          CALL acc_get_property_string(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), &
                                                          acc_property_driver, output3)
        END IF
        test1 = .FALSE.
      END
#endif

      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_hostptr.F90:::
#ifndef T1
!T1:runtime,data,V:3.3
    LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        REAL,  DIMENSION(LOOPCOUNT) :: a !Data
        INTEGER :: err = 0

        CALL acc_create(a)

        IF (a /= acc_hostptr(a)) THEN
                err = err + 1
        END IF

        CALL acc_delete(a)

        IF (err .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif

     PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM




########## NEXT FILE ##########
acc_init.F90:::
#ifndef T1
!T1:runtime,construct-independent,internal-control-values,init,nonvalidating,V:1.0-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        IF (acc_get_device_type() .ne. acc_device_none) THEN
          CALL acc_init(acc_get_device_type())
        END IF

        test1 = .FALSE.
      END
#endif


      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_is_present.F90:::
#ifndef T1
!T1:runtime,devonly,construct-independent,present,V:2.0-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a !Data
        INTEGER,DIMENSION(1):: devtest
        INTEGER :: errors
        errors = 0

        devtest(1) = 1
        !$acc enter data copyin(devtest(1:1))
        !$acc parallel present(devtest(1:1))
          devtest(1) = 0
        !$acc end parallel

        !$acc enter data create(a(1:LOOPCOUNT))
        IF (acc_is_present(a(1:LOOPCOUNT)) .eqv. .FALSE.) THEN
          errors = errors + 1
          PRINT*, 1
        END IF
        !$acc exit data delete(a(1:LOOPCOUNT))

        IF (devtest(1) .eq. 1) THEN
          IF (acc_is_present(a(1:LOOPCOUNT)) .eqv. .TRUE.) THEN
            errors = errors + 1
            PRINT*, 2
          END IF
        END IF

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif


      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_is_present_with_len.F90:::
#ifndef T1
!T1:runtime,devonly,construct-independent,present,V:2.0-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a !Data
        INTEGER,DIMENSION(1):: devtest
        INTEGER :: errors = 0

        devtest(1) = 1
        !$acc enter data copyin(devtest(1:1))
        !$acc parallel present(devtest(1:1))
          devtest(1) = 0
        !$acc end parallel

        !$acc enter data create(a(1:LOOPCOUNT))
        IF (acc_is_present(a(1), LOOPCOUNT*8) .eqv. .FALSE.) THEN
          errors = errors + 1
        END IF
        !$acc exit data delete(a(1:LOOPCOUNT))

        IF (devtest(1) .eq. 1) THEN
          IF (acc_is_present(a(1), LOOPCOUNT*8) .eqv. .TRUE.) THEN
            errors = errors + 1
          END IF
        END IF

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif


      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_malloc.F90:::
#ifndef T1
!T1:runtime,construct-independent,internal-control-values,init,nonvalidating,V:3.3
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        REAL(8),DIMENSION(LOOPCOUNT):: initial_memory, final_memory !Data
        INTEGER, POINTER :: a(:)
        INTEGER :: errors = 0

        initial_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory)
        
        CALL acc_malloc(a(N))

        IF (initial_memory .ne. 0) THEN
          test1 = .FALSE.
        END IF

        final_memory = acc_get_property(acc_get_device_num(acc_get_device_type()), acc_get_device_type(), acc_property_free_memory)

        DO x = 1, LOOPCOUNT
          IF (final_memory + N * sizeof(a(1)) .gt. initial_memory) THEN
            errors = errors + 1
          END IF
        END DO

        CALL acc_free(a(N))

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif

      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM



########## NEXT FILE ##########
acc_map_data.F90:::
#ifndef T1
!T1:runtime,data,executable-data,construct-independent,V:3.3
    LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e !Data
        INTEGER :: errors = 0
        INTEGER :: x,i
        !Initilization
        SEEDDIM(1) = 1
        #ifdef SEED
            SEEDDIM(1) = SEED
        #endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)

        CALL acc_map_data(C_LOC(c), C_LOC(d), LOOPCOUNT)

        !$acc data copyin(a, b) present(c)
            !$acc parallel
                !$acc loop
                DO i = 1, LOOPCOUNT
                    c(i) = a(i) + b(i)
                END DO
                !$acc end loop
            !$acc end parallel
        !$acc end data


        !$acc update host(c(1:LOOPCOUNT))
        DO x = 1, LOOPCOUNT
            IF (ABS(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
            END IF
        END DO

        CALL acc_unmap_data(c)
        CALL acc_free(d)

        IF (errors .eq. 0) THEN
            test1 = .FALSE.
        ELSE
            test1 = .TRUE.
        END IF
    END
#endif


PROGRAM main
    IMPLICIT NONE
    INTEGER :: failcode, testrun
    LOGICAL :: failed
    INCLUDE "acc_testsuite.Fh"
#ifndef T1
    LOGICAL :: test1
#endif
    failed = .FALSE.
    failcode = 0
#ifndef T1
    DO testrun = 1, NUM_TEST_CALLS
      failed = failed .or. test1()
    END DO
    IF (failed) THEN
      failcode = failcode + 2 ** 0
      failed = .FALSE.
    END IF
#endif
    CALL EXIT (failcode)
  END PROGRAM

########## NEXT FILE ##########
acc_memcpy_d2d.F90:::
#ifndef T1
!T1:runtime,data,executable-data,construct-independent,V:3.3
    INTEGER FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        REAL(8), DIMENSION(LOOPCOUNT) :: a, b, c  
        INTEGER :: errors = 0
        INTEGER :: x, i

        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)

        CALL acc_set_device_num(0, acc_device_nvidia)
        !$acc enter data create(a(1:LOOPCOUNT))
        CALL acc_set_device_num(1, acc_device_nvidia)
        !$acc enter data create(b(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
            ! a(x) = rand() / (real(8)(RAND_MAX / 10))
            b(x) = a(x)
            c(x) = 4 * a(x)
        END DO
        CALL acc_set_device_num(0, acc_device_nvidia)
        !$acc update device(a(1:LOOPCOUNT))
        CALL acc_set_device_num(1, acc_device_nvidia)
        !$acc update device(b(1:LOOPCOUNT))

        CALL acc_set_device_num(0, acc_device_nvidia)
        !$acc data present(a)
            !$acc parallel loop
            DO i = 1, LOOPCOUNT
                a(i) = a(i) * 2
            END DO
            CALL acc_memcpy_d2d(b, a, LOOPCOUNT * 8, 1, 0)
        !$acc end data

        CALL acc_set_device_num(1, acc_device_nvidia)
        !$acc parallel loop
        DO i = 1, LOOPCOUNT
            b(i) = b(i) * 2
        END DO

        !$acc update host(b(1:LOOPCOUNT))

        DO x = 1, LOOPCOUNT
            IF (ABS(b(x) - c(x)) > PRECISION) THEN
                errors = errors + 1
                EXIT
            END IF
        END DO

        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT))

        test1 = errors
    END FUNCTION test1
#endif

PROGRAM main
    IMPLICIT NONE
    INTEGER :: failcode, testrun
    INTEGER :: failed
    INCLUDE "acc_testsuite.Fh"
#ifndef T1
    INTEGER :: test1
#endif
    failed = 0
    failcode = 0
#ifndef T1
    DO testrun = 1, NUM_TEST_CALLS
        failed = failed + test1()
    END DO
    IF (failed /= 0) THEN
        failcode = failcode + 2 ** 0
    END IF
#endif
    CALL EXIT (failcode)
END PROGRAM main

########## NEXT FILE ##########
acc_on_device.F90:::
#ifndef T1
!T1:runtime,construct-independent,internal-control-values,present,V:1.0-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: errors
        INTEGER :: device_type
        errors = 0
        device_type = acc_get_device_type()
        IF (device_type .ne. acc_device_none) THEN
          !$acc parallel
            IF (acc_on_device(device_type) .eqv. .FALSE.) THEN
              errors = errors + 1
            END IF
          !$acc end parallel
        ELSE
          !$acc parallel
            IF (acc_on_device(acc_device_host) .eqv. .FALSE.) THEN
              errors = errors + 1
            END IF
          !$acc end parallel
        END IF

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif


      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_set_default_async.F90:::
#ifndef T1
!T1:runtime,async,construct-independent,internal-control-values,set,V:2.5-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_host, b_host !Data
        INTEGER :: errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        a_host = a
        b_host = b
        c = 0

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))
          CALL acc_set_default_async(1)
          !$acc parallel async
            !$acc loop
            DO x = 1, LOOPCOUNT
              a(x) = a(x) * a(x)
            END DO
          !$acc end parallel
          CALL acc_set_default_async(2)
          !$acc parallel async
            !$acc loop
            DO x = 1, LOOPCOUNT
              b(x) = b(x) * b(x)
            END DO
          !$acc end parallel
          !$acc parallel async(1) wait(2)
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
          !$acc wait(1)
        !$acc end data

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a_host(x) * a_host(x) + b_host(x) * b_host(x))) .gt. 4 * PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif


      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_set_device_num.F90:::
#ifndef T1
!T1:runtime,construct-independent,internal-control-values,set,V:2.0-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x, y !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a !Data
        REAL(8),DIMENSION(:, :),ALLOCATABLE :: host_copy
        INTEGER :: errors = 0

        CALL RANDOM_SEED
        ALLOCATE(host_copy(acc_get_num_devices(acc_get_device_type()), LOOPCOUNT))

        IF (acc_get_device_type() .ne. acc_device_none) THEN
          !host_copy(acc_get_num_devices(acc_get_device_type()), LOOPCOUNT)
          DO x = 1, acc_get_num_devices(acc_get_device_type())
            DO y = 1, LOOPCOUNT
              CALL RANDOM_NUMBER(a)
              host_copy(x, :) = a
            END DO
            call acc_set_device_num(x, acc_get_device_type())
            !$acc enter data copyin(a(1:LOOPCOUNT))
          END DO

          DO x = 1, acc_get_num_devices(acc_get_device_type())
            call acc_set_device_num(x, acc_get_device_type())
            !$acc data present(a(1:LOOPCOUNT))
              !$acc parallel
                !$acc loop
                DO y = 1, LOOPCOUNT
                  a(y) = a(y) + 1
                END DO
              !$acc end parallel
            !$acc end data
          END DO

          DO x = 1, acc_get_num_devices(acc_get_device_type())
            call acc_set_device_num(x, acc_get_device_type())
            !$acc exit data copyout(a(1:LOOPCOUNT))
            DO y = 1, LOOPCOUNT
              IF (abs(a(y) - (host_copy(x, y) + 1)) .gt. PRECISION) THEN
                errors = errors + 1
              END IF
            END DO
          END DO
        END IF

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif


      PROGRAM test_acc_set_device_num
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM

########## NEXT FILE ##########
acc_set_device_type.F90:::
#ifndef T1
!T1:runtime,construct-independent,internal-control-values,set,V:1.0-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: errors = 0
        INTEGER :: device_type

        device_type = acc_get_device_type()
        CALL acc_set_device_type(device_type)
        IF (acc_get_device_type() .ne. device_type) THEN
          errors = errors + 1
        END IF

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif


      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_shutdown.F90:::
#ifndef T1
!T1:runtime,construct-independent,internal-control-values,shutdown,nonvalidating,V:1.0-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        IF (acc_get_device_type() .ne. acc_device_none) THEN
          CALL acc_shutdown(acc_get_device_type())
        END IF

        test1 = .FALSE.
      END
#endif


      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM
########## NEXT FILE ##########
acc_unmap_data.F90:::
#ifndef T1
!T1:runtime,data,executable-data,construct-independent,V:3.3
    LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        REAL(8),DIMENSION(LOOPCOUNT) :: a, b, c, d, e !Data
        INTEGER :: errors = 0
        INTEGER :: x,i

        !Initilization 
        SEEDDIM(1) = 1
        #ifdef SEED
            SEEDDIM(1) = SEED
        #endif
        CALL RANDOM_SEED(PUT=SEEDDIM)

        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)

        CALL acc_map_data(C_LOC(c), C_LOC(d), LOOPCOUNT)

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) present(c(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))
            !$acc parallel
                !$acc loop
                    DO i = 0, LOOPCOUNT
                        c(x) = a(x) + b(x)
                    END DO
                !$acc end loop
            !$acc end parallel
        !$acc end data 

        !$acc update host(c(0:n))
                    
        DO x = 0, LOOPCOUNT
            IF (ABS(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
                errors = errors + 1
            END IF
        END DO

        CALL acc_unmap_data(C_LOC(c))
        CALL acc_free(C_LOC(d))

        IF (errors .eq. 0) THEN
            test1 = .FALSE.
        ELSE
            test1 = .TRUE.
        END IF
    END
#endif

PROGRAM main
    IMPLICIT NONE
    INTEGER :: failcode, testrun
    LOGICAL :: failed
    INCLUDE "acc_testsuite.Fh"
#ifndef T1
    LOGICAL :: test1
#endif
    failed = .FALSE.
    failcode = 0
#ifndef T1
    DO testrun = 1, NUM_TEST_CALLS
      failed = failed .or. test1()
    END DO
    IF (failed) THEN
      failcode = failcode + 2 ** 0
      failed = .FALSE.
    END IF
#endif
    CALL EXIT (failcode)
  END PROGRAM

########## NEXT FILE ##########
acc_update_device.F90:::
#ifndef T1
!T1:runtime,data,executable-data,construct-independent,update,V:2.0-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER :: errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        !$acc data copyout(c(1:LOOPCOUNT)) create(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
          CALL acc_update_device(a(1:LOOPCOUNT))
          CALL acc_update_device(b(1:LOOPCOUNT))
          !$acc parallel
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif
#ifndef T2
!T2:runtime,data,executable-data,devonly,construct-independent,update,V:2.0-2.7
      LOGICAL FUNCTION test2()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER,DIMENSION(1):: devtest
        INTEGER :: errors = 0

        devtest(1) = 1
        !$acc enter data copyin(devtest(1:1))
        !$acc parallel present(devtest(1:1))
          devtest(1) = 0
        !$acc end parallel

        IF (devtest(1) .eq. 1) THEN
          CALL RANDOM_NUMBER(a)
          CALL RANDOM_NUMBER(b)
          c = 0

          !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
            !$acc parallel
              !$acc loop
              DO x = 1, LOOPCOUNT
                a(x) = a(x) * a(x)
              END DO
            !$acc end parallel
            CALL acc_update_device(a(1:LOOPCOUNT))
            !$acc parallel
              !$acc loop
              DO x = 1, LOOPCOUNT
                b(x) = b(x) * b(x)
              END DO
            !$acc end parallel
            CALL acc_update_device(b(1:LOOPCOUNT))
            !$acc parallel
              !$acc loop
              DO x = 1, LOOPCOUNT
                c(x) = a(x) + b(x)
              END DO
            !$acc end parallel
          !$acc end data

          DO x = 1, LOOPCOUNT
            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
              errors = errors + 1
            END IF
          END DO
        END IF

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif


      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 1
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_update_device_async.F90:::
#ifndef T1
!T1:runtime,data,executable-data,async,construct-independent,update,V:2.5-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_host, b_host !Data
        INTEGER :: errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0
        a_host = a
        b_host = b

        !$acc data create(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))
          CALL acc_update_device_async(a(1:LOOPCOUNT), 1)
          !$acc parallel async(1)
            !$acc loop
            DO x = 1, LOOPCOUNT
              a(x) = a(x) * a(x)
            END DO
          !$acc end parallel
          CALL acc_update_device_async(b(1:LOOPCOUNT), 2)
          !$acc parallel async(2)
            !$acc loop
            DO x = 1, LOOPCOUNT
              b(x) = b(x) * b(x)
            END DO
          !$acc end parallel
          !$acc parallel async(1) wait(2)
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
          !$acc wait(1)
        !$acc end data

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - ((a_host(x) * a_host(x)) + (b_host(x) * b_host(x)))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif
#ifndef T2
!T2:runtime,data,executable-data,devonly,async,construct-independent,update,V:2.5-2.7
      LOGICAL FUNCTION test2()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER,DIMENSION(1):: devtest
        INTEGER :: errors = 0

        devtest(1) = 1
        !$acc enter data copyin(devtest(1:1))
        !$acc parallel present(devtest(1:1))
          devtest(1) = 0
        !$acc end parallel
        IF (devtest(1) .eq. 1) THEN
          CALL RANDOM_NUMBER(a)
          CALL RANDOM_NUMBER(b)
          c = 0

          !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
            !$acc parallel async(1)
              !$acc loop
              DO x = 1, LOOPCOUNT
                a(x) = a(x) * a(x)
              END DO
            !$acc end parallel
            CALL acc_update_device_async(a(1:LOOPCOUNT), 1)
            !$acc parallel async(2)
              !$acc loop
              DO x = 1, LOOPCOUNT
                b(x) = b(x) * b(x)
              END DO
            !$acc end parallel
            CALL acc_update_device_async(b(1:LOOPCOUNT), 2)
            !$acc parallel async(1) wait(2)
              !$acc loop
              DO x = 1, LOOPCOUNT
                c(x) = a(x) + b(x)
              END DO
            !$acc end parallel
            !$acc wait(1)
          !$acc end data

          DO x = 1, LOOPCOUNT
            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
              errors = errors + 1
            END IF
          END DO
        END IF

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif

      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 1
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_update_device_async_with_len.F90:::
#ifndef T1
!T1:runtime,data,executable-data,async,construct-independent,update,V:2.5-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, a_host, b_host !Data
        INTEGER :: errors
        errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)
        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0
        a_host = a
        b_host = b

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) copyout(c(1:LOOPCOUNT))
          CALL acc_update_device_async(a(1), LOOPCOUNT*8, 1)
          !$acc parallel async(1)
            !$acc loop
            DO x = 1, LOOPCOUNT
              a(x) = a(x) * a(x)
            END DO
          !$acc end parallel
          CALL acc_update_device_async(b(1), LOOPCOUNT*8, 2)
          !$acc parallel async(2)
            !$acc loop
            DO x = 1, LOOPCOUNT
              b(x) = b(x) * b(x)
            END DO
          !$acc end parallel
          !$acc parallel async(1) wait(2)
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
          !$acc wait(1)
        !$acc end data

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - ((a_host(x) * a_host(x)) + (b_host(x) * b_host(x)))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif
#ifndef T2
!T2:runtime,data,executable-data,devonly,async,construct-independent,update,V:2.5-2.7
      LOGICAL FUNCTION test2()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER,DIMENSION(1):: devtest
        INTEGER :: errors
        errors = 0

        devtest(1) = 1
        !$acc enter data copyin(devtest(1:1))
        !$acc parallel present(devtest(1:1))
          devtest(1) = 0
        !$acc end parallel
        IF (devtest(1) .eq. 1) THEN
          CALL RANDOM_NUMBER(a)
          CALL RANDOM_NUMBER(b)
          c = 0

          !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
            !$acc parallel async(1)
              !$acc loop
              DO x = 1, LOOPCOUNT
                a(x) = a(x) * a(x)
              END DO
            !$acc end parallel
            CALL acc_update_device_async(a(1), LOOPCOUNT*8, 1)
            !$acc parallel async(2)
              !$acc loop
              DO x = 1, LOOPCOUNT
                b(x) = b(x) * b(x)
              END DO
            !$acc end parallel
            CALL acc_update_device_async(b(1), LOOPCOUNT*8, 2)
            !$acc parallel async(1), wait(2)
              !$acc loop
               DO x = 1, LOOPCOUNT
                 c(x) = a(x) + b(x)
               END DO
            !$acc end parallel
            !$acc wait(1)
          !$acc end data

          DO x = 1, LOOPCOUNT
            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
              errors = errors + 1
            END IF
          END DO
        END IF

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif


      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
        !Conditionally define test functions
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
        failcode = 0
        failed = .FALSE.

#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 1
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM


########## NEXT FILE ##########
acc_update_device_with_len.F90:::
#ifndef T1
!T1:runtime,data,executable-data,devonly,construct-independent,update,V:2.0-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER,DIMENSION(1):: devtest
        REAL(8) :: RAND
        INTEGER :: errors = 0

        devtest(1) = 1
        !$acc enter data copyin(devtest(1:1))
        !$acc parallel
          devtest(1) = 0
        !$acc end parallel

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)

        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        !$acc data copyout(c(1:LOOPCOUNT)) create(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
          CALL acc_update_device(a(1), LOOPCOUNT*8)
          CALL acc_update_device(b(1), LOOPCOUNT*8)
          !$acc parallel
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif
#ifndef T2
!T2:runtime,data,executable-data,devonly,construct-independent,update,V:2.0-2.7
      LOGICAL FUNCTION test2()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        INTEGER,DIMENSION(1):: devtest
        REAL(8) :: RAND
        INTEGER :: errors = 0

        devtest(1) = 1
        !$acc enter data copyin(devtest(1:1))
        !$acc parallel
          devtest(1) = 0
        !$acc end parallel

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)

        IF (devtest(1) .eq. 1) THEN
          CALL RANDOM_NUMBER(a)
          CALL RANDOM_NUMBER(b)
          c = 0

          !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
            !$acc parallel
              !$acc loop
              DO x = 1, LOOPCOUNT
                a(x) = a(x) * a(x)
              END DO
            !$acc end parallel
            CALL acc_update_device(a(1), LOOPCOUNT*8)
            !$acc parallel
              !$acc loop
              DO x = 1, LOOPCOUNT
                b(x) = b(x) * b(x)
              END DO
            !$acc end parallel
            CALL acc_update_device(b(1), LOOPCOUNT*8)
            !$acc parallel
              !$acc loop
              DO x = 1, LOOPCOUNT
                c(x) = a(x) + b(x)
              END DO
            !$acc end parallel
          !$acc end data

          DO x = 1, LOOPCOUNT
            IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
              errors = errors + 1
            END IF
          END DO
        END IF

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif

      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
        failed = .FALSE.
        failcode = 0
#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 1
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM

########## NEXT FILE ##########
acc_update_self.F90:::
#ifndef T1
!T1:runtime,data,executable-data,construct-independent,update,V:2.0-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        REAL(8) :: RAND
        INTEGER :: errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)

        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) create(c(1:LOOPCOUNT))
          !$acc parallel
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
          CALL acc_update_self(c(1:LOOPCOUNT))
        !$acc end data

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif
#ifndef T2
!T2:runtime,data,executable-data,construct-independent,update,V:2.0-2.7
      LOGICAL FUNCTION test2()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        REAL(8) :: RAND
        INTEGER :: errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)

        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
          !$acc parallel
            !$acc loop
            DO x = 1, LOOPCOUNT
              a(x) = a(x) * a(x)
            END DO
          !$acc end parallel
          CALL acc_update_self(a(1:LOOPCOUNT))
          !$acc parallel
            !$acc loop
            DO x = 1, LOOPCOUNT
              b(x) = b(x) * b(x)
            END DO
          !$acc end parallel
          CALL acc_update_self(b(1:LOOPCOUNT))
          !$acc parallel
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif

      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
        failed = .FALSE.
        failcode = 0
#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 1
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM

########## NEXT FILE ##########
acc_update_self_async.F90:::
#ifndef T1
!T1:runtime,data,executable-data,devonly,async,construct-independent,update,V:2.5-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d !Data
        INTEGER,DIMENSION(1):: devtest
        REAL(8) :: RAND
        INTEGER :: errors = 0

        devtest(1) = 1
        !$acc enter data copyin(devtest(1:1))
        !$acc parallel
          devtest(1) = 0
        !$acc end parallel

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)

        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0
        d = 0

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) create(c(1:LOOPCOUNT), d(1:LOOPCOUNT))
          !$acc parallel async(1)
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
          !$acc parallel async(2)
            !$acc loop
            DO x = 1, LOOPCOUNT
              d(x) = a(x) * b(x)
            END DO
          !$acc end parallel
          CALL acc_update_self_async(c(1:LOOPCOUNT), 1)
          CALL acc_update_self_async(d(1:LOOPCOUNT), 2)
          !$acc wait
        !$acc end data

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
          IF (abs(d(x) - (a(x) * b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif
#ifndef T2
!T2:runtime,data,executable-data,devonly,async,construct-independent,update,V:2.5-2.7
      LOGICAL FUNCTION test2()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d !Data
        INTEGER,DIMENSION(1):: devtest
        REAL(8) :: RAND
        INTEGER :: errors = 0

        devtest(1) = 1
        !$acc enter data copyin(devtest(1:1))
        !$acc parallel
          devtest(1) = 0
        !$acc end parallel

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)

        IF (devtest(1) .eq. 1) THEN
          CALL RANDOM_NUMBER(a)
          CALL RANDOM_NUMBER(b)
          c = 0

          !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
            !$acc parallel async(1)
              !$acc loop
              DO x = 1, LOOPCOUNT
                a(x) = a(x) * a(x)
              END DO
            !$acc end parallel
            CALL acc_update_self_async(a(1:LOOPCOUNT), 1)
            !$acc parallel async(2)
              !$acc loop
              DO x = 1, LOOPCOUNT
                b(x) = b(x) * b(x)
              END DO
            !$acc end parallel
            CALL acc_update_self_async(b(1:LOOPCOUNT), 2)
            !$acc parallel async(1)
              !$acc loop
              DO x = 1, LOOPCOUNT
                a(x) = a(x) + 1
              END DO
            !$acc end parallel
            !$acc parallel async(2)
              !$acc loop
              DO x = 1, LOOPCOUNT
                b(x) = b(x) + 1
              END DO
            !$acc end parallel
            !$acc parallel async(1) wait(2)
              !$acc loop
              DO x = 1, LOOPCOUNT
                c(x) = a(x) * b(x)
              END DO
            !$acc end parallel
          !$acc end data

          DO x = 1, LOOPCOUNT
            IF (abs(c(x) - ((a(x) + 1) * (b(x) + 1))) .gt. PRECISION) THEN
              errors = errors + 1
            END IF
          END DO
        END IF

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif

      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
        failed = .FALSE.
        failcode = 0
#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 1
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM

########## NEXT FILE ##########
acc_update_self_async_with_len.F90:::
#ifndef T1
!T1:runtime,data,executable-data,devonly,async,construct-independent,update,V:2.5-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d !Data
        INTEGER,DIMENSION(1):: devtest
        REAL(8) :: RAND
        INTEGER :: errors = 0

        devtest(1) = 1
        !$acc enter data copyin(devtest(1:1))
        !$acc parallel present(devtest(1:1))
          devtest(1) = 0
        !$acc end parallel

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)

        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0
        d = 0

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) create(c(1:LOOPCOUNT), d(1:LOOPCOUNT))
          !$acc parallel async(1)
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
          !$acc parallel async(2)
            !$acc loop
            DO x = 1, LOOPCOUNT
              d(x) = a(x) * b(x)
            END DO
          !$acc end parallel
          CALL acc_update_self_async(c(1), LOOPCOUNT*8, 1)
          CALL acc_update_self_async(d(1), LOOPCOUNT*8, 2)
          !$acc wait
        !$acc end data
        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
          IF (abs(d(x) - (a(x) * b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif
#ifndef T2
!T2:runtime,data,executable-data,devonly,async,construct-independent,update,V:2.5-2.7
      LOGICAL FUNCTION test2()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d !Data
        INTEGER,DIMENSION(1):: devtest
        REAL(8) :: RAND
        INTEGER :: errors = 0

        devtest(1) = 1
        !$acc enter data copyin(devtest(1:1))
        !$acc parallel present(devtest(1:1))
          devtest(1) = 0
        !$acc end parallel

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)

        IF (devtest(1) .eq. 1) THEN
          CALL RANDOM_NUMBER(a)
          CALL RANDOM_NUMBER(b)
          c = 0

          !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
            !$acc parallel async(1)
              !$acc loop
              DO x = 1, LOOPCOUNT
                a(x) = a(x) * a(x)
              END DO
            !$acc end parallel
            CALL acc_update_self_async(a(1), LOOPCOUNT*8, 1)
            !$acc parallel async(2)
              !$acc loop
              DO x = 1, LOOPCOUNT
                b(x) = b(x) * b(x)
              END DO
            !$acc end parallel
            CALL acc_update_self_async(b(1), LOOPCOUNT*8, 2)
            !$acc parallel async(1)
              !$acc loop
              DO x = 1, LOOPCOUNT
                a(x) = a(x) + 1
              END DO
            !$acc end parallel
            !$acc parallel async(2)
              !$acc loop
              DO x = 1, LOOPCOUNT
                b(x) = b(x) + 1
              END DO
            !$acc end parallel
            !$acc parallel async(1) wait(2)
              !$acc loop
              DO x = 1, LOOPCOUNT
                c(x) = a(x) * b(x)
              END DO
            !$acc end parallel
            !$acc wait(1)
          !$acc end data

          DO x = 1, LOOPCOUNT
            IF (abs(c(x) - ((a(x) + 1) * (b(x) + 1))) .gt. PRECISION) THEN
              errors = errors + 1
            END IF
          END DO
        END IF

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif

      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
        failed = .FALSE.
        failcode = 0
#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 1
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM

########## NEXT FILE ##########
acc_update_self_with_len.F90:::
#ifndef T1
!T1:runtime,data,executable-data,construct-independent,update,V:2.0-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        REAL(8) :: RAND
        INTEGER :: errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)

        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) create(c(1:LOOPCOUNT))
          !$acc parallel
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
          CALL acc_update_self(c(1), LOOPCOUNT*8)
        !$acc end data

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif
#ifndef T2
!T2:runtime,data,executable-data,construct-independent,update,V:2.0-2.7
      LOGICAL FUNCTION test2()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c !Data
        REAL(8) :: RAND
        INTEGER :: errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)

        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0

        !$acc data copyout(c(1:LOOPCOUNT)) copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
          !$acc parallel
            !$acc loop
            DO x = 1, LOOPCOUNT
              a(x) = a(x) * a(x)
            END DO
          !$acc end parallel
          CALL acc_update_self(a(1), LOOPCOUNT*8)
          !$acc parallel
            !$acc loop
            DO x = 1, LOOPCOUNT
              b(x) = b(x) * b(x)
            END DO
          !$acc end parallel
          CALL acc_update_self(b(1), LOOPCOUNT*8)
          !$acc parallel
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
        !$acc end data

        DO x = 1, LOOPCOUNT
          IF (abs(c(x) - (a(x) + b(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif

      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
        failed = .FALSE.
        failcode = 0
#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 1
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM

########## NEXT FILE ##########
acc_wait.F90:::
#ifndef T1
!T1:runtime,async,construct-independent,V:2.0-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e !Data
        REAL(8) :: RAND
        INTEGER :: errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)

        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0
        CALL RANDOM_NUMBER(d)
        e = 0

        !$acc enter data  copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT)) create(c(1:LOOPCOUNT)) async(1)
        !$acc enter data copyin(d(1:LOOPCOUNT)) create(e(1:LOOPCOUNT)) async(2)
        !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT)) async(1)
          !$acc loop
          DO x = 1, LOOPCOUNT
            c(x) = a(x) + b(x)
          END DO
        !$acc end parallel
        !$acc parallel present(c(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT)) async(1) wait(2)
          !$acc loop
          DO x = 1, LOOPCOUNT
            e(x) = c(x) + d(x)
          END DO
        !$acc end parallel
        !$acc exit data copyout(e(1:LOOPCOUNT)) async(1)

        CALL acc_wait(1)

        DO x = 1, LOOPCOUNT
          IF (abs(e(x) - (a(x) + b(x) + d(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        !$acc exit data delete(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT), d(1:LOOPCOUNT))

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif

      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
#ifndef T1
        LOGICAL :: test1
#endif
        failed = .FALSE.
        failcode = 0
#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM

########## NEXT FILE ##########
acc_wait_all.F90:::
#ifndef T1
!T1:runtime,async,construct-independent,V:2.0-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, a_host, b_host, c_host !Data
        REAL(8) :: RAND
        INTEGER :: errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)

        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        CALL RANDOM_NUMBER(c)
        d = 0
        a_host = a
        b_host = b
        c_host = c

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), c(1:LOOPCOUNT)) copyout(d(1:LOOPCOUNT))
          !$acc parallel async(1)
            !$acc loop
            DO x = 1, LOOPCOUNT
              a(x) = a(x) * a(x)
            END DO
          !$acc end parallel
          !$acc parallel async(2)
            !$acc loop
            DO x = 1, LOOPCOUNT
              b(x) = b(x) * b(x)
            END DO
          !$acc end parallel
          !$acc parallel async(3)
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = c(x) * c(x)
            END DO
          !$acc end parallel
          CALL acc_wait_all()
          !$acc parallel
            !$acc loop
            DO x = 1, LOOPCOUNT
              d(x) = a(x) + b(x) + c(x)
            END DO
          !$acc end parallel
        !$acc end data

        DO x = 1, LOOPCOUNT
          IF (abs(d(x) - ((a_host(x) * a_host(x)) + (b_host(x) * b_host(x)) + (c_host(x) * c_host(x)))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif

      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
#ifndef T1
        LOGICAL :: test1
#endif
        failed = .FALSE.
        failcode = 0
#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM

########## NEXT FILE ##########
acc_wait_all_async.F90:::
#ifndef T1
!T1:runtime,async,construct-independent,V:2.0-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f, g, h, i, j, k !Data
        REAL(8),DIMENSION(LOOPCOUNT):: a_host, d_host, g_host
        REAL(8) :: RAND
        REAL(8) :: temp
        INTEGER :: errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)

        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0
        CALL RANDOM_NUMBER(d)
        CALL RANDOM_NUMBER(e)
        f = 0
        CALL RANDOM_NUMBER(g)
        CALL RANDOM_NUMBER(h)
        i = 0
        j = 0
        k = 0
        a_host = a
        d_host = d
        g_host = g

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT), g(1:LOOPCOUNT), h(1:LOOPCOUNT)) create(c(1:LOOPCOUNT), f(1:LOOPCOUNT), i(1:LOOPCOUNT), j(1:LOOPCOUNT)) copyout(k(1:LOOPCOUNT))
          !$acc parallel async(1)
            !$acc loop
            DO x = 1, LOOPCOUNT
              c(x) = a(x) + b(x)
            END DO
          !$acc end parallel
          !$acc parallel async(2)
            !$acc loop
            DO x = 1, LOOPCOUNT
              f(x) = d(x) + e(x)
            END DO
          !$acc end parallel
          !$acc parallel async(3)
            !$acc loop
            DO x = 1, LOOPCOUNT
              i(x) = g(x) + h(x)
            END DO
          !$acc end parallel
          CALL acc_wait_all_async(4)
          !$acc parallel async(4)
            !$acc loop
            DO x = 1, LOOPCOUNT
              j(x) = c(x) + f(x) + i(x)
            END DO
          !$acc end parallel
          !$acc parallel async(1)
            !$acc loop
            DO x = 1, LOOPCOUNT
              a(x) = b(x) * c(x)
            END DO
          !$acc end parallel
          !$acc parallel async(2)
            !$acc loop
            DO x = 1, LOOPCOUNT
              d(x) = e(x) * f(x)
            END DO
          !$acc end parallel
          !$acc parallel async(3)
            !$acc loop
            DO x = 1, LOOPCOUNT
              g(x) = h(x) * i(x)
            END DO
          !$acc end parallel
          CALL acc_wait_all_async(4)
          !$acc parallel async(4)
            !$acc loop
            DO x = 1, LOOPCOUNT
              k(x) = j(x) + a(x) + d(x) + g(x)
            END DO
          !$acc end parallel
          !$acc wait(4)
        !$acc end data

        DO x = 1, LOOPCOUNT
          temp = a_host(x) + b(x) + d_host(x) + e(x) + g_host(x) + h(x)
          temp = temp + (b(x) * (a_host(x) + b(x))) + (e(x) * (d_host(x) + e(x))) + (h(x) * (g_host(x) + h(x)))
          IF (abs(k(x) - temp) .gt. PRECISION * 10) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif

      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
#ifndef T1
        LOGICAL :: test1
#endif
        failed = .FALSE.
        failcode = 0
#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM

########## NEXT FILE ##########
acc_wait_async.F90:::
#ifndef T1
!T1:runtime,async,construct-independent,V:2.0-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: x !Iterators
        REAL(8),DIMENSION(LOOPCOUNT):: a, b, c, d, e, f, g, h, i !Data
        REAL(8) :: RAND
        INTEGER :: errors = 0

        !Initilization
        SEEDDIM(1) = 1
#       ifdef SEED
        SEEDDIM(1) = SEED
#       endif
        CALL RANDOM_SEED(PUT=SEEDDIM)

        CALL RANDOM_NUMBER(a)
        CALL RANDOM_NUMBER(b)
        c = 0
        CALL RANDOM_NUMBER(d)
        CALL RANDOM_NUMBER(e)
        f = 0
        CALL RANDOM_NUMBER(g)
        h = 0
        i = 0

        !$acc data copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT), e(1:LOOPCOUNT), g(1:LOOPCOUNT)) create(c(1:LOOPCOUNT), f(1:LOOPCOUNT), h(1:LOOPCOUNT)) copyout(i(1:LOOPCOUNT))
          !$acc parallel async(1)
            !$acc loop
              DO x = 1, LOOPCOUNT
                c(x) = a(x) + b(x)
              END DO
          !$acc end parallel
          CALL acc_wait_async(1, 2)
          !$acc parallel async(2)
            !$acc loop
            DO x = 1, LOOPCOUNT
              h(x) = c(x) + g(x)
            END DO
          !$acc end parallel
          !$acc parallel async(1)
            !$acc loop
            DO x = 1, LOOPCOUNT
              f(x) = d(x) + e(x)
            END DO
          !$acc end parallel
          CALL acc_wait_async(1, 2)
          !$acc parallel async(2)
            !$acc loop
            DO x = 1, LOOPCOUNT
              i(x) = h(x) + f(x)
            END DO
          !$acc end parallel
          !$acc wait(2)
        !$acc end data

        DO x = 1, LOOPCOUNT
          IF (abs(i(x) - (a(x) + b(x) + g(x) + d(x) + e(x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif

      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
#ifndef T1
        LOGICAL :: test1
#endif
        failed = .FALSE.
        failcode = 0
#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM

########## NEXT FILE ##########
declare_copyin.F90:::
!$acc routine vector
FUNCTION multiplyData(a)
  REAL(8),DIMENSION(LOOPCOUNT), INTENT(INOUT) :: a
  INTEGER :: x
  !$acc loop vector
  DO x = 1, LOOPCOUNT
    a(x) = a(x) * 2
  END DO
END FUNCTION multiplyData

#ifndef T1
!T1:construct-independent,declare,V:2.0-2.7
      LOGICAL FUNCTION test1()
  USE OPENACC
  USE DECLARE_COPYIN_MOD
  IMPLICIT NONE
  INCLUDE "acc_testsuite.Fh"
  INTEGER :: errors = 0
  INTEGER :: mult = 2
  INTEGER :: x
  REAL(8),DIMENSION(LOOPCOUNT) :: a, b

  SEEDDIM(1) = 1
# ifdef SEED
  SEEDDIM(1) = SEED
# endif
  CALL RANDOM_SEED(PUT=SEEDDIM)

  CALL RANDOM_NUMBER(a)
  b = 0

  !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT)) present(fixed_size_array)
    !$acc parallel
      !$acc loop
      DO x = 1, LOOPCOUNT
        b(x) = a(x) + fixed_size_array(MOD(x, 10))
      END DO
    !$acc end parallel
  !$acc end data

  DO x = 1, LOOPCOUNT
    IF (abs(b(x) - (a(x) + fixed_size_array(MOD(x, 10)))) .gt. PRECISION) THEN
      errors = errors + 1
    END IF
  END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif
#ifndef T2
!T2:construct-independent,declare,V:1.0-2.7
      LOGICAL FUNCTION test2()
  USE OPENACC
  USE DECLARE_COPYIN_MOD
  IMPLICIT NONE
  INCLUDE "acc_testsuite.Fh"
  INTEGER :: errors = 0
  INTEGER :: mult = 2
  REAL(8),DIMENSION(LOOPCOUNT) :: a, b

  SEEDDIM(1) = 1
# ifdef SEED
  SEEDDIM(1) = SEED
# endif
  CALL RANDOM_SEED(PUT=SEEDDIM)

  CALL RANDOM_NUMBER(a)
  b = 0

  !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT)) present(scalar)
    !$acc parallel
      !$acc loop
      DO x = 1, LOOPCOUNT
        b(x) = a(x) + scalar
      END DO
    !$acc end parallel
  !$acc end data

  DO x = 1, LOOPCOUNT
    IF (abs(b(x) - (a(x) + scalar)) .gt. PRECISION) THEN
      errors = errors + 1
    END IF
  END DO

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif
#ifndef T3
!T3:construct-independent,declare,V:1.0-2.7
      LOGICAL FUNCTION test3()
  USE OPENACC
  USE DECLARE_COPYIN_MOD
  IMPLICIT NONE
  INCLUDE "acc_testsuite.Fh"
  INTEGER :: errors = 0
  INTEGER :: mult = 2
  REAL(8),DIMENSION(LOOPCOUNT) :: a, b

  SEEDDIM(1) = 1
# ifdef SEED
  SEEDDIM(1) = SEED
# endif
  CALL RANDOM_SEED(PUT=SEEDDIM)

  CALL RANDOM_NUMBER(a)
  b = a

  !$acc data copy(a(1:LOOPCOUNT))
    !$acc parallel
      !$acc loop
      DO x = 1, 1
        CALL externMultiplyData(a, LOOPCOUNT)
      END DO
    !$acc end parallel
  !$acc end data

  DO x = 1, LOOPCOUNT
    IF (abs(a(x) - (b(x) * 2)) .gt. PRECISION) THEN
      errors = errors + 1
    END IF
  END DO

        IF (errors .eq. 0) THEN
          test3 = .FALSE.
        ELSE
          test3 = .TRUE.
        END IF
      END
#endif
#ifndef T4
!T4:construct-independent,declare,V:1.0-2.7
      LOGICAL FUNCTION test4()
  USE OPENACC
  USE DECLARE_COPYIN_MOD
  IMPLICIT NONE
  INCLUDE "acc_testsuite.Fh"
  INTEGER :: errors = 0
  INTEGER :: mult = 2
  REAL(8),DIMENSION(LOOPCOUNT) :: a, b

  SEEDDIM(1) = 1
# ifdef SEED
  SEEDDIM(1) = SEED
# endif
  CALL RANDOM_SEED(PUT=SEEDDIM)

  CALL RANDOM_NUMBER(a)
  b = a

  !$acc data copy(a(1:LOOPCOUNT))
    !$acc parallel
      !$acc loop
      DO x = 1, 1
        CALL multiplyData(a)
      END DO
    !$acc end parallel
  !$acc end data

  DO x = 1, LOOPCOUNT
    IF (abs(a(x) - (b(x) * 2)) .gt. PRECISION) THEN
      errors = errors + 1
    END IF
  END DO

        IF (errors .eq. 0) THEN
          test4 = .FALSE.
        ELSE
          test4 = .TRUE.
        END IF
      END
#endif

      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
#ifndef T3
        LOGICAL :: test3
#endif
#ifndef T4
        LOGICAL :: test4
#endif
        failed = .FALSE.
        failcode = 0
#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 1
          failed = .FALSE.
        END IF
#endif
#ifndef T3
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test3()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 2
          failed = .FALSE.
        END IF
#endif
#ifndef T4
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test4()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 3
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM

########## NEXT FILE ##########
declare_create.F90:::
!$acc declare create(fixed_size_array)
!$acc declare create(scalar)
!$acc declare create(LOOPCOUNT)

FUNCTION multiplyData(a)
  REAL(8),DIMENSION(LOOPCOUNT), INTENT(INOUT) :: a
  !$acc loop vector
  DO x = 1, LOOPCOUNT
    a(x) = a(x) * 2
  END DO
END FUNCTION multiplyData

#ifndef T1
!T1:construct-independent,declare,update,V:2.0-2.7
      LOGICAL FUNCTION test1()
  USE OPENACC
  IMPLICIT NONE
  INCLUDE "acc_testsuite.Fh"
  INTEGER :: errors = 0
  INTEGER :: mult = 2
  REAL(8),DIMENSION(LOOPCOUNT) :: a, b

  SEEDDIM(1) = 1
# ifdef SEED
  SEEDDIM(1) = SEED
# endif
  CALL RANDOM_SEED(PUT=SEEDDIM)

  CALL RANDOM_NUMBER(a)
  b = 0
  !$acc update device(n)
  !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT)) present(fixed_size_array)
    !$acc parallel
      !$acc loop
      DO x = 1, 10
        fixed_size_array(x) = x * x
      END DO
    !$acc end parallel
    !$acc parallel
      !$acc loop
      DO x = 1, LOOPCOUNT
        b(x) = a(x) + fixed_size_array(MOD(x, 10))
      END DO
    !$acc end parallel
  !$acc end data

  DO x = 1, LOOPCOUNT
    IF (abs(b(x) - (a(x) + (MOD(x, 10) * MOD(x, 10)))) .gt. PRECISION) THEN
      errors = errors + 1
    END IF
  END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif
#ifndef T2
!T2:construct-independent,declare,update,V:2.0-2.7
      LOGICAL FUNCTION test2()
  USE OPENACC
  IMPLICIT NONE
  INCLUDE "acc_testsuite.Fh"
  INTEGER :: errors = 0
  INTEGER :: mult = 2
  REAL(8),DIMENSION(LOOPCOUNT) :: a, b

  SEEDDIM(1) = 1
# ifdef SEED
  SEEDDIM(1) = SEED
# endif
  CALL RANDOM_SEED(PUT=SEEDDIM)

  CALL RANDOM_NUMBER(a)
  b = 0
  scalar = 10
  !$acc update device(scalar)
  !$acc data copyin(a(1:LOOPCOUNT)) copyout(b(1:LOOPCOUNT)) present(scalar)
    !$acc parallel
      !$acc loop
      DO x = 1, LOOPCOUNT
        b(x) = a(x) + scalar
      END DO
    !$acc end parallel
  !$acc end data

  DO x = 1, LOOPCOUNT
    IF (abs(b(x) - (a(x) + scalar)) .gt. PRECISION) THEN
      errors = errors + 1
    END IF
  END DO

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif
#ifndef T3
!T3:construct-independent,declare,V:2.0-2.7
      LOGICAL FUNCTION test3()
  USE OPENACC
  IMPLICIT NONE
  INCLUDE "acc_testsuite.Fh"
  INTEGER :: errors = 0
  INTEGER :: mult = 2
  REAL(8),DIMENSION(LOOPCOUNT) :: a, b

  SEEDDIM(1) = 1
# ifdef SEED
  SEEDDIM(1) = SEED
# endif
  CALL RANDOM_SEED(PUT=SEEDDIM)

  CALL RANDOM_NUMBER(a)
  b = a
  !$acc update
  !$acc data copy(a(1:LOOPCOUNT))
    !$acc parallel
      !$acc loop
      DO x = 1, 1
        CALL externMultiplyData(a, LOOPCOUNT)
      END DO
    !$acc end parallel
  !$acc end data

  DO x = 1, LOOPCOUNT
    IF (abs(a(x) - (b(x) * 2)) .gt. PRECISION) THEN
      errors = errors + 1
    END IF
  END DO

        IF (errors .eq. 0) THEN
          test3 = .FALSE.
        ELSE
          test3 = .TRUE.
        END IF
      END
#endif
#ifndef T4
!T4:construct-independent,declare,V:2.0-2.7
      LOGICAL FUNCTION test4()
  USE OPENACC
  IMPLICIT NONE
  INCLUDE "acc_testsuite.Fh"
  INTEGER :: errors = 0
  INTEGER :: mult = 2
  REAL(8),DIMENSION(LOOPCOUNT) :: a, b

  SEEDDIM(1) = 1
# ifdef SEED
  SEEDDIM(1) = SEED
# endif
  CALL RANDOM_SEED(PUT=SEEDDIM)

  CALL RANDOM_NUMBER(a)
  b = a

  !$acc data copy(a(1:LOOPCOUNT))
    !$acc parallel
      !$acc loop
      DO x = 1, 1
        CALL multiplyData(a)
      END DO
    !$acc end parallel
  !$acc end data

  DO x = 1, LOOPCOUNT
    IF (abs(a(x) - (b(x) * 2)) .gt. PRECISION) THEN
      errors = errors + 1
    END IF
  END DO

        IF (errors .eq. 0) THEN
          test4 = .FALSE.
        ELSE
          test4 = .TRUE.
        END IF
      END
#endif

      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
#ifndef T3
        LOGICAL :: test3
#endif
#ifndef T4
        LOGICAL :: test4
#endif
        failed = .FALSE.
        failcode = 0
#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 1
          failed = .FALSE.
        END IF
#endif
#ifndef T3
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test3()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 2
          failed = .FALSE.
        END IF
#endif
#ifndef T4
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test4()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 3
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM

########## NEXT FILE ##########
declare_function_scope_copy.F90:::
SUBROUTINE copyin_copyout_test(a, b, c, LOOPCOUNT)
  REAL(8),DIMENSION(LOOPCOUNT),INTENT(IN) :: a, b
  REAL(8),DIMENSION(LOOPCOUNT),INTENT(INOUT) :: c
  INTEGER,INTENT(IN) :: LOOPCOUNT
  INTEGER :: y
  !$acc declare copy(c(1:LOOPCOUNT))
  !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
    !$acc loop
    DO y = 1, LOOPCOUNT
      c(y) = c(y) + a(y) + b(y)
    END DO
  !$acc end parallel
END SUBROUTINE copyin_copyout_test

#ifndef T1
!T1:devonly,construct-independent,declare,V:2.0-2.7
      LOGICAL FUNCTION test1()
  USE OPENACC
  IMPLICIT NONE
  INCLUDE "acc_testsuite.Fh"
  INTEGER :: errors = 0
  INTEGER :: mult = 2
  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c
  INTEGER,DIMENSION(1) :: devtest
  INTEGER :: x, y

  devtest(1) = 1
  !$acc enter data copyin(devtest(1:1))
  !$acc parallel present(devtest(1:1))
    devtest(1) = 0
  !$acc end parallel

  SEEDDIM(1) = 1
# ifdef SEED
  SEEDDIM(1) = SEED
# endif
  CALL RANDOM_SEED(PUT=SEEDDIM)

  CALL RANDOM_NUMBER(a)
  CALL RANDOM_NUMBER(b)
  c = 1
  !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))
    DO x = 1, LOOPCOUNT
      CALL copyin_copyout_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)
    END DO
  !$acc end data
  DO x = 1, LOOPCOUNT
    DO y = 1, LOOPCOUNT
      IF (abs(c(x, y) - (1 + a(x, y) + b(x, y))) .gt. PRECISION) THEN
        errors = errors + 1
      END IF
    END DO
  END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif
#ifndef T2
!T2:devonly,construct-independent,declare,V:2.0-2.7
      LOGICAL FUNCTION test2()
  USE OPENACC
  IMPLICIT NONE
  INCLUDE "acc_testsuite.Fh"
  INTEGER :: errors = 0
  INTEGER :: mult = 2
  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c
  INTEGER,DIMENSION(1) :: devtest
  INTEGER :: x, y

  devtest(1) = 1
  !$acc enter data copyin(devtest(1:1))
  !$acc parallel present(devtest(1:1))
    devtest(1) = 0
  !$acc end parallel

  SEEDDIM(1) = 1
# ifdef SEED
  SEEDDIM(1) = SEED
# endif
  CALL RANDOM_SEED(PUT=SEEDDIM)

  CALL RANDOM_NUMBER(a)
  CALL RANDOM_NUMBER(b)
  c = 2

  !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))
    DO x = 1, LOOPCOUNT
      !$acc data copy(c(1:LOOPCOUNT, x:x))
        CALL copyin_copyout_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)
      !$acc end data
    END DO
  !$acc end data

  DO x = 1, LOOPCOUNT
    DO y = 1, LOOPCOUNT
      IF (abs(c(x, y) - (2 + a(x, y) + b(x, y))) .gt. PRECISION) THEN
        errors = errors + 1
      END IF
    END DO
  END DO

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif
#ifndef T3
!T3:devonly,construct-independent,declare,V:2.0-2.7
      LOGICAL FUNCTION test3()
  USE OPENACC
  IMPLICIT NONE
  INCLUDE "acc_testsuite.Fh"
  INTEGER :: errors = 0
  INTEGER :: mult = 2
  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c
  INTEGER,DIMENSION(1) :: devtest
  INTEGER :: x, y

  devtest(1) = 1
  !$acc enter data copyin(devtest(1:1))
  !$acc parallel present(devtest(1:1))
    devtest(1) = 0
  !$acc end parallel

  SEEDDIM(1) = 1
# ifdef SEED
  SEEDDIM(1) = SEED
# endif
  CALL RANDOM_SEED(PUT=SEEDDIM)

  IF (devtest(1) .eq. 1) THEN
    CALL RANDOM_NUMBER(a)
    CALL RANDOM_NUMBER(b)
    c = 3

    !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))
      DO x = 1, LOOPCOUNT
        !$acc data copyin(c(1:LOOPCOUNT, x:x))
          CALL copyin_copyout_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)
          DO y = 1, LOOPCOUNT
            IF (abs(c(y, x) - 3) .gt. PRECISION) THEN
              errors = errors + 1
            END IF
          END DO
        !$acc end data
        DO y = 1, LOOPCOUNT
          IF (abs(c(y, x) - 3) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO
      END DO
    !$acc end data
  END IF

        IF (errors .eq. 0) THEN
          test3 = .FALSE.
        ELSE
          test3 = .TRUE.
        END IF
      END
#endif
#ifndef T4
!T4:devonly,construct-independent,declare,V:2.0-2.7
      LOGICAL FUNCTION test4()
  USE OPENACC
  IMPLICIT NONE
  INCLUDE "acc_testsuite.Fh"
  INTEGER :: errors = 0
  INTEGER :: mult = 2
  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c
  INTEGER,DIMENSION(1) :: devtest
  INTEGER :: x, y

  devtest(1) = 1
  !$acc enter data copyin(devtest(1:1))
  !$acc parallel present(devtest(1:1))
    devtest(1) = 0
  !$acc end parallel

  SEEDDIM(1) = 1
# ifdef SEED
  SEEDDIM(1) = SEED
# endif
  CALL RANDOM_SEED(PUT=SEEDDIM)

  IF (devtest(1) .eq. 1) THEN
    CALL RANDOM_NUMBER(a)
    CALL RANDOM_NUMBER(b)
    c = 4

    !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))
      DO x = 1, LOOPCOUNT
        !$acc data copy(c(1:LOOPCOUNT, x:x))
          CALL copyin_copyout_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)
          DO y = 1, LOOPCOUNT
            IF (abs(c(y, x) - 4) .gt. PRECISION) THEN
              errors = errors + 1
            END IF
          END DO
        !$acc end data
        DO y = 1, LOOPCOUNT
          IF (abs(c(y, x) - (4 + a(y, x) + b(y, x))) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO
      END DO
    !$acc end data
  END IF

        IF (errors .eq. 0) THEN
          test4 = .FALSE.
        ELSE
          test4 = .TRUE.
        END IF
      END
#endif

      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
#ifndef T3
        LOGICAL :: test3
#endif
#ifndef T4
        LOGICAL :: test4
#endif
        failed = .FALSE.
        failcode = 0
#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 1
          failed = .FALSE.
        END IF
#endif
#ifndef T3
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test3()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 2
          failed = .FALSE.
        END IF
#endif
#ifndef T4
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test4()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 3
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM

########## NEXT FILE ##########
declare_function_scope_copyin.F90:::
FUNCTION function_test(a, b, c, LOOPCOUNT)
  REAL(8),DIMENSION(LOOPCOUNT),INTENT(IN) :: a, b
  REAL(8),DIMENSION(LOOPCOUNT),INTENT(INOUT) :: c
  INTEGER,INTENT(IN) :: LOOPCOUNT
  INTEGER :: x

  !$acc declare copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
  !$acc parallel present(c(1:LOOPCOUNT))
    !$acc loop
    DO x = 1, LOOPCOUNT
      c(x) = c(x) + a(x) + b(x)
    END DO
  !$acc end parallel
END FUNCTION function_test

FUNCTION function_test_dev_only(a, b, c, LOOPCOUNT)
  REAL(8),DIMENSION(LOOPCOUNT),INTENT(INOUT) :: a, b
  REAL(8),DIMENSION(LOOPCOUNT),INTENT(INOUT) :: c
  INTEGER,INTENT(IN) :: LOOPCOUNT
  INTEGER :: x

  !$acc declare copyin(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
  !$acc parallel present(c(1:LOOPCOUNT))
    !$acc loop
    DO x = 1, LOOPCOUNT
      c(x) = c(x) + a(x) + b(x)
      a(x) = -1
      b(x) = -1
    END DO
  !$acc end parallel
END FUNCTION function_test_dev_only

#ifndef T1
!T1:devonly,construct-independent,declare,V:2.0-2.7
      LOGICAL FUNCTION test1()
  USE OPENACC
  IMPLICIT NONE
  INCLUDE "acc_testsuite.Fh"
  INTEGER :: errors = 0
  INTEGER :: mult = 2
  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, a_host, b_host
  INTEGER,DIMENSION(1) :: devtest
  INTEGER :: x, y

  devtest(1) = 1
  !$acc enter data copyin(devtest(1:1))
  !$acc parallel present(devtest(1:1))
    devtest(1) = 0
  !$acc end parallel

  SEEDDIM(1) = 1
# ifdef SEED
  SEEDDIM(1) = SEED
# endif
  CALL RANDOM_SEED(PUT=SEEDDIM)

  CALL RANDOM_NUMBER(a)
  CALL RANDOM_NUMBER(b)
  c = 1

  !$acc data copy(c(1:LOOPCOUNT, 1:LOOPCOUNT))
    DO x = 1, LOOPCOUNT
      CALL function_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)
    END DO
  !$acc end data

  DO x = 1, LOOPCOUNT
    DO y = 1, LOOPCOUNT
      IF (abs(c(x, y) - (1 + a(x, y) + b(x, y))) .gt. PRECISION) THEN
        errors = errors + 1
        PRINT*, "1"
      END IF
    END DO
  END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif
#ifndef T2
!T2:devonly,construct-independent,declare,V:2.0-2.7
      LOGICAL FUNCTION test2()
  USE OPENACC
  IMPLICIT NONE
  INCLUDE "acc_testsuite.Fh"
  INTEGER :: errors = 0
  INTEGER :: mult = 2
  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, a_host, b_host
  INTEGER,DIMENSION(1) :: devtest
  INTEGER :: x, y

  devtest(1) = 1
  !$acc enter data copyin(devtest(1:1))
  !$acc parallel present(devtest(1:1))
    devtest(1) = 0
  !$acc end parallel

  SEEDDIM(1) = 1
# ifdef SEED
  SEEDDIM(1) = SEED
# endif
  CALL RANDOM_SEED(PUT=SEEDDIM)

  IF (devtest(1) .eq. 1) THEN
    CALL RANDOM_NUMBER(a)
    CALL RANDOM_NUMBER(b)
    c = 0
    a_host = a
    b_host = b

    !$acc data copy(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT), c(1:LOOPCOUNT, 1:LOOPCOUNT))
      DO x = 1, LOOPCOUNT
        CALL function_test_dev_only(a(:,x), b(:,x), c(:,x), LOOPCOUNT)
      END DO
    !$acc end data

    DO x = 1, LOOPCOUNT
      DO y = 1, LOOPCOUNT
        IF (abs(a(x, y) + 1) .gt. PRECISION) THEN
          errors = errors + 1
          PRINT*, "2"
        END IF
        IF (abs(b(x, y) + 1) .gt. PRECISION) THEN
          errors = errors + 1
          PRINT*, "3"
        END IF
        IF (abs(c(x, y) - (a_host(x, y) + b_host(x, y))) .gt. PRECISION) THEN
          errors = errors + 1
          PRINT*, "4"
        END IF
      END DO
    END DO
  END IF

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif
#ifndef T3
!T3:devonly,construct-independent,declare,V:2.0-2.7
      LOGICAL FUNCTION test3()
  USE OPENACC
  IMPLICIT NONE
  INCLUDE "acc_testsuite.Fh"
  INTEGER :: errors = 0
  INTEGER :: mult = 2
  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, a_host, b_host
  INTEGER,DIMENSION(1) :: devtest
  INTEGER :: x, y

  devtest(1) = 1
  !$acc enter data copyin(devtest(1:1))
  !$acc parallel present(devtest(1:1))
    devtest(1) = 0
  !$acc end parallel

  SEEDDIM(1) = 1
# ifdef SEED
  SEEDDIM(1) = SEED
# endif
  CALL RANDOM_SEED(PUT=SEEDDIM)

  IF (devtest(1) .eq. 1) THEN
    CALL RANDOM_NUMBER(a)
    CALL RANDOM_NUMBER(b)
    c = 1
    a_host = a
    b_host = b

    !$acc data copy(c(1:LOOPCOUNT, 1:LOOPCOUNt))
      DO x = 1, LOOPCOUNT
        CALL function_test_dev_only(a(:,x), b(:,x), c(:,x), LOOPCOUNT)
      END DO
    !$acc end data

    DO x = 1, LOOPCOUNT
      DO y = 1, LOOPCOUNT
        IF (abs(a(x, y) - a_host(x, y)) .gt. PRECISION) THEN
          errors = errors + 1
          PRINT*, "5"
        END IF
        IF (abs(b(x, y) - b_host(x, y)) .gt. PRECISION) THEN
          errors = errors + 1
          PRINT*, "6"
        END IF
        IF (abs(c(x, y) - (1 + a(x, y) + b(x, y))) .gt. PRECISION) THEN
          errors = errors + 1
          PRINT*, "7"
        END IF
      END DO
    END DO
  END IF

        IF (errors .eq. 0) THEN
          test3 = .FALSE.
        ELSE
          test3 = .TRUE.
        END IF
      END
#endif

      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
#ifndef T3
        LOGICAL :: test3
#endif
        failed = .FALSE.
        failcode = 0
#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 1
          failed = .FALSE.
        END IF
#endif
#ifndef T3
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test3()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 2
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM

########## NEXT FILE ##########
declare_function_scope_copyout.F90:::
FUNCTION copyout_test(a, b, c, LOOPCOUNT)
  REAL(8),DIMENSION(LOOPCOUNT),INTENT(IN) :: a, b
  REAL(8),DIMENSION(LOOPCOUNT),INTENT(INOUT) :: c
  INTEGER,INTENT(IN) :: LOOPCOUNT
  INTEGER :: x

  !$acc declare copyout(c(1:LOOPCOUNT))
  !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT))
    !$acc loop
    DO x = 1, LOOPCOUNT
      c(x) = a(x) + b(x)
    END DO
  !$acc end parallel
END FUNCTION copyout_test

#ifndef T1
!T1:devonly,construct-independent,declare,V:2.0-2.7
      LOGICAL FUNCTION test1()
  USE OPENACC
  IMPLICIT NONE
  INCLUDE "acc_testsuite.Fh"
  INTEGER :: errors = 0
  INTEGER :: mult = 2
  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c
  INTEGER,DIMENSION(1) :: devtest
  INTEGER :: x, y

  devtest(1) = 1
  !$acc enter data copyin(devtest(1:1))
  !$acc parallel present(devtest(1:1))
    devtest(1) = 0
  !$acc end parallel

  SEEDDIM(1) = 1
# ifdef SEED
  SEEDDIM(1) = SEED
# endif
  CALL RANDOM_SEED(PUT=SEEDDIM)

  CALL RANDOM_NUMBER(a)
  CALL RANDOM_NUMBER(b)
  c = 1

  !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))
    DO x = 1, LOOPCOUNT
      CALL copyout_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)
    END DO
  !$acc end data

  DO x = 1, LOOPCOUNT
    DO y = 1, LOOPCOUNT
      IF (abs(c(x, y) - (a(x, y) + b(x, y))) .gt. PRECISION) THEN
        errors = errors + 1
      END IF
    END DO
  END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif
#ifndef T2
!T2:devonly,construct-independent,declare,V:2.0-2.7
      LOGICAL FUNCTION test2()
  USE OPENACC
  IMPLICIT NONE
  INCLUDE "acc_testsuite.Fh"
  INTEGER :: errors = 0
  INTEGER :: mult = 2
  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c
  INTEGER,DIMENSION(1) :: devtest
  INTEGER :: x, y

  devtest(1) = 1
  !$acc enter data copyin(devtest(1:1))
  !$acc parallel present(devtest(1:1))
    devtest(1) = 0
  !$acc end parallel

  SEEDDIM(1) = 1
# ifdef SEED
  SEEDDIM(1) = SEED
# endif
  CALL RANDOM_SEED(PUT=SEEDDIM)

  CALL RANDOM_NUMBER(a)
  CALL RANDOM_NUMBER(b)
  c = 2

  !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))
    DO x = 1, LOOPCOUNT
      !$acc data copy(c(1:LOOPCOUNT, x:x))
        CALL copyout_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)
      !$acc end data
    END DO
  !$acc end data

  DO x = 1, LOOPCOUNT
    DO y = 1, LOOPCOUNT
      IF (abs(c(x, y) - (a(x, y) + b(x, y))) .gt. PRECISION) THEN
        errors = errors + 1
      END IF
    END DO
  END DO

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif
#ifndef T3
!T3:devonly,construct-independent,declare,V:2.0-2.7
      LOGICAL FUNCTION test3()
  USE OPENACC
  IMPLICIT NONE
  INCLUDE "acc_testsuite.Fh"
  INTEGER :: errors = 0
  INTEGER :: mult = 2
  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c
  INTEGER,DIMENSION(1) :: devtest
  INTEGER :: x, y

  devtest(1) = 1
  !$acc enter data copyin(devtest(1:1))
  !$acc parallel present(devtest(1:1))
    devtest(1) = 0
  !$acc end parallel

  SEEDDIM(1) = 1
# ifdef SEED
  SEEDDIM(1) = SEED
# endif
  CALL RANDOM_SEED(PUT=SEEDDIM)

  IF (devtest(1) .eq. 1) THEN
    CALL RANDOM_NUMBER(a)
    CALL RANDOM_NUMBER(b)
    c = 3

    !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))
      DO x = 1, LOOPCOUNT
        !$acc data copyin(c(1:LOOPCOUNT, x:x))
          CALL copyout_test(a(:,x), b(:,x), c(:,x), LOOPCOUNT)
        !$acc end data
        DO y = 1, LOOPCOUNT
          IF (abs(c(y, x) - 3) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
        END DO
      END DO
    !$acc end data
  END IF

        IF (errors .eq. 0) THEN
          test3 = .FALSE.
        ELSE
          test3 = .TRUE.
        END IF
      END
#endif

      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
#ifndef T3
        LOGICAL :: test3
#endif
        failed = .FALSE.
        failcode = 0
#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 1
          failed = .FALSE.
        END IF
#endif
#ifndef T3
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test3()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 2
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM

########## NEXT FILE ##########
declare_function_scope_create.F90:::
FUNCTION create_test(a, b, c, d, LOOPCOUNT)
  REAL(8),DIMENSION(LOOPCOUNT),INTENT(IN) :: a, b
  REAL(8),DIMENSION(LOOPCOUNT),INTENT(INOUT) :: c, d
  INTEGER,INTENT(IN) :: LOOPCOUNT
  INTEGER :: x

  !$acc declare create(c(1:LOOPCOUNT))
  !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT))
    !$acc loop
    DO x = 1, LOOPCOUNT
      c(x) = a(x) + b(x)
    END DO
    !$acc loop
    DO x = 1, LOOPCOUNT
      d(x) = c(x) * a(x)
    END DO
  !$acc end parallel
END FUNCTION function_test

FUNCTION create_as_present(a, b, c, d, LOOPCOUNT)
  REAL(8),DIMENSION(LOOPCOUNT),INTENT(IN) :: a, b
  REAL(8),DIMENSION(LOOPCOUNT),INTENT(INOUT) :: c, d
  INTEGER,INTENT(IN) :: LOOPCOUNT
  INTEGER :: x

  !$acc declare create(c(1:LOOPCOUNT))
  !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT))
    !$acc loop
    DO x = 1, LOOPCOUNT
      c(x) = c(x) + a(x) + b(x)
    END DO
    !$acc loop
    DO x = 1, LOOPCOUNT
      d(x) = c(x) * a(x)
    END DO
  !$acc end parallel
END FUNCTION function_test_dev_only

#ifndef T1
!T1:devonly,construct-independent,declare,V:2.0-2.7
      LOGICAL FUNCTION test1()
  USE OPENACC
  IMPLICIT NONE
  INCLUDE "acc_testsuite.Fh"
  INTEGER :: errors = 0
  INTEGER :: mult = 2
  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, d
  INTEGER,DIMENSION(1) :: devtest
  INTEGER :: x, y

  devtest(1) = 1
  !$acc enter data copyin(devtest(1:1))
  !$acc parallel present(devtest(1:1))
    devtest(1) = 0
  !$acc end parallel

  SEEDDIM(1) = 1
# ifdef SEED
  SEEDDIM(1) = SEED
# endif
  CALL RANDOM_SEED(PUT=SEEDDIM)

  CALL RANDOM_NUMBER(a)
  CALL RANDOM_NUMBER(b)
  c = 1
  d = 0

  !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT)) copyout(d(1:LOOPCOUNT, 1:LOOPCOUNT))
    DO x = 1, LOOPCOUNT
      CALL create_test(a(x), b(x), c(x), d(x), LOOPCOUNT)
    END DO
  !$acc end data

  DO x = 1, LOOPCOUNT
    DO y = 1, LOOPCOUNT
      IF (abs(d(x, y) - (a(x, y) * (a(x, y) + b(x, y)))) .gt. PRECISION) THEN
        errors = errors + 1
      END IF
    END DO
  END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif
#ifndef T2
!T2:devonly,construct-independent,declare,V:2.0-2.7
      LOGICAL FUNCTION test2()
  USE OPENACC
  IMPLICIT NONE
  INCLUDE "acc_testsuite.Fh"
  INTEGER :: errors = 0
  INTEGER :: mult = 2
  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, d
  INTEGER,DIMENSION(1) :: devtest
  INTEGER :: x, y

  devtest(1) = 1
  !$acc enter data copyin(devtest(1:1))
  !$acc parallel present(devtest(1:1))
    devtest(1) = 0
  !$acc end parallel

  SEEDDIM(1) = 1
# ifdef SEED
  SEEDDIM(1) = SEED
# endif
  CALL RANDOM_SEED(PUT=SEEDDIM)

  CALL RANDOM_NUMBER(a)
  CALL RANDOM_NUMBER(b)
  c = 2
  d = 0

  !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT)) copy(c(1:LOOPCOUNT, 1:LOOPCOUNT)) copyout(d(1:LOOPCOUNT, 1:LOOPCOUNT))
    DO x = 1, LOOPCOUNT
      CALL create_as_present(a(x), b(x), c(x), d(x), LOOPCOUNT)
    END DO
  !$acc end data

  DO x = 1, LOOPCOUNT
    DO y = 1, LOOPCOUNT
      IF (abs(c(x, y) - (2 + a(x, y) + b(x, y))) .gt. PRECISION) THEN
        errors = errors + 1
      END IF
      IF (abs(d(x, y) - (a(x, y) * c(x, y))) .gt. PRECISION * 2) THEN
        errors = errors + 1
      END IF
    END DO
  END DO

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif
#ifndef T3
!T3:devonly,construct-independent,declare,V:2.0-2.7
      LOGICAL FUNCTION test3()
  USE OPENACC
  IMPLICIT NONE
  INCLUDE "acc_testsuite.Fh"
  INTEGER :: errors = 0
  INTEGER :: mult = 2
  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, d
  INTEGER,DIMENSION(1) :: devtest
  INTEGER :: x, y

  devtest(1) = 1
  !$acc enter data copyin(devtest(1:1))
  !$acc parallel present(devtest(1:1))
    devtest(1) = 0
  !$acc end parallel

  SEEDDIM(1) = 1
# ifdef SEED
  SEEDDIM(1) = SEED
# endif
  CALL RANDOM_SEED(PUT=SEEDDIM)

  IF (devtest(1) .eq. 1) THEN
    CALL RANDOM_NUMBER(a)
    CALL RANDOM_NUMBER(b)
    c = 3

    !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))
      DO x = 1, LOOPCOUNT
        !$acc data copyin(c(x:x, 1:LOOPCOUNT)) copyout(d(x:x, 1:LOOPCOUNT))
          CALL create_as_present(a(x), b(x), c(x), d(x), LOOPCOUNT)
        !$acc end data
        DO y = 1, LOOPCOUNT
          IF (abs(c(x, y) - 3) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
          IF (abs(d(x, y) - (a(x, y) * (3 + a(x, y) + b(x, y)))) .gt. PRECISION * 2) THEN
            errors = errors + 1
          END IF
        END DO
      END DO
    !$acc end data
  END IF

        IF (errors .eq. 0) THEN
          test3 = .FALSE.
        ELSE
          test3 = .TRUE.
        END IF
      END
#endif

      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
#ifndef T3
        LOGICAL :: test3
#endif
        failed = .FALSE.
        failcode = 0
#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 1
          failed = .FALSE.
        END IF
#endif
#ifndef T3
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test3()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 2
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM

########## NEXT FILE ##########
declare_function_scope_present.F90:::
FUNCTION present(a, b, c, d, LOOPCOUNT)
  REAL(8),DIMENSION(LOOPCOUNT),INTENT(IN) :: a, b
  REAL(8),DIMENSION(LOOPCOUNT),INTENT(INOUT) :: c, d
  INTEGER,INTENT(IN) :: LOOPCOUNT
  INTEGER :: x

  !$acc declare present(c(1:LOOPCOUNT))
  !$acc parallel present(a(1:LOOPCOUNT), b(1:LOOPCOUNT), d(1:LOOPCOUNT))
    !$acc loop
    DO x = 1, LOOPCOUNT
      c(x) = c(x) + a(x) + b(x)
    END DO
    !$acc loop
    DO x = 1, LOOPCOUNT
      d(x) = c(x) * a(x)
    END DO
  !$acc end parallel
END FUNCTION function_test

#ifndef T1
!T1:devonly,construct-independent,declare,V:2.0-2.7
      LOGICAL FUNCTION test1()
  USE OPENACC
  IMPLICIT NONE
  INCLUDE "acc_testsuite.Fh"
  INTEGER :: errors = 0
  INTEGER :: mult = 2
  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, d
  INTEGER,DIMENSION(1) :: devtest
  INTEGER :: x, y

  devtest(1) = 1
  !$acc enter data copyin(devtest(1:1))
  !$acc parallel present(devtest(1:1))
    devtest(1) = 0
  !$acc end parallel

  SEEDDIM(1) = 1
# ifdef SEED
  SEEDDIM(1) = SEED
# endif
  CALL RANDOM_SEED(PUT=SEEDDIM)

  CALL RANDOM_NUMBER(a)
  CALL RANDOM_NUMBER(b)
  c = 1
  d = 0

  !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT)) copyout(d(1:LOOPCOUNT, 1:LOOPCOUNT))
    DO x = 1, LOOPCOUNT
      !$acc data copy(c(x:x, 1:LOOPCOUNT))
        CALL present(a(x), b(x), c(x), d(x), LOOPCOUNT)
      !$acc end data
    END DO
  !$acc end data

  DO x = 1, LOOPCOUNT
    DO y = 1, LOOPCOUNT
      IF (abs(c(x, y) - (1 + a(x, y) + b(x, y))) .gt. PRECISION) THEN
        errors = errors + 1
      END IF
      IF (abs(d(x, y) - (a(x, y) * c(x, y))) .gt. PRECISION * 2) THEN
        errors = errors + 1
      END IF
    END DO
  END DO

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif
#ifndef T2
!T2:devonly,construct-independent,declare,V:2.0-2.7
      LOGICAL FUNCTION test2()
  USE OPENACC
  IMPLICIT NONE
  INCLUDE "acc_testsuite.Fh"
  INTEGER :: errors = 0
  INTEGER :: mult = 2
  REAL(8),DIMENSION(LOOPCOUNT, LOOPCOUNT) :: a, b, c, d
  INTEGER,DIMENSION(1) :: devtest
  INTEGER :: x, y

  devtest(1) = 1
  !$acc enter data copyin(devtest(1:1))
  !$acc parallel present(devtest(1:1))
    devtest(1) = 0
  !$acc end parallel

  SEEDDIM(1) = 1
# ifdef SEED
  SEEDDIM(1) = SEED
# endif
  CALL RANDOM_SEED(PUT=SEEDDIM)

  IF (devtest(1) .eq. 1) THEN
    CALL RANDOM_NUMBER(a)
    CALL RANDOM_NUMBER(b)
    c = 3

    !$acc data copyin(a(1:LOOPCOUNT, 1:LOOPCOUNT), b(1:LOOPCOUNT, 1:LOOPCOUNT))
      DO x = 1, LOOPCOUNT
        !$acc data copyin(c(x:x, 1:LOOPCOUNT)) copyout(d(x:x, 1:LOOPCOUNT))
          CALL present(a(x), b(x), c(x), d(x), LOOPCOUNT)
        !$acc end data
        DO y = 1, LOOPCOUNT
          IF (abs(c(x, y) - 3) .gt. PRECISION) THEN
            errors = errors + 1
          END IF
          IF (abs(d(x, y) - (a(x, y) * (3 + a(x, y) + b(x, y)))) .gt. PRECISION * 2) THEN
            errors = errors + 1
          END IF
        END DO
      END DO
    !$acc end data
  END IF

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif

      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
        failed = .FALSE.
        failcode = 0
#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 1
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM

########## NEXT FILE ##########
init.F90:::
#ifndef T1
!T1:construct-independent,init,nonvalidating,V:2.5-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: errors = 0

        !$acc init

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif

      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
#ifndef T1
        LOGICAL :: test1
#endif
        failed = .FALSE.
        failcode = 0
#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM

########## NEXT FILE ##########
init_device_num.F90:::
#ifndef T1
!T1:runtime,construct-independent,internal-control-values,init,nonvalidating,V:2.5-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: device_num
        INTEGER :: device_type
        INTEGER :: errors = 0

        device_num = acc_get_device_num(acc_get_device_type())
        !$acc init device_num(device_num)

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif

      PROGRAM main
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
#ifndef T1
        LOGICAL :: test1
#endif
        failed = .FALSE.
        failcode = 0
#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM

########## NEXT FILE ##########
init_device_type.F90:::
#ifndef T1
!T1:runtime,construct-independent,internal-control-values,init,nonvalidating,V:2.5-3.2
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: errors = 0

        !$acc init device_type(host)

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif
#ifndef T2
!T2:runtime,construct-independent,internal-control-values,init,nonvalidating,V:2.5-3.2
      LOGICAL FUNCTION test2()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: errors = 0

        !$acc init device_type(multicore)

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif
#ifndef T3
!T3:runtime,construct-independent,internal-control-values,init,nonvalidating,V:2.5-3.2
      LOGICAL FUNCTION test3()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: errors = 0

        !$acc init device_type(default)

        IF (errors .eq. 0) THEN
          test3 = .FALSE.
        ELSE
          test3 = .TRUE.
        END IF
      END
#endif

      PROGRAM init_device_type
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
#ifndef T3
        LOGICAL :: test3
#endif
        failed = .FALSE.
        failcode = 0
#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 1
          failed = .FALSE.
        END IF
#endif
#ifndef T3
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test3()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 2
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM

########## NEXT FILE ##########
init_device_type_num.F90:::
#ifndef T1
!T1:runtime,construct-independent,internal-control-values,init,nonvalidating,V:2.5-3.2
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: device_num
        INTEGER :: device_type
        INTEGER :: errors = 0

        device_type = acc_get_device_type()
        device_num = acc_get_device_num(device_type)
        !$acc init device_type(host) device_num(device_num)

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif
#ifndef T2
!T2:runtime,construct-independent,internal-control-values,init,nonvalidating,V:2.5-3.2
      LOGICAL FUNCTION test2()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: device_num
        INTEGER :: device_type
        INTEGER :: errors = 0

        device_type = acc_get_device_type()
        device_num = acc_get_device_num(device_type)
        !$acc init device_type(multicore) device_num(device_num)

        IF (errors .eq. 0) THEN
          test2 = .FALSE.
        ELSE
          test2 = .TRUE.
        END IF
      END
#endif
#ifndef T3
!T3:runtime,construct-independent,internal-control-values,init,nonvalidating,V:2.5-3.2
      LOGICAL FUNCTION test3()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: device_num
        INTEGER :: device_type
        INTEGER :: errors = 0

        device_type = acc_get_device_type()
        device_num = acc_get_device_num(device_type)
        !$acc init device_type(default) device_num(device_num)

        IF (errors .eq. 0) THEN
          test3 = .FALSE.
        ELSE
          test3 = .TRUE.
        END IF
      END
#endif

      PROGRAM init_device_type_num
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
#ifndef T1
        LOGICAL :: test1
#endif
#ifndef T2
        LOGICAL :: test2
#endif
#ifndef T3
        LOGICAL :: test3
#endif
        failed = .FALSE.
        failcode = 0
#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
#ifndef T2
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test2()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 1
          failed = .FALSE.
        END IF
#endif
#ifndef T3
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test3()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 2
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM
########## NEXT FILE ##########
init_device_type_num_nvidia.F90:::
#ifndef T1
!T1:runtime,construct-independent,internal-control-values,init,nonvalidating,V:2.5-2.7
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: device_num
        INTEGER :: device_type
        INTEGER :: errors = 0

        device_type = acc_get_device_type()
        device_num = acc_get_device_num(device_type)
        !$acc init device_type(nvidia) device_num(device_num)

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif

      PROGRAM init_device_type_num
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
#ifndef T1
        LOGICAL :: test1
#endif
        failed = .FALSE.
        failcode = 0
#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM

########## NEXT FILE ##########
init_device_type_nvidia.F90:::
#ifndef T1
!T1:runtime,construct-independent,internal-control-values,init,nonvalidating,V:2.5-3.2
      LOGICAL FUNCTION test1()
        USE OPENACC
        IMPLICIT NONE
        INCLUDE "acc_testsuite.Fh"
        INTEGER :: errors = 0

        !$acc init device_type(nvidia)

        IF (errors .eq. 0) THEN
          test1 = .FALSE.
        ELSE
          test1 = .TRUE.
        END IF
      END
#endif

      PROGRAM init_device_type
        IMPLICIT NONE
        INTEGER :: failcode, testrun
        LOGICAL :: failed
        INCLUDE "acc_testsuite.Fh"
#ifndef T1
        LOGICAL :: test1
#endif
        failed = .FALSE.
        failcode = 0
#ifndef T1
        DO testrun = 1, NUM_TEST_CALLS
          failed = failed .or. test1()
        END DO
        IF (failed) THEN
          failcode = failcode + 2 ** 0
          failed = .FALSE.
        END IF
#endif
        CALL EXIT (failcode)
      END PROGRAM
