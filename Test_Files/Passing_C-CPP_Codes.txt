/*
 * Library:   lmfit (Levenberg-Marquardt least squares fitting)
 *
 * File:      lmcurve.c
 *
 * Contents:  Levenberg-Marquardt curve-fitting
 *
 * Copyright: Joachim Wuttke, Forschungszentrum Juelich GmbH (2004-2013)
 *
 * License:   see ../COPYING (FreeBSD)
 * 
 * Homepage:  apps.jcns.fz-juelich.de/lmfit
 */

#include "lmmin.h"

#ifdef USE_OPENMP
#include "omp.h"
#endif

typedef struct {
    const double *t;
    const double *y;
    double (*f) (double t, const double *par);
} lmcurve_data_struct;


void lmcurve_evaluate( const double *par, int m_dat, const void *data,
                       double *fvec, int *info )
{
    int i;
    for ( i = 0; i < m_dat; i++ )
        fvec[i] =
            ((lmcurve_data_struct*)data)->y[i] -
            ((lmcurve_data_struct*)data)->f(
                ((lmcurve_data_struct*)data)->t[i], par );
}


void lmcurve( int n_par, double *par, int m_dat, 
              const double *t, const double *y,
              double (*f)( double t, const double *par ),
              const lm_control_struct *control,
              lm_status_struct *status )
{
    lmcurve_data_struct data;
    data.t = t;
    data.y = y;
    data.f = f;

    lmmin( n_par, par, m_dat, (const void*) &data,m_dat, (const void*) &data,
           lmcurve_evaluate, control, status );
}

########## NEXT FILE ##########
/*
 * Library:   lmfit (Levenberg-Marquardt least squares fitting)
 *
 * File:      lmmin.c
 *
 * Contents:  Levenberg-Marquardt minimization.
 *
 * Copyright: MINPACK authors, The University of Chikago (1980-1999)
 *            Joachim Wuttke, Forschungszentrum Juelich GmbH (2004-2013)
 *
 * License:   see ../COPYING (FreeBSD)
 * 
 * Homepage:  apps.jcns.fz-juelich.de/lmfit
 */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <float.h>
#include "lmmin.h"

#ifdef USE_OPENMP
#include "omp.h"
#endif


#define MIN(a,b) (((a)<=(b)) ? (a) : (b))
#define MAX(a,b) (((a)>=(b)) ? (a) : (b))
#define SQR(x)   (x)*(x)

/* function declarations (implemented below). */
void lm_lmpar( int n, double *r, int ldr, int *ipvt, double *diag,
               double *qtb, double delta, double *par, double *x,
               double *sdiag, double *aux, double *xdi );
void lm_qrfac( int m, int n, double *a, int *ipvt,
               double *rdiag, double *acnorm, double *wa );
void lm_qrsolv( int n, double *r, int ldr, int *ipvt, double *diag,
                double *qtb, double *x, double *sdiag, double *wa );


/*****************************************************************************/
/*  Numeric constants                                                        */
/*****************************************************************************/

/* machine-dependent constants from float.h */
#define LM_MACHEP     DBL_EPSILON   /* resolution of arithmetic */
#define LM_DWARF      DBL_MIN       /* smallest nonzero number */
#define LM_SQRT_DWARF sqrt(DBL_MIN) /* square should not underflow */
#define LM_SQRT_GIANT sqrt(DBL_MAX) /* square should not overflow */
#define LM_USERTOL    30*LM_MACHEP  /* users are recommended to require this */

/* If the above values do not work, the following seem good for an x86:
 LM_MACHEP     .555e-16
 LM_DWARF      9.9e-324 
 LM_SQRT_DWARF 1.e-160   
 LM_SQRT_GIANT 1.e150 
 LM_USER_TOL   1.e-14
   The following values should work on any machine:
 LM_MACHEP     1.2e-16
 LM_DWARF      1.0e-38
 LM_SQRT_DWARF 3.834e-20
 LM_SQRT_GIANT 1.304e19
 LM_USER_TOL   1.e-14
*/

const lm_control_struct lm_control_double = {
    LM_USERTOL, LM_USERTOL, LM_USERTOL, LM_USERTOL, 1.00 , 100, 1, 
    NULL, 0, -1, -1, 4 };
const lm_control_struct lm_control_float = {
    1.e-7,      1.e-7,      1.e-7,      1.e-7,      1.00 , 100, 1,
    NULL, 0, -1, -1, 4 };


/*****************************************************************************/
/*  Message texts (indexed by status.info)                                   */
/*****************************************************************************/

const char *lm_infmsg[] = {
    "found zero (sum of squares below underflow limit)",
    "converged  (the relative error in the sum of squares is at most tol)",
    "converged  (the relative error of the parameter vector is at most tol)",
    "converged  (both errors are at most tol)",
    "trapped    (by degeneracy; increasing epsilon might help)",
    "exhausted  (number of function calls exceeding preset patience)",
    "failed     (ftol<tol: cannot reduce sum of squares any further)",
    "failed     (xtol<tol: cannot improve approximate solution any further)",
    "failed     (gtol<tol: cannot improve approximate solution any further)",
    "crashed    (not enough memory)",
    "exploded   (fatal coding error: improper input parameters)",
    "stopped    (break requested within function evaluation)",
	"stopped    (break because validation set fail to improve)"
};

const char *lm_shortmsg[] = {
    "found zero",
    "converged (f)",
    "converged (p)",
    "converged (2)",
    "degenerate",
    "call limit",
    "failed (f)",
    "failed (p)",
    "failed (o)",
    "no memory",
    "invalid input",
    "user break"
	"validation check break"
};


/*****************************************************************************/
/*  Monitoring auxiliaries.                                                  */
/*****************************************************************************/

void lm_print_pars( int nout, const double *par, double fval, double fnorm, FILE* fout )
{
    int i;
    for (i = 0; i < nout; ++i)
        fprintf( fout, " %16.9g", par[i] );
    fprintf( fout, " => %18.11g ", fval );
    fprintf( fout, " => %18.11g\n", fnorm );
}


/*****************************************************************************/
/*  lmmin (main minimization routine)                                        */
/*****************************************************************************/

void lmmin( int n, double *x, int m, const void *data, int m2, const void * data2,
            void (*evaluate) (const double *par, int m_dat, const void *data,
                              double *fvec, int *userbreak),
            const lm_control_struct *C, lm_status_struct *S )
{
	int nalert;    /* added by dawei li */
	double *fvec2, validation_sum, temp_validation, *xback; /* added by dawei li */
    double *fvec, *diag, *fjac, *qtf, *wa1, *wa2, *wa3, *wf;
    int *ipvt;
    int j, i;
    double actred, dirder, fnorm, fnorm1, gnorm, pnorm,
        prered, ratio, step, sum, temp, temp1, temp2, temp3;
    static double p0001 = 1.0e-4;

    int maxfev = C->patience * (n+1);

    int    outer, inner;  /* loop counters, for monitoring */
    int    inner_success; /* flag for loop control */
    double lmpar = 0;     /* Levenberg-Marquardt parameter */
    double delta = 0;
    double xnorm = 0;
    double eps = sqrt(MAX(C->epsilon, LM_MACHEP)); /* for forward differences */

    int nout = C->n_maxpri==-1 ? n : MIN( C->n_maxpri, n );

    /* The workaround msgfile=NULL is needed for default initialization */
    FILE* msgfile = C->msgfile ? C->msgfile : stdout;

    /* Default status info; must be set ahead of first return statements */    
    S->outcome = 0;      /* status code */
    S->userbreak = 0;
    S->nfev = 0;      /* function evaluation counter */

/***  Check input parameters for errors.  ***/

    if ( n <= 0 ) {
        fprintf( stderr, "lmmin: invalid number of parameters %i\n", n );
        S->outcome = 10; /* invalid parameter */
        return;
    }
    if (m < n) {
        fprintf( stderr, "lmmin: number of data points (%i) "
                 "smaller than number of parameters (%i)\n", m, n );
        S->outcome = 10;
        return;
    }
    if (C->ftol < 0. || C->xtol < 0. || C->gtol < 0.) {
        fprintf( stderr,
                 "lmmin: negative tolerance (at least one of %g %g %g)\n",
                 C->ftol, C->xtol, C->gtol );
        S->outcome = 10;
        return;
    }
    if (maxfev <= 0) {
        fprintf( stderr, "lmmin: nonpositive function evaluations limit %i\n",
                 maxfev );
        S->outcome = 10;
        return;
    }
    if (C->stepbound <= 0.) {
        fprintf( stderr, "lmmin: nonpositive stepbound %g\n", C->stepbound );
        S->outcome = 10;
        return;
    }
    if (C->scale_diag != 0 && C->scale_diag != 1) {
        fprintf( stderr, "lmmin: logical variable scale_diag=%i, "
                 "should be 0 or 1\n", C->scale_diag );
        S->outcome = 10;
        return;
    }

/***  Allocate work space.  ***/

    if ( (fvec = (double *) malloc(m * sizeof(double))) == NULL ||
		 (fvec2= (double *) malloc(m2* sizeof(double))) == NULL ||  /*added by dawei*/
		 (xback= (double *) malloc(n * sizeof(double))) == NULL ||  /*added by dawei*/
         (diag = (double *) malloc(n * sizeof(double))) == NULL ||
         (qtf  = (double *) malloc(n * sizeof(double))) == NULL ||
         (fjac = (double *) malloc(n*m*sizeof(double))) == NULL ||
         (wa1  = (double *) malloc(n * sizeof(double))) == NULL ||
         (wa2  = (double *) malloc(n * sizeof(double))) == NULL ||
         (wa3  = (double *) malloc(n * sizeof(double))) == NULL ||
         (wf  = (double *)  malloc(m * sizeof(double))) == NULL ||
         (ipvt = (int *)    malloc(n * sizeof(int)   )) == NULL    ) {
        S->outcome = 9;
        return;
    }

    if (!C->scale_diag) {
        for (j = 0; j < n; j++)
            diag[j] = 1.;
    }

	/* get the sum of validation */
	
	(*evaluate)(x,m2,data2,fvec2, &(S->userbreak) );
	temp_validation=0.0;
	for(j=0;j<m2;j++)
		temp_validation+=fvec2[j]*fvec2[j];
	validation_sum=temp_validation;
	nalert=0;

/* above code block is added by dawei li*/

/***  Evaluate function at starting point and calculate norm.  ***/

    (*evaluate)( x, m, data, fvec, &(S->userbreak) );
    S->nfev = 1;
    if ( S->userbreak )
        goto terminate;
    fnorm = lm_enorm(m, fvec);
    if( C->verbosity ) {
        fprintf( msgfile, "lmmin start " );
        lm_print_pars( nout, x, validation_sum, fnorm, msgfile );
    }
    if( fnorm <= LM_DWARF ){
        S->outcome = 0; /* sum of squares almost zero, nothing to do */
        goto terminate;
    }



/***  The outer loop: compute gradient, then descend.  ***/

    for( outer=0; ; ++outer ) {

/* validation check added by dawei li */
		
		(*evaluate)(x,m2,data2,fvec2, &(S->userbreak) );
		temp_validation=0.0;
		for(j=0;j<m2;j++)
			temp_validation+=fvec2[j]*fvec2[j];

		if(temp_validation>validation_sum)  
		{
			nalert++;
			if(nalert>4) 
			{
				S->outcome = 12;
				/*restor x from x_back because x is not good but xback is the best set*/
				for(j=0;j<n;j++)
					x[j]=xback[j];
                goto terminate;
			}
		}
		else
		{
			nalert=0;
			validation_sum=temp_validation;
			
			/*backup x to xback*/
			for(j=0;j<n;j++)
				xback[j]=x[j];
		}


/***  [outer]  Calculate the Jacobian.  ***/

        for (j = 0; j < n; j++) {
            temp = x[j];
            step = MAX(eps*eps, eps * fabs(temp));
            x[j] += step; /* replace temporarily */
            (*evaluate)( x, m, data, wf, &(S->userbreak) );
            ++(S->nfev);
            if ( S->userbreak )
                goto terminate;
            for (i = 0; i < m; i++)
                fjac[j*m+i] = (wf[i] - fvec[i]) / step;
            x[j] = temp; /* restore */
        }
        if ( C->verbosity >=10 ) {
            /* print the entire matrix */
            printf("\nlmmin Jacobian\n");
            for (i = 0; i < m; i++) {
                printf("  ");
                for (j = 0; j < n; j++)
                    printf("%.5e ", fjac[j*m+i]);
                printf("\n");
            }
        }

/***  [outer]  Compute the QR factorization of the Jacobian.  ***/

/*      fjac is an m by n array. The upper n by n submatrix of fjac 
 *        is made to contain an upper triangular matrix r with diagonal
 *        elements of nonincreasing magnitude such that
 *
 *              p^T*(jac^T*jac)*p = r^T*r
 *
 *              (NOTE: ^T stands for matrix transposition),
 *
 *        where p is a permutation matrix and jac is the final calculated
 *        Jacobian. Column j of p is column ipvt(j) of the identity matrix.
 *        The lower trapezoidal part of fjac contains information generated
 *        during the computation of r.
 *
 *      ipvt is an integer array of length n. It defines a permutation
 *        matrix p such that jac*p = q*r, where jac is the final calculated
 *        Jacobian, q is orthogonal (not stored), and r is upper triangular
 *        with diagonal elements of nonincreasing magnitude. Column j of p
 *        is column ipvt(j) of the identity matrix.
 */

        lm_qrfac(m, n, fjac, ipvt, wa1, wa2, wa3);
        /* return values are ipvt, wa1=rdiag, wa2=acnorm */

/***  [outer]  Form q^T * fvec and store first n components in qtf.  ***/

        for (i = 0; i < m; i++)
            wf[i] = fvec[i];

        for (j = 0; j < n; j++) {
            temp3 = fjac[j*m+j];
            if (temp3 != 0.) {
                sum = 0;
                for (i = j; i < m; i++)
                    sum += fjac[j*m+i] * wf[i];
                temp = -sum / temp3;
                for (i = j; i < m; i++)
                    wf[i] += fjac[j*m+i] * temp;
            }
            fjac[j*m+j] = wa1[j];
            qtf[j] = wf[j];
        }

/***  [outer]  Compute norm of scaled gradient and detect degeneracy.  ***/

        gnorm = 0;
        for (j = 0; j < n; j++) {
            if (wa2[ipvt[j]] == 0)
                continue;
            sum = 0.;
            for (i = 0; i <= j; i++)
                sum += fjac[j*m+i] * qtf[i];
            gnorm = MAX( gnorm, fabs( sum / wa2[ipvt[j]] / fnorm ) );
        }

        if (gnorm <= C->gtol) {
            S->outcome = 4;
            goto terminate;
        }

/***  [outer]  Initialize / update diag and delta. ***/

        if ( !outer ) { 
            /* first iteration only */
            if (C->scale_diag) {
                /* diag := norms of the columns of the initial Jacobian */
                for (j = 0; j < n; j++)
                    diag[j] = wa2[j] ? wa2[j] : 1;
                /* xnorm := || D x || */
                for (j = 0; j < n; j++)
                    wa3[j] = diag[j] * x[j];
                xnorm = lm_enorm(n, wa3);
                if( C->verbosity >= 2 ) {
                    fprintf( msgfile, "lmmin diag  " );
                    lm_print_pars( nout, x, validation_sum, xnorm, msgfile );
                }
                /* only now print the header for the loop table */
                if( C->verbosity >=3 ) {
                    fprintf( msgfile, "  o  i     lmpar    prered"
                             "          ratio    dirder      delta"
                             "      pnorm                 fnorm" );
                    for (i = 0; i < nout; ++i)
                        fprintf( msgfile, "               p%i", i );
                    fprintf( msgfile, "\n" );
                }
            } else {
                xnorm = lm_enorm(n, x);
            }
            /* initialize the step bound delta. */
            if ( xnorm )
                delta = C->stepbound * xnorm;
            else
                delta = C->stepbound;
        } else {
            if (C->scale_diag) {
                for (j = 0; j < n; j++)
                    diag[j] = MAX( diag[j], wa2[j] );
            }
        }

/***  The inner loop. ***/
        inner = 0;
        do {

/***  [inner]  Determine the Levenberg-Marquardt parameter.  ***/

            lm_lmpar( n, fjac, m, ipvt, diag, qtf, delta, &lmpar,
                      wa1, wa2, wf, wa3 );
            /* used return values are fjac (partly), lmpar, wa1=x, wa3=diag*x */

            /* predict scaled reduction */
            pnorm = lm_enorm(n, wa3);
            temp2 = lmpar * SQR( pnorm / fnorm );
            for (j = 0; j < n; j++) {
                wa3[j] = 0;
                for (i = 0; i <= j; i++)
                    wa3[i] -= fjac[j*m+i] * wa1[ipvt[j]];
            }
            temp1 = SQR( lm_enorm(n, wa3) / fnorm );
            prered = temp1 + 2 * temp2;
            dirder = -temp1 + temp2; /* scaled directional derivative */

            /* at first call, adjust the initial step bound. */
            if ( !outer && pnorm < delta )
                delta = pnorm;

/***  [inner]  Evaluate the function at x + p.  ***/

            for (j = 0; j < n; j++)
                wa2[j] = x[j] - wa1[j];

            (*evaluate)( wa2, m, data, wf, &(S->userbreak) );
            ++(S->nfev);
            if ( S->userbreak )
                goto terminate;
            fnorm1 = lm_enorm(m, wf);

/***  [inner]  Evaluate the scaled reduction.  ***/

            /* actual scaled reduction */
            actred = 1 - SQR(fnorm1/fnorm);

            /* ratio of actual to predicted reduction */
            ratio = prered ? actred/prered : 0;

            if( C->verbosity == 2 ) {
                fprintf( msgfile, "lmmin (%i:%i) ", outer, inner );
                lm_print_pars( nout, wa2, validation_sum, fnorm1, msgfile );
            } else if( C->verbosity >= 3 ) {
                printf( "%3i %2i %9.2g %9.2g %14.6g"
                        " %9.2g %10.3e %10.3e %21.15e",
                        outer, inner, lmpar, prered, ratio,
                        dirder, delta, pnorm, fnorm1 );
                for (i = 0; i < nout; ++i)
                    fprintf( msgfile, " %16.9g", wa2[i] );
                fprintf( msgfile, "\n" );
            }

            /* update the step bound */
            if        ( ratio <= 0.25 ) {
                if      ( actred >= 0 )
                    temp = 0.5;
                else if ( actred > -99 ) /* -99 = 1-1/0.1^2 */
                    temp = MAX( dirder / (2*dirder + actred), 0.1 );
                else
                    temp = 0.1;
                delta = temp * MIN(delta, pnorm / 0.1);
                lmpar /= temp;
            } else if ( ratio >= 0.75 ) {
                delta = 2*pnorm;
                lmpar *= 0.5;
            } else if ( !lmpar ) {
                delta = 2*pnorm;
            }

/***  [inner]  On success, update solution, and test for convergence.  ***/

            inner_success = ratio >= p0001;
            if ( inner_success ) {

                /* update x, fvec, and their norms */
                if (C->scale_diag) {
                    for (j = 0; j < n; j++) {
                        x[j] = wa2[j];
                        wa2[j] = diag[j] * x[j];
                    }
                } else {
                    for (j = 0; j < n; j++)
                        x[j] = wa2[j];
                }
                for (i = 0; i < m; i++)
                    fvec[i] = wf[i];
                xnorm = lm_enorm(n, wa2);
                fnorm = fnorm1;
            }

            /* convergence tests */ 
            S->outcome = 0;
            if( fnorm<=LM_DWARF )
                goto terminate;  /* success: sum of squares almost zero */
            /* test two criteria (both may be fulfilled) */
            if (fabs(actred) <= C->ftol && prered <= C->ftol && ratio <= 2)
                S->outcome = 1;  /* success: x almost stable */
            if (delta <= C->xtol * xnorm)
                S->outcome += 2; /* success: sum of squares almost stable */
            if (S->outcome != 0) {
                goto terminate;
            }

/***  [inner]  Tests for termination and stringent tolerances.  ***/

            if ( S->nfev >= maxfev ){
                S->outcome = 5;
                goto terminate;
            }
            if ( fabs(actred) <= LM_MACHEP &&
                 prered <= LM_MACHEP && ratio <= 2 ){
                S->outcome = 6;
                goto terminate;
            }
            if ( delta <= LM_MACHEP*xnorm ){
                S->outcome = 7;
                goto terminate;
            }
            if ( gnorm <= LM_MACHEP ){
                S->outcome = 8;
                goto terminate;
            }

/***  [inner]  End of the loop. Repeat if iteration unsuccessful.  ***/

            ++inner;
        } while ( !inner_success );

/***  [outer]  End of the loop. ***/

    };

terminate:
    S->fnorm = lm_enorm(m, fvec);
    if ( C->verbosity >= 2 )
        printf("lmmin outcome (%i) xnorm %g ftol %g xtol %g\n",
               S->outcome, xnorm, C->ftol, C->xtol );
    if( C->verbosity & 1 ) {
        fprintf( msgfile, "lmmin final " );
        lm_print_pars( nout, x, validation_sum, S->fnorm, msgfile );
    }
    if ( S->userbreak ) /* user-requested break */
        S->outcome = 11;

/***  Deallocate the workspace.  ***/
    free(fvec);
    free(diag);
    free(qtf);
    free(fjac);
    free(wa1);
    free(wa2);
    free(wa3);
    free(wf);
    free(ipvt);

} /*** lmmin. ***/


/*****************************************************************************/
/*  lm_lmpar (determine Levenberg-Marquardt parameter)                       */
/*****************************************************************************/

void lm_lmpar(int n, double *r, int ldr, int *ipvt, double *diag,
              double *qtb, double delta, double *par, double *x,
              double *sdiag, double *aux, double *xdi)
{
/*     Given an m by n matrix a, an n by n nonsingular diagonal
 *     matrix d, an m-vector b, and a positive number delta,
 *     the problem is to determine a value for the parameter
 *     par such that if x solves the system
 *
 *          a*x = b  and  sqrt(par)*d*x = 0
 *
 *     in the least squares sense, and dxnorm is the euclidean
 *     norm of d*x, then either par=0 and (dxnorm-delta) < 0.1*delta,
 *     or par>0 and abs(dxnorm-delta) < 0.1*delta.
 *
 *     Using lm_qrsolv, this subroutine completes the solution of the problem
 *     if it is provided with the necessary information from the
 *     qr factorization, with column pivoting, of a. That is, if
 *     a*p = q*r, where p is a permutation matrix, q has orthogonal
 *     columns, and r is an upper triangular matrix with diagonal
 *     elements of nonincreasing magnitude, then lmpar expects
 *     the full upper triangle of r, the permutation matrix p,
 *     and the first n components of qT*b. On output
 *     lmpar also provides an upper triangular matrix s such that
 *
 *          p^T*(a^T*a + par*d*d)*p = s^T*s.
 *
 *     s is employed within lmpar and may be of separate interest.
 *
 *     Only a few iterations are generally needed for convergence
 *     of the algorithm. If, however, the limit of 10 iterations
 *     is reached, then the output par will contain the best
 *     value obtained so far.
 *
 *     parameters:
 *
 *      n is a positive integer input variable set to the order of r.
 *
 *      r is an n by n array. on input the full upper triangle
 *        must contain the full upper triangle of the matrix r.
 *        on OUTPUT the full upper triangle is unaltered, and the
 *        strict lower triangle contains the strict upper triangle
 *        (transposed) of the upper triangular matrix s.
 *
 *      ldr is a positive integer input variable not less than n
 *        which specifies the leading dimension of the array r.
 *
 *      ipvt is an integer input array of length n which defines the
 *        permutation matrix p such that a*p = q*r. column j of p
 *        is column ipvt(j) of the identity matrix.
 *
 *      diag is an input array of length n which must contain the
 *        diagonal elements of the matrix d.
 *
 *      qtb is an input array of length n which must contain the first
 *        n elements of the vector (q transpose)*b.
 *
 *      delta is a positive input variable which specifies an upper
 *        bound on the euclidean norm of d*x.
 *
 *      par is a nonnegative variable. on input par contains an
 *        initial estimate of the levenberg-marquardt parameter.
 *        on OUTPUT par contains the final estimate.
 *
 *      x is an OUTPUT array of length n which contains the least
 *        squares solution of the system a*x = b, sqrt(par)*d*x = 0,
 *        for the output par.
 *
 *      sdiag is an array of length n needed as workspace; on OUTPUT
 *        it contains the diagonal elements of the upper triangular matrix s.
 *
 *      aux is a multi-purpose work array of length n.
 *
 *      xdi is a work array of length n. On OUTPUT: diag[j] * x[j].
 *
 */
    int i, iter, j, nsing;
    double dxnorm, fp, fp_old, gnorm, parc, parl, paru;
    double sum, temp;
    static double p1 = 0.1;

/*** lmpar: compute and store in x the gauss-newton direction. if the
     jacobian is rank-deficient, obtain a least squares solution. ***/

    nsing = n;
    for (j = 0; j < n; j++) {
        aux[j] = qtb[j];        
        if (r[j * ldr + j] == 0 && nsing == n)
            nsing = j;
        if (nsing < n)
            aux[j] = 0;
    }
    for (j = nsing - 1; j >= 0; j--) {
        aux[j] = aux[j] / r[j + ldr * j];
        temp = aux[j];
        for (i = 0; i < j; i++)
            aux[i] -= r[j * ldr + i] * temp;
    }

    for (j = 0; j < n; j++)
        x[ipvt[j]] = aux[j];

/*** lmpar: initialize the iteration counter, evaluate the function at the
     origin, and test for acceptance of the gauss-newton direction. ***/

    for (j = 0; j < n; j++)
        xdi[j] = diag[j] * x[j];
    dxnorm = lm_enorm(n, xdi);
    fp = dxnorm - delta;
    if (fp <= p1 * delta) {
#ifdef LMFIT_DEBUG_MESSAGES
        printf("debug lmpar nsing %d n %d, terminate (fp<p1*delta)\n",
               nsing, n);
#endif
        *par = 0;
        return;
    }

/*** lmpar: if the jacobian is not rank deficient, the newton
     step provides a lower bound, parl, for the 0. of
     the function. otherwise set this bound to 0.. ***/

    parl = 0;
    if (nsing >= n) {
        for (j = 0; j < n; j++)
            aux[j] = diag[ipvt[j]] * xdi[ipvt[j]] / dxnorm;

        for (j = 0; j < n; j++) {
            sum = 0.;
            for (i = 0; i < j; i++)
                sum += r[j * ldr + i] * aux[i];
            aux[j] = (aux[j] - sum) / r[j + ldr * j];
        }
        temp = lm_enorm(n, aux);
        parl = fp / delta / temp / temp;
    }

/*** lmpar: calculate an upper bound, paru, for the 0. of the function. ***/

    for (j = 0; j < n; j++) {
        sum = 0;
        for (i = 0; i <= j; i++)
            sum += r[j * ldr + i] * qtb[i];
        aux[j] = sum / diag[ipvt[j]];
    }
    gnorm = lm_enorm(n, aux);
    paru = gnorm / delta;
    if (paru == 0.)
        paru = LM_DWARF / MIN(delta, p1);

/*** lmpar: if the input par lies outside of the interval (parl,paru),
     set par to the closer endpoint. ***/

    *par = MAX(*par, parl);
    *par = MIN(*par, paru);
    if (*par == 0.)
        *par = gnorm / dxnorm;

/*** lmpar: iterate. ***/

    for (iter=0; ; iter++) {

        /** evaluate the function at the current value of par. **/

        if (*par == 0.)
            *par = MAX(LM_DWARF, 0.001 * paru);
        temp = sqrt(*par);
        for (j = 0; j < n; j++)
            aux[j] = temp * diag[j];

        lm_qrsolv( n, r, ldr, ipvt, aux, qtb, x, sdiag, xdi );
        /* return values are r, x, sdiag */

        for (j = 0; j < n; j++)
            xdi[j] = diag[j] * x[j]; /* used as output */
        dxnorm = lm_enorm(n, xdi);
        fp_old = fp;
        fp = dxnorm - delta;
        
        /** if the function is small enough, accept the current value
            of par. Also test for the exceptional cases where parl
            is zero or the number of iterations has reached 10. **/

        if (fabs(fp) <= p1 * delta
            || (parl == 0. && fp <= fp_old && fp_old < 0.)
            || iter == 10) {
#ifdef LMFIT_DEBUG_MESSAGES
            printf("debug lmpar nsing %d iter %d "
                   "par %.4e [%.4e %.4e] delta %.4e fp %.4e\n",
                   nsing, iter, *par, parl, paru, delta, fp);
#endif
            break; /* the only exit from the iteration. */
        }
        
        /** compute the Newton correction. **/

        for (j = 0; j < n; j++)
            aux[j] = diag[ipvt[j]] * xdi[ipvt[j]] / dxnorm;

        for (j = 0; j < n; j++) {
            aux[j] = aux[j] / sdiag[j];
            for (i = j + 1; i < n; i++)
                aux[i] -= r[j * ldr + i] * aux[j];
        }
        temp = lm_enorm(n, aux);
        parc = fp / delta / temp / temp;

        /** depending on the sign of the function, update parl or paru. **/

        if (fp > 0)
            parl = MAX(parl, *par);
        else if (fp < 0)
            paru = MIN(paru, *par);
        /* the case fp==0 is precluded by the break condition  */
        
        /** compute an improved estimate for par. **/
        
        *par = MAX(parl, *par + parc);
        
    }

} /*** lm_lmpar. ***/

/*****************************************************************************/
/*  lm_qrfac (QR factorization, from lapack)                                 */
/*****************************************************************************/

void lm_qrfac(int m, int n, double *a, int *ipvt,
              double *rdiag, double *acnorm, double *wa)
{
/*
 *     This subroutine uses Householder transformations with column
 *     pivoting (optional) to compute a qr factorization of the
 *     m by n matrix a. That is, qrfac determines an orthogonal
 *     matrix q, a permutation matrix p, and an upper trapezoidal
 *     matrix r with diagonal elements of nonincreasing magnitude,
 *     such that a*p = q*r. The Householder transformation for
 *     column k, k = 1,2,...,min(m,n), is of the form
 *
 *          i - (1/u(k))*u*uT
 *
 *     where u has zeroes in the first k-1 positions. The form of
 *     this transformation and the method of pivoting first
 *     appeared in the corresponding linpack subroutine.
 *
 *     Parameters:
 *
 *      m is a positive integer input variable set to the number
 *        of rows of a.
 *
 *      n is a positive integer input variable set to the number
 *        of columns of a.
 *
 *      a is an m by n array. On input a contains the matrix for
 *        which the qr factorization is to be computed. On OUTPUT
 *        the strict upper trapezoidal part of a contains the strict
 *        upper trapezoidal part of r, and the lower trapezoidal
 *        part of a contains a factored form of q (the non-trivial
 *        elements of the u vectors described above).
 *
 *      ipvt is an integer OUTPUT array of length lipvt. This array
 *        defines the permutation matrix p such that a*p = q*r.
 *        Column j of p is column ipvt(j) of the identity matrix.
 *
 *      rdiag is an OUTPUT array of length n which contains the
 *        diagonal elements of r.
 *
 *      acnorm is an OUTPUT array of length n which contains the
 *        norms of the corresponding columns of the input matrix a.
 *        If this information is not needed, then acnorm can coincide
 *        with rdiag.
 *
 *      wa is a work array of length n.
 *
 */
    int i, j, k, kmax, minmn;
    double ajnorm, sum, temp;

/*** qrfac: compute initial column norms and initialize several arrays. ***/

    for (j = 0; j < n; j++) {
        acnorm[j] = lm_enorm(m, &a[j*m]);
        rdiag[j] = acnorm[j];
        wa[j] = rdiag[j];
        ipvt[j] = j;
    }
#ifdef LMFIT_DEBUG_MESSAGES
    printf("debug qrfac\n");
#endif

/*** qrfac: reduce a to r with Householder transformations. ***/

    minmn = MIN(m, n);
    for (j = 0; j < minmn; j++) {

        /** bring the column of largest norm into the pivot position. **/

        kmax = j;
        for (k = j + 1; k < n; k++)
            if (rdiag[k] > rdiag[kmax])
                kmax = k;
        if (kmax == j)
            goto pivot_ok;

        for (i = 0; i < m; i++) {
            temp = a[j*m+i];
            a[j*m+i] = a[kmax*m+i];
            a[kmax*m+i] = temp;
        }
        rdiag[kmax] = rdiag[j];
        wa[kmax] = wa[j];
        k = ipvt[j];
        ipvt[j] = ipvt[kmax];
        ipvt[kmax] = k;

      pivot_ok:
        /** compute the Householder transformation to reduce the
            j-th column of a to a multiple of the j-th unit vector. **/

        ajnorm = lm_enorm(m-j, &a[j*m+j]);
        if (ajnorm == 0.) {
            rdiag[j] = 0;
            continue;
        }

        if (a[j*m+j] < 0.)
            ajnorm = -ajnorm;
        for (i = j; i < m; i++)
            a[j*m+i] /= ajnorm;
        a[j*m+j] += 1;

        /** apply the transformation to the remaining columns
            and update the norms. **/
#pragma omp parallel for private(k,sum,temp,i)
        for (k = j + 1; k < n; k++) {
            sum = 0;

            for (i = j; i < m; i++)
                sum += a[j*m+i] * a[k*m+i];

            temp = sum / a[j + m * j];

#pragma ivdep
            for (i = j; i < m; i++)
                a[k*m+i] -= temp * a[j*m+i];

            if (rdiag[k] != 0.) {
                temp = a[m * k + j] / rdiag[k];
                temp = MAX(0., 1 - temp * temp);
                rdiag[k] *= sqrt(temp);
                temp = rdiag[k] / wa[k];
                if ( 0.05 * SQR(temp) <= LM_MACHEP ) {
                    rdiag[k] = lm_enorm(m-j-1, &a[m*k+j+1]);
                    wa[k] = rdiag[k];
                }
            }
        }

        rdiag[j] = -ajnorm;
    }
} /*** lm_qrfac. ***/


/*****************************************************************************/
/*  lm_qrsolv (linear least-squares)                                         */
/*****************************************************************************/

void lm_qrsolv(int n, double *r, int ldr, int *ipvt, double *diag,
               double *qtb, double *x, double *sdiag, double *wa)
{
/*
 *     Given an m by n matrix a, an n by n diagonal matrix d,
 *     and an m-vector b, the problem is to determine an x which
 *     solves the system
 *
 *          a*x = b  and  d*x = 0
 *
 *     in the least squares sense.
 *
 *     This subroutine completes the solution of the problem
 *     if it is provided with the necessary information from the
 *     qr factorization, with column pivoting, of a. That is, if
 *     a*p = q*r, where p is a permutation matrix, q has orthogonal
 *     columns, and r is an upper triangular matrix with diagonal
 *     elements of nonincreasing magnitude, then qrsolv expects
 *     the full upper triangle of r, the permutation matrix p,
 *     and the first n components of (q transpose)*b. The system
 *     a*x = b, d*x = 0, is then equivalent to
 *
 *          r*z = q^T*b,  p^T*d*p*z = 0,
 *
 *     where x = p*z. If this system does not have full rank,
 *     then a least squares solution is obtained. On output qrsolv
 *     also provides an upper triangular matrix s such that
 *
 *          p^T *(a^T *a + d*d)*p = s^T *s.
 *
 *     s is computed within qrsolv and may be of separate interest.
 *
 *     Parameters
 *
 *      n is a positive integer input variable set to the order of r.
 *
 *      r is an n by n array. On input the full upper triangle
 *        must contain the full upper triangle of the matrix r.
 *        On OUTPUT the full upper triangle is unaltered, and the
 *        strict lower triangle contains the strict upper triangle
 *        (transposed) of the upper triangular matrix s.
 *
 *      ldr is a positive integer input variable not less than n
 *        which specifies the leading dimension of the array r.
 *
 *      ipvt is an integer input array of length n which defines the
 *        permutation matrix p such that a*p = q*r. Column j of p
 *        is column ipvt(j) of the identity matrix.
 *
 *      diag is an input array of length n which must contain the
 *        diagonal elements of the matrix d.
 *
 *      qtb is an input array of length n which must contain the first
 *        n elements of the vector (q transpose)*b.
 *
 *      x is an OUTPUT array of length n which contains the least
 *        squares solution of the system a*x = b, d*x = 0.
 *
 *      sdiag is an OUTPUT array of length n which contains the
 *        diagonal elements of the upper triangular matrix s.
 *
 *      wa is a work array of length n.
 *
 */
    int i, kk, j, k, nsing;
    double qtbpj, sum, temp;
    double _sin, _cos, _tan, _cot; /* local variables, not functions */

/*** qrsolv: copy r and q^T*b to preserve input and initialize s.
     in particular, save the diagonal elements of r in x. ***/

    for (j = 0; j < n; j++) {
        for (i = j; i < n; i++)
            r[j * ldr + i] = r[i * ldr + j];
        x[j] = r[j * ldr + j];
        wa[j] = qtb[j];
    }
/*** qrsolv: eliminate the diagonal matrix d using a Givens rotation. ***/

    for (j = 0; j < n; j++) {

/*** qrsolv: prepare the row of d to be eliminated, locating the
     diagonal element using p from the qr factorization. ***/

        if (diag[ipvt[j]] == 0.)
            goto L90;
        for (k = j; k < n; k++)
            sdiag[k] = 0.;
        sdiag[j] = diag[ipvt[j]];

/*** qrsolv: the transformations to eliminate the row of d modify only 
     a single element of qT*b beyond the first n, which is initially 0. ***/

        qtbpj = 0.;
        for (k = j; k < n; k++) {

            /** determine a Givens rotation which eliminates the
                appropriate element in the current row of d. **/

            if (sdiag[k] == 0.)
                continue;
            kk = k + ldr * k;
            if (fabs(r[kk]) < fabs(sdiag[k])) {
                _cot = r[kk] / sdiag[k];
                _sin = 1 / sqrt(1 + SQR(_cot));
                _cos = _sin * _cot;
            } else {
                _tan = sdiag[k] / r[kk];
                _cos = 1 / sqrt(1 + SQR(_tan));
                _sin = _cos * _tan;
            }

            /** compute the modified diagonal element of r and
                the modified element of ((q^T)*b,0). **/

            r[kk] = _cos * r[kk] + _sin * sdiag[k];
            temp = _cos * wa[k] + _sin * qtbpj;
            qtbpj = -_sin * wa[k] + _cos * qtbpj;
            wa[k] = temp;

            /** accumulate the tranformation in the row of s. **/

            for (i = k + 1; i < n; i++) {
                temp = _cos * r[k * ldr + i] + _sin * sdiag[i];
                sdiag[i] = -_sin * r[k * ldr + i] + _cos * sdiag[i];
                r[k * ldr + i] = temp;
            }
        }

      L90:
        /** store the diagonal element of s and restore
            the corresponding diagonal element of r. **/

        sdiag[j] = r[j * ldr + j];
        r[j * ldr + j] = x[j];
    }

/*** qrsolv: solve the triangular system for z. if the system is
     singular, then obtain a least squares solution. ***/

    nsing = n;
    for (j = 0; j < n; j++) {
        if (sdiag[j] == 0. && nsing == n)
            nsing = j;
        if (nsing < n)
            wa[j] = 0;
    }

    for (j = nsing - 1; j >= 0; j--) {
        sum = 0;
        for (i = j + 1; i < nsing; i++)
            sum += r[j * ldr + i] * wa[i];
        wa[j] = (wa[j] - sum) / sdiag[j];
    }

/*** qrsolv: permute the components of z back to components of x. ***/

    for (j = 0; j < n; j++)
        x[ipvt[j]] = wa[j];

} /*** lm_qrsolv. ***/


/*****************************************************************************/
/*  lm_enorm (Euclidean norm)                                                */
/*****************************************************************************/

double lm_enorm(int n, const double *x)
{
/*     Given an n-vector x, this function calculates the
 *     euclidean norm of x.
 *
 *     The euclidean norm is computed by accumulating the sum of
 *     squares in three different sums. The sums of squares for the
 *     small and large components are scaled so that no overflows
 *     occur. Non-destructive underflows are permitted. Underflows
 *     and overflows do not occur in the computation of the unscaled
 *     sum of squares for the intermediate components.
 *     The definitions of small, intermediate and large components
 *     depend on two constants, LM_SQRT_DWARF and LM_SQRT_GIANT. The main
 *     restrictions on these constants are that LM_SQRT_DWARF**2 not
 *     underflow and LM_SQRT_GIANT**2 not overflow.
 *
 *     Parameters
 *
 *      n is a positive integer input variable.
 *
 *      x is an input array of length n.
 */
    int i;
    double agiant, s1, s2, s3, xabs, x1max, x3max, temp;

    s1 = 0;
    s2 = 0;
    s3 = 0;
    x1max = 0;
    x3max = 0;
    agiant = LM_SQRT_GIANT / n;

    /** sum squares. **/

    for (i = 0; i < n; i++) {
        xabs = fabs(x[i]);
        if (xabs > LM_SQRT_DWARF) {
            if ( xabs < agiant ) {
                s2 += xabs * xabs;
            } else if ( xabs > x1max ) {
                temp = x1max / xabs;
                s1 = 1 + s1 * SQR(temp);
                x1max = xabs;
            } else {
                temp = xabs / x1max;
                s1 += SQR(temp);
            }
        } else if ( xabs > x3max ) {
            temp = x3max / xabs;
            s3 = 1 + s3 * SQR(temp);
            x3max = xabs;
        } else if (xabs != 0.) {
            temp = xabs / x3max;
            s3 += SQR(temp);
        }
    }

    /** calculation of norm. **/

    if (s1 != 0)
        return x1max * sqrt(s1 + (s2 / x1max) / x1max);
    else if (s2 != 0)
        if (s2 >= x3max)
            return sqrt(s2 * (1 + (x3max / s2) * (x3max * s3)));
        else
            return sqrt(x3max * ((s2 / x3max) + (x3max * s3)));
    else
        return x3max * sqrt(s3);

} /*** lm_enorm. ***/

########## NEXT FILE ##########
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <math.h>
#include <time.h>

using namespace std;


#include "pdb.h"

#include "debug.h"

int CDssp::loaddata(string name)
{
	char buffer[255];
	bool begin;
	struct dsspline aadssp;
	string line;

	sprintf(buffer,"dssp %s > dssp.out",name.c_str());
	system(buffer); 

	ifstream fin("dssp.out");
	if (!fin.is_open())
		return 1;

	
	begin=0;
	while(getline(fin,line))
	{
		if(line.find("RESIDUE AA")!=std::string::npos)
		{
			begin=1;
			continue;
		}
		if(begin==1)
		{
			aadssp.id=atoi(line.substr(5,5).c_str());
			aadssp.code=line[13];
			aadssp.ss=line[16];
			data.push_back(aadssp);
		}
	}
	return 0;
}

string CDssp::getseq()
{
	int i;
	string s;

	for(i=0;i<(int)data.size();i++)
		s.push_back(data.at(i).code);
	return s;
}

CDssp::CDssp()
{}
CDssp::~CDssp()
{}

//////////////////////////
// class CPdb           //
//////////////////////////

void CPdb::process_ambig(int flag)
{
	//meaning of flag:
	// 1. remove any ambig assignment
	// 2. combine all hb2, hb3 into mean value, if code is 1 or 2, otherwise remove ambig
	int i;
	if(flag==1)
	{
		for(i=0;i<(int)v.size();i++)
		{
			v.at(i)->remove_ambig(flag);
		}
	}
	
	//not really needed ??? if take mean in function get all proton
	if(flag==2)
	{
		for(i=0;i<(int)v.size();i++)
		{
			v.at(i)->methyl_ambig(flag);
			//v.at(i)->combine_hsamec(flag);
		}
	}

	if(flag==3)
	{
		//remove methyl ambig==2 case
	}
}


void CPdb::clear()
{
	unsigned int i;
	for(i=0;i<(int)v.size();i++)
	{
		delete v.at(i);
	}
	v.clear();
	for(i=0;i<(int)ligand.size();i++)
	{
		delete ligand.at(i);
	}
	ligand.clear();
	chains.clear();
	chain_block.clear();
	chain_ligand.clear();
	blocks.clear();
	pdbseq.clear();
}

void CPdb::print_print(FILE *fp,vector<int> att1, vector<int> att2,int index,int type,double a,double b,double c,double w)
{
	int i,j;

	for(i=0;i<att1.size();i++)
	for(j=0;j<att2.size();j++)
	{	
		fprintf(fp,"%10d%10d%10d%10d%10d",att1.at(i),att2.at(j),1,index,type);
		fprintf(fp,"%10.4f%10.4f%10.4f%10.4f\n",a/10,b/10,c/10,w);  //unit is nm instead of A in Gromacs!
	}
	return;
}

void CPdb::print_gromacs(string filename,vector <struct diheline> *dihecons)
{
	FILE *fp;
	struct noeline tline;
	int i,j;

	fp=fopen(filename.c_str(),"wt");
	fprintf(fp,"[dihedral_restraints]\n");
	for(i=0;i<dihecons->size();i++)
	{
		for(j=0;j<4;j++) fprintf(fp,"%d ",dihecons->at(i).index[j].atoms.at(0).at(0));
		fprintf(fp," 1 1 ");
		fprintf(fp,"%8.3f%8.3f",(float)dihecons->at(i).middle,(float)dihecons->at(i).delta);
		fprintf(fp," 1 2\n");
	}
	fclose(fp);
	return;
}



void CPdb::print_gromacs(string filename,vector <struct noeline> *nmrcons)
{
	FILE *fp;
	struct noeline tline;
	int i,j,index;
	int n1,n2;
	double length1,length2;
	vector<int> att1,att2;
	string filename2;

	vector<int> nshort;
	vector<int> nlong;
	vector< vector<int> > whos;
	vector< vector<int> > pairs;
	vector< vector<int> > used;
	vector< vector<double> > weights;

	nshort.resize(v.size());
	nlong.resize(v.size());
	whos.resize(v.size());
	pairs.resize(v.size());
	weights.resize(v.size());
	used.resize(v.size());
	for(i=0;i<v.size();i++)
		used.at(i).resize(v.size(),0);


	for(i=0;i<pairs.size();i++)
	{
		pairs.at(i).resize(v.size());
		weights.at(i).resize(v.size());
	}

	for(i=0;i<nmrcons->size();i++)
	{
		if(fabs((float)(nmrcons->at(i).resid1-nmrcons->at(i).resid2))<=4)
		{
			nshort.at(nmrcons->at(i).resid1-1)++;
			nshort.at(nmrcons->at(i).resid2-1)++;
		}
		else
		{
			nlong.at(nmrcons->at(i).resid1-1)++;
			nlong.at(nmrcons->at(i).resid2-1)++;
			whos.at(nmrcons->at(i).resid1-1).push_back(nmrcons->at(i).resid2);
			whos.at(nmrcons->at(i).resid2-1).push_back(nmrcons->at(i).resid1);
			pairs.at(nmrcons->at(i).resid1-1).at(nmrcons->at(i).resid2-1)++;
			pairs.at(nmrcons->at(i).resid2-1).at(nmrcons->at(i).resid1-1)++;
		}

	}

	fp=fopen("cons_detail.dat","wt");
	for(i=0;i<v.size();i++)
	{
		fprintf(fp,"%d %d %d\n",i+1,nshort.at(i),nlong.at(i));
	}
	fclose(fp);

	fp=fopen("cons_whos.dat","wt");
	for(i=0;i<whos.size();i++)
	{
		fprintf(fp,"%d",i+1);
		for(j=0;j<whos.at(i).size();j++)
			fprintf(fp," %d",whos.at(i).at(j));
		fprintf(fp,"\n");
	}
	fclose(fp);


	int b1,b2,s1,s2,k1,k2;
	double c;
	for(i=0;i<v.size();i++)
	{
		for(j=0;j<v.size();j++)
		{
			weights.at(i).at(j)=1;
			if(pairs.at(i).at(j)>0)
				weights.at(i).at(j)=1.0/pairs.at(i).at(j);
			c=0;
			b1=-1; if(i==0) b1=0;
			b2=-1; if(j==0) b2=0;
			s1=1; if(i==v.size()-1) s1=0;
			s2=1; if(j==v.size()-1) s2=0;
			for(k1=i+b1;k1<=i+s1;k1++)
			for(k2=j+b2;k2<=j+s2;k2++)
				c+=pairs.at(k1).at(k2);
			c-=pairs.at(i).at(j);
			if(c>0) weights.at(i).at(j)/=sqrt(c);
		}
	}


	index=-1;
	fp=fopen(filename.c_str(),"wt");
	fprintf(fp,"[distance_restraints]\n");
	fprintf(fp,"; all long range noe distance restraints\n");
	for(i=0;i<nmrcons->size();i++)
	{
		if(fabs((float)(nmrcons->at(i).resid1-nmrcons->at(i).resid2))<=4)
			continue;
		tline=nmrcons->at(i);
		length1=0;
		length2=0;

		for(n1=0;n1<(int)nmrcons->at(i).index1.atoms.size();n1++)
		{
			length1=nmrcons->at(i).index1.length;
			for(n2=0;n2<(int)nmrcons->at(i).index2.atoms.size();n2++)
			{
				index++;
				length2=nmrcons->at(i).index1.length;
				att1=nmrcons->at(i).index1.atoms.at(n1);
				att2=nmrcons->at(i).index2.atoms.at(n2);
				print_print(fp,att1,att2,index,1,0,nmrcons->at(i).a+length1+length2,nmrcons->at(i).a+2+length1+length2,weights.at(tline.resid1-1).at(tline.resid2-1));
			}
		}
	}
	fclose(fp);

	fp=fopen("cns_distance.tbl","wt");
	for(i=0;i<nmrcons->size();i++)
	{
		if(nmrcons->at(i).bvio==1)
			continue;
		if(fabs((float)(nmrcons->at(i).resid1-nmrcons->at(i).resid2))<=4)
		{
			tline=nmrcons->at(i);
			fprintf(fp,"assign (resid %d and name %s ) (resid %d and name %s ) %f %f %f\n",
				tline.oldresid1,tline.oldatomname1.c_str(),tline.oldresid2,tline.oldatomname2.c_str(),
				(float)tline.b,(float)tline.c,(float)tline.a);
		}
		else
		{
			tline=nmrcons->at(i);
			if(used.at(tline.resid1-1).at(tline.resid2-1)==0)
			{
				fprintf(fp,"assign (resid %d and name %s ) (resid %d and name %s ) %f %f %f\n",
					tline.oldresid1,tline.oldatomname1.c_str(),tline.oldresid2,tline.oldatomname2.c_str(),
					(float)tline.b,(float)tline.c,(float)tline.a);
				used.at(tline.resid1-1).at(tline.resid2-1)++;
				used.at(tline.resid2-1).at(tline.resid1-1)++;
			}
		}
	}
	fclose(fp);


	index=-1;
	filename2=filename;
	filename2.insert(filename2.find("."),"2");
	fp=fopen(filename2.c_str(),"wt");
	fprintf(fp,"[distance_restraints]\n");
	fprintf(fp,"; vilated noe distance restraints\n");
	for(i=0;i<nmrcons->size();i++)
	{
		if(nmrcons->at(i).bvio==0)
			continue;
		tline=nmrcons->at(i);
		length1=0;
		length2=0;

		for(n1=0;n1<(int)nmrcons->at(i).index1.atoms.size();n1++)
		{
			length1=nmrcons->at(i).index1.length;
			for(n2=0;n2<(int)nmrcons->at(i).index2.atoms.size();n2++)
			{
				index++;
				length2=nmrcons->at(i).index1.length;
				att1=nmrcons->at(i).index1.atoms.at(n1);
				att2=nmrcons->at(i).index2.atoms.at(n2);
				print_print(fp,att1,att2,index,1,0,nmrcons->at(i).a+length1+length2,nmrcons->at(i).a+2+length1+length2,1.0);
			}
		}
	}
	fclose(fp);


	index=-1;
	filename2=filename;
	filename2.insert(filename2.find("."),"3");
	fp=fopen(filename2.c_str(),"wt");
	fprintf(fp,"[distance_restraints]\n");
	fprintf(fp,"; fullfiled noe distance restraints\n");
	for(i=0;i<nmrcons->size();i++)
	{
		if(nmrcons->at(i).bvio==1)
			continue;
		tline=nmrcons->at(i);
		length1=0;
		length2=0;

		for(n1=0;n1<(int)nmrcons->at(i).index1.atoms.size();n1++)
		{
			length1=nmrcons->at(i).index1.length;
			for(n2=0;n2<(int)nmrcons->at(i).index2.atoms.size();n2++)
			{
				index++;
				length2=nmrcons->at(i).index1.length;
				att1=nmrcons->at(i).index1.atoms.at(n1);
				att2=nmrcons->at(i).index2.atoms.at(n2);
				print_print(fp,att1,att2,index,1,0,nmrcons->at(i).a+length1+length2,nmrcons->at(i).a+2+length1+length2,1.0);
			}
		}
	}
	fclose(fp);


	index=-1;
	filename2=filename;
	filename2.insert(filename2.find("."),"4");
	fp=fopen(filename2.c_str(),"wt");
	fprintf(fp,"[distance_restraints]\n");
	fprintf(fp,"; all noe distance restraints\n");
	for(i=0;i<nmrcons->size();i++)
	{
		tline=nmrcons->at(i);
		length1=0;
		length2=0;

		for(n1=0;n1<(int)nmrcons->at(i).index1.atoms.size();n1++)
		{
			length1=nmrcons->at(i).index1.length;
			for(n2=0;n2<(int)nmrcons->at(i).index2.atoms.size();n2++)
			{
				index++;
				length2=nmrcons->at(i).index1.length;
				att1=nmrcons->at(i).index1.atoms.at(n1);
				att2=nmrcons->at(i).index2.atoms.at(n2);
				print_print(fp,att1,att2,index,1,0,nmrcons->at(i).a+length1+length2,nmrcons->at(i).a+2+length1+length2,1.0);
			}
		}
	}
	fclose(fp);

	return;
}


int CPdb::loadnoedata(string filename,string filename2,vector <struct noeline> *nmrcons)
{
	string nmrseq;
	int adj,adj2;
	vector<int> out;
	char c1,c2;
	ifstream fin(filename.c_str());
	ifstream fin2(filename2.c_str());
	istringstream iss;
	string line,p;
	string resname1,atomname1,resname2,atomname2,resname,atomname;
	int resid1,resid2,order,resid;
	double a,b,c;
	int i;
	struct noeline tline;
	bool bfirst;
	int index,index_old;
	int norder1,norder2;

	i=0;
	bfirst=1;
	while(getline(fin,line))
	{
		i++;
		iss.clear();
		iss.str(line);
		iss>>index;
		iss>>p>>order>>p>>p;
		iss>>resid;
		iss>>resname;
		iss>>atomname;
		iss>>p>>p>>p>>p>>p>>p;

		if(bfirst)
		{
			bfirst=0;
			resid1=resid2=-1;
			index_old=index;
			norder1=norder2=0;
		}

		if(index>index_old) //we now reach a new entry
		{
			tline.id=index_old;
			tline.resid1=resid1;
			tline.resid2=resid2;
			tline.resname1=resname1;
			tline.resname2=resname2;
			tline.atomname1=atomname1;
			tline.atomname2=atomname2;
			tline.multi=0;
			if(norder1>1 || norder2>1)
				tline.multi=1;
			nmrcons->push_back(tline);

			resid1=resid2=-1;
			index_old=index;
			norder1=norder2=0;
		}

		if(order==1)
		{
			norder1++;
			resid1=resid;
			resname1=resname;
			atomname1=atomname;
		}
		else if(order==2)
		{
			norder2++;
			resid2=resid;
			resname2=resname;
			atomname2=atomname;
		}
		else
		{
			cout<<"Unsupported order "<<order<<endl;
			break;
		}
	}

	//process the final entry.
	if(resid1>0 && resid2>0)
	{
		tline.id=index_old;
		tline.resid1=resid1;
		tline.resid2=resid2;
		tline.resname1=resname1;
		tline.resname2=resname2;
		tline.atomname1=atomname1;
		tline.atomname2=atomname2;
		nmrcons->push_back(tline);
	}


	i=0;
	while(getline(fin2,line))
	{
		iss.clear();
		iss.str(line);
		iss>>index;
		if(index!=nmrcons->at(i).id)
		{
			cout<<"readin noe data error. index is NOT as expected in second part"<<endl;
			break;
		}
		iss>>p>>p>>p>>p>>p>>p;
		iss>>b>>c>>a;
		iss>>p>>p;
		nmrcons->at(i).a=a;
		nmrcons->at(i).b=b;
		nmrcons->at(i).c=c;


		c1=Sequence::name2code(nmrcons->at(i).resname1);
		c2=Sequence::name2code(nmrcons->at(i).resname2);
		nmrcons->at(i).resid1--;
		nmrcons->at(i).resid2--;
		if(nmrcons->at(i).resid1+1>nmrseq.size())
			nmrseq.resize(nmrcons->at(i).resid1+1,'U');
		nmrseq.at(nmrcons->at(i).resid1)=c1;
		if(nmrcons->at(i).resid2+1>nmrseq.size())
			nmrseq.resize(nmrcons->at(i).resid2+1,'U');
		nmrseq.at(nmrcons->at(i).resid2)=c2;

		i++;
	}

	out=Sequence::align(pdbseq,nmrseq);
	adj=0;adj2=0;
	for(i=0;i<out.size();i++)
	{
		if(out.at(i)!=0)
		{
			adj+=(out.at(i)-i);
			adj2++;
		}
	}
	adj/=adj2;


	//remove entry with multiply atoms
	for(i=nmrcons->size()-1;i>=0;i--)
	{
		nmrcons->at(i).resid1++;
		nmrcons->at(i).resid2++;
		if(nmrcons->at(i).multi==1)
		{
			cout<<"Remove noe entry with umbigirious assignment. "<<nmrcons->at(i).id<<endl;
			nmrcons->erase(nmrcons->begin()+i);
		}
	}


	for(i=0;i<nmrcons->size();i++)
	{
		nmrcons->at(i).index1.length=0.0;
		nmrcons->at(i).index2.length=0.0;
		nmrcons->at(i).resid1-=adj;
		nmrcons->at(i).resid2-=adj;

		if(nmrcons->at(i).resid1>=1 && nmrcons->at(i).resid2>=1 && nmrcons->at(i).resid1<=(int)v.size() && nmrcons->at(i).resid2<=(int)v.size() )
		{
			nmrcons->at(i).index1=v.at(nmrcons->at(i).resid1-1)->query(nmrcons->at(i).atomname1);
			nmrcons->at(i).index2=v.at(nmrcons->at(i).resid2-1)->query(nmrcons->at(i).atomname2);
		}
		else
		{
			nmrcons->erase(nmrcons->begin()+i);
			i--;
		}
	}
	return adj;

}




int CPdb::loadnoedata(string filename,vector <struct noeline> *nmrcons)
{

	ifstream fin(filename.c_str());
	string line;
	vector<string> block1, block2;
	bool bstart,inloop,begin1,begin2;

	bstart=0;
	inloop=0;
	begin1=0;
	begin2=0;

	while(getline(fin,line))
	{
		if(line.size()<4)
			continue;

		if(begin2==1 &&  line.find("stop_")!=string::npos)
			bstart=begin2=0;
		if(begin1==1 &&  line.find("stop_")!=string::npos)
			begin1=0;


		if(begin1==1)
			block1.push_back(line);
		if(begin2==1)
			block2.push_back(line);

		if(line.find("loop_")!=string::npos)
			inloop=1;
		if(line.find("stop_")!=string::npos)
			inloop=0;

		if(inloop==0 && ( line.find("save_CNS/XPLOR_distance_constraints")!=string::npos || line.find("save_DYANA/DIANA_distance_constraints")!=string::npos) )
		{
			getline(fin,line);
			getline(fin,line);
			getline(fin,line);
			getline(fin,line);
			
			if(line.find("_Distance_constraint_list.Constraint_type")!=string::npos)
			{
				if( line.find("NOE")!=string::npos )
					bstart=1;
			}
			getline(fin,line);
			getline(fin,line);
		}

		if(bstart==1 && inloop==1 && line.find("_Dist_constraint.Distance_constraint_list_ID")!=string::npos)
			begin1=1;
		if(bstart==1 && inloop==1 && line.find("_Dist_constraint_value.Distance_constraint_list_ID")!=string::npos)
			begin2=1;
	}

	return actualload(&block1,&block2,nmrcons);
}
      



 
int CPdb::actualload(vector<string> *b1, vector<string> *b2, vector <struct noeline> *nmrcons)
{
	string nmrseq;
	int adj,adj2;
	vector<int> out;
	char c1,c2;
	istringstream iss;
	string line,p;
	string resname1,atomname1,resname2,atomname2,resname,atomname;
	string oldatomname,oldatomname1,oldatomname2;
	int resid1,resid2,order,resid,oldresid,oldresid1,oldresid2;
	double a,b,c;
	int i,ii,iii;
	struct noeline tline;
	bool bfirst;
	int index,index_old;
	int norder1,norder2;


	bfirst=1;
	for(i=0;i<b1->size();i++)
	{
		
		iss.clear();
		iss.str(b1->at(i));
		iss>>index;
		iss>>p>>order>>p>>p;
		iss>>resid;
		iss>>resname;
		iss>>atomname;
		iss>>p>>oldresid>>p>>oldatomname>>p>>p;

		if(bfirst)
		{
			bfirst=0;
			resid1=resid2=-1;
			index_old=index;
			norder1=norder2=0;
		}

		if(index>index_old) //we now reach a new entry
		{
			tline.id=index_old;
			tline.resid1=resid1;
			tline.resid2=resid2;
			tline.resname1=resname1;
			tline.resname2=resname2;
			tline.atomname1=atomname1;
			tline.atomname2=atomname2;
			tline.oldresid1=oldresid1;
			tline.oldresid2=oldresid2;
			tline.oldatomname1=oldatomname1;
			tline.oldatomname2=oldatomname2;
			tline.multi=0;
			if(norder1>1 || norder2>1)
				tline.multi=1;
			nmrcons->push_back(tline);

			resid1=resid2=-1;
			index_old=index;
			norder1=norder2=0;
		}

		if(order==1)
		{
			norder1++;
			resid1=resid;
			resname1=resname;
			atomname1=atomname;
			oldresid1=oldresid;
			oldatomname1=oldatomname;
		}
		else if(order==2)
		{
			norder2++;
			resid2=resid;
			resname2=resname;
			atomname2=atomname;
			oldresid2=oldresid;
			oldatomname2=oldatomname;
		}
		else
		{
			cout<<"Unsupported order "<<order<<endl;
			break;
		}
	}

	//process the final entry.
	if(resid1>0 && resid2>0)
	{
		tline.id=index_old;
		tline.resid1=resid1;
		tline.resid2=resid2;
		tline.resname1=resname1;
		tline.resname2=resname2;
		tline.atomname1=atomname1;
		tline.atomname2=atomname2;
		nmrcons->push_back(tline);
		tline.oldresid1=oldresid1;
		tline.oldresid2=oldresid2;
		tline.oldatomname1=oldatomname1;
		tline.oldatomname2=oldatomname2;
	}


	cout<<"fillin sequence of NOE"<<endl;
	for(i=0;i<b2->size();i++)
	{
		//cout<<"i is "<<i<<" and b2's size is "<<b2->size()<<" and b1's size is "<<b1->size()<<" and nmrcons's size is "<<nmrcons->size()<<endl;
		iss.clear();
		iss.str(b2->at(i));
		iss>>index;

		iss>>p;
		iss>>p;
		iss>>p;
		iss>>p;
		iss>>p;
		iss>>p;
		iss>>p; b=atof(p.c_str());
		iss>>p; c=atof(p.c_str());
		iss>>p; a=atof(p.c_str());
		iss>>p;
		iss>>p;
		iii=-1;
		for(ii=0;ii<nmrcons->size();ii++)
		{
			if(index==nmrcons->at(ii).id)
				iii=ii;
		}

		// not found!
		if(iii<0)
			break;

		nmrcons->at(iii).a=a;
		nmrcons->at(iii).b=b;
		nmrcons->at(iii).c=c;
	}

	for(i=0;i<nmrcons->size();i++)
	{
		c1=Sequence::name2code(nmrcons->at(i).resname1);
		c2=Sequence::name2code(nmrcons->at(i).resname2);

		if(nmrcons->at(i).resid1>nmrseq.size())
		{
			nmrseq.resize(nmrcons->at(i).resid1,'U');
			//cout<<"resize nmrseq to "<<nmrcons->at(i).resid1+1<<endl;
		}
		//cout<<nmrcons->at(i).resid1<<" is filled with "<<c1<<"size of nmrseq is "<<nmrseq.size()<<endl;
		//cout.flush();
		nmrseq.at(nmrcons->at(i).resid1-1)=c1;
		//cout<<"done1"<<endl;
		if(nmrcons->at(i).resid2>nmrseq.size())
		{
			nmrseq.resize(nmrcons->at(i).resid2,'U');
			//cout<<"resize nmrseq to "<<nmrcons->at(i).resid2+1<<endl;
		}
		//cout<<nmrcons->at(i).resid2<<" is filled with "<<c2<<"size of nmrseq is "<<nmrseq.size()<<endl;
		//cout.flush();
		nmrseq.at(nmrcons->at(i).resid2-1)=c2;
		//cout<<"done2"<<endl;
	}

	//cout<<"just before alighment"<<endl;
	out=Sequence::align(pdbseq,nmrseq);
	adj=0;adj2=0;
	for(i=out.size()/10;i<out.size()-out.size()/10;i++)
	{
		if(out.at(i)!=0)
		{
			adj+=(out.at(i)-i);
			adj2++;
		}
	}
	adj/=adj2;
	//cout<<"Alignment of NOE data is "<<adj<<endl;


	//remove entry with multiply atoms
	for(i=nmrcons->size()-1;i>=0;i--)
	{
		if(nmrcons->at(i).multi==1)
		{
			cout<<"Remove noe entry with umbigirious assignment. "<<nmrcons->at(i).id<<endl;
			nmrcons->erase(nmrcons->begin()+i);
		}
	}


	for(i=0;i<nmrcons->size();i++)
	{
        nmrcons->at(i).group=1;
		nmrcons->at(i).index1.length=0.0;
		nmrcons->at(i).index2.length=0.0;
		nmrcons->at(i).resid1-=adj;
		nmrcons->at(i).resid2-=adj;

		if(nmrcons->at(i).resid1>=1 && nmrcons->at(i).resid2>=1 && nmrcons->at(i).resid1<=(int)v.size() && nmrcons->at(i).resid2<=(int)v.size() )
		{
			nmrcons->at(i).index1=v.at(nmrcons->at(i).resid1-1)->query(nmrcons->at(i).atomname1);
			nmrcons->at(i).index2=v.at(nmrcons->at(i).resid2-1)->query(nmrcons->at(i).atomname2);
		}
		else
		{
			nmrcons->erase(nmrcons->begin()+i);
			i--;
		}
	}
	return adj;

}

void CPdb::outputnoe(string filename, vector <struct noeline> * nmrcons)
{
	int i;
	ofstream fout;

	fout.open(filename.c_str());

	for(i=0;i<nmrcons->size();i++)
	{
		fout<<nmrcons->at(i).group<<" ";
		fout<<nmrcons->at(i).resid1<<" ";
		fout<<nmrcons->at(i).resname1<<" ";
		fout<<nmrcons->at(i).atomname1<<" ";
		fout<<nmrcons->at(i).resid2<<" ";
		fout<<nmrcons->at(i).resname2<<" ";
		fout<<nmrcons->at(i).atomname2<<" ";
		fout<<nmrcons->at(i).b<<" ";
		fout<<nmrcons->at(i).c<<" ";
		fout<<nmrcons->at(i).a;
		fout<<endl;
	}
	fout.close();

	return;
}

void CPdb::inputnoe(string filename, vector <struct noeline> * nmrcons)
{
	int i;
	ifstream fin;
	struct noeline noe;
	string line,p;
	vector<string> ps;

	fin.open(filename.c_str());

	istringstream iss;

	i=0;
	while(getline(fin,line))
	{
		iss.clear();
		iss.str(line);
		ps.clear();
		
		while(iss>>p)
		{
			ps.push_back(p);
		}

		if(ps.size()>10)
		{
			noe.group=atoi(ps.at(0).c_str());
			noe.id=i++;
			noe.multi=0;
			noe.resid1=atoi(ps.at(2).c_str());
			noe.resname1=ps.at(3);
			noe.atomname1=ps.at(4);
			noe.resid2=atoi(ps.at(5).c_str());
			noe.resname2=ps.at(6);
			noe.atomname2=ps.at(7);
			noe.b=atof(ps.at(8).c_str());
			noe.c=atof(ps.at(9).c_str());
			noe.a=atof(ps.at(10).c_str());
			nmrcons->push_back(noe);
		}
	}
	fin.close();


	for(i=0;i<nmrcons->size();i++)
	{
		nmrcons->at(i).index1.length=0.0;
		nmrcons->at(i).index2.length=0.0;
		if(nmrcons->at(i).resid1>=1 && nmrcons->at(i).resid2>=1 && nmrcons->at(i).resid1<=(int)v.size() && nmrcons->at(i).resid2<=(int)v.size() )
		{
			nmrcons->at(i).index1=v.at(nmrcons->at(i).resid1-1)->query(nmrcons->at(i).atomname1);
			nmrcons->at(i).index2=v.at(nmrcons->at(i).resid2-1)->query(nmrcons->at(i).atomname2);
		}
	}

	return;
}




int CPdb::load_exactnoe(string filename,vector <struct noeline> *nmrcons)
{
	ifstream fin(filename.c_str());
	string line,p;
	istringstream iss;
	struct noeline tline;
	string nmrseq;
	char c1,c2;
	int i;

	i=0;
	while(getline(fin,line))
	{
		i++;
		tline.id=i;
		iss.clear();
		iss.str(line);
		iss>>tline.resid1>>tline.resname1>>tline.atomname1;
		iss>>tline.resid2>>tline.resname2>>tline.atomname2;
		iss>>tline.a>>tline.c;
		nmrcons->push_back(tline);
	}

	for(i=0;i<nmrcons->size();i++)
	{
		c1=Sequence::name2code(nmrcons->at(i).resname1);
		c2=Sequence::name2code(nmrcons->at(i).resname2);
		if(nmrcons->at(i).resid1>=nmrseq.size())
		{
			nmrseq.resize(nmrcons->at(i).resid1+1,'U');
		}
		nmrseq.at(nmrcons->at(i).resid1)=c1;
		if(nmrcons->at(i).resid2>=nmrseq.size())
		{
			nmrseq.resize(nmrcons->at(i).resid2+1,'U');
		}
		nmrseq.at(nmrcons->at(i).resid2)=c2;
	}

	int adj,adj2;
	string out1,out2,out3;
	vector<int> out=Sequence::aligno(pdbseq,nmrseq,out1,out2,out3);
	adj=0;adj2=0;
	for(i=out.size()/10;i<out.size()-out.size()/10;i++)
	{
		if(out.at(i)!=0)
		{
			adj+=(out.at(i)-i);
			adj2++;
		}
	}
	adj/=adj2;
	cout<<out1<<endl;
	cout<<out2<<endl;
	cout<<out3<<endl;



	for(i=0;i<nmrcons->size();i++)
	{
		nmrcons->at(i).index1.length=0.0;
		nmrcons->at(i).index2.length=0.0;
		nmrcons->at(i).resid1-=adj;nmrcons->at(i).resid1++;
		nmrcons->at(i).resid2-=adj;nmrcons->at(i).resid2++;

		if(nmrcons->at(i).resid1>=1 && nmrcons->at(i).resid2>=1 && nmrcons->at(i).resid1<=(int)v.size() && nmrcons->at(i).resid2<=(int)v.size() )
		{
			nmrcons->at(i).index1=v.at(nmrcons->at(i).resid1-1)->query(nmrcons->at(i).atomname1);
			nmrcons->at(i).index2=v.at(nmrcons->at(i).resid2-1)->query(nmrcons->at(i).atomname2);
		}
		else
		{
			nmrcons->erase(nmrcons->begin()+i);
			i--;
		}
	}

	return 0;
}





int CPdb::loaddihecons(string filename,vector<struct diheline> *dihes)		
{
	ifstream fin(filename.c_str());
	string line;
	vector<string> block;
	bool bstart,inloop,begin;


	bstart=0;
	inloop=0;
	begin=0;

	block.clear();
	while(getline(fin,line))
	{
		if(line.size()<4)
			continue;

		if(begin==1 &&  line.find("stop_")!=string::npos)
		{
			bstart=begin=0;
			dihecons_actualload(&block,dihes);
			block.clear();
		}

		if(begin==1)
			block.push_back(line);


		if(line.find("loop_")!=string::npos)
			inloop=1;
		if(line.find("stop_")!=string::npos)
			inloop=0;

		if(inloop==0 && line.find("save_CNS/XPLOR_dihedral")!=string::npos)
			bstart=1;

		if(bstart==1 && inloop==1 && line.find("_Torsion_angle_constraint.Torsion_angle_constraint_list_ID")!=string::npos)
			begin=1;
	}

	if(block.size()>0) 
	{
		dihecons_actualload(&block,dihes);
		block.clear();
	}
	return 0;
}


int CPdb::dihecons_actualload(vector<string>* block,vector<struct diheline> *dihes)
{
	istringstream iss;
	string p;
	int i,j,m;
	string nmrseq;
	vector<int> out;
	char c1,c2;
	int adj,adj2;
	bool bremove;

	dihes->resize(block->size());
	for(i=0;i<block->size();i++)
	{
		iss.clear();
		iss.str(block->at(i));
		iss>>dihes->at(i).id;
		iss>>p;
		for(j=0;j<4;j++)
		{
			iss>>p>>p;
			iss>>m;dihes->at(i).resid.push_back(m);
			iss>>p;dihes->at(i).resname.push_back(p);
			iss>>p;dihes->at(i).atomname.push_back(p);
		}
		iss>>dihes->at(i).upper>>dihes->at(i).lower;
		dihes->at(i).middle=(dihes->at(i).lower+dihes->at(i).upper)/2.0;
		dihes->at(i).delta=fabs(dihes->at(i).upper-dihes->at(i).lower)/2.0;

		c1=Sequence::name2code(dihes->at(i).resname[0]);
		c2=Sequence::name2code(dihes->at(i).resname[3]);
		for(j=0;j<4;j++)	dihes->at(i).resid[j]--;
		if(dihes->at(i).resid[0]+1>nmrseq.size())
			nmrseq.resize(dihes->at(i).resid[0]+1,'U');
		nmrseq.at(dihes->at(i).resid[0])=c1;
		if(dihes->at(i).resid[3]+1>nmrseq.size())
			nmrseq.resize(dihes->at(i).resid[3]+1,'U');
		nmrseq.at(dihes->at(i).resid[3])=c2;
	}

	out=Sequence::align(pdbseq,nmrseq);
	adj=0;adj2=0;
	for(i=0;i<out.size();i++)
	{
		if(out.at(i)!=0)
		{
			adj+=(out.at(i)-i);
			adj2++;
		}
	}
	adj/=adj2;

	for(i=dihes->size()-1;i>=0;i--)
	{
		bremove=0;
		for(j=0;j<4;j++)
		{
			dihes->at(i).resid[j]++;
			dihes->at(i).resid[j]-=adj;
			if(dihes->at(i).resid[j]<1 || dihes->at(i).resid[j]>v.size())
				bremove=1;
		}
		if(bremove)
		{
			cerr<<"Remove dihes cons ID "<<dihes->at(i).id<<" because it is out-of-bound"<<endl;
			dihes->erase(dihes->begin()+i);
		}
	}




	for(i=0;i<dihes->size();i++)
	{
		dihes->at(i).index.resize(4);
		for(j=0;j<4;j++)
			dihes->at(i).index[j]=v.at(dihes->at(i).resid[j]-1)->query(dihes->at(i).atomname[j]);
	}
	return 0;
}

int CPdb::buildpdb(string seq)
{	
	string residue;
	CAminoacid *t;
	int nres;
	int i;

	for(i=0;i<seq.size();i++)
	{
		residue=Sequence::code2name(seq.at(i));
		t=NULL;
		if(residue=="ALA")	t=new CAla;
		else if(residue=="ARG")	t=new CArg;
		else if(residue=="ASN")	t=new CAsn;
		else if(residue=="ASP")	t=new CAsp;
		else if(residue=="GLN")	t=new CGln;
		else if(residue=="GLU")	t=new CGlu;
		else if(residue=="GLY")	t=new CGly;
		else if(residue=="HIS")	t=new CHis;
		else if(residue=="HID")	t=new CHis;
		else if(residue=="HIE")	t=new CHis;
		else if(residue=="ILE")	t=new CIle;
		else if(residue=="LEU") t=new CLeu;
		else if(residue=="LYS")	t=new CLys;
		else if(residue=="LYP")	t=new CLys;
		else if(residue=="MET")	t=new CMet;
		else if(residue=="PHE")	t=new CPhe;
		else if(residue=="PRO")	t=new CPro;
		else if(residue=="SER")	t=new CSer;
		else if(residue=="THR")	t=new CThr;
		else if(residue=="TYR")	t=new CTyr;
		else if(residue=="VAL")	t=new CVal;
		else if(residue=="TRP")	t=new CTrp;
		else if(residue=="CYS")	t=new CCys;
		else if(residue=="CYN")	t=new CCys;
		else if(residue=="CYX")	t=new CCyx;
		else if(residue=="UNK")	t=new CUnk;
		else t=new CUnk;

		t->setresidue(i+1);

		v.push_back(t);
	}

	nres=v.size();
	natom=0;
	natom2=0;
	chains.push_back(v.size());

	return natom;
}

void CPdb::setup(CAminoacid *t, CLigand *tt, int iligand, string residue , int index_old,vector<string> block)
{
	return;
}

int CPdb::loadpdb(string filename)
{
	string line,part;
	ifstream fin(filename.c_str());
	pdbfilename=filename;
	bool first;
	int iligand;
	int atomindex;
	int index,index_old;
	string chain,chain_old;
	string residue,residue_old;
	struct proteinblock pdbblock;
	string add;
	char buffer[10];
	

	cout<<"load in "<<pdbfilename<<endl;

	clear(); //clear all data before load in new PDB information
	iligand=0;
	atomindex=0;
	first=1;
	index_old=1;
	chain_old=" ";
	while(getline(fin,line))
	{
		part=line.substr(0,6);
		if(part=="SEQADV")
		{

		}



		part=line.substr(0,6);
		if(part=="END" || part=="ENDMDL")
		{
			break;
		}

		part=line.substr(0,3);
		if(part=="TER")
		{
			//following is ligand or water in most case
			//or another chain! need to be taken care of this situation
			iligand=1;
			continue;
		}

		//neglect all entries that are not ATOM or HETATM
		part=line.substr(0,6);
		if(part!="ATOM  " && part!="HETATM")
			continue;


		//ignore water molecules.
		part=line.substr(17,3);
		if(part=="HOH" || part=="WAT")
			continue;

		
		index=atoi(line.substr(22,4).c_str());
		chain=line.substr(21,1);
		residue=line.substr(17,3);

		//Put in real atom index, this is important for coor processing !!
		atomindex++;
		sprintf(buffer,"%5d",atomindex);
		add=buffer;
		line.replace(6,5,add);

		if(first==1)
		{
			first=0;
			index_old=index;
			chain_old=chain;
			residue_old=residue;
			pdbblock.block.push_back(line);
			pdbblock.iligand=iligand;
			pdbblock.residue=residue;
			pdbblock.index=index;
		}
		else if(index==index_old && chain==chain_old )
		{
			pdbblock.block.push_back(line);
		}
		else if(chain==chain_old && index>index_old ) // new residue
		{
			blocks.push_back(pdbblock);
			pdbblock.block.clear();
			pdbblock.block.push_back(line);  
			pdbblock.iligand=iligand;
			pdbblock.index=index;
			pdbblock.residue=residue;
			index_old=index;
			residue_old=residue;
		}
		else if(chain==chain_old && index<index_old ) //most likely a new chain
		{
			blocks.push_back(pdbblock);
			chain_block.push_back(blocks.size());
			iligand=0;
			pdbblock.block.clear();
			pdbblock.block.push_back(line);	
			pdbblock.iligand=iligand;
			pdbblock.index=index;
			pdbblock.residue=residue;
			index_old=index;
			residue_old=residue;
			chain_old=chain;
		}
		else if(chain!=chain_old)
		{
			blocks.push_back(pdbblock);
			chain_block.push_back(blocks.size());
			iligand=0;
			pdbblock.block.clear();
			pdbblock.block.push_back(line);	
			pdbblock.iligand=iligand;
			pdbblock.index=index;
			pdbblock.residue=residue;
			index_old=index;
			residue_old=residue;
			chain_old=chain;
		}
	}
	
	if(pdbblock.block.size()>0)
		blocks.push_back(pdbblock);
	chain_block.push_back(blocks.size());

	//start part 2 here
	int start,begin,stop,stop2;
	CAminoacid *t,*t2;
	CLigand *tt;
	int n;
	int i,j,ii;
	natom=natom2=0;


	for(ii=0;ii<chain_block.size();ii++)
	{
		if(ii==0)
			start=0;
		else
			start=chain_block.at(ii-1);
		stop=chain_block.at(ii);
		n=0;
		stop2=stop;


		pdbblock=blocks.at(stop-1);
		if(pdbblock.iligand==0)
		{
			//even without TER, res has only one line is mostly a ligand,if it is the last entry
			if(pdbblock.block.size()==1 )
			{
					blocks.at(stop-1).iligand=1;
					stop2=stop-1;
			}
		}

		for(i=stop-2;i>=start;i--)
		{
			pdbblock=blocks.at(i);
			if(pdbblock.iligand==0 && blocks.at(i+1).iligand==1)
			{
				//even without TER, res has only one line is mostly a ligand, if following one is also a ligand
				if(pdbblock.block.size()==1 )
				{
					blocks.at(i).iligand=1;
					stop2=i;
				}
			}
		}


		for(i=start;i<stop;i++)
		{
			
			pdbblock=blocks.at(i);
			if(pdbblock.iligand==0)
			{
				residue=pdbblock.residue;
				if(residue=="ALA")	t=new CAla;
				else if(residue=="ARG")	t=new CArg;
				else if(residue=="ASN")	t=new CAsn;
				else if(residue=="ASP")	t=new CAsp;
				else if(residue=="GLN")	t=new CGln;
				else if(residue=="GLU")	t=new CGlu;
				else if(residue=="GLY")	t=new CGly;
				else if(residue=="HIS")	t=new CHis;	
				else if(residue=="HID")	t=new CHis;
				else if(residue=="HIE")	t=new CHis;
				else if(residue=="ILE")	t=new CIle;
				else if(residue=="LEU")	t=new CLeu;
				else if(residue=="LYS")	t=new CLys;
				else if(residue=="LYP")	t=new CLys;
				else if(residue=="MET")	t=new CMet;
				else if(residue=="PHE")	t=new CPhe;
				else if(residue=="PRO")	t=new CPro;
				else if(residue=="SER")	t=new CSer;
				else if(residue=="THR")	t=new CThr;
				else if(residue=="TYR")	t=new CTyr;
				else if(residue=="VAL")	t=new CVal;
				else if(residue=="TRP") t=new CTrp;
				else if(residue=="CYS") t=new CCys;
				else if(residue=="CYN") t=new CCys;
				else if(residue=="CYX") t=new CCyx;
				else if(iligand>=2) tt=new CLigand;
				else
				{
					t=new CUnk;
					#ifndef BENCHMARK
					cout<<"Warning! unrecognized residue name "<<residue<<" for residue "<<index_old<<endl;
					printblock(pdbblock.block);
					#endif
				}

				n++;t->setresidue(n);
				if(i==start) t->setnterminal();
				if(i==stop2-1) t->setcterminal();
				else if(blocks.at(i+1).iligand==1) t->setcterminal();
				t->process(pdbblock.block);
				natom+=pdbblock.block.size();
				
				if(i>start)
				{
					for(j=blocks.at(i-1).index+1;j<pdbblock.index;j++)
					{
						t2=new CMiss;
						n++;t2->setresidue(n);
						v.push_back(t2);
						nmiss++;
					}
				}
				v.push_back(t);
			}
			else //ligand
			{
				tt=new CLigand;
				n++;tt->setresidue(n);
				tt->process(pdbblock.block);
				natom2+=pdbblock.block.size();
				ligand.push_back(tt);
			}
		}//for(i=start;i<stop;i++)

		chains.push_back(v.size());
		chain_ligand.push_back(ligand.size());
	}



	//re-index residues
	for(j=0;j<(int)chains.size();j++)
	{
		if(j==0)
			begin=0;
		else
			begin=chains.at(j-1);
		stop=chains.at(j);

		for(i=begin;i<stop;i++)
		{
			v.at(i)->setresidue(i+1);
		}
	}


	for(j=0;j<(int)chains.size();j++)
	{
		if(j==0)
			begin=0;
		else
			begin=chains.at(j-1);
		stop=chains.at(j);

		//set up chain information
		for(i=begin;i<stop;i++)
			v.at(i)->chain=j;

		for(i=begin;i<stop-1;i++)
		{	
			v.at(i)->setfollowingn(v.at(i+1)->get("N").index);
		}
		v.at(stop-1)->setfollowingn(v.at(stop-1)->get("O").index);
		
		for(i=begin+1;i<stop;i++)
		{
			v.at(i)->setpreviousc(v.at(i-1)->get("C").index);
		}
		v.at(begin)->setpreviousc(v.at(begin)->get("H1").index);

		//residue index from the PDB file may be inconsistent
	}

	for(i=0;i<(int)v.size();i++)
	{
		pdbseq.push_back(v.at(i)->OneLetterName);
	}

	return (natom+natom2);

}


		

int CPdb::loadpdb_old(string filename)
{
	bool bres;
	int i,j,n;
	int begin,stop;
	int atomindex;
	int iligand;
	vector<string> block;
	string line, part, residue,chain,chain_old,add;
	int index,index_old;
	bool first;
	char buffer[6];

	pdbfilename=filename;

	clear();
	
	ifstream fin(filename.c_str());
	CAminoacid *t;
	CLigand *tt;

	
	natom=natom2=0;
	first=1;
	atomindex=0;
	iligand=0;
	nmiss=0;


	cout<<"load in "<<pdbfilename<<endl;
	while(getline(fin,line))
	{
		part=line.substr(0,6);
		if(part=="ENDMDL")
		{
			break;
		}

		part=line.substr(0,3);
		if(part=="TER")
		{
			//following is ligand or water in most case
			//or another chain! need to be taken care of this situation
			iligand=1;
			continue;
		}

		part=line.substr(0,6);
		if(part!="ATOM  " && part!="HETATM")
			continue;

		part=line.substr(17,3);
		if(part=="HOH" || part=="WAT")
			continue;

		atomindex++;
		index=atoi(line.substr(22,4).c_str());
		chain=line.substr(21,1);


		if(first==1)
		{
			first=0;
			index_old=index;
			chain_old=chain;
			residue=line.substr(17,3);
			n=0;
		}
		bres=0;

		if(index==index_old  && chain==chain_old) //same residue
		{
			if(line.substr(17,3)==residue)
			{
				sprintf(buffer,"%5d",atomindex);
				add=buffer;
				line.replace(6,5,add);
				block.push_back(line);
			}
			else
			{
				cout<<"Warning: same residue index but different residue name!   ";
				cout<<line<<endl;
			}
		}
		else if(chain != chain_old) //new chain, so that there is also new residue
		{
			chains.push_back((int)v.size()+1);
			if(chain.compare("A")!=0 ) iligand=0;
			bres=1;
			n=0;
		}
		else if(index!=index_old)//same chain, but new residue.
		{
			bres=1;
		}
		else //must be error, so we break;
		{
			cout<<"Error in processing PDB file! Processing aborted!"<<endl;
			break;
		}


		if(bres==1)  //
		{
			t=NULL;
			tt=NULL;
		if(residue=="ALA")	t=new CAla;
		else if(residue=="ARG")	t=new CArg;
		else if(residue=="ASN")	t=new CAsn;
		else if(residue=="ASP")	t=new CAsp;
		else if(residue=="GLN")	t=new CGln;
		else if(residue=="GLU")	t=new CGlu;
		else if(residue=="GLY")	t=new CGly;
		else if(residue=="HIS")	t=new CHis;	
		else if(residue=="HID")	t=new CHis;
		else if(residue=="HIE")	t=new CHis;
		else if(residue=="ILE")	t=new CIle;
		else if(residue=="LEU")	t=new CLeu;
		else if(residue=="LYS")	t=new CLys;
		else if(residue=="LYP")	t=new CLys;
		else if(residue=="MET")	t=new CMet;
		else if(residue=="PHE")	t=new CPhe;
		else if(residue=="PRO")	t=new CPro;
		else if(residue=="SER")	t=new CSer;
		else if(residue=="THR")	t=new CThr;
		else if(residue=="TYR")	t=new CTyr;
		else if(residue=="VAL")	t=new CVal;
		else if(residue=="TRP") t=new CTrp;
		else if(residue=="CYS") t=new CCys;
		else if(residue=="CYN") t=new CCys;
		else if(residue=="CYX") t=new CCyx;
		else if(iligand>=2) tt=new CLigand;
		else
		{
			t=new CUnk;
#ifndef BENCHMARK
			cout<<"Warning! unrecognized resiude name "<<residue<<" fore residue "<<index_old<<endl;
			printblock(block);
#endif
		}

			if(t!=NULL)
			{
				n++;t->setresidue(n);
				if(n==1) t->setnterminal();
				t->process(block);
				natom+=block.size();
				v.push_back(t);
				if(iligand>0)
					iligand++;
				//cout<<natom<<endl;
			}

			if(tt!=NULL)
			{
				tt->process(block);
				natom2+=block.size();
				ligand.push_back(tt);
			}
			
			//insert missing residues if necessary
			if(iligand<2)
			{
				for(i=index_old+1;i<index;i++)
				{
					t=new CMiss;
					n++;t->setresidue(n);
					v.push_back(t);
					nmiss++;
				}
			}

			

			//prepare for new residues
			index_old=index;
			chain_old=chain;
			block.clear();
			index=atoi(line.substr(22,4).c_str());
			chain=line.substr(21,1);

			sprintf(buffer,"%5d",atomindex);
			add=buffer;
			line.replace(6,5,add);

			block.push_back(line);
			residue=line.substr(17,3);
		}

	}

	

	if(block.size()>0)
	{
		if(iligand>=1)
			iligand++;
		
		t=NULL;
		tt=NULL;
		
		if(residue=="ALA")	t=new CAla;
		else if(residue=="ARG")	t=new CArg;
		else if(residue=="ASN")	t=new CAsn;
		else if(residue=="ASP")	t=new CAsp;
		else if(residue=="GLN")	t=new CGln;
		else if(residue=="GLU")	t=new CGlu;
		else if(residue=="GLY")	t=new CGly;
		else if(residue=="HIS")	t=new CHis;	
		else if(residue=="HID")	t=new CHis;
		else if(residue=="HIE")	t=new CHis;
		else if(residue=="ILE")	t=new CIle;
		else if(residue=="LEU")	t=new CLeu;
		else if(residue=="LYS")	t=new CLys;
		else if(residue=="LYP")	t=new CLys;
		else if(residue=="MET")	t=new CMet;
		else if(residue=="PHE")	t=new CPhe;
		else if(residue=="PRO")	t=new CPro;
		else if(residue=="SER")	t=new CSer;
		else if(residue=="THR")	t=new CThr;
		else if(residue=="TYR")	t=new CTyr;
		else if(residue=="VAL")	t=new CVal;
		else if(residue=="TRP") t=new CTrp;
		else if(residue=="CYS") t=new CCys;
		else if(residue=="CYN") t=new CCys;
		else if(residue=="CYX") t=new CCyx;
		else if(iligand>=2) tt=new CLigand;
		else
		{
			t=new CUnk;
#ifndef BENCHMARK
			cout<<"Warning! unrecognized resiude name "<<residue<<" fore residue "<<index_old<<endl;
			printblock(block);
#endif
		}

		if(t!=NULL)
		{
			n++;t->setresidue(n);
			t->process(block);
			natom+=block.size();
			v.push_back(t);
		}
		if(tt!=NULL)
		{
			tt->process(block);
			ligand.push_back(tt);
			natom2+=block.size();
		}
		chains.push_back((int)v.size());
	}

	//re-index residues
	for(j=0;j<(int)chains.size();j++)
	{
		if(j==0)
			begin=0;
		else
			begin=chains.at(j-1);
		stop=chains.at(j);

		for(i=begin;i<stop;i++)
		{
			v.at(i)->setresidue(i+1-begin);
		}
	}


	for(j=0;j<(int)chains.size();j++)
	{
		if(j==0)
			begin=0;
		else
			begin=chains.at(j-1);
		stop=chains.at(j);

		for(i=begin;i<stop-1;i++)
		{	
			v.at(i)->setfollowingn(v.at(i+1)->get("N").index);
		}
		v.at(stop-1)->setfollowingn(v.at(stop-1)->get("O").index);
		
		for(i=begin+1;i<stop;i++)
		{
			v.at(i)->setpreviousc(v.at(i-1)->get("C").index);
		}
		v.at(begin)->setpreviousc(v.at(begin)->get("H1").index);

		//residue index from the PDB file may be inconsistent
	}

	for(i=0;i<(int)v.size();i++)
	{
		pdbseq.push_back(v.at(i)->OneLetterName);
	}

	return (natom+natom2);
}


bool CPdb::bisunknownmissing()
{
	int i;
	bool flag1,flag2,flag3;

	flag1=0;
	flag2=0;
	flag3=0;

	for(i=0;i<(int)v.size();i++)
	{
		if(v.at(i)->OneLetterName!='X' && flag2==0)
		{
			flag1=1;
			continue;
		}
		if(v.at(i)->OneLetterName=='X' && flag1==1)
		{
			flag1=0;
			flag2=1;
			continue;
		}
		if(v.at(i)->OneLetterName!='X' && flag2==1)
		{
			flag3=1;
			flag1=0;
			flag2=0;
			break;
		}
	}

	return flag3;
}

		



void CPdb::printpdb(char * filename, int flag)
{
	int i,n;
	FILE *fp;

	fp=fopen(filename,"wt");
	n=1;
	for(i=0;i<v.size();i++)
	{
		if(flag==0) v.at(i)->printpdb(fp,atomname,x,y,z,b,n);
		else v.at(i)->printpdb(fp,atomname,x,y,z,b2,n);
	}
	fclose(fp);
	return;
}
	



void CPdb::printblock(vector<string> block)
{
	int i;
	cout<<"*********************************************************"<<endl;
	for(i=0;i<(int)block.size();i++)
		cout<<block.at(i)<<endl;
	cout<<"*********************************************************"<<endl;
	return;
}

vector<int> CPdb::getselect(string input)
{
	int n,n1,n2;
	vector<int> res;
	vector<int> sel;
	vector<string> atoms;
	size_t found_res,found;
	string part1,part2,part3;
	string p,p1,p2;


	stringstream ss;

	try
	{
		found_res=input.find(':');
		if(found_res==string::npos)
			throw "Can't find :";
		if(found_res!=0)
			throw "First charactor is not :";
		found_res=input.find('@');
		//cout<<"input is "<<input<<" found_res is "<<found_res<<endl;
		if(found_res==string::npos)
			throw "Can't find @";
		part1=input.substr(1,found_res-1);
		part2=input.substr(found_res+1,input.length()-found_res-1);
		//cout<<part1<<endl;
		//cout<<part2<<endl;

		//extract & part to part3
		found_res=input.find('&');
		if(found_res!=string::npos)
		{
			part3=part1.substr(found_res,part1.length()-found_res);
			part1=part1.substr(0,found_res-1);
		}


		//processing part1 now
		ss.str(part1);
		while(getline(ss,p,','))
		{
			found=p.find('-');
			if(found==string::npos)
			{
				if(p=="%")
					n=v.size();
				else
					n=atoi(p.c_str());
				if(n<=0)
					throw "Residue number <=0 ??";
				res.push_back(n);
			}
			else
			{
				p1=p.substr(0,found);
				p2=p.substr(found+1,p.length()-found);
				if(p1=="%")
					n1=v.size();
				else
					n1=atoi(p1.c_str());
				if(p2=="%")
					n2=v.size();
				else
					n2=atoi(p2.c_str());
				if(n1<=0 || n2<=0)
					throw "Residue number <=0 ??";
				for(n=n1;n<=n2;n++)
					res.push_back(n);

			}
		}
		//process part3 now
		if(part3.size()>0)
		{
			for(int i=res.size()-1;i>=0;i--)
			{
				n=res.at(i)-1;
				if(n<0)
					throw "Res index is less than 1";
				if(n>=v.size())
					throw "Res index is larger than nres";
				char c=v.at(n)->getdssp();
				if(part3.find(c)==string::npos)
					res.erase(res.begin()+i);
			}
		}

		//precess part2 now
		ss.clear();
		ss.str(part2);
		while(getline(ss,p,','))
		{
			atoms.push_back(p);
		}
	


		unsigned int i,j;
		for(i=0;i<(int)res.size();i++)
		{
			n=res.at(i)-1;
			if(n<0)
				throw "Res index is less than 1";
			if(n>=v.size())
				throw "Res index is larger than nres";

			for(j=0;j<atoms.size();j++)
			{
				
				if(atoms.at(j).compare("allheavy")==0)
				{
					v.at(n)->bbheavycoor(&sel);
					v.at(n)->heavycoor(&sel);
				}
				else if(atoms.at(j).compare("all")==0)
				{
					v.at(n)->allcoor(&sel);
				}
				else if(atoms.at(j).compare("scheavy")==0)
				{
					v.at(n)->heavycoor(&sel);
				}
				else if(atoms.at(j).compare("bbheavy")==0)
				{
					v.at(n)->bbheavycoor(&sel);
				}				
				else
				{
					n1=v.at(n)->get(atoms.at(j).c_str()).index;
					if(n1>0)
						sel.push_back(n1);
					else
						cout<<"Res "<<n+1<<v.at(n)->OneLetterName<<" doesn't have "<<atoms.at(j).c_str()<<" atom"<<endl;
				}
			}
		}
	}


	catch (const char * str)
	{
		cout<<"Input selection phasing exception raised because "<<str<<". Please check."<<endl;
		cout<<"select all Ca atoms of all residues instead!"<<endl;
		sel.clear();getca(&sel);
	}
	return sel;
}


vector<int> CPdb::getselect(string input,vector<int> res)
{
	int n,n1;
	vector<int> sel;
	vector<string> atoms;
	string part1,part2;
	string p,p1,p2;


	stringstream ss;


	ss.clear();
	ss.str(input);
	while(getline(ss,p,','))
	{
		atoms.push_back(p);
	}
	

	unsigned int i,j;
	for(i=0;i<(int)res.size();i++)
	{
		n=res.at(i)-1;

		for(j=0;j<atoms.size();j++)
		{
			if(atoms.at(j).compare("allheavy")==0)
			{
				v.at(n)->bbheavycoor(&sel);
				v.at(n)->heavycoor(&sel);
			}
			else if(atoms.at(j).compare("all")==0)
			{
				v.at(n)->allcoor(&sel);
			}
			else if(atoms.at(j).compare("scheavy")==0)
			{
				v.at(n)->heavycoor(&sel);
			}
			else if(atoms.at(j).compare("bbheavy")==0)
			{
				v.at(n)->bbheavycoor(&sel);
			}					
			else
			{
				n1=v.at(n)->get(atoms.at(j).c_str()).index;
				if(n1>0)
					sel.push_back(n1);
				else
					cout<<"Res "<<n+1<<v.at(n)->OneLetterName<<" doesn't have "<<atoms.at(j).c_str()<<" atom"<<endl;
			}
		}
	}
	return sel;
}



vector<int> CPdb::getselect(vector<int> &num, string input)
{
    int n,n1;
    unsigned int j;
    vector<int> sel;
    vector<string> atoms;
    string part1,part2;
    string p,p1,p2;
    
    
    stringstream ss;
    
    
    ss.clear();
    ss.str(input);
    while(getline(ss,p,','))
    {
        atoms.push_back(p);
    }
    
    
    
    for(n=0;n<v.size();n++)
    {
        
        for(j=0;j<atoms.size();j++)
        {
            if(atoms.at(j).compare("allheavy")==0)
            {
                v.at(n)->bbheavycoor(&sel);
                v.at(n)->heavycoor(&sel);
            }
            else if(atoms.at(j).compare("all")==0)
            {
                v.at(n)->allcoor(&sel);
            }
            else if(atoms.at(j).compare("scheavy")==0)
            {
                v.at(n)->heavycoor(&sel);
            }
            else if(atoms.at(j).compare("bbheavy")==0)
            {
                v.at(n)->bbheavycoor(&sel);
            }					
            else
            {
                n1=v.at(n)->get(atoms.at(j).c_str()).index;
                if(n1>0)
                    sel.push_back(n1);
                else
                    cout<<"Res "<<n+1<<v.at(n)->OneLetterName<<" doesn't have "<<atoms.at(j).c_str()<<" atom"<<endl;
            }
        }
        num.push_back(sel.size());
    }
    return sel;
}



void CPdb::getca(vector<int> *index)
{
	unsigned int i;
	for(i=0;i<(int)v.size();i++)
	{
		//if(i>40 && i<87) continue;
		index->push_back(v.at(i)->getca());
	}

	return;
}

vector<int> CPdb::getselectca(vector<int> res)
{
	unsigned int i;
	int n;
	vector<int> index;

	for(i=0;i<(int)res.size();i++)
	{
		n=res.at(i);
		if(n>=1 && n<=v.size()) index.push_back(v.at(n-1)->getca());
	}
	return index;
}




void CPdb::getdihe(vector<dihe_group> *t, vector<int> *n)
{
	unsigned int i;

	for(i=0;i<(int)v.size();i++)
	{
		v[i]->bbdihe(t);	
		v[i]->dihe(t);
		n->push_back(t->size());
	}
}


void CPdb::getbbdihe(vector<dihe_group> *t)
{
	unsigned int i;

	for(i=0;i<(int)v.size();i++)
	{
		v[i]->bbdihe(t);	
	}
}


void CPdb::getbbdihe(vector<dihe_group> *t,int *ibb)
{
	unsigned int i;

	for(i=0;i<(int)v.size();i++)
	{
		if( i==0 || i==(int)v.size()-1)
		{
			ibb[i]=0;
		}
		else
		{
			v[i]->bbdihe(t);	
			ibb[i]=1;
		}
	}
}

void CPdb::getbbdihe_nopro(vector<dihe_group> *t,int *ibb)
{
	unsigned int i;

	for(i=0;i<(int)v.size();i++)
	{
		if(v.at(i)->OneLetterName=='P' || i==0 || i==(int)v.size()-1)
		{
			ibb[i]=0;
		}
		else
		{
			v[i]->bbdihe(t);	
			ibb[i]=1;
		}
	}
}



void CPdb::getdihe(vector<dihe_group> *t)
{
	unsigned int i;


	for(i=0;i<(int)v.size();i++)
	{
		v[i]->bbdihe(t);	
		v[i]->dihe(t);
	}
}

void CPdb::getbb(vector<bb_group> *t)
{
	int i,j;
	int begin,stop;

	for(j=0;j<chains.size();j++)
	{
		if(j==0)
			begin=0;
		else
			begin=chains.at(j-1);
		stop=chains.at(j);

		if(stop-begin<3)
			cout<<"Chain "<<j<<" only has 1 or 2 residues! I don't know how to do."<<endl;
	
		v[begin+0]->bb(t);
		v[begin+1]->follow_bb(t);

		for(i=begin+1;i<stop-1;i++)
		{
			v[i]->bb(t);
			v[i-1]->previous_bb(t);
			v[i+1]->follow_bb(t);
		}
		v[stop-1]->bb(t);
	}
	return;
}

void CPdb::getbb_assign(vector<bb_group> *t)
{
    int i,j;
    int begin,stop;
    
    for(j=0;j<chains.size();j++)
    {
        if(j==0)
            begin=0;
        else
            begin=chains.at(j-1);
        stop=chains.at(j);
        
        if(stop-begin<3)
            cout<<"Chain "<<j<<" only has 1 or 2 residues! I don't know how to do."<<endl;
        
        v[begin+0]->bb(t);
        v[begin+1]->follow_bb_assign(t);
        
        for(i=begin+1;i<stop-1;i++)
        {
            v[i]->bb(t);
            v[i-1]->previous_bb(t);
            v[i+1]->follow_bb_assign(t);
        }
        v[stop-1]->bb(t);
    }
    return;
}

void CPdb::bbhbond(vector<bbhbond_group> *t)
{	
	unsigned int i;
	for(i=0;i<(int)v.size();i++)
	{
		v[i]->bbhbond(t);
	}
	return;
}





void CPdb::schbond(vector<bbhbond_group> *t)
{
	unsigned int i;
	for(i=0;i<v.size();i++)
	{
		v[i]->schbond(t);
	}
	return;
}

void CPdb::caha(vector<index_three> *t)
{
	int i;
	for(i=0;i<(int)v.size();i++)
	{
		if(v[i]->OneLetterName != 'G')
			v[i]->caha(t);
	}
	return;
}

void CPdb::bbco(vector<co_group> *t)
{
	int i;
	for(i=0;i<(int)v.size()-1;i++)
	{
		v[i]->bbco(t);
	}
	return;
}


void CPdb::bbnh(vector<nh_group> *t)
{
	int i;
	for(i=0+1;i<(int)v.size();i++)
	{
		if(v[i]->OneLetterName != 'P')
			v[i]->bbnh(t);
	}
	return;
}


void CPdb::ired(vector<struct ired> *t)
{
	int i;
	for(i=0;i<(int)v.size();i++)
	{
		v[i]->ired(t,i);
	}
	return;
}

void CPdb::clearred(void)
{
	int i;
	for(i=0;i<v.size();i++)
		v.at(i)->clearred();
	return;
}


void CPdb::loadred(vector<struct ired> *t)
{
	int i;

	clearred();
	for(i=0;i<t->size();i++)
	{
		if(t->at(i).pos>=0 && t->at(i).pos<v.size())
			v.at(t->at(i).pos)->loadred(t->at(i));
	}

	return;
}
		
void CPdb::loadred(string filename)
{
	ifstream fin(filename.c_str());
	string p,line;
	string name1,name2;
	istringstream iss;
	vector<struct ired> red;
	struct ired t;
	int i,j,base;
	string seq1,seq2;
	vector<int> out;
	double dtotal;
	int n,total;

	clearred();

	while(getline(fin,line))
	{
		iss.clear();
		iss.str(line);
		iss>>t.id>>t.code>>t.s2.name1>>t.s2.name2>>t.s2.exp;
		red.push_back(t);
	}
	fin.close();


	if(red.size()>0) base=red.at(0).id-1;
	for(i=0;i<(int)red.size();i++)
		red.at(i).id-=base;

	base=0;
	seq2.clear();
	for(i=0;i<(int)red.size();i++)
	{
		if(red.at(i).id>base)
		{
			base=red.at(i).id;
			if(seq2.size()<base)
				seq2.resize(base,'X');
			seq2.at(base-1)=red.at(i).code;
		}
	}

	for(i=0;i<(int)v.size();i++)
	{
		seq1.push_back(v.at(i)->OneLetterName);
	}
	out=Sequence::align(seq1,seq2);

	dtotal=0.0;
	n=0;
	for(i=2;i<(int)out.size()-1;i++)
	{
		j=out.at(i);
		if(j!=0 && out.at(i)==out.at(i-1)+1 && out.at(i)==out.at(i+1)-1)
		{
			dtotal+=j-i;
			n++;
		}
	}
	dtotal/=n;
	if(dtotal>=0) total=(int)(dtotal+0.5);
	else total=(int)(dtotal-0.5);



	for(i=0;i<(int)red.size();i++)
	{
		red.at(i).pos=red.at(i).id-total-1;
	}

	loadred(&red);

};
	


void CPdb::getring(vector<ring_group> *t)
{	
	int i;

	for(i=0;i<(int)v.size();i++)
	{
		v[i]->ring(t);
	}

	for(i=t->size()-1;i>=0;i--)
	{
		if(t->at(i).x1==3 || t->at(i).x1==4)
		{
			if(t->at(i).x2<0 || t->at(i).x3<0 || t->at(i).x4<0 || t->at(i).x5<0 || t->at(i).x6<0 )
				t->erase(t->begin()+i);
		}
		else
		{
			if(t->at(i).x2<0 || t->at(i).x3<0 || t->at(i).x4<0 || t->at(i).x5<0 || t->at(i).x6<0 || t->at(i).x7<0)
				t->erase(t->begin()+i);
		}
	}

	return;
}

void CPdb::getred(int in,vector<struct ired> *t)
{
	in--;

	if(in<0 || in>v.size()-1)
		;
	else
		v.at(in)->ired(t,in);

	return;
}

char CPdb::code(int in)
{
	char c;
	in=in-1;
	if(in<0 || in >(int)v.size()-1)
		c='X';
	else
		c=v[in]->OneLetterName;

	return c;
}

int CPdb::chain(int in)
{
	int r;
	in=in-1;
	if(in<0 || in>(int)v.size()-1)
		r=-1;
	else
		r=v[in]->chain;
	return r;
}

void CPdb::name(int in,char *name)
{	in=in-1;
	if(in<0 || in >(int)v.size()-1)
		strcpy(name,"err");
	else
		strcpy(name,v[in]->ThreeLetterName);
}

void CPdb::proton(vector<struct proton> *sel, int flag)
{
	int i;
	sel->clear();
	for(i=0;i<(int)v.size();i++)
	{
		v.at(i)->proton2(sel);
	}

	if(flag==1)
	{
		for(i=0;i<sel->size();i++)
		{
			bool bmiss=0;
			for(int j=0;j<sel->at(i).nh;j++)
			{
				if(sel->at(i).hpos[j]<0)
					bmiss=1;
			}
			if(bmiss==1)
			{
#ifndef BENCHMARK
				cerr<<"Residue "<<sel->at(i).id<<" "<<sel->at(i).code<<" contain missing protons "<<sel->at(i).name<<" , removed"<<endl;
#endif
				sel->erase(sel->begin()+i);
				i--;
			}
		}
	}
}


void CPdb::proton(vector<struct proton> *sel)
{
	int i;
	vector<struct proton> tmp;
	sel->clear();
	for(i=0;i<(int)v.size();i++)
	{
		v.at(i)->proton2(&tmp);
	}
	for(i=0;i<tmp.size();i++)
	{
		bool bmiss=0;
		for(int j=0;j<tmp.at(i).nh;j++)
		{
			if(tmp.at(i).hpos[j]<0) {
				bmiss=1;
				break;
			}
		}
		if(bmiss==1) {
#ifndef BENCHMARK
			cerr<<"Residue "<<sel->at(i).id<<" "<<sel->at(i).code<<" contain missing protons "<<sel->at(i).name<<" , removed"<<endl;
#endif
			//sel->erase(sel->begin()+i);
			//i--;
		} else {
			sel->push_back(tmp.at(i));
		}
	}
}


void CPdb::allproton3(vector<struct proton> *sel)
{
	int i;
	vector<struct proton> tmp;
	sel->clear();
	for(i=0;i<(int)(int)v.size();i++)
	{
		v.at(i)->proton3(&tmp);
	}
	for(i=0;i<tmp.size();i++)
	{
		bool bmiss=0;
		for(int j=0;j<tmp.at(i).nh;j++)
		{
			if(tmp.at(i).hpos[j]<0) {
				bmiss=1;
				break;
			}
		}
		if(bmiss==1) {
#ifndef BENCHMARK
			cerr<<"Residue "<<sel->at(i).id<<" "<<sel->at(i).code<<" contain missing protons "<<sel->at(i).name<<" , removed"<<endl;
#endif
			//sel->erase(sel->begin()+i);
			//i--;
		} else {
			sel->push_back(tmp.at(i));
		}
	}
}

void CPdb::allproton(vector<struct proton> *sel)
{
	int i;
	vector<struct proton> tmp;
	sel->clear();
	for(i=0;i<(int)(int)v.size();i++)
	{
		v.at(i)->proton(&tmp);
	}
	for(i=0;i<tmp.size();i++)
	{
		bool bmiss=0;
		for(int j=0;j<tmp.at(i).nh;j++)
		{
			if(tmp.at(i).hpos[j]<0) {
				bmiss=1;
				break;
			}
		}
		if(bmiss==1) {
#ifndef BENCHMARK
			cerr<<"Residue "<<sel->at(i).id<<" "<<sel->at(i).code<<" contain missing protons "<<sel->at(i).name<<" , removed"<<endl;
#endif
			//sel->erase(sel->begin()+i);
			//i--;
		} else {
			sel->push_back(tmp.at(i));
		}
	}
}

void CPdb::ani(vector<struct ani_group> *anistropy)
{
	int i,j;
	int begin,stop;

	for(j=0;j<chains.size();j++)
	{
		if(j==0)
			begin=0;
		else
			begin=chains.at(j-1);
		stop=chains.at(j);

	
		for(i=begin;i<stop-1;i++)
		{
			v[i]->bbani(anistropy);
			v[i]->ani(anistropy);
		}
		if(stop>1) v[stop-1]->ani(anistropy);

	}


	for(i=anistropy->size()-1;i>=0;i--)
	{
		if(anistropy->at(i).pos[0]<0 || anistropy->at(i).pos[1]<0 || anistropy->at(i).pos[2]<0 )
			anistropy->erase(anistropy->begin()+i);
	}

	return;
}

void CPdb::heavycoor()
{
	int i;
	heavy.clear();
	boundary.clear();
	allcoor.clear();
	for(i=0;i<(int)v.size();i++)
	{
		v.at(i)->bbheavycoor(&heavy);
		v.at(i)->heavycoor(&heavy);
		boundary.push_back(heavy.size());
		v.at(i)->allcoor(&allcoor);
	}

	for(i=0;i<(int)ligand.size();i++)
	{
		ligand.at(i)->heavycoor(&heavy);
		boundary.push_back(heavy.size());
	}

	return;
}



void CPdb::output(string filename)
{
	int i,j;
	int begin,stop;
	FILE *fp;

	fp=fopen(filename.c_str(),"wt");

	for(i=0;i<(int)v.size();i++)
	{
		if(i==0)
			begin=0;
		else
			begin=boundary.at(i-1);
		stop=boundary.at(i);
		for(j=begin;j<stop;j++)
		{
			if(heavy.at(j)>0)
			{
				fprintf(fp,"%d %s %s",i+1,v.at(i)->ThreeLetterName,atomname.at(heavy.at(j)-1).c_str());
				//fprintf(fp," %f %f %f",x.at(heavy.at(j)-1),y.at(heavy.at(j)-1),z.at(heavy.at(j)-1));
				fprintf(fp," %f %f\n",b.at(heavy.at(j)-1),b2.at(heavy.at(j)-1));
			}
		}
	}
	fclose(fp);
	return;
}


void CPdb::caoutput(string filename)
{
	int i,j;
	FILE *fp;

	fp=fopen(filename.c_str(),"wt");

	for(i=0;i<(int)v.size();i++)
	{
		if(i==0)
			j=1;
		else
			j=boundary.at(i-1)+1;
		if(heavy.at(j)>0)
		{
			fprintf(fp,"%d %s",i+1,v.at(i)->ThreeLetterName);
			fprintf(fp," %f %f\n",b.at(heavy.at(j)-1),b2.at(heavy.at(j)-1));
		}
	}
	fclose(fp);
	return;
}



void CPdb::attach_bbprediction(int id,double pre[])
{
	v.at(id-1)->attach_bbprediction(pre);
}

void CPdb::attach_protonprediction(int id,string name,double cs)
{
	v.at(id-1)->attach_protonprediction(name,cs);
}

void CPdb::print_prediction()
{
	string test="bmrb_pre.dat";
	print_prediction(test);
}

void CPdb::print_prediction(string name)
{
	int i,j;
	FILE *fp=fopen(name.c_str(),"wt");
	char toprint0[]="loop_\n    _Residue_seq_code\n     _Residue_label\n";
	char toprint[]="      loop_\n      _Atom_shift_assign_ID\n      _Residue_seq_code\n      _Residue_label\n      _Atom_name\n      _Atom_type\n      _Chem_shift_value\n      _Chem_shift_value_error\n      _Chem_shift_ambiguity_code\n";


	fprintf(fp,toprint0);
	for(i=0;i<(int)v.size();i++)
	{
		fprintf(fp," %d %s",i+1,v.at(i)->ThreeLetterName);
		if(i%3==0) fprintf(fp,"\n");
	}
	fprintf(fp,"\n      stop_\n");
	
	
	fprintf(fp,toprint);
	j=1;
	for(i=0;i<(int)v.size();i++)
		v.at(i)->print_prediction(&j,fp);
	fprintf(fp,"      stop_\n");
	fclose(fp);

	fp=fopen("bb_predict.dat","wt");
	fprintf(fp,"%8s%8s%8s%8s%8s%8s%8s%8s%8s%8s%8s%8s%8s%8s\n","index","residue","pre_ca","exp_ca",
		"pre_cb","exp_cb","pre_c","exp_c","pre_h","exp_h","pre_n","exp_n","pre_ha","exp_ha");
	for(i=0;i<(int)v.size();i++)
		v.at(i)->print_bbprediction(fp);
	fclose(fp);

	fp=fopen("proton_predict.dat","wt");
	fprintf(fp,"%8s %8s %8s %8s %8s\n","#  index","aa type","type","cs","exp");
	for(i=0;i<(int)v.size();i++)
		v.at(i)->print_protonprediction(fp);
	fclose(fp);

}

double CPdb::test_bmbr(class CBmrb bmrb)
{
	int i;
	vector<int> index;
	string seq1,seq2;
	vector<int> out;
	int total;



	index.clear();
	seq2=bmrb.getseq(index);
	for(i=0;i<(int)v.size();i++)
	{
		seq1.push_back(v.at(i)->OneLetterName);
	}
	out=Sequence::align(seq1,seq2);

	total=0;
	for(i=1;i<out.size();i++)
	{
		if(out.at(i)>0 && seq1.at(i-1)!='X')
			total++;
	}

	return ((double)total)/seq2.length();
}


int CPdb::attach_bmrb(class CBmrb bmrb)
{
	int i,j;
	vector<int> index;
	string seq1,seq2;
	vector<int> out;
	int total,n,m;
	double dtotal;
	char c1,c2;

	for(i=0;i<v.size();i++)
		v.at(i)->clearexp();


	index.clear();
	seq2=bmrb.getseq();
	for(i=0;i<(int)v.size();i++)
	{
		seq1.push_back(v.at(i)->OneLetterName);
	}
	out=Sequence::align(seq1,seq2);

	dtotal=0.0;
	n=0;
	for(i=2;i<(int)out.size()-1;i++)
	{
		j=out.at(i);
		if(j!=0 && out.at(i)==out.at(i-1)+1 && out.at(i)==out.at(i+1)-1)
		{
			dtotal+=j-i;
			n++;
		}
	}

	dtotal/=n;


	if(dtotal>=0) total=(int)(dtotal+0.5);
	else total=(int)(dtotal-0.5);



	n=0;
	m=0;
	for(i=1;i<(int)out.size();i++)
	{
		for(j=0;j<bmrb.getsize();j++)
		{
			if(bmrb.getdata(j).res-total==i)
			{
				c1=v.at(i-1)->OneLetterName;
				c2=Sequence::name2code(bmrb.getdata(j).name);
				if(c1==c2)
				{
					v.at(i-1)->loadexp(bmrb.getdata(j));
					n++;
				}
				else
				{
					m++;
					v.at(i-1)->set_mismatch();
				}
			}
		}
	}

	return m;
}

void CPdb::clear_cs()
{
	int i;
	for(i=0;i<(int)v.size();i++)
	{
		v.at(i)->bexploaded=0;
		v.at(i)->exploaded=0;
		v.at(i)->clearexp();
	}
	return;
}



void CPdb::attach_rmsf(vector<double> t)
{
	int i;
	for(i=0;i<v.size();i++)
	{
		v.at(i)->attach_rmsf(t);
	}
	return;
}

void CPdb::print_rmsf(string filename)
{
	FILE *fp;
	int i;

	fp=fopen(filename.c_str(),"rt");
	for(i=0;i<v.size();i++)
	{
		v.at(i)->print_rmsf(fp);
	}
	fclose(fp);
	return;
}




//flag=1: bmrb rc
//flag==2: wang' rc
//flag==3: wang's rc with neighboring correction
void CPdb::attach_coil(int flag=1)
{
	int i;

	if(flag==3 && v.size()>=3 )
	{
		v.at(0)->set_coil_wc('X',v.at(1)->OneLetterName);
		for(i=0+1;i<v.size()-1;i++)
			v.at(i)->set_coil_wc(v.at(i-1)->OneLetterName,v.at(i+1)->OneLetterName);
		v.at(i)->set_coil_wc(v.at(i-1)->OneLetterName,'X');
	}
	else
	{
		for(i=0;i<(int)v.size();i++)
		{
			if(v.at(i)->bexploaded==0)
				v.at(i)->set_coil(flag);
		}
	}


	return;
}

void CPdb::attach_mean()
{
	int i;
	for(i=0;i<(int)v.size();i++)
	{
		if(v.at(i)->bexploaded==0)
			v.at(i)->set_mean();
	}
	return;
}

void CPdb::attach_dssp(string filename)
{
	int i,j;
	string seq1,seq2;
	vector<int> out;


	dssp.loaddata(filename);
	for(i=0;i<(int)v.size();i++)
	{
		seq1.push_back(v.at(i)->OneLetterName);
	}
	seq2=dssp.getseq();
	out=Sequence::align(seq1,seq2);
	for(i=1;i<(int)out.size();i++)
	{
		j=out.at(i);
		if(j!=0)
			v.at(i-1)->setdssp(dssp.data.at(j-1).ss);
	}
	return;
}


void CPdb::attach_dssp()
{
	int i,j;
	string seq1,seq2;
	vector<int> out;


	dssp.loaddata(pdbfilename);
	for(i=0;i<(int)v.size();i++)
	{
		seq1.push_back(v.at(i)->OneLetterName);
	}
	seq2=dssp.getseq();
	out=Sequence::align(seq1,seq2);
	for(i=1;i<(int)out.size();i++)
	{
		j=out.at(i);
		if(j!=0)
			v.at(i-1)->setdssp(dssp.data.at(j-1).ss);
	}
	return;
}

char CPdb::getss(int i)
{
	return v.at(i-1)->getdssp();
}

struct noeatoms CPdb::query(int resid,string name)
{
	return v.at(resid-1)->query(name);
}


CPdb::CPdb()
{nmiss=0;};

CPdb::~CPdb()
{
	clear();
};


//CPdbcut
CPdb2::CPdb2()
{};

CPdb2::~CPdb2()
{ clear(); };

void CPdb2::clear()
{
	int i;

	for(i=0;i<pdbs.size();i++)
	{
		delete pdbs.at(i);
	}

	pdbs.clear();
	return;
}

double CPdb2::loadpdb(string filename)
{
	int i,j;
	ifstream fin(filename.c_str());
	string name;
	string line;
	string part1,part2,part3,part4;
	struct modify mod;
	vector<struct modify> mods;
	char chain;
	char old_chain;
	vector<string> block;
	vector< vector<string> > blocks;
	class CPdb *pdb;
	int ixray;
	char buffer[255];
	double resolution;

	blocks.clear();
	clear();

	name=filename.substr(0,filename.find(".pdb"));


	old_chain=0;
	mods.clear();
	ixray=1;
	resolution=0.0;
	while(getline(fin,line))
	{
		//"SEQADV 1NBF GLZ C  3";
		//"76  UNP  P62988    G";
		//"LY    76 MODIFIED RE";
		//"SIDUE";

		part1=line.substr(0,6);
		if(part1.compare("EXPDTA")==0)
		{
			part2=line.substr(10,5);
			if(part2.compare("X-RAY")==0)
				ixray=1;
			if(part2.compare("SOLUT")==0)
				ixray=0;
			if(part2.compare("SOLID")==0)
				ixray=0;
		}

		part1=line.substr(0,22);
		if(part1.compare("REMARK   2 RESOLUTION.")==0)
		{
			part2=line.substr(22,8);
			resolution=atof(part2.c_str());
		}


		if(ixray==0)
		{
			cout<<"neglect nmr structure "<<filename.c_str()<<endl;
			break;
		}
		if(resolution>2.0)
		{
			cout<<"neglect low resolution ("<<resolution<<") xray structure "<<filename.c_str()<<endl;
			break;
		}

		part1=line.substr(0,6);
		part2=line.substr(49,20);
		if(part1.compare("SEQADV")==0 && part2.find("MODIFIED")!=string::npos)
		{
			mod.from=line.substr(12,3);
			mod.to=line.substr(39,3);
			mod.chain=line.at(16);
			mod.res=atoi(line.substr(18,4).c_str());
			mods.push_back(mod);
		}

		part1=line.substr(0,4);
		part2=line.substr(0,6);
		part3=line.substr(0,3);
		if(part1!="ATOM" && part2!="HETATM" && part3 !="TER")
			continue;
		
		chain=line.at(21);

		if(chain==old_chain)
		{
			block.push_back(line);
		}
		else if(chain>old_chain || (old_chain=='Z' && chain=='A'))
		{
			if(block.size()>0)
				blocks.push_back(block);
			old_chain=chain;
			block.clear();
			block.push_back(line);
		}
		else
		{
			//cout<<"old chain id is "<<old_chain<<" and new chain id is "<<chain<<endl;
			break;
		}
	}

	if(block.size()>0)
		blocks.push_back(block);

	ofstream  fout;
	for(i=0;i<blocks.size();i++)
	{
		block=blocks.at(i);
		sprintf(buffer,"%s-%d.pdb",name.c_str(),i);
		fout.open(buffer,ofstream::out);
		line=block.at(0);
		fout<<"REMART   1  PDB seperated from "<<filename.c_str()<<" chain ID is "<<line.at(21)<<endl;
		for(j=0;j<block.size();j++)
		{
			line=block.at(j);
			line.at(21)=' ';
			fout<<line<<endl;
		}
		fout.close();
		pdb=new CPdb;
		pdb->loadpdb(buffer);
		pdbs.push_back(pdb);
	}

	if(ixray==0)
	{ 
		resolution=100.0;
	}

	return resolution;
};



########## NEXT FILE ##########
#include <iostream>
#include <cstdlib>
#include <fstream>
#include <cstring>
#include <string>
#include <vector>
#include <math.h>
#include <time.h>
using namespace std;

#include "traj.h"
using namespace ldw_math;

#define USE_ACC_COMPARE
#include "debug.h"

// ///////////////////////////////////////////////////////////////////////////////////////////////////////////

void CTraj::clear()
{
	x.clear();
	y.clear();
	z.clear();
	nframe=0;
}




int CTraj::appendcoor(string filename)
{
	double xx,yy,zz;
	string line,part;

	ifstream fin(filename.c_str());
	
	while(getline(fin,line))
	{
		if(part=="ENDMDL" || part=="END")
		{
			if(x.size()%natom!=0)
				cout<<"In traj reading, suppose to read "<<natom<<" coors but actually read in "<<x.size()<<endl;
		}

		part=line.substr(0,6);
		if(part!="ATOM  " && part!="HETATM")
			continue;

		part=line.substr(30,8);
		xx=atof(part.c_str());
		x.push_back(xx);
		part=line.substr(38,8);
		yy=atof(part.c_str());
		y.push_back(yy);
		part=line.substr(46,8);
		zz=atof(part.c_str());
		z.push_back(zz);
	};


	nframe=x.size()/natom;
	return nframe;
}


int CTraj::loadcoor(string filename)
{
	double xx,yy,zz;
	string line,part;
	bool bend;

	bend=0;


	ifstream fin(filename.c_str());

	
	while(getline(fin,line))
	{
		if(part=="ENDMDL" || part=="END")
		{
			//finished read first molecule 
			bend=1;
			if(x.size()%natom!=0)
				cout<<"In traj reading, suppose to read "<<natom<<" coors but actually read in "<<x.size()<<endl;
		}

		part=line.substr(0,6);
		if(part!="ATOM  " && part!="HETATM")
			continue;

		part=line.substr(30,8);
		xx=atof(part.c_str());
		x.push_back(xx);
		part=line.substr(38,8);
		yy=atof(part.c_str());
		y.push_back(yy);
		part=line.substr(46,8);
		zz=atof(part.c_str());
		z.push_back(zz);
		if(bend==0)
		{
			part=line.substr(12,4);
			atomname.push_back(part);
		}
	};

	if(natom==0)
		nframe=0;
	else
		nframe=x.size()/natom;

#ifdef _OPENACC
#pragma acc enter data copyin(this[:1])
  double *tmp = x.data();
  int sz = x.size();
#pragma acc enter data copyin(tmp[:sz])
  tmp = y.data();
  sz = y.size();
#pragma acc enter data copyin(tmp[:sz])
  tmp = z.data();
  sz = z.size();
#pragma acc enter data copyin(tmp[:sz])
#endif

	return nframe;
}

int CTraj::set_range(int begin,int stop)
{
	if(begin<0)
	{
		begin=0;
		cout<<"Reset begin to "<<begin<<endl;
	}

	if(stop>nframe)
	{
		stop=nframe;
		cout<<"Reset stop to "<<stop<<endl;
	}

	if(stop==0)
		stop=nframe;

	nframe=stop-begin;


	if(stop<nframe)
	{
		x.erase(x.begin()+stop*natom,x.begin()+x.size());
		y.erase(y.begin()+stop*natom,y.begin()+y.size());
		z.erase(z.begin()+stop*natom,z.begin()+z.size());
	}
	if(begin>0)
	{
		x.erase(x.begin(),x.begin()+begin*natom);
		y.erase(y.begin(),y.begin()+begin*natom);
		z.erase(z.begin(),z.begin()+begin*natom);
	}

	cout<<"Using frames from "<<begin<<" to "<<stop<<endl;
	return nframe;
}



void CTraj::getschbond2(vector<struct proton> *protons, vector<struct bbhbond_group> *bb, vector< vector<ehbond> > *effect, vector< vector<eschbond> > *effect_sc)
{
	int i,j,k;
	int base;
	int n,h[3],c,o;
	int nh;
	int nid,cid;
	double u[3];
	float x2,x3,x4,x5;
	float y2,y3,y4,y5;
	float z2,z3,z4,z5;
	float phi,psi,d;

	int kk,good_kk;
	float min_d;

	effect->resize(nres);
	for(i=0;i<(int)effect->size();i++)
	{
		effect->at(i).resize(nframe);
		for(k=0;k<nframe;k++)
		{
			effect->at(i).at(k).n_length=0;
			effect->at(i).at(k).c_length=0;
			effect->at(i).at(k).n_phi=0;
			effect->at(i).at(k).c_phi=0;
			effect->at(i).at(k).n_psi=0;
			effect->at(i).at(k).c_psi=0;
		}
	}

	effect_sc->resize(protons->size());
	for(i=0;i<(int)effect_sc->size();i++)
	{
		effect_sc->at(i).resize(nframe);
		for(k=0;k<nframe;k++)
		{
			effect_sc->at(i).at(k).n_length=0;
			effect_sc->at(i).at(k).c_length=0;
			effect_sc->at(i).at(k).n_phi=0;
			effect_sc->at(i).at(k).c_phi=0;
			effect_sc->at(i).at(k).n_psi=0;
			effect_sc->at(i).at(k).c_psi=0;
		}
	}


	
	for(i=0;i<(int)protons->size();i++)
	{
		for(j=0;j<(int)bb->size();j++)
		{
			nh=protons->at(i).nh;
			for(k=0;k<nh;k++)
				h[k]=protons->at(i).hpos[k];
			n=protons->at(i).cpos;
			if(h[0]<=-1 || n<=-1 || (nh==2 && h[1]<0) || (nh==3 && h[2]<0) ) 
				continue;
			c=bb->at(j).cpos;
			o=bb->at(j).opos;
			if(o<=-1 || c<=-1)
				continue;
			n--;c--;o--;
			for(k=0;k<nh;k++)
				h[k]--;

			for(k=0;k<nframe;k++)
			{
				//cout<<"i,j,k is "<<i<<" "<<j<<" "<<k<<endl;
				min_d=100000.0;
				for(kk=0;kk<nh;kk++)
				{
					base=k*natom;
					u[0]=x[h[kk]+base]-x[o+base];
					u[1]=y[h[kk]+base]-y[o+base];
					u[2]=z[h[kk]+base]-z[o+base];
					d=veclength(u);
					if(d<min_d)
					{
						min_d=d;
						good_kk=kk;
					}
				}
				d=min_d;
				x2=x[n+base];y2=y[n+base];z2=z[n+base];
				x3=x[h[good_kk]+base];y3=y[h[good_kk]+base];z3=z[h[good_kk]+base];
				x4=x[o+base];y4=y[o+base];z4=z[o+base];
				x5=x[c+base];y5=y[c+base];z5=z[c+base];
				phi=coor_to_angle(x2,y2,z2,x3,y3,z3,x4,y4,z4);
				psi=coor_to_angle(x3,y3,z3,x4,y4,z4,x5,y5,z5);
				if(d<3 && phi>0.5 && psi>0.5)
				{
					d=1/(d-1);
					phi*=phi;
					psi*=psi;
					nid=protons->at(i).id-1;
					cid=bb->at(j).id-1; /* C start from 0*/
					
					//effect->at(nid).at(k).n_length=d;
					//effect->at(nid).at(k).n_phi=phi;
					//effect->at(nid).at(k).n_psi=psi;

					effect_sc->at(i).at(k).n_length=d;
					effect_sc->at(i).at(k).n_phi=phi;
					effect_sc->at(i).at(k).n_psi=psi;
					effect_sc->at(i).at(k).id=protons->at(i).id;
					effect_sc->at(i).at(k).type=protons->at(i).type;

					if(bb->at(j).type==1)
					{
						effect->at(cid).at(k).c_length=d;
						effect->at(cid).at(k).c_phi=phi;
						effect->at(cid).at(k).c_psi=psi;
					}
					
				}
			}//for k
		}//for j
	}//for i

	return;
}


//hbond type (1, bb) (12, sc OH) (13,sc NH) (22 or 23, sc CO)
void CTraj::gethbond(vector<bbhbond_group> *hbond,vector<ehbond> *effect)
{
	int i,j,k;
	int base;
	int nid,cid;
	int n,h,c,o;
	double u[3];
	double x2,x3,x4,x5,y2,y3,y4,y5,z2,z3,z4,z5;
	double d,phi,psi;

	bbhbond_group* hbond_arr = hbond->data();
	int hbond_size = hbond->size();
	effect->resize(nres);
	ehbond* effect_arr = effect->data();
	int effect_size = effect->size();
	double* x_arr = this->x.data();
	int x_size = this->x.size();
	double* y_arr = this->y.data();
	int y_size = this->y.size();
	double* z_arr = this->z.data();
	int z_size = this->z.size();

  int nframe = this->nframe;
  int natom  = this->natom;

#pragma acc data \
	copyin(hbond_arr[:hbond_size]) \
	copyout(effect_arr[:effect_size]) \
	present(x_arr[:x_size], y_arr[:y_size], z_arr[:z_size])
{

#pragma acc parallel loop gang
	for(i=0; i<hbond_size; i++)
	{
#pragma acc loop vector \
	private(k,n,h,c,o,base,u[:3],d,x2,x3,x4,x5,y2,y3,y4,y5,\
					z2,z3,z4,z5,phi,psi,nid,cid)
		for(j=0; j<hbond_size; j++)
		{
			//k=j-i;
			if(j-i<3 && j-i>-3)
				continue;
			n=hbond_arr[i].npos-1;
			h=hbond_arr[i].hpos-1;
			//if(h<=-1 || n<=-1) 
			//	continue;
			c=hbond_arr[j].cpos-1;
			o=hbond_arr[j].opos-1;
			//if(o<=-1 || c<=-1)
			//	continue;
			//n--;h--;c--;o--;
			if(h<0 || n<0 || o<0 || c<0)
				continue;

#pragma acc loop seq
			for(k=0;k<nframe;k++)
			{
				base=k*natom;
				u[0]=x_arr[h+base]-x_arr[o+base];
				u[1]=y_arr[h+base]-y_arr[o+base];
				u[2]=z_arr[h+base]-z_arr[o+base];
				d=veclength(u);
				x2=x_arr[n+base];y2=y_arr[n+base];z2=z_arr[n+base];
				x3=x_arr[h+base];y3=y_arr[h+base];z3=z_arr[h+base];
				x4=x_arr[o+base];y4=y_arr[o+base];z4=z_arr[o+base];
				x5=x_arr[c+base];y5=y_arr[c+base];z5=z_arr[c+base];
				phi=coor_to_angle(x2,y2,z2,x3,y3,z3,x4,y4,z4);
				psi=coor_to_angle(x3,y3,z3,x4,y4,z4,x5,y5,z5);
				if(d<3 && phi>0.5 && psi>0.5)
				{
					d=1/(d-1);
					phi*=phi;
					psi*=psi;
					nid=hbond_arr[i].id-1;
					cid=hbond_arr[j].id-1; /* C start from 0*/
					if(hbond_arr[i].type==1)
					{
#pragma acc atomic update
						effect_arr[nid].n_length+=d;
#pragma acc atomic update
						effect_arr[nid].n_phi+=phi;
#pragma acc atomic update
						effect_arr[nid].n_psi+=psi;
					}
					if(hbond_arr[j].type==1)
					{
#pragma acc atomic update
						effect_arr[cid].c_length+=d;
#pragma acc atomic update
						effect_arr[cid].c_phi+=phi;
#pragma acc atomic update
						effect_arr[cid].c_psi+=psi;
					}
				}
			}
		}
	}

#pragma acc parallel loop
	for(i=0; i<effect_size; i++)
	{
		effect_arr[i].n_length/=nframe;
		effect_arr[i].c_length/=nframe;
		effect_arr[i].n_phi/=nframe;
		effect_arr[i].c_phi/=nframe;
		effect_arr[i].n_psi/=nframe;
		effect_arr[i].c_psi/=nframe;
	}

} // end data

	return;
}


//hbond type (1, bb) (12, sc OH) (13,sc NH) (22 or 23, sc CO)
void CTraj::gethbond(vector<bbhbond_group> *hbond,vector<ehbond> *effect, double cutoff)
{

	int i,j,k;
	int base;
	int nid,cid;
	int n,h,c,o;
	double u[3];
	double x2,x3,x4,x5,y2,y3,y4,y5,z2,z3,z4,z5;
	double d,phi,psi;

	
	effect->resize(nres);
	for(i=0;i<(int)hbond->size();i++)
	{

		for(j=0;j<(int)hbond->size();j++)
		{
			k=j-i;
			if(k<3 && k>-3)
				continue;
			n=hbond->at(i).npos;
			h=hbond->at(i).hpos;
			if(h<=-1 || n<=-1) 
				continue;
			c=hbond->at(j).cpos;
			o=hbond->at(j).opos;
			if(o<=-1 || c<=-1)
				continue;
			n--;h--;c--;o--;
			if(h<0 || n<0 || o<0 || c<0)
				continue;



			for(k=0;k<nframe;k++)
			{
				//cout<<"i,j,k is "<<i<<" "<<j<<" "<<k<<endl;
				base=k*natom;
				u[0]=x[h+base]-x[o+base];
				u[1]=y[h+base]-y[o+base];
				u[2]=z[h+base]-z[o+base];
				d=veclength(u);
				x2=x[n+base];y2=y[n+base];z2=z[n+base];
				x3=x[h+base];y3=y[h+base];z3=z[h+base];
				x4=x[o+base];y4=y[o+base];z4=z[o+base];
				x5=x[c+base];y5=y[c+base];z5=z[c+base];
				phi=coor_to_angle(x2,y2,z2,x3,y3,z3,x4,y4,z4);
				psi=coor_to_angle(x3,y3,z3,x4,y4,z4,x5,y5,z5);
				if(d<3 && phi>0.5 && psi>0.5)
				{
					d=1/(d-1);
					phi*=phi;
					psi*=psi;
					nid=hbond->at(i).id-1;
					cid=hbond->at(j).id-1; /* C start from 0*/

					if(d>cutoff)
						d=cutoff;

					if(hbond->at(i).type==1)
					{
						effect->at(nid).n_length+=d;
						effect->at(nid).n_phi+=phi;
						effect->at(nid).n_psi+=psi;
					}
					if(hbond->at(j).type==1)
					{
						effect->at(cid).c_length+=d;
						effect->at(cid).c_phi+=phi;
						effect->at(cid).c_psi+=psi;
					}
				}
			}
		}
	}

	for(i=0;i<(int)effect->size();i++)
	{
		effect->at(i).n_length/=nframe;
		effect->at(i).c_length/=nframe;
		effect->at(i).n_phi/=nframe;
		effect->at(i).c_phi/=nframe;
		effect->at(i).n_psi/=nframe;
		effect->at(i).c_psi/=nframe;
	}
	return;
}



void CTraj::gethbond(vector<bbhbond_group> *hbond,vector< vector<ehbond> > *effect)
{

	int i,j,k;
	int base;
	int nid,cid;
	int n,h,c,o;
	double u[3];
	double x2,x3,x4,x5,y2,y3,y4,y5,z2,z3,z4,z5;
	double d,phi,psi;

	effect->resize(nres);
	for(i=0;i<(int)effect->size();i++)
	{
		effect->at(i).resize(nframe);
		for(k=0;k<nframe;k++)
		{
			effect->at(i).at(k).n_length=0;
			effect->at(i).at(k).c_length=0;
			effect->at(i).at(k).n_phi=0;
			effect->at(i).at(k).c_phi=0;
			effect->at(i).at(k).n_psi=0;
			effect->at(i).at(k).c_psi=0;
		}
	}

	for(i=0;i<(int)hbond->size();i++)
	{

		for(j=0;j<(int)hbond->size();j++)
		{
			k=j-i;
			if(k<3 && k>-3)
				continue;
			n=hbond->at(i).npos;
			h=hbond->at(i).hpos;
			if(h<0) 
				continue;
			c=hbond->at(j).cpos;
			o=hbond->at(j).opos;
			if(o<0)
				continue;
			n--;h--;c--;o--;


			for(k=0;k<nframe;k++)
			{
				//cout<<"i,j,k is "<<i<<" "<<j<<" "<<k<<endl;
				base=k*natom;
				u[0]=x[h+base]-x[o+base];
				u[1]=y[h+base]-y[o+base];
				u[2]=z[h+base]-z[o+base];
				d=veclength(u);
				x2=x[n+base];y2=y[n+base];z2=z[n+base];
				x3=x[h+base];y3=y[h+base];z3=z[h+base];
				x4=x[o+base];y4=y[o+base];z4=z[o+base];
				x5=x[c+base];y5=y[c+base];z5=z[c+base];
				phi=coor_to_angle(x2,y2,z2,x3,y3,z3,x4,y4,z4);
				psi=coor_to_angle(x3,y3,z3,x4,y4,z4,x5,y5,z5);
				if(d<3 && phi>0.5 && psi>0.5)
				{
					d=1/(d-1);
					phi*=phi;
					psi*=psi;
					nid=hbond->at(i).id-1;
					cid=hbond->at(j).id-1; /* C start from 0*/
					if(hbond->at(i).type==1)
					{
						effect->at(nid).at(k).n_length+=d;
						effect->at(nid).at(k).n_phi+=phi;
						effect->at(nid).at(k).n_psi+=psi;
					}
					if(hbond->at(j).type==1)
					{
						effect->at(cid).at(k).c_length+=d;
						effect->at(cid).at(k).c_phi+=phi;
						effect->at(cid).at(k).c_psi+=psi;
					}
				}
			}
		}
	}
	return;
}


void CTraj::gethbond2(vector<bbhbond_group> *hbond,vector< vector<ehbond> > *effect)
{

	int i,j,k;
	int base;
	int nid,cid;
	int n,h,c,o;
	double u[3];
	double x2,x3,x4,x5,y2,y3,y4,y5,z2,z3,z4,z5;
	double d,phi,psi;

	effect->resize(nres);
	for(i=0;i<(int)effect->size();i++)
	{
		effect->at(i).resize(nframe);
		for(k=0;k<nframe;k++)
		{
			effect->at(i).at(k).n_length=0;
			effect->at(i).at(k).c_length=0;
			effect->at(i).at(k).n_phi=0;
			effect->at(i).at(k).c_phi=0;
			effect->at(i).at(k).n_psi=0;
			effect->at(i).at(k).c_psi=0;
		}
	}

	for(i=0;i<(int)hbond->size();i++)
	{

		for(j=0;j<(int)hbond->size();j++)
		{
			k=j-i;
			if(k<=3 && k>=-3)
				continue;
			n=hbond->at(i).npos;
			h=hbond->at(i).hpos;
			if(h<0) 
				continue;
			c=hbond->at(j).cpos;
			o=hbond->at(j).opos;
			if(o<0)
				continue;
			n--;h--;c--;o--;


			for(k=0;k<nframe;k++)
			{
				//cout<<"i,j,k is "<<i<<" "<<j<<" "<<k<<endl;
				base=k*natom;
				u[0]=x[h+base]-x[o+base];
				u[1]=y[h+base]-y[o+base];
				u[2]=z[h+base]-z[o+base];
				d=veclength(u);
				x2=x[n+base];y2=y[n+base];z2=z[n+base];
				x3=x[h+base];y3=y[h+base];z3=z[h+base];
				x4=x[o+base];y4=y[o+base];z4=z[o+base];
				x5=x[c+base];y5=y[c+base];z5=z[c+base];
				phi=coor_to_angle(x2,y2,z2,x3,y3,z3,x4,y4,z4);
				psi=coor_to_angle(x3,y3,z3,x4,y4,z4,x5,y5,z5);
				if(d<3 && phi>0.5 && psi>0.5)
				{
					d=1/(d-1);
					phi*=phi;
					psi*=psi;
					nid=hbond->at(i).id-1;
					cid=hbond->at(j).id-1; /* C start from 0*/
					if(hbond->at(i).type==1)
					{
						effect->at(nid).at(k).n_length=d;
						effect->at(nid).at(k).n_phi=phi;
						effect->at(nid).at(k).n_psi=psi;
					}
					if(hbond->at(i).type==1)
					{
						effect->at(cid).at(k).c_length=d;
						effect->at(cid).at(k).c_phi=phi;
						effect->at(cid).at(k).c_psi=psi;
					}
				}
			}
		}
	}
	return;
}




void CTraj::dis_matrix(vector<int> *index,vector<double> *dis)
{
	int i,j,n1,n2;
	double d1,d2,d3,d;
	for(i=0;i<(int)index->size();i++)
	{
		n1=index->at(i)-1;
		for(j=0;j<(int)index->size();j++)
		{		
			n2=index->at(j)-1;
			d1=x.at(n1)-x.at(n2);
			d2=y.at(n1)-y.at(n2);
			d3=z.at(n1)-z.at(n2);
			d=sqrt(d1*d1+d2*d2+d3*d3);
			dis->push_back(d);
		}
	}
	return;
}


void CTraj::getangle(vector<struct dihe_group> *index, vector<double> * angle)
{
	int i,j;
	int x1,x2,x3,x4;
	int base;
	double t;


	for(i=0;i<nframe;i++)
	{
		base=i*natom-1;  // -1 because of C starts from 0 but not 1 !
		for(j=0;j<(int)index->size();j++)
		{
			x1=base+index->at(j).x1;
			x2=base+index->at(j).x2;
			x3=base+index->at(j).x3;
			x4=base+index->at(j).x4;
			t=coor_to_angle(x[x1],y[x1],z[x1],x[x2],y[x2],z[x2],x[x3],y[x3],z[x3]);
			angle->push_back(t);
			t=coor_to_angle(x[x2],y[x2],z[x2],x[x3],y[x3],z[x3],x[x4],y[x4],z[x4]);
			angle->push_back(t);
		}
	}
	return;
}




void CTraj::getdihe(vector<struct dihe_group> *index, vector<double> * dihe)
{	
	int i,j;
	int x1,x2,x3,x4;
	int base;
	double t;


	for(i=0;i<nframe;i++)
	{
		base=i*natom-1;  // -1 because of C starts from 0 but not 1 !
		for(j=0;j<(int)index->size();j++)
		{
			if(index->at(j).bgood==1)
			{
				x1=base+index->at(j).x1;
				x2=base+index->at(j).x2;
				x3=base+index->at(j).x3;
				x4=base+index->at(j).x4;
				t=coor_to_dihe(x[x1],y[x1],z[x1],x[x2],y[x2],z[x2],x[x3],y[x3],z[x3],x[x4],y[x4],z[x4]);
				dihe->push_back(t);
			}
			else
				dihe->push_back(-1000.0);
		}
	}
	return;
}


void CTraj::getring(vector<struct ring_group> *index, vector<struct nh_group>* select, vector<struct double_five> *ring_effect)
{	
	int i,j,k,ii,jj,m;
	int base;
	int t[6];
	double p1[3],t1[3],t2[3],t3[3];
	double u[6][3];
	double sum[3];
	double ori[3];
	double e;

	ring_group* index_arr = index->data();
	int index_size = index->size();
	nh_group* select_arr = select->data();
	int select_size = select->size();
	ring_effect->resize(select_size);
	double_five* effect_arr = ring_effect->data();
	int effect_size = ring_effect->size();
	double* x_arr = this->x.data();
	int x_size = this->x.size();
	double* y_arr = this->y.data();
	int y_size = this->y.size();
	double* z_arr = this->z.data();
	int z_size = this->z.size();

	int nframe = this->nframe;
	int natom = this->natom;

#pragma acc data \
	copyin(index_arr[:index_size], select_arr[:select_size], \
  	x_arr[:x_size], y_arr[:y_size], z_arr[:z_size]) \
	copyout(effect_arr[:effect_size])
{

#pragma acc parallel loop collapse(2)
	for(i=0; i<select_size; i++)
		for(j=0; j<5; j++)
			effect_arr[i].x[j]=0.0;

	for(i=0;i<nframe;i++)
	{
		base=i*natom;

#pragma acc parallel loop gang \
	private(ii,jj,m,t[:6],u[:6][:3],sum[:3],\
	ori[:3],t1[:3],t2[:3],t3[:3])
		for(j=0; j<index_size; j++)
		{
			if(index_arr[j].x1 == 1 || index_arr[j].x1 == 2 || index_arr[j].x1 == 5){
				m=6;
			} else {
				m=5;
			}

			t[0]=index_arr[j].x2;
			t[1]=index_arr[j].x3;
			t[2]=index_arr[j].x4;
			t[3]=index_arr[j].x5;
			t[4]=index_arr[j].x6;
			t[5]=index_arr[j].x7;

			u[0][0]=x_arr[t[0]+base-1]; u[0][1]=y_arr[t[0]+base-1]; u[0][2]=z_arr[t[0]+base-1];
			u[1][0]=x_arr[t[1]+base-1]; u[1][1]=y_arr[t[1]+base-1]; u[1][2]=z_arr[t[1]+base-1];
			u[2][0]=x_arr[t[2]+base-1]; u[2][1]=y_arr[t[2]+base-1]; u[2][2]=z_arr[t[2]+base-1];
			u[3][0]=x_arr[t[3]+base-1]; u[3][1]=y_arr[t[3]+base-1]; u[3][2]=z_arr[t[3]+base-1];
			u[4][0]=x_arr[t[4]+base-1]; u[4][1]=y_arr[t[4]+base-1]; u[4][2]=z_arr[t[4]+base-1];
			if(m >= 6) {
				u[5][0]=x_arr[t[5]+base-1]; u[5][1]=y_arr[t[5]+base-1]; u[5][2]=z_arr[t[5]+base-1];
			} else {
				u[5][0]=0; u[5][1]=0; u[5][2]=0;
			}

			sum[0] = (u[0][0] + u[1][0] + u[2][0] + u[3][0] + u[4][0] + u[5][0]) / m;
			sum[1] = (u[0][1] + u[1][1] + u[2][1] + u[3][1] + u[4][1] + u[5][1]) / m;
			sum[2] = (u[0][2] + u[1][2] + u[2][2] + u[3][2] + u[4][2] + u[5][2]) / m;

			u[0][0] -= sum[0]; u[0][1] -= sum[1]; u[0][2] -= sum[2];
			u[1][0] -= sum[0]; u[1][1] -= sum[1]; u[1][2] -= sum[2];
			u[2][0] -= sum[0]; u[2][1] -= sum[1]; u[2][2] -= sum[2];
			u[3][0] -= sum[0]; u[3][1] -= sum[1]; u[3][2] -= sum[2];
			u[4][0] -= sum[0]; u[4][1] -= sum[1]; u[4][2] -= sum[2];
			u[5][0] -= sum[0]; u[5][1] -= sum[1]; u[5][2] -= sum[2];

			ring(u,m,ori);

			t1[0] = u[0][0] - u[1][0];
			t1[1] = u[0][1] - u[1][1];
			t1[2] = u[0][2] - u[1][2];
			t2[0] = u[2][0] - u[1][0];
			t2[1] = u[2][1] - u[1][1];
			t2[2] = u[2][2] - u[1][2];

			cross(t3,t1,t2);
			if(dot(t3,ori)<0)
			{
				ori[0] = -ori[0];
				ori[1] = -ori[1];
				ori[2] = -ori[2];
			}

#pragma acc loop vector private(e,p1[:3])
			for(k=0; k<select_size; k++)
			{
				if(select_arr[k].hpos>=1)
				{
					e=0;
					p1[0]=x_arr[base+select_arr[k].hpos-1]-sum[0];
					p1[1]=y_arr[base+select_arr[k].hpos-1]-sum[1];
					p1[2]=z_arr[base+select_arr[k].hpos-1]-sum[2];
					e+=effect(u,m,ori,p1); 
					e=e*10;
#pragma acc atomic update
					effect_arr[k].x[index_arr[j].x1-1]+=e;
				}
			}
		}
	}

#pragma acc parallel loop collapse(2)
	for(ii=0; ii<select_size; ii++)
	{
		for(jj=0;jj<5;jj++)
		{
			effect_arr[ii].x[jj]/=nframe;
		}
	}

} // end data

	return;
}


void CTraj::getring(vector<struct ring_group> *index, vector<struct nh_group>* select, vector< vector<struct double_five> > *ring_effect)
{	
	int i,j,ii,jj,m;
	int base;
	int t[6];
	double p1[3],t1[3],t2[3],t3[3];
	double u[6][3];
	double sum[3];
	double ori[3];
	double e;
	struct double_five temp;
	
	for(i=0;i<5;i++)
		temp.x[i]=0;
	ring_effect->resize(select->size());
	for(ii=0;ii<(int)select->size();ii++)
	{
		for(jj=0;jj<nframe;jj++)
		{
			ring_effect->at(ii).push_back(temp);
		}
	}


	for(i=0;i<nframe;i++)
	{
		base=i*natom;  
		for(j=0;j<(int)index->size();j++)
		{
			switch(index->at(j).x1)
			{
				case 1:
                case 2:
                case 5:
					m=6;
					break;
				case 4:
				case 3:
					m=5;
					break;
			}
			t[0]=index->at(j).x2;
			t[1]=index->at(j).x3;
			t[2]=index->at(j).x4;
			t[3]=index->at(j).x5;
			t[4]=index->at(j).x6;
			t[5]=index->at(j).x7;

           
            for(ii=0;ii<m;ii++)
			{
				u[ii][0]=x[t[ii]+base-1];
                u[ii][1]=y[t[ii]+base-1];
                u[ii][2]=z[t[ii]+base-1];
            }
           
            for(jj=0;jj<3;jj++)
				sum[jj]=0; 
			for(ii=0;ii<m;ii++)
            {
				for(jj=0;jj<3;jj++)
				{
					sum[jj]+=u[ii][jj];
				}
			}
			for(jj=0;jj<3;jj++)
				sum[jj]/=m; 
			for(ii=0;ii<m;ii++)
			{
				for(jj=0;jj<3;jj++)
					u[ii][jj]-=sum[jj];
			}

			ring(u,m,ori);

            for(jj=0;jj<3;jj++)
            {
                   t1[jj]=u[0][jj]-u[1][jj];
                   t2[jj]=u[2][jj]-u[1][jj];
            }
            cross(t3,t1,t2);
            if(dot(t3,ori)<0)
            {
				for(jj=0;jj<3;jj++)
					ori[jj]=-ori[jj];
			}

			for(ii=0;ii<(int)select->size();ii++)
			{
				if(select->at(ii).hpos>=1)
				{
					e=0;
					p1[0]=x[base+select->at(ii).hpos-1]-sum[0];
					p1[1]=y[base+select->at(ii).hpos-1]-sum[1];
					p1[2]=z[base+select->at(ii).hpos-1]-sum[2];
					e+=effect(u,m,ori,p1); 
					e=e*10;
					ring_effect->at(ii).at(i).x[index->at(j).x1-1]+=e;
				}
			}
		}
	}

	return;
}



void CTraj::getring(vector<struct ring_group> *index, vector<struct methyl_group>* select, vector<struct double_five> *ring_effect, enum methyl c)
{	
	int i,j,ii,jj,m,k;
	int base;
	int t[6];
	double p1[3],t1[3],t2[3],t3[3];
	double u[6][3];
	double sum[3];
	double ori[3];
	double e;
	struct double_five temp;
	
	for(i=0;i<5;i++)
		temp.x[i]=0;
	for(i=0;i<(int)select->size();i++)
		ring_effect->push_back(temp);


	for(i=0;i<nframe;i++)
	{
		base=i*natom;  
		for(j=0;j<(int)index->size();j++)
		{
			switch(index->at(j).x1)
			{
				case 1:
                case 2:
                case 5:
					m=6;
					break;
				case 4:
				case 3:
					m=5;
					break;
			}
			t[0]=index->at(j).x2;
			t[1]=index->at(j).x3;
			t[2]=index->at(j).x4;
			t[3]=index->at(j).x5;
			t[4]=index->at(j).x6;
			t[5]=index->at(j).x7;

           
            for(ii=0;ii<m;ii++)
			{
				u[ii][0]=x[t[ii]+base-1];
                u[ii][1]=y[t[ii]+base-1];
                u[ii][2]=z[t[ii]+base-1];
            }
           
            for(jj=0;jj<3;jj++)
				sum[jj]=0; 
			for(ii=0;ii<m;ii++)
            {
				for(jj=0;jj<3;jj++)
				{
					sum[jj]+=u[ii][jj];
				}
			}
			for(jj=0;jj<3;jj++)
				sum[jj]/=m; 
			for(ii=0;ii<m;ii++)
			{
				for(jj=0;jj<3;jj++)
					u[ii][jj]-=sum[jj];
			}

			ring(u,m,ori);

            for(jj=0;jj<3;jj++)
            {
                   t1[jj]=u[0][jj]-u[1][jj];
                   t2[jj]=u[2][jj]-u[1][jj];
            }
            cross(t3,t1,t2);
            if(dot(t3,ori)<0)
            {
				for(jj=0;jj<3;jj++)
					ori[jj]=-ori[jj];
			}

			for(ii=0;ii<(int)select->size();ii++)
			{
				e=0;

				switch(c)
				{
				case hydrogen:
					for(k=0;k<3;k++)
					{
						p1[0]=x[base+select->at(ii).hpos[k]-1]-sum[0];
						p1[1]=y[base+select->at(ii).hpos[k]-1]-sum[1];
						p1[2]=z[base+select->at(ii).hpos[k]-1]-sum[2];
						//cout<<"Ori is "<<ori[0]<<" "<<ori[1]<<" "<<ori[2]<<endl;
						//cout<<"X is "<<p1[0]<<" "<<p1[1]<<" "<<p1[2]<<endl;
						e+=effect(u,m,ori,p1); 
					}
					break;
				case carbon:
					p1[0]=x[base+select->at(ii).cpos-1]-sum[0];
					p1[1]=y[base+select->at(ii).cpos-1]-sum[1];
					p1[2]=z[base+select->at(ii).cpos-1]-sum[2];
					e+=effect(u,m,ori,p1); 
					break;
				}

				e=e*10;
				ring_effect->at(ii).x[index->at(j).x1-1]+=e;
			}
		}
	}

	for(ii=0;ii<(int)select->size();ii++)
	{
		for(jj=0;jj<5;jj++)
		{
			ring_effect->at(ii).x[jj]/=nframe;
		}
	}
	return;
}

void CTraj::getring(vector<struct ring_group> *index, vector<struct proton>* select, vector<struct double_five> *ring_effect)
{	
	int i,j,ii,jj,m,k;
	int base;
	int t[6];
	double p1[3],t1[3],t2[3],t3[3];
	double u[6][3];
	double sum[3];
	double ori[3];
	double e;

	ring_group* index_arr = index->data();
	int index_size = index->size();
	proton* select_arr = select->data();
	int select_size = select->size();
	ring_effect->resize(select_size);
	double_five* effect_arr = ring_effect->data();
	int effect_size = ring_effect->size();
	double* x_arr = this->x.data();
	int x_size = this->x.size();
	double* y_arr = this->y.data();
	int y_size = this->y.size();
	double* z_arr = this->z.data();
	int z_size = this->z.size();

	int nframe = this->nframe;
	int natom = this->natom;

#pragma acc data \
	copyin(index_arr[:index_size], select_arr[:select_size], \
		x_arr[:x_size], y_arr[:y_size], z_arr[:z_size]) \
	copyout(effect_arr[:effect_size])
{

#pragma acc parallel loop collapse(2)
	for(i=0; i<select_size; i++)
		for(j=0; j<5; j++)
			effect_arr[i].x[j]=0.0;

	for(i=0;i<nframe;i++)
	{
		base=i*natom;  

#pragma acc parallel loop gang \
	private(m,t[:6],u[:6][:3],sum[:3],ori[:3],t1[:3],t2[:3],t3[:3])
		for(j=0; j<index_size; j++)
		{
			if(index_arr[j].x1 == 1 || index_arr[j].x1 == 2 || index_arr[j].x1 == 5){
				m=6;
			} else {
				m=5;
			}

			t[0]=index_arr[j].x2;
			t[1]=index_arr[j].x3;
			t[2]=index_arr[j].x4;
			t[3]=index_arr[j].x5;
			t[4]=index_arr[j].x6;
			t[5]=index_arr[j].x7;

			u[0][0]=x_arr[t[0]+base-1]; u[0][1]=y_arr[t[0]+base-1]; u[0][2]=z_arr[t[0]+base-1];
			u[1][0]=x_arr[t[1]+base-1]; u[1][1]=y_arr[t[1]+base-1]; u[1][2]=z_arr[t[1]+base-1];
			u[2][0]=x_arr[t[2]+base-1]; u[2][1]=y_arr[t[2]+base-1]; u[2][2]=z_arr[t[2]+base-1];
			u[3][0]=x_arr[t[3]+base-1]; u[3][1]=y_arr[t[3]+base-1]; u[3][2]=z_arr[t[3]+base-1];
			u[4][0]=x_arr[t[4]+base-1]; u[4][1]=y_arr[t[4]+base-1]; u[4][2]=z_arr[t[4]+base-1];
			if(m >= 6) {
				u[5][0]=x_arr[t[5]+base-1]; u[5][1]=y_arr[t[5]+base-1]; u[5][2]=z_arr[t[5]+base-1];
			} else {
				u[5][0]=0; u[5][1]=0; u[5][2]=0;
			}

			sum[0] = (u[0][0] + u[1][0] + u[2][0] + u[3][0] + u[4][0] + u[5][0]) / m;
			sum[1] = (u[0][1] + u[1][1] + u[2][1] + u[3][1] + u[4][1] + u[5][1]) / m;
			sum[2] = (u[0][2] + u[1][2] + u[2][2] + u[3][2] + u[4][2] + u[5][2]) / m;

			u[0][0] -= sum[0]; u[0][1] -= sum[1]; u[0][2] -= sum[2];
			u[1][0] -= sum[0]; u[1][1] -= sum[1]; u[1][2] -= sum[2];
			u[2][0] -= sum[0]; u[2][1] -= sum[1]; u[2][2] -= sum[2];
			u[3][0] -= sum[0]; u[3][1] -= sum[1]; u[3][2] -= sum[2];
			u[4][0] -= sum[0]; u[4][1] -= sum[1]; u[4][2] -= sum[2];
			u[5][0] -= sum[0]; u[5][1] -= sum[1]; u[5][2] -= sum[2];

			ring(u,m,ori);

			t1[0] = u[0][0] - u[1][0];
			t1[1] = u[0][1] - u[1][1];
			t1[2] = u[0][2] - u[1][2];
			t2[0] = u[2][0] - u[1][0];
			t2[1] = u[2][1] - u[1][1];
			t2[2] = u[2][2] - u[1][2];

			cross(t3,t1,t2);
			if(dot(t3,ori)<0)
			{
				ori[0] = -ori[0];
				ori[1] = -ori[1];
				ori[2] = -ori[2];
			}

#pragma acc loop vector private(k,e,p1[:3])
			for(ii=0; ii<select_size; ii++)
			{
				e=0;
#pragma acc loop seq
				for(k=0; k<select_arr[ii].nh; k++)
				{
					if(select_arr[ii].hpos[k] >= 0) {
						p1[0]=x_arr[base+select_arr[ii].hpos[k]-1]-sum[0];
						p1[1]=y_arr[base+select_arr[ii].hpos[k]-1]-sum[1];
						p1[2]=z_arr[base+select_arr[ii].hpos[k]-1]-sum[2];
					}
					e+=effect(u,m,ori,p1); 
				}
				e=e*10*3/select_arr[ii].nh;
#pragma acc atomic update
				effect_arr[ii].x[index_arr[j].x1-1]+=e;
			}
		}
	}

#pragma acc parallel loop collapse(2)
	for(ii=0; ii<select_size; ii++)
	{
		for(jj=0;jj<5;jj++)
		{
			effect_arr[ii].x[jj]/=nframe;
		}
	}

} // end data

	return;
}



void CTraj::getring(vector<struct ring_group> *index, vector<struct proton>* select, vector< vector<struct double_five> > *ring_effect)
{	
	int i,j,ii,jj,m,k;
	int base;
	int t[6];
	double p1[3],t1[3],t2[3],t3[3];
	double u[6][3];
	double sum[3];
	double ori[3];
	double e;
	struct double_five temp;
	
	for(i=0;i<5;i++)
		temp.x[i]=0;
	ring_effect->resize(select->size());
	for(ii=0;ii<(int)select->size();ii++)
	{
		for(jj=0;jj<nframe;jj++)
		{
			ring_effect->at(ii).push_back(temp);
		}
	}


	for(i=0;i<nframe;i++)
	{
		base=i*natom;  
		for(j=0;j<(int)index->size();j++)
		{
			switch(index->at(j).x1)
			{
				case 1:
                case 2:
                case 5:
					m=6;
					break;
				case 4:
				case 3:
					m=5;
					break;
			}
			t[0]=index->at(j).x2;
			t[1]=index->at(j).x3;
			t[2]=index->at(j).x4;
			t[3]=index->at(j).x5;
			t[4]=index->at(j).x6;
			t[5]=index->at(j).x7;

           
            for(ii=0;ii<m;ii++)
			{
				u[ii][0]=x[t[ii]+base-1];
                u[ii][1]=y[t[ii]+base-1];
                u[ii][2]=z[t[ii]+base-1];
            }
           
            for(jj=0;jj<3;jj++)
				sum[jj]=0; 
			for(ii=0;ii<m;ii++)
            {
				for(jj=0;jj<3;jj++)
				{
					sum[jj]+=u[ii][jj];
				}
			}
			for(jj=0;jj<3;jj++)
				sum[jj]/=m; 
			for(ii=0;ii<m;ii++)
			{
				for(jj=0;jj<3;jj++)
					u[ii][jj]-=sum[jj];
			}

			ring(u,m,ori);

            for(jj=0;jj<3;jj++)
            {
                   t1[jj]=u[0][jj]-u[1][jj];
                   t2[jj]=u[2][jj]-u[1][jj];
            }
            cross(t3,t1,t2);
            if(dot(t3,ori)<0)
            {
				for(jj=0;jj<3;jj++)
					ori[jj]=-ori[jj];
			}

			for(ii=0;ii<(int)select->size();ii++)
			{
				e=0;	
				for(k=0;k<(int)select->at(ii).nh;k++)
				{
					p1[0]=x[base+select->at(ii).hpos[k]-1]-sum[0];
					p1[1]=y[base+select->at(ii).hpos[k]-1]-sum[1];
					p1[2]=z[base+select->at(ii).hpos[k]-1]-sum[2];
					e+=effect(u,m,ori,p1); 
				}
				e=e*10*3/select->at(ii).nh;
				ring_effect->at(ii).at(i).x[index->at(j).x1-1]+=e;
			}
		}
	}
	return;
}


void CTraj::getring_bb(vector<struct ring_group> *index, vector<struct bb_group>* select, vector<struct double_five> *ring_effect, enum bb_carbon c)
{	
	int i,j,ii,jj,m;
	int base;
	int t[6];
	double p1[3],t1[3],t2[3],t3[3];
	double u[6][3];
	double sum[3];
	double ori[3];
	double e;
	struct double_five temp;
	
	for(i=0;i<5;i++)
		temp.x[i]=0;
	for(i=0;i<(int)select->size();i++)
		ring_effect->push_back(temp);


	for(i=0;i<nframe;i++)
	{
		base=i*natom;  
		for(j=0;j<(int)index->size();j++)
		{
			switch(index->at(j).x1)
			{
				case 1:
                case 2:
                case 5:
					m=6;
					break;
				case 4:
				case 3:
					m=5;
					break;
			}
			t[0]=index->at(j).x2;
			t[1]=index->at(j).x3;
			t[2]=index->at(j).x4;
			t[3]=index->at(j).x5;
			t[4]=index->at(j).x6;
			t[5]=index->at(j).x7;

           
            for(ii=0;ii<m;ii++)
			{
				u[ii][0]=x[t[ii]+base-1];
                u[ii][1]=y[t[ii]+base-1];
                u[ii][2]=z[t[ii]+base-1];
            }
           
            for(jj=0;jj<3;jj++)
				sum[jj]=0; 
			for(ii=0;ii<m;ii++)
            {
				for(jj=0;jj<3;jj++)
				{
					sum[jj]+=u[ii][jj];
				}
			}
			for(jj=0;jj<3;jj++)
				sum[jj]/=m; 
			for(ii=0;ii<m;ii++)
			{
				for(jj=0;jj<3;jj++)
					u[ii][jj]-=sum[jj];
			}

			ring(u,m,ori);

            for(jj=0;jj<3;jj++)
            {
                   t1[jj]=u[0][jj]-u[1][jj];
                   t2[jj]=u[2][jj]-u[1][jj];
            }
            cross(t3,t1,t2);
            if(dot(t3,ori)<0)
            {
				for(jj=0;jj<3;jj++)
					ori[jj]=-ori[jj];
			}

			for(ii=0;ii<(int)select->size();ii++)
			{
				e=0;

				if((select->at(ii).capos>=1 && c==bb_ca) || (select->at(ii).cbpos>=1 && c==bb_cb)||(select->at(ii).copos>=1 && c==bb_co))
				switch (c)
				{
				case bb_ca:
					p1[0]=x[base+select->at(ii).capos-1]-sum[0];
					p1[1]=y[base+select->at(ii).capos-1]-sum[1];
					p1[2]=z[base+select->at(ii).capos-1]-sum[2];
					break;
				case bb_cb:
					p1[0]=x[base+select->at(ii).cbpos-1]-sum[0];
					p1[1]=y[base+select->at(ii).cbpos-1]-sum[1];
					p1[2]=z[base+select->at(ii).cbpos-1]-sum[2];
					break;
				case bb_co:
					p1[0]=x[base+select->at(ii).copos-1]-sum[0];
					p1[1]=y[base+select->at(ii).copos-1]-sum[1];
					p1[2]=z[base+select->at(ii).copos-1]-sum[2];
					break;
				}
				e+=effect(u,m,ori,p1); 
				e=e*10;
				ring_effect->at(ii).x[index->at(j).x1-1]+=e;
			}
		}
	}

	for(ii=0;ii<(int)select->size();ii++)
	{
		for(jj=0;jj<5;jj++)
		{
			ring_effect->at(ii).x[jj]/=nframe;
		}
	}
	return;
}



void CTraj::getani(vector<struct ani_group> *index, vector<struct methyl_group>* select, vector<struct double_four> *ani_effect, enum methyl c)
{
	int i,j,ii,jj,k;
	int i1,i2,i3;
	int base;
	double center[3];
	double v1[3];
	double v2[3];
	double ori[3];
	double cosa;
	double length;
	double e;


	struct double_four temp;
	
	for(i=0;i<4;i++)
		temp.x[i]=0;
	for(i=0;i<(int)select->size();i++)
		ani_effect->push_back(temp);
	
	for(i=0;i<nframe;i++)
	{
		base=i*natom;
		for(j=0;j<(int)index->size();j++)
		{
			i1=index->at(j).pos[0]+base-1;
			i2=index->at(j).pos[1]+base-1;
			i3=index->at(j).pos[2]+base-1;
			center[0]=(x[i1]+x[i2]+x[i3])/3;
			center[1]=(y[i1]+y[i2]+y[i3])/3;
			center[2]=(z[i1]+z[i2]+z[i3])/3;

			v1[0]=x[i1]-x[i2];
			v1[1]=y[i1]-y[i2];
			v1[2]=z[i1]-z[i2];

			v2[0]=x[i3]-x[i2];
			v2[1]=y[i3]-y[i2];
			v2[2]=z[i3]-z[i2];

			cross(ori,v1,v2);

			for(jj=0;jj<(int)select->size();jj++)
			{
				e=0;				
				switch(c)
				{
				case hydrogen:
					for(k=0;k<3;k++)
					{
						i1=base+select->at(jj).cpos-1+k+1;
						v1[0]=center[0]-x[i1];
						v1[1]=center[1]-y[i1];
						v1[2]=center[2]-z[i1];
						length=v1[0]*v1[0]+v1[1]*v1[1]+v1[2]*v1[2];
						cosa=dot(v1,ori);
						cosa/=sqrt(ori[0]*ori[0]+ori[1]*ori[1]+ori[2]*ori[2]);
						cosa/=sqrt(length);					 
						e+=(1-3*cosa*cosa)/(length*sqrt(length));
					}
					ani_effect->at(jj).x[index->at(j).type-1]+=e/3.0*1000;
					break;

				case carbon:
					i1=base+select->at(jj).cpos-1;
					v1[0]=center[0]-x[i1];
					v1[1]=center[1]-y[i1];
					v1[2]=center[2]-z[i1];
					length=v1[0]*v1[0]+v1[1]*v1[1]+v1[2]*v1[2];
					cosa=dot(v1,ori);
					cosa/=sqrt(ori[0]*ori[0]+ori[1]*ori[1]+ori[2]*ori[2]);
					cosa/=sqrt(length);					 
					e+=(1-3*cosa*cosa)/(length*sqrt(length));
					ani_effect->at(jj).x[index->at(j).type-1]+=e*1000;
					break;
				}
			}
		}
	}

	for(ii=0;ii<(int)select->size();ii++)
	{
		for(jj=0;jj<4;jj++)
		{
			ani_effect->at(ii).x[jj]/=nframe;
		}
	}
	return;
}


void CTraj::getani(vector<struct ani_group> *index, vector<struct proton>* select, vector<struct double_four> *ani_effect)
{
	int i,j,ii,jj,k;
	int i1,i2,i3,i4;
	int base;
	double center[3];
	double v1[3];
	double v2[3];
	double v3[3];
	double ori[3];
	double cosa;
	double length;
	double e;

	ani_group* index_arr = index->data();
	int index_size = index->size();
	proton* select_arr = select->data();
	int select_size = select->size();
	ani_effect->resize(select_size);
	double_four* effect_arr = ani_effect->data();
	int effect_size = ani_effect->size();
	double* x_arr = this->x.data();
	int x_size = this->x.size();
	double* y_arr = this->y.data();
	int y_size = this->y.size();
	double* z_arr = this->z.data();
	int z_size = this->z.size();

	int nframe = this->nframe;
	int natom = this->natom;

#pragma acc data \
	copyin(index_arr[:index_size], select_arr[:select_size], \
		x_arr[:x_size], y_arr[:y_size], z_arr[:z_size]) \
	copyout(effect_arr[:effect_size])
{

#pragma acc parallel loop collapse(2)
	for(i=0;i<select_size;i++)
		for(j=0;j<4;j++)
			effect_arr[i].x[j]=0.0;
	
	for(i=0;i<nframe;i++)
	{
		base=i*natom;
#pragma acc parallel loop gang private(i1,i2,i3,center[:3], \
	v1[:3],v2[:3],ori[:3])
		for(j=0; j<index_size; j++)
		{
			i1=index_arr[j].pos[0]+base-1;
			i2=index_arr[j].pos[1]+base-1;
			i3=index_arr[j].pos[2]+base-1;
			center[0]=(x_arr[i1]+x_arr[i2]+x_arr[i3])/3;
			center[1]=(y_arr[i1]+y_arr[i2]+y_arr[i3])/3;
			center[2]=(z_arr[i1]+z_arr[i2]+z_arr[i3])/3;

			v1[0]=x_arr[i1]-x_arr[i2];
			v1[1]=y_arr[i1]-y_arr[i2];
			v1[2]=z_arr[i1]-z_arr[i2];

			v2[0]=x_arr[i3]-x_arr[i2];
			v2[1]=y_arr[i3]-y_arr[i2];
			v2[2]=z_arr[i3]-z_arr[i2];

			cross(ori,v1,v2);

#pragma acc loop vector private(k,e,i4,v3[:3],length,cosa)
			for(jj=0; jj<select_size; jj++)
			{
				e=0;		
#pragma acc loop seq		
				for(k=0; k<select_arr[jj].nh; k++)
				{
					i4=base+select_arr[jj].hpos[k]-1;
					v3[0]=center[0]-x_arr[i4];
					v3[1]=center[1]-y_arr[i4];
					v3[2]=center[2]-z_arr[i4];
					length=v3[0]*v3[0]+v3[1]*v3[1]+v3[2]*v3[2];
					cosa=dot(v3,ori);
					cosa/=sqrt(ori[0]*ori[0]+ori[1]*ori[1]+ori[2]*ori[2]);
					cosa/=sqrt(length);		 
					e+=(1-3*cosa*cosa)/(length*sqrt(length));
				}
#pragma acc atomic update
				effect_arr[jj].x[index_arr[j].type-1]+=e/select_arr[jj].nh*1000;
			}
		}
	}

#pragma acc parallel loop collapse(2)
	for(ii=0; ii<select_size; ii++)
	{
		for(jj=0; jj<4; jj++)
		{
			effect_arr[ii].x[jj]/=nframe;
		}
	}

} // end data

	return;
}


void CTraj::getani(vector<struct ani_group> *index, vector<struct proton>* select, vector< vector<struct double_four>  > *ani_effect)
{
	int i,j,ii,jj,k;
	int i1,i2,i3;
	int base;
	double center[3];
	double v1[3];
	double v2[3];
	double ori[3];
	double cosa;
	double length;
	double e;


	struct double_four temp;
	
	for(i=0;i<4;i++)
		temp.x[i]=0;
	ani_effect->resize(select->size());
	for(ii=0;ii<(int)select->size();ii++)
	{
		for(jj=0;jj<nframe;jj++)
		{
			ani_effect->at(ii).push_back(temp);
		}
	}

	
	for(i=0;i<nframe;i++)
	{
		base=i*natom;
		for(j=0;j<(int)index->size();j++)
		{
			i1=index->at(j).pos[0]+base-1;
			i2=index->at(j).pos[1]+base-1;
			i3=index->at(j).pos[2]+base-1;
			center[0]=(x[i1]+x[i2]+x[i3])/3;
			center[1]=(y[i1]+y[i2]+y[i3])/3;
			center[2]=(z[i1]+z[i2]+z[i3])/3;

			v1[0]=x[i1]-x[i2];
			v1[1]=y[i1]-y[i2];
			v1[2]=z[i1]-z[i2];

			v2[0]=x[i3]-x[i2];
			v2[1]=y[i3]-y[i2];
			v2[2]=z[i3]-z[i2];

			cross(ori,v1,v2);

			for(jj=0;jj<(int)select->size();jj++)
			{
				e=0;				
				for(k=0;k<(int)select->at(jj).nh;k++)
				{
					i1=base+select->at(jj).hpos[k]-1;
					v1[0]=center[0]-x[i1];
					v1[1]=center[1]-y[i1];
					v1[2]=center[2]-z[i1];
					length=v1[0]*v1[0]+v1[1]*v1[1]+v1[2]*v1[2];
					cosa=dot(v1,ori);
					cosa/=sqrt(ori[0]*ori[0]+ori[1]*ori[1]+ori[2]*ori[2]);
					cosa/=sqrt(length);					 
					e+=(1-3*cosa*cosa)/(length*sqrt(length));
				}
				ani_effect->at(jj).at(i).x[index->at(j).type-1]+=e/select->at(jj).nh*1000;
			}
		}
	}


	return;
}


void CTraj::getani(vector<struct ani_group> *index, vector<struct nh_group>* select, vector<struct double_four> *ani_effect)
{
	int i,j,ii,k;
	int i1,i2,i3,i4;
	int base;
	double center[3];
	double v1[3];
	double v2[3];
	double v3[3];
	double ori[3];
	double cosa;
	double length;
	double e;

	ani_group* index_arr = index->data();
	int index_size = index->size();
	nh_group* select_arr = select->data();
	int select_size = select->size();
	ani_effect->resize(select_size);
	double_four* effect_arr = ani_effect->data();
	int effect_size = ani_effect->size();
	double* x_arr = this->x.data();
	int x_size = this->x.size();
	double* y_arr = this->y.data();
	int y_size = this->y.size();
	double* z_arr = this->z.data();
	int z_size = this->z.size();

	int nframe = this->nframe;
	int natom = this->natom;

#pragma acc data \
	copyin(index_arr[:index_size], select_arr[:select_size], \
		x_arr[:x_size], y_arr[:y_size], z_arr[:z_size]) \
	copyout(effect_arr[:effect_size])
{

#pragma acc parallel loop collapse(2)
	for(i=0;i<select_size;i++)
		for(j=0;j<4;j++)
			effect_arr[i].x[j]=0.0;

	for(i=0;i<nframe;i++)
	{
		base=i*natom;
#pragma acc parallel loop gang \
	private(i1,i2,i3,center[:3],v1[:3],v2[:3],ori[:3])
		for(j=0; j<index_size; j++)
		{
			i1=index_arr[j].pos[0]+base-1;
			i2=index_arr[j].pos[1]+base-1;
			i3=index_arr[j].pos[2]+base-1;
			center[0]=(x_arr[i1]+x_arr[i2]+x_arr[i3])/3;
			center[1]=(y_arr[i1]+y_arr[i2]+y_arr[i3])/3;
			center[2]=(z_arr[i1]+z_arr[i2]+z_arr[i3])/3;

			v1[0]=x_arr[i1]-x_arr[i2];
			v1[1]=y_arr[i1]-y_arr[i2];
			v1[2]=z_arr[i1]-z_arr[i2];

			v2[0]=x_arr[i3]-x_arr[i2];
			v2[1]=y_arr[i3]-y_arr[i2];
			v2[2]=z_arr[i3]-z_arr[i2];

			cross(ori,v1,v2);

#pragma acc loop vector private(e,i4,v3[:3],length,cosa)
			for(k=0; k<select_size; k++)
			{
				if(select_arr[k].hpos>=1)
				{
					e=0;				
					i4=base+select_arr[k].hpos-1;
					v3[0]=center[0]-x_arr[i4];
					v3[1]=center[1]-y_arr[i4];
					v3[2]=center[2]-z_arr[i4];
					length=v3[0]*v3[0]+v3[1]*v3[1]+v3[2]*v3[2];
					cosa=dot(v3,ori);
					cosa/=sqrt(ori[0]*ori[0]+ori[1]*ori[1]+ori[2]*ori[2]);
					cosa/=sqrt(length);					 
					e+=(1-3*cosa*cosa)/(length*sqrt(length));
#pragma acc atomic update
					effect_arr[k].x[index_arr[j].type-1]+=e*1000;
				}
			}
		}
	}

#pragma acc parallel loop collapse(2)
	for(i=0; i<select_size; i++)
		for(j=0; j<4; j++)
			effect_arr[i].x[j]/=nframe;

} // end data

	return;
}


void CTraj::do_rmsf(void)
{
	int i,j;
	int jump;
	double meanx,meany,meanz;
	double rms;
	double t,tt;

	rmsf.clear();
	for(i=0;i<natom;i++)
	{
		meanx=meany=meanz=0.0;
		for(j=0;j<nframe;j++)
		{
			jump=j*natom+i;
			meanx+=x.at(jump);
			meany+=y.at(jump);
			meanz+=z.at(jump);
		}
		meanx/=nframe;
		meany/=nframe;
		meanz/=nframe;

		rms=0.0;
		for(j=0;j<nframe;j++)
		{
			jump=j*nframe+i;
			t=x.at(jump)-meanx;tt=t*t;
			t=y.at(jump)-meany;tt+=t*t;
			t=z.at(jump)-meanz;tt+=t*t;
			rms+=tt;
		}
		rms=sqrt(rms/nframe);
		rmsf.push_back(rms);
	}

	return;
}



void CTraj::getani(vector<struct ani_group> *index, vector<struct nh_group>* select, vector< vector<struct double_four>  > *ani_effect)
{
	int i,j,ii,jj;
	int i1,i2,i3;
	int base;
	double center[3];
	double v1[3];
	double v2[3];
	double ori[3];
	double cosa;
	double length;
	double e;


	struct double_four temp;
	
	for(i=0;i<4;i++)
		temp.x[i]=0;
	ani_effect->resize(select->size());
	for(ii=0;ii<(int)select->size();ii++)
	{
		for(jj=0;jj<nframe;jj++)
		{
			ani_effect->at(ii).push_back(temp);
		}
	}
	
	for(i=0;i<nframe;i++)
	{
		base=i*natom;
		for(j=0;j<(int)index->size();j++)
		{
			i1=index->at(j).pos[0]+base-1;
			i2=index->at(j).pos[1]+base-1;
			i3=index->at(j).pos[2]+base-1;
			center[0]=(x[i1]+x[i2]+x[i3])/3;
			center[1]=(y[i1]+y[i2]+y[i3])/3;
			center[2]=(z[i1]+z[i2]+z[i3])/3;

			v1[0]=x[i1]-x[i2];
			v1[1]=y[i1]-y[i2];
			v1[2]=z[i1]-z[i2];

			v2[0]=x[i3]-x[i2];
			v2[1]=y[i3]-y[i2];
			v2[2]=z[i3]-z[i2];

			cross(ori,v1,v2);

			for(jj=0;jj<(int)select->size();jj++)
			{
				if(select->at(jj).hpos>=1)
				{
					e=0;				
					i1=base+select->at(jj).hpos-1;
					v1[0]=center[0]-x[i1];
					v1[1]=center[1]-y[i1];
					v1[2]=center[2]-z[i1];
					length=v1[0]*v1[0]+v1[1]*v1[1]+v1[2]*v1[2];
					cosa=dot(v1,ori);
					cosa/=sqrt(ori[0]*ori[0]+ori[1]*ori[1]+ori[2]*ori[2]);
					cosa/=sqrt(length);					 
					e+=(1-3*cosa*cosa)/(length*sqrt(length));
					ani_effect->at(jj).at(i).x[index->at(j).type-1]+=e*1000;
				}
			}
		}
	}

	return;
}

double CTraj::noedistance_frame(vector<int> *att1, vector<int> *att2,int j)
{

	double x0,y0,z0;
	double r2,r6,sum,sumsum;
	int i1,j1;
	int n1,n2;
	int jump;

	sumsum=0;
	for(i1=0;i1<(int)att1->size();i1++)
	for(j1=0;j1<(int)att2->size();j1++)
	{
		n1=att1->at(i1)-1;
		n2=att2->at(j1)-1;
		
		jump=j*natom;
		x0=x.at(jump+n1)-x.at(jump+n2);
		y0=y.at(jump+n1)-y.at(jump+n2);
		z0=z.at(jump+n1)-z.at(jump+n2);
		r2=x0*x0+y0*y0+z0*z0;
		r6=r2*r2*r2;
		sum=1.0/r6;
		sumsum+=sum;
	}
	sumsum/=i1;
	sumsum/=j1;
	r2=pow(sumsum,-1/6.0);
	return r2;
}

double CTraj::noedistance(vector<int> *att1, vector<int> *att2)
{
	double x0,y0,z0;
	double r2,r6,sum,sumsum;
	int i1,j1;
	int n1,n2;
	int j;
	int jump;

	sumsum=0;
	for(i1=0;i1<(int)att1->size();i1++)
	for(j1=0;j1<(int)att2->size();j1++)
	{
		n1=att1->at(i1)-1;
		n2=att2->at(j1)-1;

		sum=0.0;
		for(j=0;j<nframe;j++)
		{
			jump=j*natom;
			x0=x.at(jump+n1)-x.at(jump+n2);
			y0=y.at(jump+n1)-y.at(jump+n2);
			z0=z.at(jump+n1)-z.at(jump+n2);
			r2=x0*x0+y0*y0+z0*z0;
			r6=r2*r2*r2;
			sum+=1.0/r6;
		}
		sum/=nframe;
		sumsum+=sum;
	}
	sumsum/=i1;
	sumsum/=j1;
	r2=pow(sumsum,-1/6.0);
	return r2;
}


void CTraj::evaluatenmrcons_frame(vector<struct noeline> *nmrcons, double cutoff)
{
	int ii,i,j;
	int pos1,pos2;
	int n1,n2;
	vector<int> att1,att2;
	double d;
	ofstream fout("noe_frame.dat");


	for(ii=0;ii<nframe;ii++)
	{
		for(i=0;i<(int)nmrcons->size();i++)
		{	

			if(fabs((float)(nmrcons->at(i).resid1-nmrcons->at(i).resid2))<=2)
				continue;

			nmrcons->at(i).obs.clear();
			nmrcons->at(i).pos1.clear();
			nmrcons->at(i).pos2.clear();
			for(n1=0;n1<(int)nmrcons->at(i).index1.atoms.size();n1++)
			for(n2=0;n2<(int)nmrcons->at(i).index2.atoms.size();n2++)
			{
				att1=nmrcons->at(i).index1.atoms.at(n1);
				att2=nmrcons->at(i).index2.atoms.at(n2);
				nmrcons->at(i).obs.push_back(noedistance_frame(&att1,&att2,ii));
				nmrcons->at(i).pos1.push_back(att1.at(0));
				nmrcons->at(i).pos2.push_back(att2.at(0));
			}

			d=100000.0;
			pos1=pos2=0;
			for(j=0;j<nmrcons->at(i).obs.size();j++)
			{
				if(nmrcons->at(i).obs.at(j)<d)
				{
					d=nmrcons->at(i).obs.at(j);
					pos1=nmrcons->at(i).pos1.at(j);
					pos2=nmrcons->at(i).pos2.at(j);
				}
			}
			nmrcons->at(i).bvio=0;
			nmrcons->at(i).d=d;
			
			if(nmrcons->at(i).a+cutoff<d)
				fout<<d<<" ";
			else
				fout<<d<<" ";
		}
		fout<<endl;

	}
	fout.close();

	ofstream fout2("noe_frame_head.dat");
	for(i=0;i<(int)nmrcons->size();i++)
	{
		if(fabs((float)(nmrcons->at(i).resid1-nmrcons->at(i).resid2))<=2)
			continue;

		fout2<<nmrcons->at(i).resid1<<" ";
		fout2<<nmrcons->at(i).resname1<<" ";
		fout2<<nmrcons->at(i).atomname1<<" ";
		fout2<<nmrcons->at(i).resid2<<" ";
		fout2<<nmrcons->at(i).resname2<<" ";
		fout2<<nmrcons->at(i).atomname2<<" ";
		fout2<<nmrcons->at(i).b<<" ";
		fout2<<nmrcons->at(i).c<<" ";
		fout2<<nmrcons->at(i).a<<endl;
	}
	fout2.close();
	return;
}

void CTraj::evulatenmrcons(vector<struct noeline> *nmrcons, double cutoff)
{
	int i,j;
	int pos1,pos2;
	int n1,n2;
	vector<int> att1,att2;
	double d;
	ofstream fout("violation.dat");
	ofstream fout2("fullfilled.dat");
	ofstream fout3("grouped.dat");
	ofstream fchimera("for_chimera.dat");
	ofstream fchimera2("for_chimera2.dat");


	
	for(i=0;i<(int)nmrcons->size();i++)
	{	
		for(n1=0;n1<(int)nmrcons->at(i).index1.atoms.size();n1++)
		for(n2=0;n2<(int)nmrcons->at(i).index2.atoms.size();n2++)
		{
			att1=nmrcons->at(i).index1.atoms.at(n1);
			att2=nmrcons->at(i).index2.atoms.at(n2);
			nmrcons->at(i).obs.push_back(noedistance(&att1,&att2));
			nmrcons->at(i).pos1.push_back(att1.at(0));
			nmrcons->at(i).pos2.push_back(att2.at(0));
		}
	}

	for(i=0;i<(int)nmrcons->size();i++)
	{
		d=100000.0;
		pos1=pos2=0;
		for(j=0;j<nmrcons->at(i).obs.size();j++)
		{
			if(nmrcons->at(i).obs.at(j)<d)
			{
				d=nmrcons->at(i).obs.at(j);
				pos1=nmrcons->at(i).pos1.at(j);
				pos2=nmrcons->at(i).pos2.at(j);
			}
		}
		nmrcons->at(i).bvio=0;
		nmrcons->at(i).d=d;

		if(nmrcons->at(i).a+cutoff<d)
		{
			nmrcons->at(i).bvio=1;
			fout<<nmrcons->at(i).group<<" ";
			fout<<i<<" "<<nmrcons->at(i).resid1<<" "<<nmrcons->at(i).resname1<<" "<<nmrcons->at(i).atomname1<<" ";
			fout<<nmrcons->at(i).resid2<<" "<<nmrcons->at(i).resname2<<" "<<nmrcons->at(i).atomname2<<" ";
			fout<<d<<" "<<nmrcons->at(i).c<<" "<<nmrcons->at(i).a<<endl;
			if(abs(nmrcons->at(i).resid1-nmrcons->at(i).resid2)>2 && d-nmrcons->at(i).a>cutoff)
			{
				fchimera<<"distance @/serialNumber="<<pos1<<" @/serialNumber="<<pos2<<endl;
				fchimera<<"display :"<<nmrcons->at(i).resid1<<endl;
				fchimera<<"display :"<<nmrcons->at(i).resid2<<endl;
				fchimera2<<"distance :"<<nmrcons->at(i).resid1<<"@CA :"<<nmrcons->at(i).resid2<<"@CA"<<endl;
			}
		}
		else
		{		
			fout2<<nmrcons->at(i).group<<" ";
			fout2<<i<<" "<<nmrcons->at(i).resid1<<" "<<nmrcons->at(i).resname1<<" "<<nmrcons->at(i).atomname1<<" ";
			fout2<<nmrcons->at(i).resid2<<" "<<nmrcons->at(i).resname2<<" "<<nmrcons->at(i).atomname2<<" ";
			fout2<<d<<" "<<nmrcons->at(i).c<<" "<<nmrcons->at(i).a<<endl;
		}
	}

	int ngroup=nmrcons->at(i-1).group;
	int i1=0;
	int i2=0;


	for(i=0;i<=ngroup;i++)
	{
		for(;i1<nmrcons->size() && nmrcons->at(i1).group<=i;i1++)
		{
			if(nmrcons->at(i1).a+cutoff<nmrcons->at(i1).d)
			{
				fout3<<nmrcons->at(i1).group<<" ";
				fout3<<i1<<" "<<nmrcons->at(i1).resid1<<" "<<nmrcons->at(i1).resname1<<" "<<nmrcons->at(i1).atomname1<<" ";
				fout3<<nmrcons->at(i1).resid2<<" "<<nmrcons->at(i1).resname2<<" "<<nmrcons->at(i1).atomname2<<" ";
				fout3<<nmrcons->at(i1).d<<" "<<nmrcons->at(i1).c<<" "<<nmrcons->at(i1).a<<" VIOLATED "<<endl;
			}
		}
		

		for(;i2<nmrcons->size() && nmrcons->at(i2).group<=i;i2++)
		{
			if(nmrcons->at(i2).a+cutoff>=nmrcons->at(i2).d)
			{
				fout3<<nmrcons->at(i2).group<<" ";
				fout3<<i2<<" "<<nmrcons->at(i2).resid1<<" "<<nmrcons->at(i2).resname1<<" "<<nmrcons->at(i2).atomname1<<" ";
				fout3<<nmrcons->at(i2).resid2<<" "<<nmrcons->at(i2).resname2<<" "<<nmrcons->at(i2).atomname2<<" ";
				fout3<<nmrcons->at(i2).d<<" "<<nmrcons->at(i2).c<<" "<<nmrcons->at(i2).a<<endl;
			}
		}
		fout3<<endl;
	}
	
	fout.close();
	fout2.close();
	fout3.close();
	fchimera.close();
	fchimera2.close();


	return;
}


void CTraj::rmsd_matrix(vector< vector<double> > *rmsd,vector<int> *ca, int skip)
{
	float *x1,*y1,*z1,*x2,*y2,*z2;
	int nca,jumpi,jumpj;
	int i,j,k;
	vector< double> t;
	class CRmsd rmsdf;

	nca=ca->size();
	
	x1=new float[nframe*nca];
	x2=new float[nframe*nca];
	y1=new float[nframe*nca];
	y2=new float[nframe*nca];
	z1=new float[nframe*nca];
	z2=new float[nframe*nca];

	for(i=0;i<nframe;i++)
	{
		if((i+1)%skip==0)
		{
			
			t.clear();
			jumpi=i*natom-1;
			for(j=0;j<i;j++)
				t.push_back(rmsd->at(j).at(i));
			t.push_back(0.0);
			for(j=i+1;j<nframe;j++)
			{
				if((j+1)%skip==0)
				{
					jumpj=j*natom-1;
					for(k=0;k<nca;k++)
					{
						x1[k]=x[jumpi+ca->at(k)];
						y1[k]=y[jumpi+ca->at(k)];
						z1[k]=z[jumpi+ca->at(k)];

						x2[k]=x[jumpj+ca->at(k)];
						y2[k]=y[jumpj+ca->at(k)];
						z2[k]=z[jumpj+ca->at(k)];
					}

					t.push_back(rmsdf.calculate_rotation_rmsd(x1,y1,z1,x2,y2,z2,nca));
				}
			}
			rmsd->push_back(t);
		}
	}
	return;
}



void CTraj::getvector(vector<struct index_three> nh,vector<double> *xx,vector<double> *yy,vector<double> *zz)
{
	int i,m,j;
	double r;
	double x1,y1,z1;
	for(i=0;i<nframe;i++)
	{	
		m=i*natom-1;		
		for(j=0;j<nh.size();j++)
		{
			x1=x.at(m+nh.at(j).x3)-x.at(m+nh.at(j).x2);
			y1=y.at(m+nh.at(j).x3)-y.at(m+nh.at(j).x2);
			z1=z.at(m+nh.at(j).x3)-z.at(m+nh.at(j).x2);
			r=sqrt(x1*x1+y1*y1+z1*z1);
			if(r>0)
			{
				x1/=r;y1/=r;z1/=r;
			}	
			else
			{
				x1=1.0;y1=z1=0.0;
			}	
			xx->push_back(x1);
			yy->push_back(y1);
			zz->push_back(z1);		
		}
	}
}


void CTraj:: getcoor(int ipos,int iframe,double *xx,double *yy,double *zz)
{
	ipos+=iframe*natom-1;
	*xx=x.at(ipos);
	*yy=y.at(ipos);
	*zz=z.at(ipos);
}


void CTraj::getcoor(vector<int> pos,int iframe,vector<double> *xx,vector<double> *yy,vector<double> *zz)
{
	int j;
	int adj;
	unsigned int i;

	adj=iframe*natom-1;
	for(i=0;i<pos.size();i++)
	{
		j=pos.at(i)+adj;
		xx->push_back(x.at(j));
		yy->push_back(y.at(j));
		zz->push_back(z.at(j));
	}
	return;
}


void CTraj::getcoor(vector<int> pos,vector<float> *xx,vector<float> *yy,vector<float> *zz)
{
	int j;
	int adj;
	unsigned int i,iframe;

	for(iframe=0;iframe<nframe;iframe++)
	{
		adj=iframe*natom-1;
		for(i=0;i<pos.size();i++)
		{
			j=pos.at(i)+adj;
			xx->push_back(x.at(j));
			yy->push_back(y.at(j));
			zz->push_back(z.at(j));
		}
	}
	return;
}

void CTraj::getcoor(vector<int> pos,int iframe,vector<float> *xx,vector<float> *yy,vector<float> *zz)
{
	int j;
	int adj;
	unsigned int i;

	adj=iframe*natom-1;
	for(i=0;i<pos.size();i++)
	{
		j=pos.at(i)+adj;
		xx->push_back(x.at(j));
		yy->push_back(y.at(j));
		zz->push_back(z.at(j));
	}
	return;
}

void CTraj::get_contact(float rc,float shift, vector<int> pos, vector<int> used, vector<float> * result)
{
	int i,j;
	int ii,jj;
	float contact;
	float x0,y0,z0;
	float rr;

	int *used_arr = used.data();
	int used_size = used.size();
	double *x_arr = x.data();
	int x_size = x.size();
	double *y_arr = y.data();
	int y_size = y.size();
	double *z_arr = z.data();
	int z_size = z.size();

#pragma acc data copyin(used_arr[:used_size], \
 x_arr[:x_size], y_arr[:y_size], z_arr[:z_size])
	for(i=0;i<(int)pos.size();i++)
	{
		contact=0.0;
		ii=pos.at(i);
		if(ii<1)
		{
			result->push_back(-1.0);
			continue;
		}
		ii--;
		x0=x.at(ii);
		y0=y.at(ii);
		z0=z.at(ii);
#pragma acc parallel loop \
 private(jj, rr) \
 reduction(+:contact)
		for(j=0;j<used_size;j++)
		{
			jj=used_arr[j]-1;
			if(jj<0)
				continue;
			rr=(x_arr[jj]-x0)*(x_arr[jj]-x0)+(y_arr[jj]-y0)*(y_arr[jj]-y0)+(z_arr[jj]-z0)*(z_arr[jj]-z0);
			rr=sqrt(rr)-shift;
			contact+=exp(-rr/rc);				
		}
		result->push_back(contact);
	}

	return;
}


void CTraj::get_contact(vector<int> pos, vector<int> used, vector<float> * result)
{
	int i,j;
	int ii,jj;
	float contact;
	float x0,y0,z0;
	float rr;

	for(i=0;i<(int)pos.size();i++)
	{
		contact=0.0;
		ii=pos.at(i);
		if(ii<0)
		{
			result->push_back(-1.0);
			continue;
		}
		ii--;
		x0=x.at(ii);
		y0=y.at(ii);
		z0=z.at(ii);
		for(j=0;j<(int)used.size();j++)
		{
			jj=used.at(j);
			if(jj<0)
				continue;
			jj--;
			rr=(x.at(jj)-x0)*(x.at(jj)-x0)+(y.at(jj)-y0)*(y.at(jj)-y0)+(z.at(jj)-z0)*(z.at(jj)-z0);
			rr=sqrt(rr);
			contact+=exp(-rr/3.0);				
		}
		result->push_back(contact);
	}

	return;
}

void CTraj::get_contacts(vector<struct bb_group> bb, vector<struct index_two> index, vector<int> c2, vector<float> *results)
{
	int i,j,p;
	int ii,jj;
	float contact;
	float x0,y0,z0;
	float rr;

	bb_group* bb_arr = bb.data();
	int bb_size = bb.size();
	index_two* index_arr = index.data();
	int index_size = index.size();
	int* c2_arr = c2.data();
	int c2_size = c2.size();
	results->resize(index_size*3);
	float* results_arr = results->data();
	int results_size = results->size();
	double* x_arr = this->x.data();
	int x_size = this->x.size();
	double* y_arr = this->y.data();
	int y_size = this->y.size();
	double* z_arr = this->z.data();
	int z_size = this->z.size();

#pragma acc data copyin(bb_arr[:bb_size], index_arr[:index_size], \
 c2_arr[:c2_size], x_arr[:x_size], y_arr[:y_size], z_arr[:z_size]) \
 copyout(results_arr[:results_size])
{

#pragma acc parallel loop gang collapse(2) private(ii,x0,y0,z0,contact)
	for(i=1; i<index_size-1; i++)
	{
  	for(p=0; p<3; p++)
		{
			if(p==0) {
					ii=bb_arr[index_arr[i].x1-1].capos;
			} else if(p==1) {
					ii=bb_arr[index_arr[i].x1-1].cbpos;
			} else {
					ii=bb_arr[index_arr[i].x1-1].copos;
			}

			if(ii < 1 || ii > x_size) {
				results_arr[i*3+p]=-1.0;
				continue;
			}

			contact=0.0;

			ii--;
			x0=x_arr[ii];
			y0=y_arr[ii];
			z0=z_arr[ii];

#pragma acc loop vector private(jj,rr) reduction(+:contact)
			for(j=0;j<c2_size;j++)
			{
				jj=c2_arr[j];
				if(jj<=1 || jj>x_size) continue;

				jj--;
				rr=(x_arr[jj]-x0)*(x_arr[jj]-x0)+(y_arr[jj]-y0)*(y_arr[jj]-y0)+(z_arr[jj]-z0)*(z_arr[jj]-z0);
				rr=sqrt(rr);
				contact+=exp(-rr/3.0);			
			}

			results_arr[i*3+p]=contact;

		}
	}

} // end data

	return;

}	



CTraj::CTraj()
{
	natom=0;
	nres=0;
	nframe=0;
};

CTraj::~CTraj()
{
  double *tmp = x.data();
#pragma acc exit data delete(tmp)
  tmp = y.data();
#pragma acc exit data delete(tmp)
  tmp = z.data();
#pragma acc exit data delete(tmp)
#pragma acc exit data delete(this)
};







void smtry::getdata(double x[3][3],double y[3])
{
	int i,j;
	for(i=0;i<3;i++)
	for(j=0;j<3;j++)
		matrix[i][j]=x[i][j];
	for(i=0;i<3;i++)
		motion[i]=y[i];
	return;
}

void smtry::trans(double x[3],double y[3])
{
	for(int i=0;i<3;i++)
		y[i]=x[0]*matrix[i][0]+x[1]*matrix[i][1]+x[2]*matrix[i][2]+motion[i];
	return;
}

void smtry::print()
{
	int j;
	for(int i=0;i<3;i++)
	{
		for(j=0;j<3;j++)
			cout<<matrix[i][j]<<" ";
		cout<<motion[i]<<endl;
	}
	return ;
}





void CTraj2::clear()
{
	x.clear();
	y.clear();
	z.clear();
	b.clear();
	crystal_sym_array.clear();
	nframe=0;
	natom=0;
	nres=0;
	memset(translation,0,sizeof(double)*9);
	memset(scale,0,sizeof(double)*9);
	btrans=0;
	bsmtry=0;
}

int CTraj2::select(vector<int> t)
{	
	int i,j;
	int nmiss=0;
	vector<double> xx,yy,zz,bb;
	for(i=0;i<(int)t.size();i++)
	{
		j=t.at(i)-1;
		if(j>=0)
		{
			xx.push_back(x.at(j));
			yy.push_back(y.at(j));
			zz.push_back(z.at(j));
			bb.push_back(b.at(j));
		}
		else
		{
			nmiss++;
		}
	}
	x=xx;
	y=yy;
	z=zz;
	b=bb;
	natom=x.size();
	return nmiss;
}


int CTraj2::loadcoor(string filename)
{
	double xx,yy,zz,bb;
	string line,part,part1,part2;
	double cx[3][3];
	double cy[3];
	class smtry crystal_sym;
	crystal_sym_array.clear();


	ifstream fin(filename.c_str());
	while(getline(fin,line))
	{
		part1.clear();
		part2.clear();

		if(line.size()>18)
		{
			part1=line.substr(0,10);
			part2=line.substr(13,5);
		}
		if(part1=="REMARK 290" && part2=="SMTRY")
		{
			bsmtry=1;
			cx[0][0]=atof(line.substr(24,9).c_str());
			cx[0][1]=atof(line.substr(34,9).c_str());
			cx[0][2]=atof(line.substr(44,9).c_str());
			cy[0]=atof(line.substr(59,9).c_str());
			getline(fin,line);
			cx[1][0]=atof(line.substr(24,9).c_str());
			cx[1][1]=atof(line.substr(34,9).c_str());
			cx[1][2]=atof(line.substr(44,9).c_str());
			cy[1]=atof(line.substr(59,9).c_str());
			getline(fin,line);
			cx[2][0]=atof(line.substr(24,9).c_str());
			cx[2][1]=atof(line.substr(34,9).c_str());
			cx[2][2]=atof(line.substr(44,9).c_str());
			cy[2]=atof(line.substr(59,9).c_str());
			
			if(!(cx[0][0]==1 && cx[1][1]==1 && cx[2][2]==1 && cx[0][1]==0 && cx[1][0]==0 && cx[0][2]==0 && cx[2][0]==0
						  && cx[1][2]==0 && cx[2][1]==0 && cy[0]==0 && cy[1]==0 && cy[2]==0))
			{
				crystal_sym.getdata(cx,cy);crystal_sym_array.push_back(crystal_sym);
			}
		}

		if(line.size()>5)
			part1=line.substr(0,5);
		else
			part1.clear();
		if(part1=="SCALE")
		{
			scale[0][0]=atof(line.substr(10,10).c_str());
			scale[0][1]=atof(line.substr(20,10).c_str());
			scale[0][2]=atof(line.substr(30,10).c_str());
			getline(fin,line);
			scale[1][0]=atof(line.substr(10,10).c_str());
			scale[1][1]=atof(line.substr(20,10).c_str());
			scale[1][2]=atof(line.substr(30,10).c_str());
			getline(fin,line);
			scale[2][0]=atof(line.substr(10,10).c_str());
			scale[2][1]=atof(line.substr(20,10).c_str());
			scale[2][2]=atof(line.substr(30,10).c_str());
			process_tran();
			btrans=1;
		}
		if(part1=="CRYST")
		{
			part1=line.substr(67,4);
			ncry=atoi(part1.c_str());
		}

		if(line.size()>6)
			part=line.substr(0,6);
		else
			part.clear();
		if(part=="ENDMDL" || part=="END")
		{
			//finished read first molecule 
			if(x.size()%natom!=0)
				cout<<"In traj reading, suppose to read "<<natom<<" coors but actually read in "<<x.size()<<endl;
		}


		part=line.substr(0,6);
		if(part!="ATOM  " && part!="HETATM")
			continue;

		part=line.substr(17,3);
		if(part=="HOH" || part=="WAT")
			continue;

		part=line.substr(30,8);
		xx=atof(part.c_str());
		x.push_back(xx);
		part=line.substr(38,8);
		yy=atof(part.c_str());
		y.push_back(yy);
		part=line.substr(46,8);
		zz=atof(part.c_str());
		z.push_back(zz);
		part=line.substr(60,6);
		bb=atof(part.c_str());
		b.push_back(bb);
		part=line.substr(12,4);
		atomname.push_back(part);
	};

	if(natom==0)
		nframe=0;
	else
		nframe=x.size()/natom;
	return nframe;
}

void CTraj2::process_tran()
{
	if(scale[1][0]!=0 || scale[2][0]!=0 || scale[2][1]!=0)
		return;
		
	translation[0][0]=1/scale[0][0];
	translation[0][1]=-scale[0][1]/(scale[1][1]*scale[0][0]);
	translation[0][2]=(scale[0][1]*scale[1][2]/scale[1][1]-scale[0][2])/(scale[0][0]*scale[2][2]);

	translation[1][0]=0;
	translation[1][1]=1/scale[1][1];
	translation[1][2]=-scale[1][2]/(scale[1][1]*scale[2][2]);

	translation[2][0]=0;
	translation[2][1]=0;
	translation[2][2]=1/scale[2][2];
	
	return;
}



int CTraj2::unitcell(void)
{
	class smtry crystal_sym;
	double xmean,ymean,zmean;
	double xscale,yscale,zscale;
	double xtran,ytran,ztran;
	double yold[3];
	double ynew[3];
	int n;
	int i,j;


	n=x.size();
	for(i=0;i<(int)crystal_sym_array.size();i++)
	{
		xmean=ymean=zmean=0;
		crystal_sym=crystal_sym_array.at(i);			
		for(j=0;j<n;j++)
		{
			yold[0]=x.at(j);
			yold[1]=y.at(j);
			yold[2]=z.at(j);
			crystal_sym.trans(yold,ynew);
			x.push_back(ynew[0]);
			y.push_back(ynew[1]);
			z.push_back(ynew[2]);
			xmean+=ynew[0];
			ymean+=ynew[1];
			zmean+=ynew[2];				
		}
		xmean/=n;
		ymean/=n;
		zmean/=n;

		xscale=scale[0][0]*xmean+scale[0][1]*ymean+scale[0][2]*zmean;
		yscale=scale[1][0]*xmean+scale[1][1]*ymean+scale[1][2]*zmean;
		zscale=scale[2][0]*xmean+scale[2][1]*ymean+scale[2][2]*zmean;
		
		xscale= xscale>=0 ? -((int)xscale) : -((int)(xscale-0.9999));
		yscale= yscale>=0 ? -((int)yscale) : -((int)(yscale-0.9999));
		zscale= zscale>=0 ? -((int)zscale) : -((int)(zscale-0.9999));	
		
		
		xtran=xscale*translation[0][0]+yscale*translation[0][1]+zscale*translation[0][2];
		ytran=yscale*translation[1][1]+zscale*translation[1][2];
		ztran=zscale*translation[2][2];
		
		for(j=0;j<natom;j++)
		{
			x.at(j+natom*(i+1))+=xtran;
			y.at(j+natom*(i+1))+=ytran;
			z.at(j+natom*(i+1))+=ztran;
		}			
	}

	return i;
}

void CTraj2::ninecells(void)
{
	int i,m,k,n;
	double xtran,ytran,ztran;
	int nnow;

	nnow=x.size();

	for(m=-1;m<=1;m++)
	for(n=-1;n<=1;n++)
	for(k=-1;k<=1;k++)
	{
		if(m==0 && n==0 && k==0)
			continue;
		xtran=m*translation[0][0]+n*translation[0][1]+k*translation[0][2];
		ytran=n*translation[1][1]+k*translation[1][2];
		ztran=k*translation[2][2];
		for(i=0;i<nnow;i++)
		{
			x.push_back(x.at(i)+xtran);
			y.push_back(y.at(i)+ytran);
			z.push_back(z.at(i)+ztran);
		}
	}
	return;
}


CTraj2::CTraj2()
{
	x.clear();
	y.clear();
	z.clear();
	b.clear();
	crystal_sym_array.clear();
	nframe=0;
	natom=0;
	nres=0;
	memset(translation,0,sizeof(double)*9);
	memset(scale,0,sizeof(double)*9);
	btrans=0;
	bsmtry=0;
};

CTraj2::~CTraj2()
{

};

########## NEXT FILE ##########
#include <iostream>
#include <cstdlib>
#include <fstream>
#include <string>
#include <cstring>
#include <vector>
#include <math.h>
#include <time.h>
#include <sstream>

using namespace std;
#include "lmmin.h"
#include "config.h"
#include "supply.h"
#include "bmrb.h"
#include  "aa.h"
#include "pdb.h"
#include "traj.h"
#include "mainbody.h"

#include "debug.h"

#ifdef BENCHMARK
#include <omp.h>
#endif

// ///////////////////////////////////////////////////////////////////////////////////////////////////////////
int main(int argc, char ** argv)
{
	int begin,stop;
	bool bh,bdetail,bnew,bann,btest,bnew_pdb,blinear,bold;
	class CMainbody mainbody;
	string pdbname;
	string spartaname;
	string gmxname;
	string bmrbname;
	int para;
	int nconf;

	cout<<"PPM: an enemble-based chemical shifts predictor"<<endl;

#ifdef BENCHMARK
	double clock = omp_get_wtime();
#endif

	bh=bdetail=bnew=btest=bnew_pdb=bann=blinear=bold=0;

	CCommandline cmdline;
	vector<string> args,args2,args3;

	args.push_back("-h");		args2.push_back("no");						args3.push_back("print help informaiton then quit");
	args.push_back("-mode");	args2.push_back("ann");						args3.push_back("prediciton algorithm: ann(default) or linear");
	args.push_back("-pdb");		args2.push_back("pdb.pdb");					args3.push_back("input pdb file name");
	args.push_back("-bmrb");	args2.push_back("bmrb.dat");				args3.push_back("input experimental chemical shifts file in NMRSTAR format");
    args.push_back("-pre");		args2.push_back("bmrb_pre.dat");			args3.push_back("output filename for predicted chemical shifts in NMRSTAR format");
	args.push_back("-begin");	args2.push_back("0");						args3.push_back("Index of first snapshot to be used (start from 0)");
	args.push_back("-stop");	args2.push_back("0");						args3.push_back("Index of last snapshot to be used (0 means last snapshot)");
	args.push_back("-para");	args2.push_back("pdb");                     args3.push_back("Parameter set: pdb(ppm_one) or old(ppm)");
    args.push_back("-detail(s)");	args2.push_back("no");					args3.push_back("calculate chemical shifts for each snapshots, only applicable to ensemble predictions");

		
	cmdline.init(args,args2,args3);
	cmdline.pharse(argc,argv);


	spartaname="sparta.pdb";
	pdbname=cmdline.query("-pdb");
	bmrbname=cmdline.query("-bmrb");
	begin=atoi(cmdline.query("-begin").c_str());
	stop=atoi(cmdline.query("-stop").c_str());
    


	if(cmdline.query("-h").compare("yes")==0)		bh=1;
	if(cmdline.query("-mode").compare("linear")==0)		{blinear=1;bann=0;}
	if(cmdline.query("-mode").compare("ann")==0)		{blinear=0;bann=1;}


	if(cmdline.query("-para").compare("pdb")==0)		para=2;
	if(cmdline.query("-para").compare("old")==0)		bold=1;
    
    if(cmdline.query("-detail").compare("yes")==0)		bdetail=1;
    if(cmdline.query("-details").compare("yes")==0)		bdetail=1;



	cmdline.print();

	if(bh==1)
	{	
		exit(0);
	}


	nconf=mainbody.loadpdb(pdbname,gmxname);
	mainbody.set_range(begin,stop);
	mainbody.load(bmrbname);




	if(bold)  //previous generation PPM
	{
		cout<<"Prediction using the old PPM parameters\n";
		cout<<"Chemical shifts root-mean-square deviations (RMSDs) between predicted and experimental values:"<<endl;
        if(bdetail)
        {
            mainbody.predict_proton2();
            mainbody.predict_bb2();
        }
        else
        {
            mainbody.predict_proton();
            mainbody.predict_bb();
        }
		mainbody.print_prediction(cmdline.query("-pre"));
	}
	else if(blinear && para==2)
	{
		cout<<"Prediction using the linear model with static parameters set\n";
		cout<<"Chemical shifts root-mean-square deviations (RMSDs) between predicted and experimental values:"<<endl;
		mainbody.predict_bb_static_new();
		mainbody.predict_proton_static_new();
		mainbody.print_prediction(cmdline.query("-pre"));
	}


	else if(bann && para==2)
	{
		cout<<"Prediction using the ANN model with static parameters set\n";
		cout<<"Chemical shifts root-mean-square deviations (RMSDs) between predicted and experimental values:"<<endl;
		mainbody.predict_bb_static_ann();
		mainbody.predict_proton_static_new();
		mainbody.print_prediction(cmdline.query("-pre"));
	}

	else
	{
		cout<<"Unrecognized command line arguments!\n";
	}

#ifdef BENCHMARK
	printf("Total runtime: %.4f\n", omp_get_wtime()-clock);
#endif

	return 0;
}










########## NEXT FILE ##########
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <string>
#include <vector>
#include <math.h>
#include <time.h>
#include <sstream>
using namespace std;

#include "ann.h"
#include "mainbody.h"

#include "debug.h"

#ifdef BENCHMARK
#include <omp.h>
#endif



//class Dihe_process, used by ppm only

void CDihe_process::init(vector<int> innum,vector<double> *indihe)
{
	num=innum;
	dihe=indihe;
	if(num.size()>2)
	{
		ndihe=num.at(num.size()-1);
		nframe=dihe->size()/ndihe;
	}
	else
	{
		ndihe=0;
		nframe=0;
	}

	return;
}

void CDihe_process::init(vector<int> innum,vector<double> *indihe, vector<dihe_group> *indihe_index)
{
	num=innum;
	dihe=indihe;
	dihe_index=indihe_index;

	if(num.size()>2)
	{
		ndihe=num.at(num.size()-1);
		nframe=dihe->size()/ndihe;
	}
	else
	{
		ndihe=0;
		nframe=0;
	}

	return;
}

void CDihe_process::init(vector<int> innum,vector<double> *indihe, vector<double> *inangle)
{
	num=innum;
	dihe=indihe;
	angle=inangle;
	if(num.size()>2)
	{
		ndihe=num.at(num.size()-1);
		nframe=dihe->size()/ndihe;
	}
	else
	{
		ndihe=0;
		nframe=0;
	}

	return;
}


void CDihe_process::hb_expand(int type)
{
	int i;
	int begin,stop;
	vector<double> temp;

	begin=table[type]*8;
	stop=table[type]*8+8;

	if(stop==0)
	{
		out.clear();
		out.resize(18*8,0.0);
	}
	else
	{
		temp.resize(18*8,0.0);
		for(i=begin;i<stop;i++)
			temp.at(i)=out.at(i-begin);
		out=temp;
	}

	return;
}

void CDihe_process::hb_expand2(int type)
{
    int i;
    int begin,stop;
    vector< vector<double> > temp;
    vector<double> t;
    
    t.resize(nframe,0.0);
    
    begin=table[type]*8;
    stop=table[type]*8+8;
    
    if(stop==0)
    {
        out2.clear();
        out2.resize(18*8,t);
    }
    else
    {
        temp.resize(18*8,t);
        for(i=begin;i<stop;i++)
            temp.at(i)=out2.at(i-begin);
        out2=temp;
    }
    
    return;
}


vector<int> CDihe_process::pos(int in)
{
	int i;
	int base,stop;
	vector<int> out;


	if(in==1)
		base=1;
	else
		base=num.at(in-2)+1;
	
	stop=num.at(in-1);

	if(in<=0)
		base=num.at(num.size()-1)+100;
	if(in>(int)num.size())
		base=num.at(num.size()-1)+100;

	
	for(i=base;i<=stop;i++)
	{
		out.push_back(i);
		//cout<<"in is "<<in<<" "<<i<<endl;
	}

	return out;
}


vector<int> CDihe_process::pos_angle(int in)
{
	int i;
	int base,stop;
	vector<int> out;


	if(in==1)
		base=1;
	else
		base=num.at(in-2)*2+1;
	
	stop=num.at(in-1)*2;

	if(in<=0)
		base=num.at(num.size()-1)+100;
	if(in>(int)num.size())
		base=num.at(num.size()-1)+100;

	
	for(i=base;i<=stop;i++)
	{
		out.push_back(i);
		//cout<<"in is "<<in<<" "<<i<<endl;
	}

	return out;
}

void CDihe_process::allproton(int id)
{
	out.clear();
	process(id,2,2,2);
	return;
}

void CDihe_process::allproton2(int id)
{
    out2.clear();
    process2(id,2,2,2);
    return;
}

bool CDihe_process::test_good(int id,int cut)
{
	bool r;
	vector<int> index;
	int t,i;

	index=pos(id);

	if((int)index.size()>=cut)
		t=cut;
	else
		t=index.size();

	r=1;
	for(i=0;i<t;i++)
	{
		if(dihe_index->at(index.at(i)-1).bgood==0)
			r=0;
	}

	return r;
}


bool CDihe_process::test(int id, int t1, int t2)
{
	bool r;
	if(test_good(id-1,t2) && test_good(id,t1) && test_good(id+1,t2) )
		r=1;
	else
		r=0;
	return r;
}


bool CDihe_process::test_proton(int id, int type)
{
	return ((table[type]==-1) || test_good(id,2));
}


bool CDihe_process::ca_static_new(int id)
{
	out.clear();
	bool r;

	if(test_good(id-1,3) && test_good(id,4) && test_good(id+1,3) )
	{
		process_static_new(id-1,3,2,2);
		process_static_new(id  ,4,3,3);
		process_static_new(id+1,3,2,2);
		r=1;
	}
	else
		r=0;

	return r;
	
}

void CDihe_process::md_new(int id)
{
	out.clear();

	process_static_new(id-1,4,2,2);
	process_static_new(id  ,4,3,3);
	process_static_new(id+1,4,2,2);
  	return;
}

void CDihe_process::md_new_detail(int id, int n)
{
	out.clear();
    
	process_md_sep(n,id-1,4,2,2);
	process_md_sep(n,id  ,4,3,3);
	process_md_sep(n,id+1,4,2,2);
  	return;
}


void CDihe_process::ca(int id)
{
	out.clear();

	process(id-1,3,3,3);
	process(id  ,4,3,3);
	process(id+1,3,3,3);
  	return;
}



void CDihe_process::ca_ann(int id)
{
	out.clear();

	process_static_new(id-1,4,1,1);
	process_static_new(id  ,4,2,2);
	process_static_new(id+1,4,1,1);
  	return;
}

void CDihe_process::md_ann(int id,int n)
{
	out.clear();
	process_md_sep(n,id-1,4,1,1);
	process_md_sep(n,id  ,4,1,1);
	process_md_sep(n,id+1,4,1,1);
	return;
}


void CDihe_process::process_md_sep(int nn,int id,int cut, int order1, int order2)
{
	int i,ii,j,p;
	int base;
	int t;
	double phi;
	int order;
	vector<int> index;
	vector<double> temp;

	index=pos(id);
	if((int)index.size()>=cut)
		t=cut;
	else
		t=index.size();


	for(i=0;i<t;i++)
	{
		p=index.at(i);
		order=order1;
		if(i>1) order=order2;

		for(ii=1;ii<=order;ii++)
		{
			j=nn;
			base=j*ndihe;
			phi=dihe->at(base+p-1);
			out.push_back(cos(phi*ii));
			
			j=nn;
			base=j*ndihe;
			phi=dihe->at(base+p-1);
			out.push_back(sin(phi*ii));
		}
	}

	for(i=t;i<cut;i++)
	{
		for(ii=1;ii<=order2;ii++)
		{
			out.push_back(0.0);
			out.push_back(0.0);
		}
	}

	return;
}

void CDihe_process::process(int id,int cut,int order,int order2)
{
	int p,i,j,k,t,base;
	vector<int> index;
	double phi;
	double cosphi[10];
	double sinphi[10];

	

	index=pos(id);
	if((int)index.size()>=cut)
		t=cut;
	else
		t=index.size();

	for(i=0;i<2;i++)
	{
		p=index.at(i);
		for(k=1;k<=order;k++)
			cosphi[k]=sinphi[k]=0.0;
		for(j=0;j<nframe;j++)
		{
			base=j*ndihe;
			phi=dihe->at(base+p-1);
			for(k=1;k<=order;k++)
			{
				cosphi[k]+=cos(phi*k);
				sinphi[k]+=sin(phi*k);
			}
		}
		for(k=1;k<=order;k++)
		{
			out.push_back(cosphi[k]/nframe);
		}
		for(k=1;k<=order;k++)
		{
			out.push_back(sinphi[k]/nframe);
		}
	}

	for(i=2;i<t;i++)
        {
                p=index.at(i);
                for(k=1;k<=order2;k++)
                        cosphi[k]=sinphi[k]=0.0;
                for(j=0;j<nframe;j++)
                {
                        base=j*ndihe;
                        phi=dihe->at(base+p-1);
                        for(k=1;k<=order2;k++)
                        {
                                cosphi[k]+=cos(phi*k);
                                sinphi[k]+=sin(phi*k);
                        }
                }
                for(k=1;k<=order2;k++)
                {
                        out.push_back(cosphi[k]/nframe);
                }
                for(k=1;k<=order2;k++)
                {
                        out.push_back(sinphi[k]/nframe);
                }
        }

	for(i=t;i<cut;i++)
	{
		for(j=0;j<order2*2;j++)
			out.push_back(0.0);
	}
}


void CDihe_process::process_static_new(int id,int cut,int order,int order2)
{
	int p,i,j,k,t,base;
	vector<int> index;
	double phi;
	double cosphi[10];
	double sinphi[10];


	index=pos(id);
	if((int)index.size()>=cut)
		t=cut;
	else
		t=index.size();

	for(i=0;i<2;i++)
	{
		p=index.at(i);
		for(k=1;k<=order;k++)
			cosphi[k]=sinphi[k]=0.0;
		for(j=0;j<nframe;j++)
		{
			base=j*ndihe;
			phi=dihe->at(base+p-1);
			for(k=1;k<=order;k++)
			{
				cosphi[k]+=cos(phi*k);
				sinphi[k]+=sin(phi*k);
			}
		}
		for(k=1;k<=order;k++)
		{
			out.push_back(cosphi[k]/nframe);
			out.push_back(sinphi[k]/nframe);
		}
	}

	for(i=2;i<t;i++)
        {
                p=index.at(i);
                for(k=1;k<=order2;k++)
                        cosphi[k]=sinphi[k]=0.0;
                for(j=0;j<nframe;j++)
                {
                        base=j*ndihe;
                        phi=dihe->at(base+p-1);
                        for(k=1;k<=order2;k++)
                        {
                                cosphi[k]+=cos(phi*k);
                                sinphi[k]+=sin(phi*k);
                        }
                }
                for(k=1;k<=order2;k++)
                {
                        out.push_back(cosphi[k]/nframe);
						out.push_back(sinphi[k]/nframe);
                }
        }

	for(i=t;i<cut;i++)
	{
		for(j=0;j<order2*2;j++)
			out.push_back(0.0);
	}
}

void CDihe_process::proton(int id)
{
	out2.clear();
	process_fit(id,7);
  	return;
}


void CDihe_process::ca2(int id)
{
	out2.clear();

	process2(id-1,3,3,3);
	process2(id  ,4,3,3);
	process2(id+1,3,3,3);
  	return;
}

void CDihe_process::for_fit(int id)
{
	out2.clear();

	process_fit(id-1,4);
	process_fit(id,4);
	process_fit(id+1,4);
	return;
}


void CDihe_process::fit_angle(int id)
{
	int i,j,p,base;
	vector<int> index;
	vector<double> temp;
	double phi;

	index=pos_angle(id);

	out2.clear();

	int touse[5]={0,1,3,4,5};

	
	for(i=0;i<5;i++)
	{
		if(touse[i]<(int)index.size())
		{
			p=index.at(touse[i]);
			temp.clear();
			for(j=0;j<nframe;j++)
			{
				base=j*ndihe*2;
				phi=angle->at(base+p-1);
				temp.push_back(phi);
			}
			out2.push_back(temp);
		}
		else
		{
			temp.clear();
			for(j=0;j<nframe;j++)
			{
				temp.push_back(0.0);
			}
			out2.push_back(temp);
		}

	}

}


void CDihe_process::process_fit(int id,int cut)
{
	int i,j,p;
	int base;
	int t;
	double phi;
	vector<int> index;
	vector<double> temp;

	index=pos(id);
	if((int)index.size()>=cut)
		t=cut;
	else
		t=index.size();


	for(i=0;i<t;i++)
	{
		p=index.at(i);
		temp.clear();
		for(j=0;j<nframe;j++)
		{
			base=j*ndihe;
			phi=dihe->at(base+p-1);
			temp.push_back(phi);
		}
		out2.push_back(temp);
	}

	for(i=t;i<cut;i++)
	{
		temp.clear();
		for(j=0;j<nframe;j++)
		{
			temp.push_back(0.0);
		}
		out2.push_back(temp);
	}

	return;
}





void CDihe_process::process2(int id,int cut,int order,int order2)
{
	int p,i,j,k,t,base;
	vector<int> index;
	double phi;
	vector< vector<double> > t1,t2;

	

	index=pos(id);
	if((int)index.size()>=cut)
		t=cut;
	else
		t=index.size();

	for(i=0;i<2;i++)
	{
		p=index.at(i);
		t1.clear();
		t2.clear();
		t1.resize(order);
		t2.resize(order);
		for(j=0;j<nframe;j++)
		{
			base=j*ndihe;
			phi=dihe->at(base+p-1);
			for(k=1;k<=order;k++)
			{
				t1.at(k-1).push_back(cos(phi*k));
				t2.at(k-1).push_back(sin(phi*k));
			}
		}
		for(k=1;k<=order;k++)
		{
			out2.push_back(t1.at(k-1));
		}
		for(k=1;k<=order;k++)
		{
			out2.push_back(t2.at(k-1));
		}
	}

	for(i=2;i<t;i++)
    {
		p=index.at(i);
		t1.clear();
		t2.clear();
		t1.resize(order2);
		t2.resize(order2);
		for(j=0;j<nframe;j++)
        {
			base=j*ndihe;
            phi=dihe->at(base+p-1);
            for(k=1;k<=order2;k++)
            {
				t1.at(k-1).push_back(cos(phi*k));
				t2.at(k-1).push_back(sin(phi*k));
			}
		}
        for(k=1;k<=order2;k++)
		{
			out2.push_back(t1.at(k-1));
		}
        for(k=1;k<=order2;k++)
        {
			out2.push_back(t2.at(k-1));
		}
    }

	for(i=t;i<cut;i++)
	{
		t1.clear();
		t2.clear();
		t1.resize(order2);
		t2.resize(order2);
		for(j=0;j<nframe;j++)
		{
			for(k=1;k<=order2;k++)
            {
				t1.at(k-1).push_back(0.0);
				t2.at(k-1).push_back(0.0);
			}
		}
		for(k=1;k<=order2;k++)
		{
			out2.push_back(t1.at(k-1));
		}
        for(k=1;k<=order2;k++)
        {
			out2.push_back(t2.at(k-1));
		}
	}
}

vector<double> CDihe_process::output()
{
	return out;
}

vector< vector<double> > CDihe_process::output2()
{
	return out2;
}

CDihe_process::CDihe_process(void)
{
	int i;
	table=new int[98+1];
	for(i=0;i<98+1;i++)
		table[i]=-1;

	for(i=0;i<18;i++)
		table[hbs[i]]=i;

};


CDihe_process::~CDihe_process(void)
{
	delete [] table ;
};



CMainbody::CMainbody()
{
	int i;

	bnew=0;
	
	sep_table=new int[98+1];
	for(i=0;i<98+1;i++)
		sep_table[i]=-1;

	for(i=0;i<19;i++)
		sep_table[sep[i]]=i;
};

CMainbody::~CMainbody()
{
	if(bnew)
	{
		delete pdb;
		delete traj;
	}
	delete [] sep_table;
};



int CMainbody::loadpdb(CPdb *p_pdb, CTraj * p_traj)
{
	pdb=p_pdb;
	traj=p_traj;

	natom=pdb->getnatom();
	nres=pdb->getnres();
	nconf=traj->getnframe();

	return nconf;
}



int CMainbody::loadpdb(string name)
{
	pdb=new CPdb;
	traj=new CTraj;
	bnew=1;

	natom=pdb->loadpdb(name);
	nres=pdb->getnres();
	traj->setnres(nres);
	traj->setnatom(natom);
	nconf=traj->loadcoor(name);
	return nconf;
}

int CMainbody::loadpdb(string name,string name2)
{
	pdb=new CPdb;
	traj=new CTraj;
	bnew=1;

	pdb_name=name;

	natom=pdb->loadpdb(name);
	nres=pdb->getnres();
	traj->setnres(nres);
	traj->setnatom(natom);

	
	
    nconf=traj->loadcoor(name);


	return nconf;
}




void CMainbody::load(string bmrbname)
{
	bmrb.process(bmrbname.c_str());
	pdb->attach_bmrb(bmrb);
	pdb->getdihe(&dihe_index,&dihe_num);
	pdb->getring(&ring_index);
	pdb->ani(&anistropy);
	pdb->proton(&protons);
	pdb->allproton(&allprotons);
	pdb->process_ambig(2);
	pdb->allproton3(&allprotons3);
	heavy=pdb->getheavy();
	pdb->getbb(&bb);
	pdb->bbnh(&bbnh);
	pdb->bbhbond(&hbond);
	pdb->schbond(&hbond);  //This is new !
	ndihe=dihe_index.size();
	traj->getdihe(&dihe_index,&dihe);
	dihe_process.init(dihe_num,&dihe,&dihe_index);
	//process bb to remove all entry that has missing part !!
	//bbnh willn't take effect if bb is not there for particular residue
	bb=clear(bb);
	allprotons=clear(allprotons);
	allprotons3=clear(allprotons3);

	//seperate ring group to two, one for internal, one for surface, according to contact sum !
	int i;
	vector<int> ring_atom;
	vector<float> result;
	ring_atom.clear();
	result.clear();
	for(i=0;i<(int)ring_index.size();i++)
	{
		ring_atom.push_back(ring_index.at(i).x2);
	}
#ifdef BENCHMARK
	double clock = omp_get_wtime();
#endif
	traj->get_contact(1.00,0.0,ring_atom,heavy,&result);
#ifdef BENCHMARK
	printf("%.4f traj->get_contact\n", omp_get_wtime()-clock);
#endif
	ring_index_internal.clear();
	ring_index_external.clear();

	for(i=0;i<(int)ring_index.size();i++)
	{
		if(result.at(i)>2.5)
			ring_index_internal.push_back(ring_index.at(i));
		else
			ring_index_external.push_back(ring_index.at(i));
	}

	return;
}

vector<struct proton> CMainbody::clear(vector<struct proton> &protons)
{
	int i;
	int id,type;
	vector<struct proton> newprotons;
	newprotons.reserve(protons.size());

	for(i=0;i<protons.size();i++)
	{
		id=protons.at(i).id;
		type=protons.at(i).type;

		if(id<1 || id>pdb->getnres())
		{
			//protons.erase(protons.begin()+i);
			continue;
		}
		if(dihe_process.test_proton(id,type)==0) //==0 means missing dihedral angles in this calculation !!
		{
			//protons.erase(protons.begin()+i);
			continue;
		}
		newprotons.push_back(protons.at(i));
	}
	return newprotons;
}


vector<struct bb_group> CMainbody::clear(vector<struct bb_group> &bb)
{
	int i;
	int id;
	char code,code_pre,code_fol;
	vector<struct bb_group> newbb;
	newbb.reserve(bb.size());
	
	for(i=0;i<bb.size();i++)
	{
		//cout<<i<<endl;
		id=bb.at(i).id;

		//first and last residue are excluded
		if(id<=1)
		{
			//bb.erase(bb.begin()+i);
			continue;
		}
		if(id>=pdb->getnres())
		{
			//bb.erase(bb.begin()+i);
			continue;
		}

		code=pdb->code(id);
		code_pre=pdb->code(id-1);
		code_fol=pdb->code(id+1);

		//previous or following residue actually belong to another chain. 
		if(pdb->chain(id)!=pdb->chain(id-1) || pdb->chain(id)!=pdb->chain(id+1))
		{
			//bb.erase(bb.begin()+i);
			continue;
		}

		//missing or unknow residue should NOT be predicted. This is also true if either previous or following residue is missing (or unknown)
		if(code_pre=='X' || code_pre=='B' || code_fol=='X' || code_fol=='B'|| code=='X' || code=='B')
		{
			//bb.erase(bb.begin()+i);
			continue;
		}

		if(dihe_process.test(id,4,4)==0) //==0 means missing dihedral angles in this calculation !!
		{
			//bb.erase(bb.begin()+i);
			continue;
		}

		if(bb.at(i).capos<0 ||  bb.at(i).copos<0 || bb.at(i).npos<0 )
		{
			//bb.erase(bb.begin()+i);
			continue;
		}

		if(bb.at(i).cbpos<0 && bb.at(i).code!='G')
		{
			//bb.erase(bb.begin()+i);
			continue;
		}

		if(bb.at(i).hpos<0 && bb.at(i).code!='P')
		{
			//bb.erase(bb.begin()+i);
			continue;
		}

		newbb.push_back(bb.at(i));

	}

	return newbb;
}



int CMainbody::set_range(int begin,int stop)
{
	nconf=traj->set_range(begin,stop);
	return nconf;
}





void CMainbody::predict_bb()
{
	int i,j,j2,jj;
	int id;
	char code;
	vector<double> out;
	vector<double> in,in2;
	vector<struct double_five> ring_effect;
	vector<struct ehbond> hbond_effect;
	vector<struct double_four> ani_effect;
	vector<struct index_two> index;
	double pre[6];
	double temp;
	vector<double> eca,ecb,eco,eh,en;
	

	traj->gethbond(&hbond,&hbond_effect);
	traj->getani(&anistropy,&bbnh,&ani_effect);
	traj->getring(&ring_index,&bbnh,&ring_effect);

	
	/*carbon=bb_ca; exp.loadexp_bb("exp_ca.dat",&bb,carbon);
	carbon=bb_cb; exp.loadexp_bb("exp_cb.dat",&bb,carbon);
	carbon=bb_co; exp.loadexp_bb("exp_co.dat",&bb,carbon);
	exp.loadexp_bbn("exp_n.dat",&bbnh);
	exp.loadexp_bbnh("exp_hn.dat",&bbnh);*/


	index.resize(pdb->getnres());
	for(i=0;i<(int)index.size();i++)
		index.at(i).x1=index.at(i).x2=-1;
	for(i=0;i<(int)bb.size();i++)
		index.at(bb.at(i).id-1).x1=i+1;
	for(i=0;i<(int)bbnh.size();i++)
		index.at(bbnh.at(i).id-1).x2=i+1;
	

	for(i=0+1;i<(int)index.size()-1;i++)
	{
		//cout<<i<<endl;
		if(index.at(i).x1<0)
			continue;
		id=i+1;
		code=pdb->code(id);
		for(jj=0;jj<5;jj++)
			pre[jj]=0.0;
		//ca=cb=co=h=n=0.0;
 
		dihe_process.ca(id); 
		out=dihe_process.output();
		for(j=0;j<30;j++)
		{
			for(jj=0;jj<5;jj++)
				pre[jj]+=c_c[jj][j]*out.at(j);
		}

		for(j=42;j<60;j++)
		{
			for(jj=0;jj<5;jj++)
				pre[jj]+=c_c[jj][j-12]*out.at(j);
		}
			

		in.clear();
		for(j=0;j<12;j++)
		{
			in.push_back(out.at(j+30));
		}
		in2=Sequence::expand(code,&in);
		for(j=0;j<(int)in2.size();j++)
		{
			for(jj=0;jj<5;jj++)
				pre[jj]+=c_c[jj][j+48]*in2.at(j);
		}
		
		
		for(jj=0;jj<5;jj++)
		{
			for(j=-2;j<=0;j++)
			{
				j2=(j+2)*6;
				pre[jj]+=c_c[jj][288+j2]*hbond_effect.at(id+j).c_length;
				pre[jj]+=c_c[jj][289+j2]*hbond_effect.at(id+j).c_phi;
				pre[jj]+=c_c[jj][290+j2]*hbond_effect.at(id+j).c_psi;
				pre[jj]+=c_c[jj][291+j2]*hbond_effect.at(id+j).n_length;
				pre[jj]+=c_c[jj][292+j2]*hbond_effect.at(id+j).n_phi;
				pre[jj]+=c_c[jj][293+j2]*hbond_effect.at(id+j).n_psi;
			}
		}

			//sequence information
			code=pdb->code(id-1);
			Sequence::code2array(code,buffer);
			for(j=0;j<20;j++)		
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j+306]*buffer[j];
			}

			code=pdb->code(id);
			Sequence::code2array(code,buffer);
			for(j=0;j<20;j++)		
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j+326]*buffer[j];
			}

			code=pdb->code(id+1);
			Sequence::code2array(code,buffer);
			for(j=0;j<20;j++)		
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j+346]*buffer[j];
			}

			if(index.at(i).x2>0)
			{
				temp=0.0;
				for(j=0;j<5;j++)
					temp+=ring_effect.at(index.at(i).x2-1).x[j];
				temp*=c_h_add[4];
				for(j=0;j<4;j++)
					temp+=ani_effect.at(index.at(i).x2-1).x[j]*c_h_add[j];
				pre[3]+=temp;
			}
			pre[5]=999.0;
			pdb->attach_bbprediction(id,pre);
	}

	cal_error();
}





void CMainbody::predict_bb_static_ann()
{
	int i,j;
	int id;
	char code,code_pre,code_fol;
	vector<double> out;
	vector<double> in,in2;
	vector<struct double_five> ring_effect,ring_effect_ha;
	vector<struct ehbond> hbond_effect;
	vector<struct double_four> ani_effect,ani_effect_ha;
	vector<struct index_two> index;
	vector<int> c1,c2;
	vector<float> result;
	double pre[6];
	vector<double> eca,ecb,eco,eh,en;

	vector<double> oneline;
	vector<double> oneline_cb;
	vector<double> oneline_co;
	vector<double> oneline_h;
	vector<double> oneline_n;
	vector<double> oneline_ha;

#ifdef BENCHMARK
	double clock;
#endif


	class CAnn ann_ca,ann_cb,ann_co,ann_n,ann_h,ann_ha;

	//ann_ca.load("ann_ca.dat");
	ann_ca.loadp(p_ann_ca);
	ann_cb.loadp(p_ann_cb);
	ann_co.loadp(p_ann_co);
	ann_n.loadp(p_ann_n);
	ann_h.loadp(p_ann_h);
	ann_ha.loadp(p_ann_ha);

#ifdef BENCHMARK
	clock = omp_get_wtime();
#endif
	traj->gethbond(&hbond,&hbond_effect);
#ifdef BENCHMARK
	printf("%.4f gethbond\n", omp_get_wtime()-clock);
	clock = omp_get_wtime();
#endif
	traj->getani(&anistropy,&bbnh,&ani_effect);
#ifdef BENCHMARK
	printf("%.4f getani(bb)\n", omp_get_wtime()-clock);
	clock = omp_get_wtime();
#endif
	traj->getring(&ring_index,&bbnh,&ring_effect);
#ifdef BENCHMARK
	printf("%.4f getring(bb)\n", omp_get_wtime()-clock);
#endif

	
	//gather all ha protons to calculate ring and ani.
	vector<struct proton> ha_protons;
	struct proton ha;
	for(i=0;i<(int)bb.size();i++)
	{
		
		if(bb.at(i).code=='G')
		{
			ha.nh=2;
			ha.hpos[0]=max(0, bb.at(i).hapos);
			ha.hpos[1]=max(0, bb.at(i).hapos2);
			ha.exp=(bb.at(i).exp_ha+bb.at(i).exp_ha2)/2.0;
			ha.exp1=bb.at(i).exp_ha;
			ha.exp2=bb.at(i).exp_ha2;
			ha.type=90;
			ha.name="HB2";
			ha.name2="HB3";
			ha.cname="CA";
			ha.cname2="CA";
		}
		else
		{
			ha.nh=1;
			ha.hpos[0]=max(0, bb.at(i).hapos);
			ha.exp=bb.at(i).exp_ha;
			ha.type=91;
			ha.name="HA";
			ha.cname="CA";
		}
		ha.cpos=bb.at(i).capos;
		ha.exp_c=bb.at(i).exp_ca;
		ha.id=bb.at(i).id;
		ha.code=bb.at(i).code;

		ha_protons.push_back(ha);
	}
#ifdef BENCHMARK
	clock = omp_get_wtime();
#endif
	traj->getani(&anistropy,&ha_protons,&ani_effect_ha);
#ifdef BENCHMARK
	printf("%.4f getani(proton)\n", omp_get_wtime()-clock);
	clock = omp_get_wtime();
#endif
	traj->getring(&ring_index,&ha_protons,&ring_effect_ha);
#ifdef BENCHMARK
	printf("%.4f getring(proton)\n", omp_get_wtime()-clock);
#endif

	index.resize(pdb->getnres());	
	for(i=0;i<(int)index.size();i++)
		index.at(i).x1=index.at(i).x2=-1;
	for(i=0;i<(int)bb.size();i++)
		index.at(bb.at(i).id-1).x1=i+1;
	for(i=0;i<(int)bbnh.size();i++)
		index.at(bbnh.at(i).id-1).x2=i+1;

	c2 = pdb->getselect(":1-%@allheavy");
#ifdef BENCHMARK
	clock = omp_get_wtime();
#endif
	traj->get_contacts(bb,index,c2,&result);
#ifdef BENCHMARK
	printf("%.4f get_contacts\n", omp_get_wtime()-clock);
#endif

	for(i=0+1;i<(int)index.size()-1;i++)
	{
		//cout<<i<<endl;
		if(index.at(i).x1<0)
			continue;
		id=i+1;
		code=pdb->code(id);
		code_pre=pdb->code(id-1);
		code_fol=pdb->code(id+1);
		oneline.clear();

		//sequence information
		//blos62 matrix
		//total 60 terms
		Sequence::code2same(code_pre,buffer);
		for(j=0;j<20;j++)		
		{
			oneline.push_back(buffer[j]);
		}

		code=pdb->code(id);
		Sequence::code2same(code,buffer);
		for(j=0;j<20;j++)		
		{
			oneline.push_back(buffer[j]);
		}

		Sequence::code2same(code_fol,buffer);
		for(j=0;j<20;j++)		
		{
			oneline.push_back(buffer[j]);
		}


		//dihedral angle contribution!
		//total 28 terms
		dihe_process.ca_ann(id); 
		out=dihe_process.output();
		for(j=2;j<26;j++)
		{
			oneline.push_back(out.at(j));
		}
		for(j=28;j<(int)out.size();j++)
		{
			oneline.push_back(out.at(j));
		}


		//hbond effect, 12 terms
		oneline.push_back(hbond_effect.at(id-2).c_length);
		oneline.push_back((hbond_effect.at(id-2).c_phi));
		oneline.push_back((hbond_effect.at(id-2).c_psi));

		


		oneline.push_back(hbond_effect.at(id-1).c_length);
		oneline.push_back(hbond_effect.at(id-1).n_length);
		oneline.push_back((hbond_effect.at(id-1).c_phi));
		oneline.push_back((hbond_effect.at(id-1).c_psi));
		oneline.push_back((hbond_effect.at(id-1).n_phi));
		oneline.push_back((hbond_effect.at(id-1).n_psi));

		oneline.push_back(hbond_effect.at(id).n_length);
		oneline.push_back((hbond_effect.at(id).n_phi));
		oneline.push_back((hbond_effect.at(id).n_psi));


		//contact sum , one term
		//c1.clear();
		//c1.push_back(bb.at(index.at(i).x1-1).capos);
		//c1.push_back(bb.at(index.at(i).x1-1).cbpos);
		//c1.push_back(bb.at(index.at(i).x1-1).copos);
		//c2=pdb->getselect(":1-%@allheavy");
		//result.clear();
		//traj->get_contact(c1,c2,&result);

		oneline_co=oneline_cb=oneline;

		oneline.insert(oneline.begin()+60,result.at(i*3));
		oneline_cb.insert(oneline_cb.begin()+60,result.at(i*3+1));
		oneline_co.insert(oneline_co.begin()+60,result.at(i*3+2));
		oneline_n=oneline;
		
		pre[0]=ann_ca.predict_one(oneline);
		pre[1]=ann_cb.predict_one(oneline_cb);
		pre[2]=ann_co.predict_one(oneline_co);
		pre[4]=ann_n.predict_one(oneline_n);
		
		//hn
		if(index.at(i).x2>0)
		{
			oneline_h=oneline;
			for(j=0;j<5;j++)
				oneline_h.push_back(ring_effect.at(index.at(i).x2-1).x[j]);
			for(j=0;j<4;j++)
				oneline_h.push_back(ani_effect.at(index.at(i).x2-1).x[j]);	
			pre[3]=ann_h.predict_one(oneline_h);
		}
		else
			pre[3]=-999.0;
	

		//ha 
		oneline_ha=oneline;
		for(j=0;j<5;j++)
			oneline_ha.push_back(ring_effect_ha.at(index.at(i).x1-1).x[j]);
		for(j=0;j<4;j++)
			oneline_ha.push_back(ani_effect_ha.at(index.at(i).x1-1).x[j]);
		pre[5]=ann_ha.predict_one(oneline_ha);

		pdb->attach_bbprediction(id,pre);
	}

	cal_error();
};


void CMainbody::predict_bb_static_new()
{
	int i,j,jj;
	int id;
	int jump;
	char code,code_pre,code_fol;
	vector<double> out;
	vector<double> in,in2;
	vector<struct double_five> ring_effect,ring_effect_ha;
	vector<struct ehbond> hbond_effect;
	vector<struct double_four> ani_effect,ani_effect_ha;
	vector<struct index_two> index;
	vector<int> c1,c2;
	vector<float> result;
	double pre[6];
	double temp,temp1,temp2,tt1,tt2;
	vector<double> eca,ecb,eco,eh,en;
	double rc;
	double vhill;
	


	traj->gethbond(&hbond,&hbond_effect);
	traj->getani(&anistropy,&bbnh,&ani_effect);
	traj->getring(&ring_index,&bbnh,&ring_effect);



	

	vector<struct proton> ha_protons;
	struct proton ha;
	for(i=0;i<(int)bb.size();i++)
	{
		
		if(bb.at(i).code=='G')
		{
			ha.nh=2;
			ha.hpos[0]=bb.at(i).hapos;
			ha.hpos[1]=bb.at(i).hapos2;
			ha.exp=(bb.at(i).exp_ha+bb.at(i).exp_ha2)/2.0;
			ha.exp1=bb.at(i).exp_ha;
			ha.exp2=bb.at(i).exp_ha2;
			ha.type=90;
			ha.name="HB2";
			ha.name2="HB3";
			ha.cname="CA";
			ha.cname2="CA";
		}
		else
		{
			ha.nh=1;
			ha.hpos[0]=bb.at(i).hapos;
			ha.exp=bb.at(i).exp_ha;
			ha.type=91;
			ha.name="HA";
			ha.cname="CA";
		}
		ha.cpos=bb.at(i).capos;
		ha.exp_c=bb.at(i).exp_ca;
		ha.id=bb.at(i).id;
		ha.code=bb.at(i).code;

		ha_protons.push_back(ha);
	}
	traj->getani(&anistropy,&ha_protons,&ani_effect_ha);
	traj->getring(&ring_index,&ha_protons,&ring_effect_ha);




	index.resize(pdb->getnres());	
	for(i=0;i<(int)index.size();i++)
		index.at(i).x1=index.at(i).x2=-1;
	for(i=0;i<(int)bb.size();i++)
		index.at(bb.at(i).id-1).x1=i+1;
	for(i=0;i<(int)bbnh.size();i++)
		index.at(bbnh.at(i).id-1).x2=i+1;
	

	for(i=0+1;i<(int)index.size()-1;i++)
	{
		//cout<<i<<endl;
		if(index.at(i).x1<0)
			continue;
		id=i+1;
		code=pdb->code(id);
		code_pre=pdb->code(id-1);
		code_fol=pdb->code(id+1);

		for(jj=0;jj<6;jj++)
			pre[jj]=0.0;
		jump=0;

		//ca=cb=co=h=n=0.0;

		//missing or unknow residue shouldn't be predicted. This is also true if either previous or following residue is missing (or unknown)
		if(code_pre=='X' || code_pre=='B' || code_fol=='X' || code_fol=='B'|| code=='X' || code=='B')
		{
			for(jj=0;jj<6;jj++)
				pre[jj]=-999.0;
			continue;
		}

		//sequence information
		Sequence::code2array(code_pre,buffer);
		for(j=0;j<20;j++)		
		{
			for(jj=0;jj<6;jj++)
				pre[jj]+=static_c[jj][j+jump]*buffer[j];
		}
		jump+=20;
		
		code=pdb->code(id);
		Sequence::code2array(code,buffer);
		for(j=0;j<20;j++)		
		{
			for(jj=0;jj<6;jj++)
				pre[jj]+=static_c[jj][j+jump]*buffer[j];
		}
		jump+=20;

		Sequence::code2array(code_fol,buffer);
		for(j=0;j<20;j++)		
		{
			for(jj=0;jj<6;jj++)
				pre[jj]+=static_c[jj][j+jump]*buffer[j];
		}
		jump+=20;



		//dihedral angle contribution!
		if(dihe_process.ca_static_new(id)==0) //==0 means missing dihedral angles in this calculation !!
		{
			for(jj=0;jj<6;jj++)
				pre[jj]=-999.0;
			continue;
		}

		out=dihe_process.output();

		//pre dihe  12*20 terms
		in.clear();
		for(j=0;j<12;j++)
		{
			in.push_back(out.at(j));
		}
		in2=Sequence::expand(code_pre,&in);
		for(j=0;j<(int)in2.size();j++)
		{
			for(jj=0;jj<6;jj++)
				pre[jj]+=static_c[jj][j+jump]*in2.at(j);
		}
		jump+=240;


		//self dihe 24*20 terms
		in.clear();
		for(j=0;j<24;j++)
		{
			in.push_back(out.at(j+12));
		}
		in2=Sequence::expand(code,&in);
		for(j=0;j<(int)in2.size();j++)
		{
			for(jj=0;jj<6;jj++)
				pre[jj]+=static_c[jj][j+jump]*in2.at(j);
		}
		jump+=480;
		
		//follow dihe  12*20 terms
		in.clear();
		for(j=0;j<12;j++)
		{
			in.push_back(out.at(j+36));
		}
		in2=Sequence::expand(code_fol,&in);
		for(j=0;j<(int)in2.size();j++)
		{
			for(jj=0;jj<6;jj++)
				pre[jj]+=static_c[jj][j+jump]*in2.at(j);
		}
		jump+=240;
		
	
		//hbond effect, length only
		for(jj=0;jj<6;jj++)
		{	
			tt1=temp1=hbond_effect.at(id-1).c_length;
			tt2=temp2=hbond_effect.at(id-1).n_length;
			pre[jj]+=static_c[jj][jump+0]*temp1;
			pre[jj]+=static_c[jj][jump+1]*temp2;

			temp1*=temp1;temp2*=temp2;
			pre[jj]+=static_c[jj][jump+2]*temp1;
			pre[jj]+=static_c[jj][jump+3]*temp2;

			pre[jj]+=static_c[jj][jump+4]*temp1*tt1;
			pre[jj]+=static_c[jj][jump+5]*temp2*tt2;

			temp1*=temp1;temp2*=temp2;
			pre[jj]+=static_c[jj][jump+6]*temp1;
			pre[jj]+=static_c[jj][jump+7]*temp2;
		}
		jump+=8;

						
		if(index.at(i).x2>0)
		{
			temp=0.0;
			for(j=0;j<5;j++)
				temp+=ring_effect.at(index.at(i).x2-1).x[j]*static_h[0][j];
			for(j=0;j<4;j++)
				temp+=ani_effect.at(index.at(i).x2-1).x[j]*static_h[0][j+5];
			pre[3]+=temp;
		}

		temp=0.0;
		for(j=0;j<5;j++)
			temp+=ring_effect_ha.at(index.at(i).x1-1).x[j]*static_h[1][j];
		for(j=0;j<4;j++)
			temp+=ani_effect_ha.at(index.at(i).x1-1).x[j]*static_h[1][j+5];
		pre[5]+=temp;


		//get contact sum adjustment
		c1.clear();
		c1.push_back(bb.at(index.at(i).x1-1).capos);
		c1.push_back(bb.at(index.at(i).x1-1).cbpos);
		c1.push_back(bb.at(index.at(i).x1-1).copos);
		c2=pdb->getselect(":1-%@allheavy");
		result.clear();
		traj->get_contact(c1,c2,&result);
		result.push_back(result.at(0));
		result.push_back(result.at(0));
		result.push_back(result.at(0));

		for(jj=0;jj<6;jj++)
		{
			vhill=hill(result.at(jj),hill_para[jj][0],hill_para[jj][1]);
			rc=(1-vhill)/vhill;
			pre[jj]+=rc*static_c[jj][Sequence::code2pos(code)+jump];
			pre[jj]*=vhill;
		}
		
		pdb->attach_bbprediction(id,pre);
	}
	
	cal_error();

}


void CMainbody::cal_error()
{
	int j;
	vector< vector<double> > cas,cbs,cos,hs,ns,has;
	double e,t,w;


	cas.resize(2);cbs.resize(2);cos.resize(2);hs.resize(2);ns.resize(2);has.resize(2);
	bb.clear();
	pdb->getbb(&bb);
	bb=clear(bb);
	for(j=0;j<(int)bb.size();j++)
	{
		cas.at(0).push_back(bb.at(j).exp_ca);
		cbs.at(0).push_back(bb.at(j).exp_cb);
		cos.at(0).push_back(bb.at(j).exp_co);
		hs.at(0).push_back(bb.at(j).exp_h);
		ns.at(0).push_back(bb.at(j).exp_n);
		has.at(0).push_back(bb.at(j).exp_ha);
	
		cas.at(1).push_back(bb.at(j).pre_ca);
		cbs.at(1).push_back(bb.at(j).pre_cb);
		cos.at(1).push_back(bb.at(j).pre_c);
		hs.at(1).push_back(bb.at(j).pre_h);
		ns.at(1).push_back(bb.at(j).pre_n);
		has.at(1).push_back(bb.at(j).pre_ha);

	}
	compare("CA",cas);compare("CB",cbs);compare("C'",cos);compare("HN",hs);compare("N",ns);compare("HA",has);


	FILE *fp=fopen("cs_rmsd.dat","wt");

	for(j=0;j<(int)bb.size();j++)
	{
		e=0;
		w=0;
		if(fabs(bb.at(j).exp_ca)<490.0 && fabs(bb.at(j).pre_ca)<490.0)
		{
			t=bb.at(j).exp_ca-bb.at(j).pre_ca;
			e+=t*t;
			w+=1.0;
		}
		if(fabs(bb.at(j).exp_cb)<490.0 && fabs(bb.at(j).pre_cb)<490.0)
		{
			t=bb.at(j).exp_cb-bb.at(j).pre_cb;
			e+=t*t;
			w+=1.0;
		}
		if(fabs(bb.at(j).exp_co)<490.0 && fabs(bb.at(j).pre_c)<490.0)
		{
			t=bb.at(j).exp_co-bb.at(j).pre_c;
			e+=t*t;
			w+=1.0;
		}
		if(fabs(bb.at(j).exp_h)<490.0 && fabs(bb.at(j).pre_h)<490.0)
		{
			t=bb.at(j).exp_h-bb.at(j).pre_h;
			e+=t*t*4;
			w+=4.0;
		}
		if(fabs(bb.at(j).exp_n)<490.0 && fabs(bb.at(j).pre_n)<490.0)
		{
			t=bb.at(j).exp_n-bb.at(j).pre_n;
			e+=t*t*0.4;
			w+=0.4;
		}
		if(fabs(bb.at(j).exp_ha)<490.0 && fabs(bb.at(j).pre_ha)<490.0)
		{
			t=bb.at(j).exp_ha-bb.at(j).pre_ha;
			e+=t*t*4;
			w+=4;
		}
		if(w>0.0)
		{
			e=sqrt(e/w);
			fprintf(fp,"%10d%10s%10.2f\n",bb.at(j).id0,Sequence::code2name(bb.at(j).code).c_str(),e);
		}
		else
			e=0.0;

	}		
	fclose(fp);		

}


double CMainbody::hill(double contact, double v1, double v2)
{
	double hill;
	
	if(contact<v1)	
		hill=0.0;
	else if(contact>v2)
		hill=1.0;
	else
	{
		hill=(contact-v1)/(v2-v1)*6-3;
		hill=(1-exp(-2*hill))/(1+exp(-2*hill));
		hill=hill/2+0.5;
	}

	return hill;

}


void CMainbody::predict_bb2()
{
	int i,j,j2,jj,n;
	int id;
	char code;
	vector< vector<double> > out;
	vector<double> in,in2;
	vector< vector<struct double_five> > ring_effect;
	vector< vector<struct ehbond> > hbond_effect;
	vector< vector<struct double_four> > ani_effect;
	vector<struct index_two> index;
	vector<double> cs_ca,cs_cb,cs_c,cs_h,cs_n;
	double pre[6];
	double temp;
	vector<double> eca,ecb,eco,eh,en;
	char name[4];
	FILE *fp;

	fp=fopen("bb_details.dat","w");
	


	traj->gethbond(&hbond,&hbond_effect);
	traj->getani(&anistropy,&bbnh,&ani_effect);
	traj->getring(&ring_index,&bbnh,&ring_effect);

	

	index.resize(pdb->getnres());	
	for(i=0;i<(int)index.size();i++)
		index.at(i).x1=index.at(i).x2=-1;
	for(i=0;i<(int)bb.size();i++)
		index.at(bb.at(i).id-1).x1=i+1;
	for(i=0;i<(int)bbnh.size();i++)
		index.at(bbnh.at(i).id-1).x2=i+1;


	

	for(i=0+1;i<(int)index.size()-1;i++)
	{	//cout<<"i is "<<i<<endl;
		if(index.at(i).x1<0)
			continue;
		id=i+1;
		code=pdb->code(id);
		pdb->name(id,name);

		if(strcmp(name,"CYS")==0)
			continue;

		dihe_process.ca2(id); 
		out=dihe_process.output2();

		cs_ca.clear();
		cs_cb.clear();
		cs_c.clear();
		cs_h.clear();
		cs_n.clear();

		for(n=0;n<nconf;n++)
		{		
			id=i+1;
			code=pdb->code(id);

			for(jj=0;jj<5;jj++)
				pre[jj]=0.0;
	 
			for(j=0;j<30;j++)
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j]*out.at(j).at(n);
			}

			for(j=42;j<60;j++)
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j-12]*out.at(j).at(n);
			}
				

			in.clear();
			for(j=0;j<12;j++)
			{
				in.push_back(out.at(j+30).at(n));
			}
			in2=Sequence::expand(code,&in);


			for(j=0;j<(int)in2.size();j++)
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j+48]*in2.at(j);
			}
			
		
			for(jj=0;jj<5;jj++)
			{
				for(j=-2;j<=0;j++)
				{
					j2=(j+2)*6;
					pre[jj]+=c_c[jj][288+j2]*hbond_effect.at(id+j).at(n).c_length;
					pre[jj]+=c_c[jj][289+j2]*hbond_effect.at(id+j).at(n).c_phi;
					pre[jj]+=c_c[jj][290+j2]*hbond_effect.at(id+j).at(n).c_psi;
					pre[jj]+=c_c[jj][291+j2]*hbond_effect.at(id+j).at(n).n_length;
					pre[jj]+=c_c[jj][292+j2]*hbond_effect.at(id+j).at(n).n_phi;
					pre[jj]+=c_c[jj][293+j2]*hbond_effect.at(id+j).at(n).n_psi;
				}
			}

			//sequence information
			code=pdb->code(id-1);
			Sequence::code2array(code,buffer);
			for(j=0;j<20;j++)		
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j+306]*buffer[j];
			}

			code=pdb->code(id);
			Sequence::code2array(code,buffer);
			for(j=0;j<20;j++)		
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j+326]*buffer[j];
			}

			code=pdb->code(id+1);
			Sequence::code2array(code,buffer);
			for(j=0;j<20;j++)		
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j+346]*buffer[j];
			}


			if(index.at(i).x2>0)
			{
				temp=0.0;
				for(j=0;j<5;j++)
					temp+=ring_effect.at(index.at(i).x2-1).at(n).x[j];
				temp*=c_h_add[4];
				for(j=0;j<4;j++)
					temp+=ani_effect.at(index.at(i).x2-1).at(n).x[j]*c_h_add[j];
				pre[3]+=temp;
			}

			cs_ca.push_back(pre[0]);
			cs_cb.push_back(pre[1]);
			cs_c.push_back(pre[2]);
			cs_n.push_back(pre[4]);
			cs_h.push_back(pre[3]);
		}
	
		fprintf(fp,"%8d%8s",id,name);
		fprintf(fp,"   CA   ");
		fprintf(fp,"%8.3f",bb.at(index.at(i).x1-1).exp_ca);
		for(n=0;n<nconf;n++)
				fprintf(fp,"%8.3f",cs_ca.at(n));

		fprintf(fp,"\n%8d%8s",id,name);
		fprintf(fp,"   CB   ");
		fprintf(fp,"%8.3f",bb.at(index.at(i).x1-1).exp_cb);
		for(n=0;n<nconf;n++)
				fprintf(fp,"%8.3f",cs_cb.at(n));

		fprintf(fp,"\n%8d%8s",id,name);
		fprintf(fp,"   C    ");	
		fprintf(fp,"%8.3f",bb.at(index.at(i).x1-1).exp_co);
		for(n=0;n<nconf;n++)
				fprintf(fp,"%8.3f",cs_c.at(n));

		fprintf(fp,"\n%8d%8s",id,name);
		fprintf(fp,"   H    ");
		if(index.at(i).x2>1)
			fprintf(fp,"%8.3f",bbnh.at(index.at(i).x2-1).exp_h);
		else
			fprintf(fp,"%8.3f",999.0);
		for(n=0;n<nconf;n++)
				fprintf(fp,"%8.3f",cs_h.at(n));

		fprintf(fp,"\n%8d%8s",id,name);
		fprintf(fp,"   N    ");
		if(index.at(i).x2>1)
			fprintf(fp,"%8.3f",bbnh.at(index.at(i).x2-1).exp_n);
		else
			fprintf(fp,"%8.3f",999.0);
		for(n=0;n<nconf;n++)
				fprintf(fp,"%8.3f",cs_n.at(n));
		fprintf(fp,"\n");


		for(n=0;n<5;n++)
			pre[n]=0;
		for(n=0;n<nconf;n++)
		{
			pre[0]+=cs_ca.at(n);
			pre[1]+=cs_cb.at(n);
			pre[2]+=cs_c.at(n);
			pre[3]+=cs_h.at(n);
			pre[4]+=cs_n.at(n);
		}
		for(n=0;n<5;n++)
			pre[n]/=nconf;
		pre[5]=999.0;
		pdb->attach_bbprediction(id,pre);
	}
	return;
}






void CMainbody::predict_proton()
{
	int i,j;
	int id;
	char code;
	int type;

	double c_ring[5]={-0.1939,-0.1629,-0.1620,-0.1872,-0.1987};
	double c_ani[4]={0.004478932,0.000925861,0.001692256,0.00040848288};
	double c_rand[10]={1.3876,1.2671,2.0763,0.0000,1.0064,0.9611,0.9102,0.8890,0.9976,0.8584};

	
	double cs_ring,cs_ani,cs_rand,cs;


	vector< vector<double> > hs;
	hs.resize(2);


	vector<struct double_five> ring_effect;
	vector<struct double_four> ani_effect;

	traj->getani(&anistropy,&protons,&ani_effect);
	traj->getring(&ring_index,&protons,&ring_effect);
		


	for(i=0;i<(int)protons.size();i++)
	{	
		id=protons.at(i).id;
		code=protons.at(i).code;	
		type=protons.at(i).type;


		cs_ring=0;
		for(j=0;j<5;j++)
			cs_ring+=ring_effect.at(i).x[j]*c_ring[j];

		cs_ani=0;
		for(j=0;j<4;j++)
			cs_ani+=ani_effect.at(i).x[j]*c_ani[j];
		cs_rand=c_rand[type-1];
		cs=cs_ring+cs_ani+cs_rand;
		pdb->attach_protonprediction(id,protons.at(i).name,cs);

		hs.at(0).push_back(protons.at(i).exp);
		hs.at(1).push_back(cs);
	}

	compare("Methyl 1H",hs);
	return;
}

void CMainbody::predict_proton2()
{
	int i,j,ii;
	int id;
	char code;
	int type;
	double cs_rand;
	vector<double> cs_ring,cs_ani,cs;
	double ccs_ring,ccs_ani,ccs;
	FILE *fp;

	fp=fopen("proton_details.dat","w");

	double c_ring[5]={-0.1939,-0.1629,-0.1620,-0.1872,-0.1987};
	double c_ani[4]={0.004478932,0.000925861,0.001692256,0.00040848288};
	double c_rand[10]={1.3876,1.2671,2.0763,0.0000,1.0064,0.9611,0.9102,0.8890,0.9976,0.8584};

	vector< vector<struct double_five> > ring_effect;
	vector< vector<struct double_four> > ani_effect;
	traj->getani(&anistropy,&protons,&ani_effect);
	traj->getring(&ring_index,&protons,&ring_effect);

	for(i=0;i<(int)protons.size();i++)
	{	
		id=protons.at(i).id;
		code=protons.at(i).code;	
		type=protons.at(i).type;

		for(ii=0;ii<nconf;ii++)
		{
			cs_ring.push_back(0.0);
			cs_ani.push_back(0.0);
			cs.push_back(0.0);
		}
		for(ii=0;ii<nconf;ii++)
		{
			cs_ring[ii]=0;
			for(j=0;j<5;j++)
				cs_ring[ii]+=ring_effect.at(i).at(ii).x[j]*c_ring[j];
			cs_ani[ii]=0;
			for(j=0;j<4;j++)
				cs_ani[ii]+=ani_effect.at(i).at(ii).x[j]*c_ani[j];
			cs_rand=c_rand[type-1];
			cs[ii]=cs_ring[ii]+cs_ani[ii]+cs_rand;
		}
		fprintf(fp,"%8d %8s %8s",id,Sequence::code2name(code).c_str(),protons.at(i).name.c_str());
		if(fabs(protons.at(i).exp)>0.00001)
			fprintf(fp," %8.3f",protons.at(i).exp);
		else
			fprintf(fp," %8.3f",999.9);
		for(ii=0;ii<nconf;ii++)
			fprintf(fp," %8.3f",cs[ii]);
		fprintf(fp,"\n");


		ccs=ccs_ring=ccs_ani=0.0;
		for(ii=0;ii<nconf;ii++)
		{	
			ccs+=cs[ii];
			ccs_ring+=cs_ring[ii];
			ccs_ani+=cs_ani[ii];
		}
		ccs/=nconf;
		ccs_ring/=nconf;
		ccs_ani/=nconf;
		pdb->attach_protonprediction(id,protons.at(i).name,ccs);
	}
	fclose(fp);
	return;
}


void CMainbody::predict_proton_static_new(void)
{
	int i,j;
	int id;
	int type;
	vector<double> out;
	int jump;
	float pre;
	double *c;
	vector< vector<double> > hs;
	double clock;



	vector<struct double_five> ring_effect;
	vector<struct double_four> ani_effect;
	
	
	allprotons=allprotons3;
	clock = omp_get_wtime();
	traj->getani(&anistropy,&allprotons,&ani_effect);
	printf("%.4f getani(proton)\n", omp_get_wtime()-clock);
	clock = omp_get_wtime();
	traj->getring(&ring_index,&allprotons,&ring_effect);
	printf("%.4f getani(proton)\n", omp_get_wtime()-clock);

	hs.resize(2);

	
		
	for(i=0;i<(int)allprotons.size();i++)
	{		
		type=allprotons.at(i).type;
		id=allprotons.at(i).id;
		
		//too few data point and bad fitting !
		if(type==18 || type==19 || type==28 || type==49 || type==64  || type==82  || type==84  || type==97 )
			continue;
		//bad fitting !
		if(type==36 || type==48 || type==62 )
			continue;

		//use gobal or individual fitting?
		if(sep_table[type]>=0)
			c=c_sep[type-1];
		else
			c=c_all;

		jump=0;
		pre=c[type-1];
		jump+=98;

		for(j=0;j<5;j++)
			pre+=ring_effect.at(i).x[j]*c[j+jump];
		jump+=5;

		for(j=0;j<4;j++)
			pre+=ani_effect.at(i).x[j]*c[j+jump];
		jump+=4;

		dihe_process.allproton(allprotons.at(i).id); 
		dihe_process.hb_expand(type);
		out=dihe_process.output();
		for(j=0;j<8*18;j++)
			pre+=out.at(j)*c[j+jump];
		jump+=8*18;

		pdb->attach_protonprediction(id,allprotons.at(i).name,pre);
		if(allprotons.at(i).name2!="")
			pdb->attach_protonprediction(id,allprotons.at(i).name2,pre);

		hs.at(0).push_back(allprotons.at(i).exp);
		hs.at(1).push_back(pre);
	}
	compare("Side chain protons",hs);
	return;
}



void CMainbody::compare(char * buff, vector< vector<double> > t)
{
	int i,j,n;
	double e,ee;
	bool b;
	vector<bool> bs;

	for(i=0;i<(int)t.at(0).size();i++)
	{
		b=0;
		for(j=0;j<(int)t.size();j++)
		{
			if(t.at(j).at(i)<-400.0 || t.at(j).at(i)>400.0 )
				b=1;
		}
		bs.push_back(b);
		
	}

	cout<<buff<<": ";
	for(i=1;i<(int)t.size();i++)
	{
		ee=0;
		n=0;
		for(j=0;j<(int)t.at(0).size();j++)
		{
			if(bs.at(j)==0)
			{
				e=t.at(0).at(j)-t.at(i).at(j);
				ee+=e*e;
				n++;
			}
		}
		if(n>0)
		{
			ee/=n;
			ee=sqrt(ee);
			cout<<" "<<ee;
		}
		else
			cout<<" N.A.";
	}
	cout<<endl;
}

//This file include all trained parameters in PPM.
#include "data.h"

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// custom user modules 

#include "./custom_modules/cancer_immune_3D.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }
	
	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// PNRG setup 
	SeedRandom(); 
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); 

	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	create_cell_types();
	setup_tissue();
	
	/* Users typically start modifying here. START USERMODS */ 

	double immune_activation_time = 
		parameters.doubles("immune_activation_time"); // 60 * 24 * 14; // activate immune response at 14 days 
	
	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );
	
	// save a simulation snapshot 

	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = cancer_immune_coloring_function;
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	display_citations(); 
	
	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}

	//set the diffusion solver to GPU
	microenvironment.diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_3D_GPU;
	bool first = true;
	
	int outs = 0;

	// main loop 
	
	try 
	{	
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			if (outs == 1){
				microenvironment.translate_array_to_vector();
				sprintf( filename , "%s/first_out" , PhysiCell_settings.folder.c_str() ); 
				save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
			}


			static bool immune_cells_introduced = false; 
			if( PhysiCell_globals.current_time > immune_activation_time - 0.01*diffusion_dt && immune_cells_introduced == false )
			{
				std::cout << "Therapy activated!" << std::endl << std::endl; 
				immune_cells_introduced = true; 
				
				PhysiCell_settings.full_save_interval = 
					parameters.doubles("save_interval_after_therapy_start"); // 3.0; 
				PhysiCell_settings.SVG_save_interval = 
					parameters.doubles("save_interval_after_therapy_start"); // 3.0; 
				
				PhysiCell_globals.next_full_save_time = PhysiCell_globals.current_time; 
				PhysiCell_globals.next_SVG_save_time = PhysiCell_globals.current_time; 
				
				introduce_immune_cells();
			} 

			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				// translate data back to vector and update host
				if (first == false){
					std::cout << "updating host" << std::endl;
					microenvironment.translate_array_to_vector();
					std::cout << "-------continuing-------" << std::endl;
				}
				first = false;
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				std::cout << "2" << std::endl;
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
			}
			
			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			// if( default_microenvironment_options.calculate_gradients )
			// { microenvironment.compute_all_gradient_vectors(); }
			
			// run PhysiCell 
			// ((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			
			// manually call the code for cell sources and sinks, 
			// since these are ordinarily automatically done as part of phenotype.secretion in the 
			// PhysiCell update that we commented out above. Remove this when we go 
			// back to main code 
/*			
			#pragma omp parallel for 
			for( int i=0; i < (*all_cells).size(); i++ )
			{
				(*all_cells)[i]->phenotype.secretion.advance( (*all_cells)[i], (*all_cells)[i]->phenotype , diffusion_dt );
			}			
*/			
			PhysiCell_globals.current_time += diffusion_dt;
			outs++;
		}
		
		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	microenvironment.translate_array_to_vector();

	std::cout << "NUM_DIRICHLET " << microenvironment.num_dirichlet << std::endl;
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );

	return 0; 
}

########## NEXT FILE ##########
/*
#############################################################################
# If you use BioFVM in your project, please cite BioFVM and the version     #
# number, such as below:                                                    #
#                                                                           #
# We solved the diffusion equations using BioFVM (Version 1.1.7) [1]        #
#                                                                           #
# [1] A. Ghaffarizadeh, S.H. Friedman, and P. Macklin, BioFVM: an efficient #
#    parallelized diffusive transport solver for 3-D biological simulations,#
#    Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730 #
#                                                                           #
#############################################################################
#                                                                           #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)   #
#                                                                           #
# Copyright (c) 2015-2017, Paul Macklin and the BioFVM Project              #
# All rights reserved.                                                      #
#                                                                           #
# Redistribution and use in source and binary forms, with or without        #
# modification, are permitted provided that the following conditions are    #
# met:                                                                      #
#                                                                           #
# 1. Redistributions of source code must retain the above copyright notice, #
# this list of conditions and the following disclaimer.                     #
#                                                                           #
# 2. Redistributions in binary form must reproduce the above copyright      #
# notice, this list of conditions and the following disclaimer in the       #
# documentation and/or other materials provided with the distribution.      #
#                                                                           #
# 3. Neither the name of the copyright holder nor the names of its          #
# contributors may be used to endorse or promote products derived from this #
# software without specific prior written permission.                       #
#                                                                           #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS       #
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED #
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A           #
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER #
# OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  #
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,       #
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR        #
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF    #
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING      #
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS        #
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.              #
#                                                                           #
#############################################################################
*/

#include "BioFVM_microenvironment.h"
#include "BioFVM_solvers.h"
#include "BioFVM_vector.h"
#include <cmath>

#include "BioFVM_basic_agent.h"
#include "openacc.h"

namespace BioFVM{

extern std::string BioFVM_version; 
extern std::string BioFVM_URL; 

Microenvironment* default_microenvironment = NULL; 

void set_default_microenvironment( Microenvironment* M )
{ default_microenvironment = M; }
Microenvironment* get_default_microenvironment( void )
{ return default_microenvironment; }

void zero_function( std::vector<double>& position, std::vector<double>& input , std::vector<double>* write_destination )
{
	for( unsigned int i=0 ; i < write_destination->size() ; i++ )
	{ (*write_destination)[i] = 0.0; }
	return; 
}

void one_function( std::vector<double>& position, std::vector<double>& input , std::vector<double>* write_destination )
{
	for( unsigned int i=0 ; i < write_destination->size() ; i++ )
	{ (*write_destination)[i] = 1.0; }
	return; 
}

void zero_function( Microenvironment* pMicroenvironment, int voxel_index, std::vector<double>* write_destination ) 
{
	for( unsigned int i=0 ; i < write_destination->size() ; i++ )
	{ (*write_destination)[i] = 0.0; }
	return; 
}

void one_function( Microenvironment* pMicroenvironment, int voxel_index, std::vector<double>* write_destination )
{
	for( unsigned int i=0 ; i < write_destination->size() ; i++ )
	{ (*write_destination)[i] = 1.0; }
	return; 
}

void empty_diffusion_solver( Microenvironment& S, double dt )
{
	static bool setup_done = false; 
	if( !setup_done )
	{
		std::cout << "Using the empty diffusion solver ... " << std::endl; 
		setup_done = true; 
	}

	return; 
}

Microenvironment::Microenvironment()
{	
	name = "unnamed"; 
	spatial_units = "none"; 
	time_units = "none";
	
	bulk_source_sink_solver_setup_done = false; 
	thomas_setup_done = false; 
	diffusion_solver_setup_done = false; 

	diffusion_decay_solver = empty_diffusion_solver;
	diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_3D; 

	mesh.resize(1,1,1); 

	openacc_data_bool = false; // GPU init
	
	one.resize( 1 , 1.0 ); 
	zero.resize( 1 , 0.0 );
	
	temporary_density_vectors1.resize( mesh.voxels.size() , zero ); 
	temporary_density_vectors2.resize( mesh.voxels.size() , zero ); 
	p_density_vectors = &temporary_density_vectors1;

	gradient_vectors.resize( mesh.voxels.size() ); 
	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		gradient_vectors[k].resize( 1 ); 
		(gradient_vectors[k])[0].resize( 3, 0.0 );
	}
	gradient_vector_computed.resize( mesh.voxels.size() , false ); 

	bulk_supply_rate_function = zero_function; 
	bulk_supply_target_densities_function = zero_function; 
	bulk_uptake_rate_function = zero_function; 

	density_names.assign( 1 , "unnamed" ); 
	density_units.assign( 1 , "none" ); 

	diffusion_coefficients.assign( number_of_densities() , 0.0 ); 
	decay_rates.assign( number_of_densities() , 0.0 ); 
	
	one_half = one; 
	one_half *= 0.5; 
	
	one_third = one; 
	one_third /= 3.0;

/*	
	dirichlet_indices.clear();
	dirichlet_value_vectors.clear();
	
	dirichlet_node_map.assign( mesh.voxels.size() , -1 ); 
*/
	dirichlet_value_vectors.assign( mesh.voxels.size(), one ); 
	dirichlet_activation_vector.assign( 1 , true ); 
	
	if(default_microenvironment==NULL)
	{ default_microenvironment=this; }

	return; 
}

Microenvironment::Microenvironment(std::string name)
{	
	Microenvironment();
	this->name=name;
	
	return; 
}

void Microenvironment::add_dirichlet_node( int voxel_index, std::vector<double>& value )
{
	mesh.voxels[voxel_index].is_Dirichlet=true;
	/*
	dirichlet_indices.push_back( voxel_index );
	dirichlet_value_vectors.push_back( value ); 
	*/
	
	dirichlet_value_vectors[voxel_index] = value; // .assign( mesh.voxels.size(), one ); 
	
	return; 
}

void Microenvironment::update_dirichlet_node( int voxel_index , std::vector<double>& new_value )
{
/*
	if( mesh.voxels[voxel_index].is_Dirichlet == false )
	{ 
		std::cout << "BioFVM Warning: No Dirichlet condition previously specified at voxel " << voxel_index << "! Creating a new one now ... " << std::endl; 
		add_dirichlet_node( voxel_index , new_value ); 
		return; 
	}
	
	int n = 0; 
	while( dirichlet_indices[n] != voxel_index && n < dirichlet_indices.size() )
	{ n++; }
		
	if( n == dirichlet_indices.size() )
	{ 
		std::cout << "BioFVM Warning: No Dirichlet condition previously specified at voxel " << voxel_index << "! Creating a new one now ... " << std::endl; 
		add_dirichlet_node( voxel_index , new_value ); 
		return; 
	}

	dirichlet_value_vectors[n] = new_value; 
	*/
	
	mesh.voxels[voxel_index].is_Dirichlet = true; 
	dirichlet_value_vectors[voxel_index] = new_value; 
	
	return; 
}

void Microenvironment::update_dirichlet_node( int voxel_index , int substrate_index , double new_value )
{
	mesh.voxels[voxel_index].is_Dirichlet = true; 
	dirichlet_value_vectors[voxel_index][substrate_index] = new_value; 
	return; 
}

void Microenvironment::remove_dirichlet_node( int voxel_index )
{
	mesh.voxels[voxel_index].is_Dirichlet = false; 
	
/*	
	if( mesh.voxels[voxel_index].is_Dirichlet == false )
	{ 
		std::cout << "BioFVM Warning: No Dirichlet condition previously specified at voxel " << voxel_index << "! Nothing to remove!" << std::endl; 
		return; 
	}	
	
	int n = 0; 
	mesh.voxels[voxel_index].is_Dirichlet=false;
	while( dirichlet_indices[n] != voxel_index && n < dirichlet_indices.size() )
	{  n++; }
	
	if( n == dirichlet_indices.size() )
	{ 
		std::cout << "BioFVM Warning: No Dirichlet condition previously specified at voxel " << voxel_index << "! Nothing to remove!" << std::endl; 
		return; 
	}
	
	// swap with the final node and then remove it 	
	dirichlet_indices[n] = dirichlet_indices[ dirichlet_indices.size()-1 ]; 
	dirichlet_value_vectors[n] = dirichlet_value_vectors[ dirichlet_value_vectors.size()-1 ]; 
	dirichlet_indices.pop_back();
	dirichlet_value_vectors.pop_back();
*/
	
	return; 
}

bool& Microenvironment::is_dirichlet_node( int voxel_index )
{
	return mesh.voxels[voxel_index].is_Dirichlet; 
}

void Microenvironment::set_substrate_dirichlet_activation( int substrate_index , bool new_value )
{
	dirichlet_activation_vector[substrate_index] = new_value; 
	return; 
}

double Microenvironment::get_substrate_dirichlet_activation( int substrate_index )
{
	return dirichlet_activation_vector[substrate_index]; 
}

void Microenvironment::apply_dirichlet_conditions( void )
{
	/*
	#pragma omp parallel for 
	for( unsigned int i=0 ; i < dirichlet_indices.size() ; i++ )
	{ density_vector( dirichlet_indices[i] ) = dirichlet_value_vectors[i]; }
	*/

	#pragma omp parallel for 
	for( unsigned int i=0 ; i < mesh.voxels.size() ;i++ )
	{
		/*
		if( mesh.voxels[i].is_Dirichlet == true )
		{ density_vector(i) = dirichlet_value_vectors[i]; }
		*/
		if( mesh.voxels[i].is_Dirichlet == true )
		{
			for( unsigned int j=0; j < dirichlet_value_vectors[i].size(); j++ )
			{
				if( dirichlet_activation_vector[j] == true )
				{
					density_vector(i)[j] = dirichlet_value_vectors[i][j]; 
				}
			}
	
		}
	}
	return; 
}

void Microenvironment::resize_voxels( int new_number_of_voxes )
{
	if( mesh.Cartesian_mesh == true )
	{
		std::cout << "Error: only use Microenvironment::" << __FUNCTION__ << " as a fall-back for non-Cartesian meshes." << std::endl
				  << "\tUse one of the Microenvironment::resize_space() functions instead. Ignoring directive." << std::endl; 
		return; 
	}
	
	mesh.voxels.resize( new_number_of_voxes ); 
	
	temporary_density_vectors1.resize( mesh.voxels.size() , zero ); 
	temporary_density_vectors2.resize( mesh.voxels.size() , zero ); 
		
	gradient_vectors.resize( mesh.voxels.size() ); 
	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		gradient_vectors[k].resize( number_of_densities() ); 
		for( unsigned int i=0 ; i < number_of_densities() ; i++ )
		{
			(gradient_vectors[k])[i].resize( 3, 0.0 );
		}
	}
	gradient_vector_computed.resize( mesh.voxels.size() , false ); 	
	
	dirichlet_value_vectors.assign( mesh.voxels.size(), one ); 
	
	return; 
}


void Microenvironment::resize_space( int x_nodes, int y_nodes, int z_nodes )
{
	mesh.resize( x_nodes, y_nodes , z_nodes ); 

	temporary_density_vectors1.assign( mesh.voxels.size() , zero ); 
	temporary_density_vectors2.assign( mesh.voxels.size() , zero ); 
		
	gradient_vectors.resize( mesh.voxels.size() ); 
	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		gradient_vectors[k].resize( number_of_densities() ); 
		for( unsigned int i=0 ; i < number_of_densities() ; i++ )
		{
			(gradient_vectors[k])[i].resize( 3, 0.0 );
		}
	}
	gradient_vector_computed.resize( mesh.voxels.size() , false ); 	
	
	dirichlet_value_vectors.assign( mesh.voxels.size(), one ); 

	return;  
}

void Microenvironment::resize_space( double x_start, double x_end, double y_start, double y_end, double z_start, double z_end , int x_nodes, int y_nodes, int z_nodes )
{
	mesh.resize( x_start, x_end, y_start, y_end, z_start, z_end, x_nodes, y_nodes , z_nodes  ); 

	temporary_density_vectors1.assign( mesh.voxels.size() , zero ); 
	temporary_density_vectors2.assign( mesh.voxels.size() , zero ); 
	
	gradient_vectors.resize( mesh.voxels.size() ); 
	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		gradient_vectors[k].resize( number_of_densities() ); 
		for( unsigned int i=0 ; i < number_of_densities() ; i++ )
		{
			(gradient_vectors[k])[i].resize( 3, 0.0 );
		}
	}
	gradient_vector_computed.resize( mesh.voxels.size() , false ); 	

	dirichlet_value_vectors.assign( mesh.voxels.size(), one ); 
	
	return;  
}

void Microenvironment::resize_space( double x_start, double x_end, double y_start, double y_end, double z_start, double z_end , double dx_new , double dy_new , double dz_new )
{
	mesh.resize( x_start, x_end, y_start, y_end, z_start, z_end,  dx_new , dy_new , dz_new ); 

	temporary_density_vectors1.assign( mesh.voxels.size() , zero ); 
	temporary_density_vectors2.assign( mesh.voxels.size() , zero ); 
	
	gradient_vectors.resize( mesh.voxels.size() ); 
	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		gradient_vectors[k].resize( number_of_densities() ); 
		for( unsigned int i=0 ; i < number_of_densities() ; i++ )
		{
			(gradient_vectors[k])[i].resize( 3, 0.0 );
		}
	}
	gradient_vector_computed.resize( mesh.voxels.size() , false ); 	
	
	dirichlet_value_vectors.assign( mesh.voxels.size(), one ); 
	
	return;  
}

void Microenvironment::resize_space_uniform( double x_start, double x_end, double y_start, double y_end, double z_start, double z_end , double dx_new )
{
 return resize_space( x_start, x_end, y_start, y_end, z_start, z_end , dx_new , dx_new, dx_new ); 
}

void Microenvironment::resize_densities( int new_size )
{
	zero.assign( new_size, 0.0 ); 
	one.assign( new_size , 1.0 );

	temporary_density_vectors1.assign( mesh.voxels.size() , zero );
	temporary_density_vectors2.assign( mesh.voxels.size() , zero );

	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		gradient_vectors[k].resize( number_of_densities() ); 
		for( unsigned int i=0 ; i < number_of_densities() ; i++ )
		{
			(gradient_vectors[k])[i].resize( 3, 0.0 );
		}
	}
	gradient_vector_computed.resize( mesh.voxels.size() , false ); 	
	
	diffusion_coefficients.assign( new_size , 0.0 ); 
	decay_rates.assign( new_size , 0.0 ); 

	density_names.assign( new_size, "unnamed" ); 
	density_units.assign( new_size , "none" ); 

	one_half = one; 
	one_half *= 0.5; 
	
	one_third = one; 
	one_third /= 3.0; 
	
	dirichlet_value_vectors.assign( mesh.voxels.size(), one ); 
	dirichlet_activation_vector.assign( new_size, true ); 

	default_microenvironment_options.Dirichlet_condition_vector.assign( new_size , 1.0 );  
	default_microenvironment_options.Dirichlet_activation_vector.assign( new_size, true ); 
	
	default_microenvironment_options.initial_condition_vector.assign( new_size , 1.0 ); 
	
	return; 
}

void Microenvironment::add_density( void )
{
	// fix in PhysiCell preview November 2017 
	// default_microenvironment_options.use_oxygen_as_first_field = false; 
	
	// update 1, 0 
	zero.push_back( 0.0 ); 
	one.push_back( 1.0 );
	
	// update units
	density_names.push_back( "unnamed" ); 
	density_units.push_back( "none" ); 

	// update coefficients 
	diffusion_coefficients.push_back( 0.0 ); 
	decay_rates.push_back( 0.0 ); 
	
	// update sources and such 
	for( unsigned int i=0; i < temporary_density_vectors1.size() ; i++ )
	{
		temporary_density_vectors1[i].push_back( 0.0 ); 
		temporary_density_vectors2[i].push_back( 0.0 ); 
	}

	// resize the gradient data structures 
	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		gradient_vectors[k].resize( number_of_densities() ); 
		for( unsigned int i=0 ; i < number_of_densities() ; i++ )
		{
			(gradient_vectors[k])[i].resize( 3, 0.0 );
		}
	}

	gradient_vector_computed.resize( mesh.voxels.size() , false ); 	
	
	one_half = one; 
	one_half *= 0.5; 
	
	one_third = one; 
	one_third /= 3.0; 
	
	dirichlet_value_vectors.assign( mesh.voxels.size(), one ); 
	dirichlet_activation_vector.assign( number_of_densities(), true ); 
	
	// Fixes in PhysiCell preview November 2017
	default_microenvironment_options.Dirichlet_condition_vector.push_back( 1.0 ); //  = one; 
	default_microenvironment_options.Dirichlet_activation_vector.push_back( true ); // assign( number_of_densities(), true ); 
	
	default_microenvironment_options.initial_condition_vector.push_back( 1.0 ); 
	
	return; 
}

void Microenvironment::add_density( std::string name , std::string units )
{
	// fix in PhysiCell preview November 2017 
	// default_microenvironment_options.use_oxygen_as_first_field = false; 
	
	// update 1, 0 
	zero.push_back( 0.0 ); 
	one.push_back( 1.0 );

	// update units
	density_names.push_back( name ); 
	density_units.push_back( units ); 

	// update coefficients 
	diffusion_coefficients.push_back( 0.0 ); 
	decay_rates.push_back( 0.0 ); 
	
	// update sources and such 
	for( unsigned int i=0; i < temporary_density_vectors1.size() ; i++ )
	{
		temporary_density_vectors1[i].push_back( 0.0 ); 
		temporary_density_vectors2[i].push_back( 0.0 ); 
	}

	// resize the gradient data structures, 
	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		gradient_vectors[k].resize( number_of_densities() ); 
		for( unsigned int i=0 ; i < number_of_densities() ; i++ )
		{
			(gradient_vectors[k])[i].resize( 3, 0.0 );
		}
	}
	gradient_vector_computed.resize( mesh.voxels.size() , false ); 	

	one_half = one; 
	one_half *= 0.5; 
	
	one_third = one; 
	one_third /= 3.0; 
	
	dirichlet_value_vectors.assign( mesh.voxels.size(), one ); 
	dirichlet_activation_vector.assign( number_of_densities(), true ); 
	
	// fix in PhysiCell preview November 2017 
	default_microenvironment_options.Dirichlet_condition_vector.push_back( 1.0 ); //  = one; 
	default_microenvironment_options.Dirichlet_activation_vector.push_back( true ); // assign( number_of_densities(), true ); 

	default_microenvironment_options.initial_condition_vector.push_back( 1.0 ); 
	
	return; 
}

void Microenvironment::add_density( std::string name , std::string units, double diffusion_constant, double decay_rate )
{
	// fix in PhysiCell preview November 2017 
	// default_microenvironment_options.use_oxygen_as_first_field = false; 
	
	// update 1, 0 
	zero.push_back( 0.0 ); 
	one.push_back( 1.0 );
	
	// update units
	density_names.push_back( name ); 
	density_units.push_back( units ); 

	// update coefficients 
	diffusion_coefficients.push_back( diffusion_constant ); 
	decay_rates.push_back( decay_rate ); 
	
	// update sources and such 
	for( unsigned int i=0; i < temporary_density_vectors1.size() ; i++ )
	{
		temporary_density_vectors1[i].push_back( 0.0 ); 
		temporary_density_vectors2[i].push_back( 0.0 ); 
	}

	// resize the gradient data structures 
	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		gradient_vectors[k].resize( number_of_densities() ); 
		for( unsigned int i=0 ; i < number_of_densities() ; i++ )
		{
			(gradient_vectors[k])[i].resize( 3, 0.0 );
		}
	}
	gradient_vector_computed.resize( mesh.voxels.size() , false ); 	

	one_half = one; 
	one_half *= 0.5; 
	
	one_third = one; 
	one_third /= 3.0; 
	
	dirichlet_value_vectors.assign( mesh.voxels.size(), one ); 
	dirichlet_activation_vector.assign( number_of_densities(), true ); 
	
	// fix in PhysiCell preview November 2017 
	default_microenvironment_options.Dirichlet_condition_vector.push_back( 1.0 ); // = one; 
	default_microenvironment_options.Dirichlet_activation_vector.push_back( true ); // assign( number_of_densities(), true ); 
	
	default_microenvironment_options.initial_condition_vector.push_back( 1.0 ); 
	
	return; 
}

int Microenvironment::find_density_index( std::string name )
{
	for( unsigned int i=0; i < density_names.size() ; i++ )
	{
		if( density_names[i] == name )
		{ return i; }
	}
	return -1; 
}

void Microenvironment::set_density( int index , std::string name , std::string units )
{
	// fix in PhysiCell preview November 2017 
	if( index == 0 )
	{ default_microenvironment_options.use_oxygen_as_first_field = false; }
	
	density_names[index] = name; 
	density_units[index] = units; 
	return; 
}

void Microenvironment::set_density( int index , std::string name , std::string units , double diffusion_constant , double decay_rate )
{
	// fix in PhysiCell preview November 2017 
	if( index == 0 )
	{ default_microenvironment_options.use_oxygen_as_first_field = false; }
	
	density_names[index] = name; 
	density_units[index] = units; 
	
	diffusion_coefficients[index] = diffusion_constant; 
	decay_rates[index] = decay_rate;	
	return; 
}

#pragma acc routine
int Microenvironment::voxel_index( int i, int j, int k )
{ return mesh.voxel_index(i,j,k) ; }

std::vector<unsigned int> Microenvironment::cartesian_indices( int n )
{ return mesh.cartesian_indices( n ); }

int Microenvironment::nearest_voxel_index( std::vector<double>& position )
{ return mesh.nearest_voxel_index( position ); }

Voxel& Microenvironment::voxels( int voxel_index )
{ return mesh.voxels[voxel_index]; }

std::vector<unsigned int> Microenvironment::nearest_cartesian_indices( std::vector<double>& position )
{ return mesh.nearest_cartesian_indices( position ); }
 
Voxel& Microenvironment::nearest_voxel( std::vector<double>& position )
{ return mesh.nearest_voxel( position ); }

std::vector<double>& Microenvironment::nearest_density_vector( std::vector<double>& position )
{ return (*p_density_vectors)[ mesh.nearest_voxel_index( position ) ]; }

std::vector<double>& Microenvironment::nearest_density_vector( int voxel_index )
{ return (*p_density_vectors)[ voxel_index ]; }

std::vector<double>& Microenvironment::operator()( int i, int j, int k )
{ return (*p_density_vectors)[ voxel_index(i,j,k) ]; }

std::vector<double>& Microenvironment::operator()( int i, int j )
{ return (*p_density_vectors)[ voxel_index(i,j,0) ]; }

std::vector<double>& Microenvironment::operator()( int n )
{ return (*p_density_vectors)[ n ]; }

std::vector<double>& Microenvironment::density_vector( int i, int j, int k )
{ return (*p_density_vectors)[ voxel_index(i,j,k) ]; }

std::vector<double>& Microenvironment::density_vector( int i, int j )
{ return (*p_density_vectors)[ voxel_index(i,j,0) ]; }

std::vector<double>& Microenvironment::density_vector( int n )
{ return (*p_density_vectors)[ n ]; }

#pragma acc routine
double& Microenvironment::density_vector_GPU( int n )
{ return (*gpu_p_density_vectors)[ n ]; }

void Microenvironment::simulate_diffusion_decay( double dt )
{
	if( diffusion_decay_solver )
	{ diffusion_decay_solver( *this, dt ); }
	else
	{
		std::cout << "Warning: diffusion-reaction-source/sink solver not set for Microenvironment object at " << this << ". Nothing happened!" << std::endl; 
		std::cout << "   Consider using Microenvironment::auto_choose_diffusion_decay_solver(void) ... " << std::endl 
		<< std::endl; 
	}
	return; 
}

void Microenvironment::auto_choose_diffusion_decay_solver( void )
{
	// set the safest choice 
	diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_explicit; 

	std::cout << "Warning: auto-selection of diffusion-decay-source/sink solver not fully implemented!" << std::endl;

 // eventual logic: if non-Cartesian, use explicit
 // if Cartesian, if non-variable, use the constant coefficient super-fast code
 // otherwise, use the variable coefficient code 

}
 
void Microenvironment::display_information( std::ostream& os )
{
	os << std::endl << "Microenvironment summary: " << name << ": " << std::endl; 
	mesh.display_information( os ); 
	os << "Densities: (" << number_of_densities() << " total)" << std::endl; 
	for( unsigned int i = 0 ; i < density_names.size() ; i++ )
	{
		os << "   " << density_names[i] << ":" << std::endl
		<< "     units: " << density_units[i] << std::endl 
		<< "     diffusion coefficient: " << diffusion_coefficients[i]  
			<< " " << spatial_units << "^2 / " << time_units << std::endl
		<< "     decay rate: " << decay_rates[i] 
			<< " " << time_units << "^-1" << std::endl 
		<< "     diffusion length scale: " << sqrt( diffusion_coefficients[i] / ( 1e-12 + decay_rates[i] ) ) 
			<< " " << spatial_units << std::endl 
		<< "     initial condition: " << default_microenvironment_options.initial_condition_vector[i] 
			<< " " << density_units[i] << std::endl 
		<< "     boundary condition: " << default_microenvironment_options.Dirichlet_condition_vector[i] 
			<< " " << density_units[i] << " (enabled: "; 
		if( dirichlet_activation_vector[i] == true )
		{ os << "true"; }
		else
		{ os << "false"; }
		os << ")" << std::endl; 
	}
	os << std::endl; 
	
	return; 
}
	
unsigned int Microenvironment::number_of_densities( void )
{ return (*p_density_vectors)[0].size(); }

unsigned int Microenvironment::number_of_voxels( void )
{ return mesh.voxels.size(); }

unsigned int Microenvironment::number_of_voxel_faces( void )
{ return mesh.voxel_faces.size(); } 

void Microenvironment::write_to_matlab( std::string filename )
{
	int number_of_data_entries = mesh.voxels.size();
	int size_of_each_datum = 3 + 1 + (*p_density_vectors)[0].size(); 

	FILE* fp = write_matlab_header( size_of_each_datum, number_of_data_entries,  filename, "multiscale_microenvironment" );  

	// storing data as cols 
	for( int i=0; i < number_of_data_entries ; i++ )
	{
		fwrite( (char*) &( mesh.voxels[i].center[0] ) , sizeof(double) , 1 , fp ); 
		fwrite( (char*) &( mesh.voxels[i].center[1] ) , sizeof(double) , 1 , fp );   
		fwrite( (char*) &( mesh.voxels[i].center[2] ) , sizeof(double) , 1 , fp ); 
		fwrite( (char*) &( mesh.voxels[i].volume ) , sizeof(double) , 1 , fp ); 

		// densities  

		for( unsigned int j=0 ; j < (*p_density_vectors)[i].size() ; j++)
		{ fwrite( (char*) &( ((*p_density_vectors)[i])[j] ) , sizeof(double) , 1 , fp ); }
	}

	fclose( fp ); 
	return;
}



void Microenvironment::simulate_bulk_sources_and_sinks( double dt )
{
	if( !bulk_source_sink_solver_setup_done )
	{
		bulk_source_sink_solver_temp1.resize( mesh.voxels.size() , zero );
		bulk_source_sink_solver_temp2.resize( mesh.voxels.size() , zero );
		bulk_source_sink_solver_temp3.resize( mesh.voxels.size() , zero );
		
		bulk_source_sink_solver_setup_done = true; 
	}
	
	#pragma omp parallel for
	for( unsigned int i=0; i < mesh.voxels.size() ; i++ )
	{
		bulk_supply_rate_function( this,i, &bulk_source_sink_solver_temp1[i] ); // temp1 = S
		bulk_supply_target_densities_function( this,i, &bulk_source_sink_solver_temp2[i]); // temp2 = T
		bulk_uptake_rate_function( this,i, &bulk_source_sink_solver_temp3[i] ); // temp3 = U

		
		bulk_source_sink_solver_temp2[i] *= bulk_source_sink_solver_temp1[i]; // temp2 = S*T
		axpy( &(*p_density_vectors)[i] , dt , bulk_source_sink_solver_temp2[i] ); // out = out + dt*temp2 = out + dt*S*T
		bulk_source_sink_solver_temp3[i] += bulk_source_sink_solver_temp1[i]; // temp3 = U+S
		bulk_source_sink_solver_temp3[i] *= dt; // temp3 = dt*(U+S)
		bulk_source_sink_solver_temp3[i] += one; // temp3 = 1 + dt*(U+S)
		
		(*p_density_vectors)[i] /= bulk_source_sink_solver_temp3[i];
	}
	
	return; 
}

void Microenvironment::simulate_cell_sources_and_sinks( std::vector<Basic_Agent*>& basic_agent_list , double dt )
{
	#pragma omp parallel for
	for( unsigned int i=0 ; i < basic_agent_list.size() ; i++ )
	{		
		basic_agent_list[i]->simulate_secretion_and_uptake( this , dt ); 
	}
	
	return; 
}

void Microenvironment::simulate_cell_sources_and_sinks( double dt )
{
	simulate_cell_sources_and_sinks(all_basic_agents, dt);
}

void Microenvironment::update_rates( void )
{
	if( supply_target_densities_times_supply_rates.size() != number_of_voxels() )
	{ supply_target_densities_times_supply_rates.assign( number_of_voxels() , zero ); }

	if( supply_rates.size() != number_of_voxels() )
	{ supply_rates.assign( number_of_voxels() , zero ); }
	
	if( uptake_rates.size() != number_of_voxels() )
	{ uptake_rates.assign( number_of_voxels() , zero ); }

	#pragma omp parallel for 
	for( unsigned int i=0 ; i < number_of_voxels() ; i++ )
	{
		bulk_uptake_rate_function( this,i, &(uptake_rates[i]) ); 		
		bulk_supply_rate_function( this,i, &(supply_rates[i]) ); 		
		bulk_supply_target_densities_function( this,i, &(supply_target_densities_times_supply_rates[i]) );
		
		supply_target_densities_times_supply_rates[i] *= supply_rates[i]; 
	}
	return; 
}

std::vector<gradient>& Microenvironment::gradient_vector(int i, int j, int k)
{
	int n = voxel_index(i,j,k);
	if( gradient_vector_computed[n] == false )
	{
		compute_gradient_vector( n );
	}
	
	return gradient_vectors[n];
}

std::vector<gradient>& Microenvironment::gradient_vector(int i, int j )
{
	int n = voxel_index(i,j,0);
	if( gradient_vector_computed[n] == false )
	{
		compute_gradient_vector( n );
	}
	
	return gradient_vectors[n];
}

std::vector<gradient>& Microenvironment::gradient_vector(int n )
{
	// if the gradient has not yet been computed, then do it!
	if( gradient_vector_computed[n] == false )
	{
		compute_gradient_vector( n );
	}
	
	
	return gradient_vectors[n];
}
	
std::vector<gradient>& Microenvironment::nearest_gradient_vector( std::vector<double>& position )
{
	int n = nearest_voxel_index( position );
	if( gradient_vector_computed[n] == false )
	{
		compute_gradient_vector( n );
	}
	
	return gradient_vectors[n];
}

void Microenvironment::compute_all_gradient_vectors( void )
{
	static double two_dx = mesh.dx; 
	static double two_dy = mesh.dy; 
	static double two_dz = mesh.dz; 
	static bool gradient_constants_defined = false; 
	if( gradient_constants_defined == false )
	{
		two_dx *= 2.0; 
		two_dy *= 2.0; 
		two_dz *= 2.0;
		gradient_constants_defined = true; 
	}
	
	#pragma omp parallel for 
	for( unsigned int k=0; k < mesh.z_coordinates.size() ; k++ )
	{
		for( unsigned int j=0; j < mesh.y_coordinates.size() ; j++ )
		{
			
			for( unsigned int i=1; i < mesh.x_coordinates.size()-1 ; i++ )
			{
				for( unsigned int q=0; q < number_of_densities() ; q++ )
				{
					int n = voxel_index(i,j,k);
					// x-derivative of qth substrate at voxel n
					gradient_vectors[n][q][0] = (*p_density_vectors)[n+thomas_i_jump][q]; 
					gradient_vectors[n][q][0] -= (*p_density_vectors)[n-thomas_i_jump][q]; 
					gradient_vectors[n][q][0] /= two_dx; 
					
					gradient_vector_computed[n] = true; 
 				}
			}
			
		}
	}
	
	#pragma omp parallel for 
	for( unsigned int k=0; k < mesh.z_coordinates.size() ; k++ )
	{
		for( unsigned int i=0; i < mesh.x_coordinates.size() ; i++ )
		{
			
			for( unsigned int j=1; j < mesh.y_coordinates.size()-1 ; j++ )
			{
				for( unsigned int q=0; q < number_of_densities() ; q++ )
				{
					int n = voxel_index(i,j,k);
					// y-derivative of qth substrate at voxel n
					gradient_vectors[n][q][1] = (*p_density_vectors)[n+thomas_j_jump][q]; 
					gradient_vectors[n][q][1] -= (*p_density_vectors)[n-thomas_j_jump][q]; 
					gradient_vectors[n][q][1] /= two_dy; 
					gradient_vector_computed[n] = true; 
				}
			}
			
		}
	}

	#pragma omp parallel for 
	for( unsigned int j=0; j < mesh.y_coordinates.size() ; j++ )
	{
		for( unsigned int i=0; i < mesh.x_coordinates.size() ; i++ )
		{
			
			for( unsigned int k=1; k < mesh.z_coordinates.size()-1 ; k++ )
			{
				for( unsigned int q=0; q < number_of_densities() ; q++ )
				{
					int n = voxel_index(i,j,k);
					// y-derivative of qth substrate at voxel n
					gradient_vectors[n][q][2] = (*p_density_vectors)[n+thomas_k_jump][q]; 
					gradient_vectors[n][q][2] -= (*p_density_vectors)[n-thomas_k_jump][q]; 
					gradient_vectors[n][q][2] /= two_dz; 
					gradient_vector_computed[n] = true; 
				}
			}
			
		}
	}

	return; 
}

void Microenvironment::compute_gradient_vector( int n )
{
	static double two_dx = mesh.dx; 
	static double two_dy = mesh.dy; 
	static double two_dz = mesh.dz; 
	static bool gradient_constants_defined = false; 
	std::vector<unsigned int> indices(3,0);
	
	if( gradient_constants_defined == false )
	{
		two_dx *= 2.0; 
		two_dy *= 2.0; 
		two_dz *= 2.0;
		gradient_constants_defined = true; 
	}	
	
	indices = cartesian_indices( n );
	
	// d/dx 
	if( indices[0] > 0 && indices[0] < mesh.x_coordinates.size()-1 )
	{
		for( unsigned int q=0; q < number_of_densities() ; q++ )
		{
			gradient_vectors[n][q][0] = (*p_density_vectors)[n+thomas_i_jump][q]; 
			gradient_vectors[n][q][0] -= (*p_density_vectors)[n-thomas_i_jump][q]; 
			gradient_vectors[n][q][0] /= two_dx; 
			gradient_vector_computed[n] = true; 
		}
	}
	
	// d/dy 
	if( indices[1] > 0 && indices[1] < mesh.y_coordinates.size()-1 )
	{
		for( unsigned int q=0; q < number_of_densities() ; q++ )
		{
			gradient_vectors[n][q][1] = (*p_density_vectors)[n+thomas_j_jump][q]; 
			gradient_vectors[n][q][1] -= (*p_density_vectors)[n-thomas_j_jump][q]; 
			gradient_vectors[n][q][1] /= two_dy; 
			gradient_vector_computed[n] = true; 
		}
	}
	
	// d/dz 
	if( indices[2] > 0 && indices[2] < mesh.z_coordinates.size()-1 )
	{
		for( unsigned int q=0; q < number_of_densities() ; q++ )
		{
			gradient_vectors[n][q][2] = (*p_density_vectors)[n+thomas_k_jump][q]; 
			gradient_vectors[n][q][2] -= (*p_density_vectors)[n-thomas_k_jump][q]; 
			gradient_vectors[n][q][2] /= two_dz; 
			gradient_vector_computed[n] = true; 
		}
	}
	
	return; 
}

void Microenvironment::reset_all_gradient_vectors( void )
{
	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		for( unsigned int i=0 ; i < number_of_densities() ; i++ )
		{
			(gradient_vectors[k])[i].resize( 3, 0.0 );
		}
	}
	gradient_vector_computed.assign( mesh.voxels.size() , false ); 	
}


Microenvironment microenvironment; 

Microenvironment_Options::Microenvironment_Options()
{
	use_oxygen_as_first_field = true; 
	
	if( get_default_microenvironment() != NULL )
	{
		pMicroenvironment = get_default_microenvironment(); 
	}
	else
	{
		pMicroenvironment = &microenvironment; 
		set_default_microenvironment( pMicroenvironment ); 
	}
	name = "microenvironment"; 
	
	time_units = "min"; 
	spatial_units = "micron"; 
	dx = 20; 
	dy = 20; 
	dz = 20; 
	
	outer_Dirichlet_conditions = false; 
	Dirichlet_condition_vector.assign( pMicroenvironment->number_of_densities() , 1.0 ); 
	Dirichlet_activation_vector.assign( pMicroenvironment->number_of_densities() , true ); 
	
	initial_condition_vector.resize(0); //  = Dirichlet_condition_vector; 
	
	// set a far-field value for oxygen (assumed to be in the first field)
	Dirichlet_condition_vector[0] = 38.0; 
	
	simulate_2D = false; 
	
	X_range.resize(2,500.0); 
	X_range[0] *= -1.0;
	
	Y_range.resize(2,500.0); 
	Y_range[0] *= -1.0;
	
	Z_range.resize(2,500.0); 
	Z_range[0] *= -1.0;
	
	calculate_gradients = false; 
	
	track_internalized_substrates_in_each_agent = false; 
	
	return; 
}

Microenvironment_Options default_microenvironment_options; 

void initialize_microenvironment( void )
{
	// create and name a microenvironment; 
	microenvironment.name = default_microenvironment_options.name;
	// register the diffusion solver 
	if( default_microenvironment_options.simulate_2D == true )
	{
		microenvironment.diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_2D; 
	}
	else
	{
		microenvironment.diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_3D; 
	}
	
	// set the default substrate to oxygen (with typical units of mmHg)
	if( default_microenvironment_options.use_oxygen_as_first_field == true )
	{
		microenvironment.set_density(0, "oxygen" , "mmHg" );
		microenvironment.diffusion_coefficients[0] = 1e5; 
		microenvironment.decay_rates[0] = 0.1; 
	}
	
	// resize the microenvironment  
	if( default_microenvironment_options.simulate_2D == true )
	{
		default_microenvironment_options.Z_range[0] = -default_microenvironment_options.dz/2.0; 
		default_microenvironment_options.Z_range[1] = default_microenvironment_options.dz/2.0;
	}
	microenvironment.resize_space( default_microenvironment_options.X_range[0], default_microenvironment_options.X_range[1] , 
		default_microenvironment_options.Y_range[0], default_microenvironment_options.Y_range[1], 
		default_microenvironment_options.Z_range[0], default_microenvironment_options.Z_range[1], 
		default_microenvironment_options.dx,default_microenvironment_options.dy,default_microenvironment_options.dz );
		
	// set units
	microenvironment.spatial_units = default_microenvironment_options.spatial_units;
	microenvironment.time_units = default_microenvironment_options.time_units;
	microenvironment.mesh.units = default_microenvironment_options.spatial_units;

	// set the initial densities to the values set in the initial_condition_vector
	
	// if the initial condition vector has not been set, use the Dirichlet condition vector 
	if( default_microenvironment_options.initial_condition_vector.size() != 
		microenvironment.number_of_densities() )
	{
		std::cout << "BioFVM Warning: Initial conditions not set. " << std::endl 
				  << "                Using Dirichlet condition vector to set initial substrate values!" << std::endl 
				  << "                In the future, set default_microenvironment_options.initial_condition_vector." 
				  << std::endl << std::endl;  
		default_microenvironment_options.initial_condition_vector = default_microenvironment_options.Dirichlet_condition_vector; 
	}
	
	for( unsigned int n=0; n < microenvironment.number_of_voxels() ; n++ )
	{ microenvironment.density_vector(n) = default_microenvironment_options.initial_condition_vector; }
	
	if( default_microenvironment_options.outer_Dirichlet_conditions == true ) 
	{
		
		for( unsigned int k=0 ; k < microenvironment.mesh.z_coordinates.size() ; k++ )
		{
			// set Dirichlet conditions along the 4 outer edges 
			for( unsigned int i=0 ; i < microenvironment.mesh.x_coordinates.size() ; i++ )
			{
				int J = microenvironment.mesh.y_coordinates.size()-1;
				microenvironment.add_dirichlet_node( microenvironment.voxel_index(i,0,k) , default_microenvironment_options.Dirichlet_condition_vector );
				microenvironment.add_dirichlet_node( microenvironment.voxel_index(i,J,k) , default_microenvironment_options.Dirichlet_condition_vector );
			}
			int I = microenvironment.mesh.x_coordinates.size()-1;
			for( unsigned int j=1; j < microenvironment.mesh.y_coordinates.size()-1 ; j++ )
			{
				microenvironment.add_dirichlet_node( microenvironment.voxel_index(0,j,k) , default_microenvironment_options.Dirichlet_condition_vector );
				microenvironment.add_dirichlet_node( microenvironment.voxel_index(I,j,k) , default_microenvironment_options.Dirichlet_condition_vector );
			}		
		}
		// if 3-D, also along the corresponding additional faces 
		if( default_microenvironment_options.simulate_2D == false )
		{
			int K = microenvironment.mesh.z_coordinates.size()-1; 
			for( unsigned int j=1 ; j < microenvironment.mesh.y_coordinates.size()-1 ; j++ )
			{
				for( unsigned int i=1; i < microenvironment.mesh.x_coordinates.size()-1 ; i++ )
				{
					microenvironment.add_dirichlet_node( microenvironment.voxel_index(i,j,0) , default_microenvironment_options.Dirichlet_condition_vector );
					microenvironment.add_dirichlet_node( microenvironment.voxel_index(i,j,K) , default_microenvironment_options.Dirichlet_condition_vector );
				}	
			}	
		}
		
	}
	
	// set the Dirichlet condition activation vector to match the microenvironment options 
	for( int i=0 ; i < default_microenvironment_options.Dirichlet_activation_vector.size(); i++ )
	{
		microenvironment.set_substrate_dirichlet_activation( i , default_microenvironment_options.Dirichlet_activation_vector[i] ); 
	}
	
	microenvironment.display_information( std::cout );
	return;
}

int Microenvironment::get_size_p1()
{
	return (*p_density_vectors).size();
}

int Microenvironment::get_size_p2()
{
	return (*p_density_vectors)[0].size();
}

void Microenvironment::transfer_2D()
{
	// start gpu_p_density_vectors
	const int bin_p_density_vectors = (*p_density_vectors).size();

	gpu_p_density_vectors = new double*[bin_p_density_vectors];

	sizes_p_density_vectors = new int[bin_p_density_vectors];
	#pragma acc enter data copyin(this[0:1])
	#pragma acc enter data create(this->gpu_p_density_vectors[0:bin_p_density_vectors][0:0])

	for (int i = 0; i < bin_p_density_vectors; i++){
		int sze = (*p_density_vectors)[i].size();
		sizes_p_density_vectors[i] = sze;
		gpu_p_density_vectors[i] = (*p_density_vectors)[i].data();
		#pragma acc enter data copyin(this->gpu_p_density_vectors[i:1][:sze])
	}
	#pragma acc enter data copyin(this->sizes_p_density_vectors[:bin_p_density_vectors])
	// end gpu_p_density_vectors

	// start gpu_thomas_constant1
	const int bin_thomas_constant1 = thomas_constant1.size();

	gpu_thomas_constant1 = new double [bin_thomas_constant1];

	sizes_thomas_constant1 = bin_thomas_constant1;
	#pragma acc enter data create(this->gpu_thomas_constant1[0:bin_thomas_constant1])

		//gpu_thomas_constant1[e] = thomas_constant1.at(e);
		gpu_thomas_constant1 = thomas_constant1.data();

	#pragma acc enter data copyin(this->gpu_thomas_constant1[:bin_thomas_constant1])
	#pragma acc enter data copyin(this->sizes_thomas_constant1)
	// end gpu_thomas_constant1
	
	// start gpu_thomas_denomx
	const int bin_thomas_denomx = thomas_denomx.size();

	gpu_thomas_denomx = new double * [bin_thomas_denomx];

	sizes_thomas_denomx = new int [bin_thomas_denomx];

	#pragma acc enter data create(this->gpu_thomas_denomx[0:bin_thomas_denomx][0:0])
	for (int i = 0; i < bin_thomas_denomx; i ++) {
		int sze = thomas_denomx[i].size();
		gpu_thomas_denomx[i] = thomas_denomx[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_denomx[i:1][:sze])
	}	
	// pragma acc enter data sizes
	// end gpu_thomas_denomx
	
	// start gpu_thomas_denomy
	const int bin_thomas_denomy = thomas_denomy.size();

	gpu_thomas_denomy = new double * [bin_thomas_denomy];

	sizes_thomas_denomy = new int [bin_thomas_denomy];

	#pragma acc enter data create(this->gpu_thomas_denomy[0:bin_thomas_denomy][0:0])
	for (int i = 0; i < bin_thomas_denomy; i ++) {
		int sze = thomas_denomy[i].size();
		gpu_thomas_denomy[i] = thomas_denomy[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_denomy[i:1][:sze])
	}	
	// pragma acc enter data sizes
	// end gpu_thomas_denomy
	
	// start gpu_thomas_i_jump
	gpu_thomas_i_jump = new int;

	*gpu_thomas_i_jump = thomas_i_jump;

	#pragma acc enter data copyin(this->gpu_thomas_i_jump)
	// end gpu_thomas_i_jump
	
	// start gpu_thomas_j_jump
	gpu_thomas_j_jump = new int;

	*gpu_thomas_j_jump = thomas_j_jump;

	#pragma acc enter data copyin(this->gpu_thomas_j_jump)
	// end gpu_thomas_j_jump
	
	// start gpu_thomas_cx
	const int bin_thomas_cx = thomas_cx.size();

	gpu_thomas_cx = new double * [bin_thomas_cx];

	sizes_thomas_cx = new int [bin_thomas_cx];

	#pragma acc enter data create(this->gpu_thomas_cx[0:bin_thomas_cx][0:0])
	for (int i = 0; i < bin_thomas_cx; i ++) {
		int sze = thomas_cx[i].size();
		gpu_thomas_cx[i] = thomas_cx[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_cx[i:1][:sze])
	}
	// end gpu_thomas_cx
	
	// start gpu_thomas_cy
	const int bin_thomas_cy = thomas_cy.size();

	gpu_thomas_cy = new double * [bin_thomas_cy];

	sizes_thomas_cy = new int [bin_thomas_cy];

	#pragma acc enter data create(this->gpu_thomas_cy[0:bin_thomas_cy][0:0])
	for (int i = 0; i < bin_thomas_cy; i ++) {
		int sze = thomas_cy[i].size();
		gpu_thomas_cy[i] = thomas_cy[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_cy[i:1][:sze])
	}
	// end gpu_thomas_cy
	
	// start gpu_dirichlet_value_vectors
	const int bin_dirichlet_value_vectors = dirichlet_value_vectors.size();

	gpu_dirichlet_value_vectors = new double * [bin_dirichlet_value_vectors];

	sizes_dirichlet_value_vectors = new int [bin_dirichlet_value_vectors];

	#pragma acc enter data create(this->gpu_dirichlet_value_vectors[0:bin_dirichlet_value_vectors][0:0])
	for (int i = 0; i < bin_dirichlet_value_vectors; i++) {
		int sze = dirichlet_value_vectors[i].size();
		sizes_dirichlet_value_vectors[i] = sze;
		gpu_dirichlet_value_vectors[i] = dirichlet_value_vectors[i].data();
		#pragma acc enter data copyin(this->gpu_dirichlet_value_vectors[i:1][:sze])
	}	
	#pragma acc enter data copyin(this->sizes_dirichlet_value_vectors[:bin_dirichlet_value_vectors])
	// end gpu_dirichlet_value_vectors
	
	// start gpu_dirichlet_activation_vector
	const int bin_dirichlet_activation_vector = dirichlet_activation_vector.size();

	gpu_dirichlet_activation_vector = new bool [bin_dirichlet_activation_vector];

	#pragma acc enter data create(this->gpu_dirichlet_activation_vector[0:bin_dirichlet_activation_vector])
	for (int i = 0; i < bin_dirichlet_activation_vector; i++) {
		gpu_dirichlet_activation_vector[i] = dirichlet_activation_vector.at(i);
	}
/*
 *potential error here, move copyin to inside interation?
 */
	#pragma acc enter data copyin(this->gpu_dirichlet_activation_vector[:bin_dirichlet_activation_vector])
	// end gpu_dirichlet_activation_vector
	
	// start gpu_voxel_is_dirichlet
	const int bin_mesh = mesh.voxels.size();

	gpu_voxels_is_dirichlet = new bool [bin_mesh];

	#pragma acc enter data create(this->gpu_voxels_is_dirichlet[0:bin_mesh])
	for (int i = 0; i < bin_mesh; i ++) {
		gpu_voxels_is_dirichlet[i] = mesh.voxels[i].is_Dirichlet;
	}
	#pragma acc enter data copyin(this->gpu_voxels_is_dirichlet[:bin_mesh])
	// end gpu_voxel_is_dirichlet

	std::cout << "Done transfer" << std::endl;
}

void Microenvironment::transfer_3D()
{
	// start gpu_p_density_vectors
	const int bin_p_density_vectors = (*p_density_vectors).size();

	gpu_p_density_vectors = new double*[bin_p_density_vectors];

	sizes_p_density_vectors = new int[bin_p_density_vectors];
	#pragma acc enter data copyin(this[0:1])
	#pragma acc enter data create(this->gpu_p_density_vectors[0:bin_p_density_vectors][0:0])

	for (int i = 0; i < bin_p_density_vectors; i++){
		int sze = (*p_density_vectors)[i].size();
		sizes_p_density_vectors[i] = sze;
		gpu_p_density_vectors[i] = (*p_density_vectors)[i].data();
		#pragma acc enter data copyin(this->gpu_p_density_vectors[i:1][:sze])
	}
	#pragma acc enter data copyin(this->sizes_p_density_vectors[:bin_p_density_vectors])
	// end gpu_p_density_vectors

	// start gpu_thomas_constant1
	const int bin_thomas_constant1 = thomas_constant1.size();

	gpu_thomas_constant1 = new double [bin_thomas_constant1];

	sizes_thomas_constant1 = bin_thomas_constant1;
	#pragma acc enter data create(this->gpu_thomas_constant1[0:bin_thomas_constant1])

		//gpu_thomas_constant1[e] = thomas_constant1.at(e);
		gpu_thomas_constant1 = thomas_constant1.data();

	#pragma acc enter data copyin(this->gpu_thomas_constant1[:bin_thomas_constant1])
	#pragma acc enter data copyin(this->sizes_thomas_constant1)
	// end gpu_thomas_constant1
	
	// start gpu_thomas_denomx
	const int bin_thomas_denomx = thomas_denomx.size();

	gpu_thomas_denomx = new double * [bin_thomas_denomx];

	sizes_thomas_denomx = new int [bin_thomas_denomx];

	#pragma acc enter data create(this->gpu_thomas_denomx[0:bin_thomas_denomx][0:0])
	for (int i = 0; i < bin_thomas_denomx; i ++) {
		int sze = thomas_denomx[i].size();
		gpu_thomas_denomx[i] = thomas_denomx[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_denomx[i:1][:sze])
	}	
	// pragma acc enter data sizes
	// end gpu_thomas_denomx
	
	// start gpu_thomas_denomy
	const int bin_thomas_denomy = thomas_denomy.size();

	gpu_thomas_denomy = new double * [bin_thomas_denomy];

	sizes_thomas_denomy = new int [bin_thomas_denomy];

	#pragma acc enter data create(this->gpu_thomas_denomy[0:bin_thomas_denomy][0:0])
	for (int i = 0; i < bin_thomas_denomy; i ++) {
		int sze = thomas_denomy[i].size();
		gpu_thomas_denomy[i] = thomas_denomy[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_denomy[i:1][:sze])
	}	
	// pragma acc enter data sizes
	// end gpu_thomas_denomy

	// start gpu_thomas_denomz
	const int bin_thomas_denomz = thomas_denomz.size();

	gpu_thomas_denomz = new double * [bin_thomas_denomz];

	sizes_thomas_denomz = new int [bin_thomas_denomz];

	#pragma acc enter data create(this->gpu_thomas_denomz[0:bin_thomas_denomz][0:0])
	for (int i = 0; i < bin_thomas_denomz; i ++) {
		int sze = thomas_denomz[i].size();
		gpu_thomas_denomz[i] = thomas_denomz[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_denomz[i:1][:sze])
	}	
	// pragma acc enter data sizes
	// end gpu_thomas_denomz
	
	// start gpu_thomas_i_jump
	gpu_thomas_i_jump = new int;

	*gpu_thomas_i_jump = thomas_i_jump;

	#pragma acc enter data copyin(this->gpu_thomas_i_jump)
	// end gpu_thomas_i_jump
	
	// start gpu_thomas_j_jump
	gpu_thomas_j_jump = new int;

	*gpu_thomas_j_jump = thomas_j_jump;

	#pragma acc enter data copyin(this->gpu_thomas_j_jump)
	// end gpu_thomas_j_jump
	
	// start gpu_thomas_k_jump
	gpu_thomas_k_jump = new int;

	*gpu_thomas_k_jump = thomas_k_jump;

	#pragma acc enter data copyin(this->gpu_thomas_k_jump)
	// end gpu_thomas_k_jump

	// start gpu_thomas_cx
	const int bin_thomas_cx = thomas_cx.size();

	gpu_thomas_cx = new double * [bin_thomas_cx];

	sizes_thomas_cx = new int [bin_thomas_cx];

	#pragma acc enter data create(this->gpu_thomas_cx[0:bin_thomas_cx][0:0])
	for (int i = 0; i < bin_thomas_cx; i ++) {
		int sze = thomas_cx[i].size();
		gpu_thomas_cx[i] = thomas_cx[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_cx[i:1][:sze])
	}
	// end gpu_thomas_cx
	
	// start gpu_thomas_cy
	const int bin_thomas_cy = thomas_cy.size();

	gpu_thomas_cy = new double * [bin_thomas_cy];

	sizes_thomas_cy = new int [bin_thomas_cy];

	#pragma acc enter data create(this->gpu_thomas_cy[0:bin_thomas_cy][0:0])
	for (int i = 0; i < bin_thomas_cy; i ++) {
		int sze = thomas_cy[i].size();
		gpu_thomas_cy[i] = thomas_cy[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_cy[i:1][:sze])
	}
	// end gpu_thomas_cy
	
	// start gpu_thomas_cz
	const int bin_thomas_cz = thomas_cz.size();

	gpu_thomas_cz = new double * [bin_thomas_cz];

	sizes_thomas_cz = new int [bin_thomas_cz];

	#pragma acc enter data create(this->gpu_thomas_cz[0:bin_thomas_cz][0:0])
	for (int i = 0; i < bin_thomas_cz; i ++) {
		int sze = thomas_cz[i].size();
		gpu_thomas_cz[i] = thomas_cz[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_cz[i:1][:sze])
	}
	// end gpu_thomas_cz

	// start gpu_dirichlet_value_vectors
	const int bin_dirichlet_value_vectors = dirichlet_value_vectors.size();

	gpu_dirichlet_value_vectors = new double * [bin_dirichlet_value_vectors];

	sizes_dirichlet_value_vectors = new int [bin_dirichlet_value_vectors];

	#pragma acc enter data create(this->gpu_dirichlet_value_vectors[0:bin_dirichlet_value_vectors][0:0])
	for (int i = 0; i < bin_dirichlet_value_vectors; i++) {
		int sze = dirichlet_value_vectors[i].size();
		sizes_dirichlet_value_vectors[i] = sze;
		gpu_dirichlet_value_vectors[i] = dirichlet_value_vectors[i].data();
		#pragma acc enter data copyin(this->gpu_dirichlet_value_vectors[i:1][:sze])
	}	
	#pragma acc enter data copyin(this->sizes_dirichlet_value_vectors[:bin_dirichlet_value_vectors])
	// end gpu_dirichlet_value_vectors
	
	// start gpu_dirichlet_activation_vector
	const int bin_dirichlet_activation_vector = dirichlet_activation_vector.size();

	gpu_dirichlet_activation_vector = new bool [bin_dirichlet_activation_vector];

//	#pragma acc enter data create(this->gpu_dirichlet_activation_vector[0:bin_dirichlet_activation_vector])
	for (int i = 0; i < bin_dirichlet_activation_vector; i++) {
		gpu_dirichlet_activation_vector[i] = dirichlet_activation_vector.at(i);
	}
		/*
 		*potential error here, move copyin to inside interation?
 		*/
	#pragma acc enter data copyin(this->gpu_dirichlet_activation_vector[:bin_dirichlet_activation_vector])
	// end gpu_dirichlet_activation_vector
	
	// start gpu_voxel_is_dirichlet
	const int bin_mesh = mesh.voxels.size();

	gpu_voxels_is_dirichlet = new bool [bin_mesh];

//	#pragma acc enter data create(this->gpu_voxels_is_dirichlet[0:bin_mesh])
	for (int i = 0; i < bin_mesh; i ++) {
		gpu_voxels_is_dirichlet[i] = mesh.voxels[i].is_Dirichlet;
	}
	#pragma acc enter data copyin(this->gpu_voxels_is_dirichlet[:bin_mesh])
	// end gpu_voxel_is_dirichlet
	

	// Below is num_dirichlet
	num_dirichlet = 0;
	#pragma acc enter data create(this->num_dirichlet)
	// End num_dirichlet

	std::cout << "Done transfer" << std::endl;
}

#pragma acc routine
void Microenvironment::axpy_acc( double* y, double* a , double* x, int size )
{
// #pragma acc parallel loop
 for( int i=0; i < size ; i++ )
 {
  y[i] += a[i] * x[i] ; 
 }
 return; 
}

#pragma acc routine
void Microenvironment::naxpy_acc( double* y, double* a , double* x, int size )
{
// #pragma acc parallel loop
 for( int i=0; i < size ; i++ )
 {
  y[i] -= a[i] * x[i] ; 
 }
 return; 
}

void Microenvironment::apply_dirichlet_conditions_GPU( void ) {
	int mesh_size = mesh.voxels.size();

	#pragma acc parallel loop present(gpu_p_density_vectors, gpu_dirichlet_value_vectors, sizes_dirichlet_value_vectors, gpu_dirichlet_activation_vector, gpu_voxels_is_dirichlet, num_dirichlet)
	for (int i = 0; i < mesh_size; i ++){
		//if (mesh.voxels[i].is_Dirichlet == true){
		if (gpu_voxels_is_dirichlet[i] == true){
					num_dirichlet ++;
			for (int j = 0; j < sizes_dirichlet_value_vectors[i]; j++) {
					num_dirichlet ++;
				if ( gpu_dirichlet_activation_vector[j] == true) {
					gpu_p_density_vectors[i][j] = gpu_dirichlet_value_vectors[i][j];
					//density_vector_GPU(i)[j] = gpu_dirichlet_value_vectors[i][j];
					// TEST whether or not it goes this far with an int
					num_dirichlet ++;
				}
			}
		}
	}	

	return;
}

// X-Diffusion GPU for 2D
void Microenvironment::x_diffusion_GPU_2D(){

	int x_size = mesh.x_coordinates.size();
	int y_size = mesh.y_coordinates.size();

	#pragma acc parallel loop present(gpu_p_density_vectors, sizes_p_density_vectors, gpu_thomas_denomx, gpu_thomas_i_jump, gpu_thomas_cx) 
	for ( int j=0; j < y_size ; j++ ) {
		int n = voxel_index(0, j, 0);
		#pragma acc loop seq 
		for (int q = 0; q < sizes_p_density_vectors[n]; q++)
			{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomx[0][q];}
		n += *gpu_thomas_i_jump;
		#pragma acc loop seq
		for (int i=1; i < x_size ; i++) {
			axpy_acc(gpu_p_density_vectors[n], gpu_thomas_constant1, gpu_p_density_vectors[n-*gpu_thomas_i_jump], sizes_p_density_vectors[n]);
			/*
			#pragma acc loop seq
			for (int k = 0; k < 3; k++) {
				gpu_p_density_vectors[n][k] += gpu_thomas_constant1[k] * gpu_p_density_vectors[n- (*gpu_thomas_i_jump)][k];
			}
			*/
			#pragma acc loop seq
			for (int q = 0; q < sizes_p_density_vectors[n]; q++)
				{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomx[i][q]; }

			n += *gpu_thomas_i_jump;
		}

		// back substitution
		n = voxel_index(x_size-2, j, 0);
		#pragma acc loop seq
		for (int i = x_size-2 ; i >= 0 ; i--) {
			naxpy_acc(gpu_p_density_vectors[n], gpu_thomas_cx[i], gpu_p_density_vectors[n+*gpu_thomas_i_jump], sizes_p_density_vectors[n]);
			/*
			#pragma acc loop seq
			for (int k = 0; k < 3; k++) {
				gpu_p_density_vectors[n][k] -= gpu_thomas_cx[i][k] * gpu_p_density_vectors[n+ (*gpu_thomas_i_jump)][k];
			}
			*/
			n -= *gpu_thomas_i_jump;
		}
	}
//	std::cout << "Done x_diffusion_acc" << std::endl;

}
// end X-Diffusion GPU for 2D

// Y-Diffusion GPU for 2D
void Microenvironment::y_diffusion_GPU_2D(){

	int x_size = mesh.x_coordinates.size();
	int y_size = mesh.y_coordinates.size();

	#pragma acc parallel loop present(gpu_p_density_vectors, sizes_p_density_vectors, gpu_thomas_denomy, gpu_thomas_j_jump, gpu_thomas_cy) 
	for ( int i=0; i < x_size ; i++ ) {
		int n = voxel_index(i, 0, 0);
		#pragma acc loop seq 
		for (int q = 0; q < sizes_p_density_vectors[n]; q++)
			{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomy[0][q];}
		n += *gpu_thomas_j_jump;
		#pragma acc loop seq
		for (int j=1; j < y_size ; j++) {
			axpy_acc(gpu_p_density_vectors[n], gpu_thomas_constant1, gpu_p_density_vectors[n-*gpu_thomas_j_jump], sizes_p_density_vectors[n]);
			/*
			#pragma acc loop seq
			for (int k = 0; k < 3; k++) {
				gpu_p_density_vectors[n][k] += gpu_thomas_constant1[k] * gpu_p_density_vectors[n- (*gpu_thomas_i_jump)][k];
			}
			*/
			#pragma acc loop seq
			for (int q = 0; q < sizes_p_density_vectors[n]; q++)
				{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomy[j][q]; }

			n += *gpu_thomas_j_jump;
		}

		// back substitution
		n = voxel_index(i, y_size-2, 0);
		#pragma acc loop seq
		for (int j = y_size-2 ; j >= 0 ; j--) {
			naxpy_acc(gpu_p_density_vectors[n], gpu_thomas_cy[j], gpu_p_density_vectors[n+*gpu_thomas_j_jump], sizes_p_density_vectors[n]);
			/*
			#pragma acc loop seq
			for (int k = 0; k < 3; k++) {
				gpu_p_density_vectors[n][k] -= gpu_thomas_cx[i][k] * gpu_p_density_vectors[n+ (*gpu_thomas_i_jump)][k];
			}
			*/
			n -= *gpu_thomas_j_jump;
		}
	}
//	std::cout << "Done y_diffusion_acc" << std::endl;

}
// end Y-Diffusion GPU for 2D

// X-Diffusion GPU for 3D
void Microenvironment::x_diffusion_GPU_3D(){

	int x_size = mesh.x_coordinates.size();
	int y_size = mesh.y_coordinates.size();
	int z_size = mesh.z_coordinates.size();

	#pragma acc parallel present(gpu_p_density_vectors, sizes_p_density_vectors, gpu_thomas_denomx, gpu_thomas_i_jump, gpu_thomas_cx) 
	{
	#pragma acc loop independent gang
	for ( int k= 0; k < z_size; k++ )
	{
		#pragma acc loop independent vector
		for ( int j=0; j < y_size ; j++ ) 
		{
			int n = voxel_index(0, j, k);
			#pragma acc loop seq 
			for (int q = 0; q < sizes_p_density_vectors[n]; q++)
				{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomx[0][q];}

			#pragma acc loop seq
			for (int i=1; i < x_size ; i++) 
			{
				n = voxel_index(i, j, k);
				axpy_acc(gpu_p_density_vectors[n], gpu_thomas_constant1, gpu_p_density_vectors[n-*gpu_thomas_i_jump], sizes_p_density_vectors[n]);
				#pragma acc loop seq
			 	for (int q = 0; q < sizes_p_density_vectors[n]; q++)
					{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomx[i][q]; }
	
			}
	
			// back substitution
			// n = voxel_index(x_size-2, j, 0);
			#pragma acc loop seq
			for (int i = x_size-2 ; i >= 0 ; i--) 
			{
				n = voxel_index(i, j, k);
				naxpy_acc(gpu_p_density_vectors[n], gpu_thomas_cx[i], gpu_p_density_vectors[n+*gpu_thomas_i_jump], sizes_p_density_vectors[n]);
			}
		}
	}
//	std::cout << "Done x_diffusion_acc" << std::endl;

	} // end of parallel region
}
// end X-Diffusion GPU for 3D

// Y-Diffusion GPU for 3D
void Microenvironment::y_diffusion_GPU_3D(){

	int x_size = mesh.x_coordinates.size();
	int y_size = mesh.y_coordinates.size();
	int z_size = mesh.z_coordinates.size();

	#pragma acc parallel present(gpu_p_density_vectors, sizes_p_density_vectors, gpu_thomas_denomy, gpu_thomas_j_jump, gpu_thomas_cy) 
	{
	#pragma acc loop independent gang
	for ( int k= 0; k < z_size; k++ )
	{
		#pragma acc loop independent vector
		for ( int i=0; i < x_size ; i++ ) 
		{
			int n = voxel_index(i, 0, k);
			#pragma acc loop seq 
			for (int q = 0; q < sizes_p_density_vectors[n]; q++)
				{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomy[0][q];}

			#pragma acc loop seq
			for (int j=1; j < y_size ; j++) 
			{
				n = voxel_index(i, j, k);
				axpy_acc(gpu_p_density_vectors[n], gpu_thomas_constant1, gpu_p_density_vectors[n-*gpu_thomas_j_jump], sizes_p_density_vectors[n]);
				#pragma acc loop seq
				for (int q = 0; q < sizes_p_density_vectors[n]; q++)
					{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomy[j][q]; }
	
			}
	
			// back substitution
			// n = voxel_index(x_size-2, j, k);
			#pragma acc loop seq
			for (int j = y_size-2 ; j >= 0 ; j--) 
			{
				n = voxel_index(i, j, k);
				naxpy_acc(gpu_p_density_vectors[n], gpu_thomas_cy[j], gpu_p_density_vectors[n+*gpu_thomas_j_jump], sizes_p_density_vectors[n]);
			}
		}
	}
//	std::cout << "Done y_diffusion_acc" << std::endl;

	} // end of parallel region
}
// end Y-Diffusion GPU for 3D

// Z-Diffusion GPU for 3D
void Microenvironment::z_diffusion_GPU_3D(){

	int x_size = mesh.x_coordinates.size();
	int y_size = mesh.y_coordinates.size();
	int z_size = mesh.z_coordinates.size();

	#pragma acc parallel present(gpu_p_density_vectors, sizes_p_density_vectors, gpu_thomas_denomz, gpu_thomas_k_jump, gpu_thomas_cz) 
	{	
	#pragma acc loop independent gang
	for ( int j= 0; j < y_size; j++ )
	{
		#pragma acc loop independent vector
		for ( int i=0; i < x_size ; i++ ) 
		{
			int n = voxel_index(i, j, 0);
			#pragma acc loop seq 
			for (int q = 0; q < sizes_p_density_vectors[n]; q++)
				{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomz[0][q];}

			#pragma acc loop seq
			for (int k=1; k < z_size ; k++) 
			{
				n = voxel_index(i, j, k);
				axpy_acc(gpu_p_density_vectors[n], gpu_thomas_constant1, gpu_p_density_vectors[n-*gpu_thomas_k_jump], sizes_p_density_vectors[n]);
				#pragma acc loop seq
				for (int q = 0; q < sizes_p_density_vectors[n]; q++)
					{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomz[k][q]; }
	
			}
	
			// back substitution
			// n = voxel_index(x_size-2, j, k);
			#pragma acc loop seq
			for (int k = z_size-2 ; k >= 0 ; k--) 
			{
				n = voxel_index(i, j, k);
				naxpy_acc(gpu_p_density_vectors[n], gpu_thomas_cz[k], gpu_p_density_vectors[n+*gpu_thomas_k_jump], sizes_p_density_vectors[n]);
			}
		}
	}
//	std::cout << "Done x_diffusion_acc" << std::endl;
	} // end of parallel region
}
// end Z-Diffusion GPU for 3D

void Microenvironment::translate_vector_to_array()
	/* translate_vector_to_array is actually an update between the two versions
	 * of p_density_vector (DEVICE = gpu_p_density_vector, HOST = p_density_vector),
	 * updating the device with the current values of the 
	 * host p_density_vector
	 */
{
	const int bin_p_density_vectors = (*p_density_vectors).size();

	for (int i = 0; i < bin_p_density_vectors; i++){
		int sze = (*p_density_vectors)[i].size();
		sizes_p_density_vectors[i] = sze;
		gpu_p_density_vectors[i] = (*p_density_vectors)[i].data();
		#pragma acc update device(this->gpu_p_density_vectors[i:1][:sze])
	}
	#pragma acc update device(this->sizes_p_density_vectors[:bin_p_density_vectors])
	
}

void Microenvironment::translate_array_to_vector()
	/* translate_array_to_vector is actually an update between the two versions
	 * of p_density_vector (DEVICE = gpu_p_density_vector, HOST = p_density_vector),
	 * updating the host with the current values of the 
	 * device gpu_p_density_vector
	 */
{
	const int bin_p_density_vectors = (*p_density_vectors).size();

	for (int i = 0; i < bin_p_density_vectors; i++){
		int sze = (*p_density_vectors)[i].size();
		#pragma acc update host(this->gpu_p_density_vectors[i:1][:sze])
	}
	#pragma acc update host(this->sizes_p_density_vectors[:bin_p_density_vectors])

	for (int i = 0; i < bin_p_density_vectors; i++) {
		for (int j = 0; j < this->sizes_p_density_vectors[i]; j++) {
			(*p_density_vectors)[i][j] = this->gpu_p_density_vectors[i][j];
		}
	}

	// Below is num_dirichlet
	#pragma acc update host(this->num_dirichlet)
	// End num_dirichlet
}

};

########## NEXT FILE ##########
/*
#############################################################################
# If you use BioFVM in your project, please cite BioFVM and the version     #
# number, such as below:                                                    #
#                                                                           #
# We solved the diffusion equations using BioFVM (Version 1.1.7) [1]        #
#                                                                           #
# [1] A. Ghaffarizadeh, S.H. Friedman, and P. Macklin, BioFVM: an efficient #
#    parallelized diffusive transport solver for 3-D biological simulations,#
#    Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730 #
#                                                                           #
#############################################################################
#                                                                           #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)   #
#                                                                           #
# Copyright (c) 2015-2017, Paul Macklin and the BioFVM Project              #
# All rights reserved.                                                      #
#                                                                           #
# Redistribution and use in source and binary forms, with or without        #
# modification, are permitted provided that the following conditions are    #
# met:                                                                      #
#                                                                           #
# 1. Redistributions of source code must retain the above copyright notice, #
# this list of conditions and the following disclaimer.                     #
#                                                                           #
# 2. Redistributions in binary form must reproduce the above copyright      #
# notice, this list of conditions and the following disclaimer in the       #
# documentation and/or other materials provided with the distribution.      #
#                                                                           #
# 3. Neither the name of the copyright holder nor the names of its          #
# contributors may be used to endorse or promote products derived from this #
# software without specific prior written permission.                       #
#                                                                           #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS       #
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED #
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A           #
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER #
# OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  #
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,       #
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR        #
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF    #
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING      #
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS        #
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.              #
#                                                                           #
#############################################################################
*/

#include "BioFVM_solvers.h" 
#include "BioFVM_vector.h" 

#include <iostream>
#include <omp.h>
#include <openacc.h>

namespace BioFVM{

// do I even need this? 
void diffusion_decay_solver__constant_coefficients_explicit( Microenvironment& M, double dt )
{
	static bool precomputations_and_constants_done = false; 
	if( !precomputations_and_constants_done )
	{
		std::cout	<< std::endl << "Using solver: " << __FUNCTION__ << std::endl 
					<< "     (constant diffusion coefficient with explicit stepping, implicit decay) ... " << std::endl << std::endl;  

		if( M.mesh.uniform_mesh == true )
		{
			std::cout << "Uniform mesh detected! Consider switching to a more efficient method, such as " << std::endl  
			<< "     diffusion_decay_solver__constant_coefficients_explicit_uniform_mesh" << std::endl  
			<< std::endl; 
		}

		precomputations_and_constants_done = true; 
	}

	return; 
}

void diffusion_decay_solver__constant_coefficients_explicit_uniform_mesh( Microenvironment& M, double dt )
{
	static bool precomputations_and_constants_done = false; 
	if( !precomputations_and_constants_done )
	{
		std::cout	<< std::endl << "Using solver: " << __FUNCTION__ << std::endl 
					<< "     (constant diffusion coefficient with explicit stepping, implicit decay, uniform mesh) ... " << std::endl << std::endl;  

		if( M.mesh.uniform_mesh == false )
		{ std::cout << "Error. This code is only supported for uniform meshes." << std::endl; }

		precomputations_and_constants_done = true; 
	}

	return; 
}

void diffusion_decay_solver__constant_coefficients_LOD_3D( Microenvironment& M, double dt )
{
	if( M.mesh.uniform_mesh == false || M.mesh.Cartesian_mesh == false )
	{
		std::cout << "Error: This algorithm is written for uniform Cartesian meshes. Try: other solvers!" << std::endl << std::endl; 
	return; 
	}

	// define constants and pre-computed quantities 
	
	if( !M.diffusion_solver_setup_done )
	{
		std::cout << std::endl << "Using method " << __FUNCTION__ << " (implicit 3-D LOD with Thomas Algorithm) ... " 
		<< std::endl << std::endl;  
		
		M.thomas_denomx.resize( M.mesh.x_coordinates.size() , M.zero );
		M.thomas_cx.resize( M.mesh.x_coordinates.size() , M.zero );

		M.thomas_denomy.resize( M.mesh.y_coordinates.size() , M.zero );
		M.thomas_cy.resize( M.mesh.y_coordinates.size() , M.zero );
		
		M.thomas_denomz.resize( M.mesh.z_coordinates.size() , M.zero );
		M.thomas_cz.resize( M.mesh.z_coordinates.size() , M.zero );

		M.thomas_i_jump = 1; 
		M.thomas_j_jump = M.mesh.x_coordinates.size(); 
		M.thomas_k_jump = M.thomas_j_jump * M.mesh.y_coordinates.size(); 

		M.thomas_constant1 =  M.diffusion_coefficients; // dt*D/dx^2 
		M.thomas_constant1a = M.zero; // -dt*D/dx^2; 
		M.thomas_constant2 =  M.decay_rates; // (1/3)* dt*lambda 
		M.thomas_constant3 = M.one; // 1 + 2*constant1 + constant2; 
		M.thomas_constant3a = M.one; // 1 + constant1 + constant2; 		
			
		M.thomas_constant1 *= dt; 
		M.thomas_constant1 /= M.mesh.dx; 
		M.thomas_constant1 /= M.mesh.dx; 

		M.thomas_constant1a = M.thomas_constant1; 
		M.thomas_constant1a *= -1.0; 

		M.thomas_constant2 *= dt; 
		M.thomas_constant2 /= 3.0; // for the LOD splitting of the source 

		M.thomas_constant3 += M.thomas_constant1; 
		M.thomas_constant3 += M.thomas_constant1; 
		M.thomas_constant3 += M.thomas_constant2; 

		M.thomas_constant3a += M.thomas_constant1; 
		M.thomas_constant3a += M.thomas_constant2; 

		// Thomas solver coefficients 

		M.thomas_cx.assign( M.mesh.x_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomx.assign( M.mesh.x_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomx[0] = M.thomas_constant3a; 
		M.thomas_denomx[ M.mesh.x_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.x_coordinates.size() == 1 )
		{ M.thomas_denomx[0] = M.one; M.thomas_denomx[0] += M.thomas_constant2; } 

		M.thomas_cx[0] /= M.thomas_denomx[0]; 
		for( unsigned int i=1 ; i <= M.mesh.x_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomx[i] , M.thomas_constant1 , M.thomas_cx[i-1] ); 
			M.thomas_cx[i] /= M.thomas_denomx[i]; // the value at  size-1 is not actually used  
		}

		M.thomas_cy.assign( M.mesh.y_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomy.assign( M.mesh.y_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomy[0] = M.thomas_constant3a; 
		M.thomas_denomy[ M.mesh.y_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.y_coordinates.size() == 1 )
		{ M.thomas_denomy[0] = M.one; M.thomas_denomy[0] += M.thomas_constant2; } 

		M.thomas_cy[0] /= M.thomas_denomy[0]; 
		for( unsigned int i=1 ; i <= M.mesh.y_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomy[i] , M.thomas_constant1 , M.thomas_cy[i-1] ); 
			M.thomas_cy[i] /= M.thomas_denomy[i]; // the value at  size-1 is not actually used  
		}

		M.thomas_cz.assign( M.mesh.z_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomz.assign( M.mesh.z_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomz[0] = M.thomas_constant3a; 
		M.thomas_denomz[ M.mesh.z_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.z_coordinates.size() == 1 )
		{ M.thomas_denomz[0] = M.one; M.thomas_denomz[0] += M.thomas_constant2; } 

		M.thomas_cz[0] /= M.thomas_denomz[0]; 
		for( unsigned int i=1 ; i <= M.mesh.z_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomz[i] , M.thomas_constant1 , M.thomas_cz[i-1] ); 
			M.thomas_cz[i] /= M.thomas_denomz[i]; // the value at  size-1 is not actually used  
		}	

		M.diffusion_solver_setup_done = true; 
	}

	// x-diffusion 
	
	M.apply_dirichlet_conditions();
	#pragma omp parallel for 
	for( unsigned int k=0; k < M.mesh.z_coordinates.size() ; k++ )
	{
		for( unsigned int j=0; j < M.mesh.y_coordinates.size() ; j++ )
		{
			// Thomas solver, x-direction

			// remaining part of forward elimination, using pre-computed quantities 
			int n = M.voxel_index(0,j,k);
			(*M.p_density_vectors)[n] /= M.thomas_denomx[0]; 

			for( unsigned int i=1; i < M.mesh.x_coordinates.size() ; i++ )
			{
				n = M.voxel_index(i,j,k); 
				axpy( &(*M.p_density_vectors)[n] , M.thomas_constant1 , (*M.p_density_vectors)[n-M.thomas_i_jump] ); 
				(*M.p_density_vectors)[n] /= M.thomas_denomx[i]; 
			}

			for( int i = M.mesh.x_coordinates.size()-2 ; i >= 0 ; i-- )
			{
				n = M.voxel_index(i,j,k); 
				naxpy( &(*M.p_density_vectors)[n] , M.thomas_cx[i] , (*M.p_density_vectors)[n+M.thomas_i_jump] ); 
			}

		}
	}

	// y-diffusion 

	M.apply_dirichlet_conditions();
	#pragma omp parallel for 
	for( unsigned int k=0; k < M.mesh.z_coordinates.size() ; k++ )
	{
		for( unsigned int i=0; i < M.mesh.x_coordinates.size() ; i++ )
		{
   // Thomas solver, y-direction

	// remaining part of forward elimination, using pre-computed quantities 

	int n = M.voxel_index(i,0,k);
	(*M.p_density_vectors)[n] /= M.thomas_denomy[0]; 

	for( unsigned int j=1; j < M.mesh.y_coordinates.size() ; j++ )
	{
		n = M.voxel_index(i,j,k); 
		axpy( &(*M.p_density_vectors)[n] , M.thomas_constant1 , (*M.p_density_vectors)[n-M.thomas_j_jump] ); 
		(*M.p_density_vectors)[n] /= M.thomas_denomy[j]; 
	}

	// back substitution 
	// n = voxel_index( mesh.x_coordinates.size()-2 ,j,k); 

	for( int j = M.mesh.y_coordinates.size()-2 ; j >= 0 ; j-- )
	{
		n = M.voxel_index(i,j,k); 
		naxpy( &(*M.p_density_vectors)[n] , M.thomas_cy[j] , (*M.p_density_vectors)[n+M.thomas_j_jump] ); 
	}

  }
 }

 // z-diffusion 

	M.apply_dirichlet_conditions();
 #pragma omp parallel for 
 for( unsigned int j=0; j < M.mesh.y_coordinates.size() ; j++ )
 {
	 
  for( unsigned int i=0; i < M.mesh.x_coordinates.size() ; i++ )
  {
   // Thomas solver, y-direction

	// remaining part of forward elimination, using pre-computed quantities 

	int n = M.voxel_index(i,j,0);
	(*M.p_density_vectors)[n] /= M.thomas_denomz[0]; 

	// should be an empty loop if mesh.z_coordinates.size() < 2  
	for( unsigned int k=1; k < M.mesh.z_coordinates.size() ; k++ )
	{
		n = M.voxel_index(i,j,k); 
		axpy( &(*M.p_density_vectors)[n] , M.thomas_constant1 , (*M.p_density_vectors)[n-M.thomas_k_jump] ); 
		(*M.p_density_vectors)[n] /= M.thomas_denomz[k]; 
	}

	// back substitution 

	// should be an empty loop if mesh.z_coordinates.size() < 2 
	for( int k = M.mesh.z_coordinates.size()-2 ; k >= 0 ; k-- )
	{
		n = M.voxel_index(i,j,k); 
		naxpy( &(*M.p_density_vectors)[n] , M.thomas_cz[k] , (*M.p_density_vectors)[n+M.thomas_k_jump] ); 
		// n -= i_jump; 
	}
  }
 }
 
	M.apply_dirichlet_conditions();
	
	// reset gradient vectors 
//	M.reset_all_gradient_vectors(); 

	return; 
}

void diffusion_decay_solver__constant_coefficients_LOD_3D_GPU( Microenvironment& M, double dt )
{

	if( M.mesh.uniform_mesh == false || M.mesh.Cartesian_mesh == false )
	{
		std::cout << "Error: This algorithm is written for uniform Cartesian meshes. Try: other solvers!" << std::endl << std::endl; 
	return; 
	}

	// define constants and pre-computed quantities 
	
	if( !M.diffusion_solver_setup_done )
	{
		std::cout << std::endl << "Using method " << __FUNCTION__ << " (implicit 3-D GPU  LOD with Thomas Algorithm) ... " 
		<< std::endl << std::endl;  
		
		M.thomas_denomx.resize( M.mesh.x_coordinates.size() , M.zero );
		M.thomas_cx.resize( M.mesh.x_coordinates.size() , M.zero );

		M.thomas_denomy.resize( M.mesh.y_coordinates.size() , M.zero );
		M.thomas_cy.resize( M.mesh.y_coordinates.size() , M.zero );
		
		M.thomas_denomz.resize( M.mesh.z_coordinates.size() , M.zero );
		M.thomas_cz.resize( M.mesh.z_coordinates.size() , M.zero );

		M.thomas_i_jump = 1; 
		M.thomas_j_jump = M.mesh.x_coordinates.size(); 
		M.thomas_k_jump = M.thomas_j_jump * M.mesh.y_coordinates.size(); 

		M.thomas_constant1 =  M.diffusion_coefficients; // dt*D/dx^2 
		M.thomas_constant1a = M.zero; // -dt*D/dx^2; 
		M.thomas_constant2 =  M.decay_rates; // (1/3)* dt*lambda 
		M.thomas_constant3 = M.one; // 1 + 2*constant1 + constant2; 
		M.thomas_constant3a = M.one; // 1 + constant1 + constant2; 		
			
		M.thomas_constant1 *= dt; 
		M.thomas_constant1 /= M.mesh.dx; 
		M.thomas_constant1 /= M.mesh.dx; 

		M.thomas_constant1a = M.thomas_constant1; 
		M.thomas_constant1a *= -1.0; 

		M.thomas_constant2 *= dt; 
		M.thomas_constant2 /= 3.0; // for the LOD splitting of the source 

		M.thomas_constant3 += M.thomas_constant1; 
		M.thomas_constant3 += M.thomas_constant1; 
		M.thomas_constant3 += M.thomas_constant2; 

		M.thomas_constant3a += M.thomas_constant1; 
		M.thomas_constant3a += M.thomas_constant2; 

		// Thomas solver coefficients 

		M.thomas_cx.assign( M.mesh.x_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomx.assign( M.mesh.x_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomx[0] = M.thomas_constant3a; 
		M.thomas_denomx[ M.mesh.x_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.x_coordinates.size() == 1 )
		{ M.thomas_denomx[0] = M.one; M.thomas_denomx[0] += M.thomas_constant2; } 

		M.thomas_cx[0] /= M.thomas_denomx[0]; 
		for( unsigned int i=1 ; i <= M.mesh.x_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomx[i] , M.thomas_constant1 , M.thomas_cx[i-1] ); 
			M.thomas_cx[i] /= M.thomas_denomx[i]; // the value at  size-1 is not actually used  
		}

		M.thomas_cy.assign( M.mesh.y_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomy.assign( M.mesh.y_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomy[0] = M.thomas_constant3a; 
		M.thomas_denomy[ M.mesh.y_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.y_coordinates.size() == 1 )
		{ M.thomas_denomy[0] = M.one; M.thomas_denomy[0] += M.thomas_constant2; } 

		M.thomas_cy[0] /= M.thomas_denomy[0]; 
		for( unsigned int i=1 ; i <= M.mesh.y_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomy[i] , M.thomas_constant1 , M.thomas_cy[i-1] ); 
			M.thomas_cy[i] /= M.thomas_denomy[i]; // the value at  size-1 is not actually used  
		}

		M.thomas_cz.assign( M.mesh.z_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomz.assign( M.mesh.z_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomz[0] = M.thomas_constant3a; 
		M.thomas_denomz[ M.mesh.z_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.z_coordinates.size() == 1 )
		{ M.thomas_denomz[0] = M.one; M.thomas_denomz[0] += M.thomas_constant2; } 

		M.thomas_cz[0] /= M.thomas_denomz[0]; 
		for( unsigned int i=1 ; i <= M.mesh.z_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomz[i] , M.thomas_constant1 , M.thomas_cz[i-1] ); 
			M.thomas_cz[i] /= M.thomas_denomz[i]; // the value at  size-1 is not actually used  
		}	

		M.diffusion_solver_setup_done = true; 
	}

	if (M.openacc_data_bool == false){
		std::cout << "transfering to device" << std::endl;
		M.transfer_3D();
		std::cout << "-continuing-" << std::endl;
		M.openacc_data_bool = true;
	}
	else {
		//M.translate_vector_to_array(); // used for updating Device if work
		// was done on Host
	}

	
	M.apply_dirichlet_conditions_GPU();

	// z-diffusion on gpu
	M.x_diffusion_GPU_3D();

	M.apply_dirichlet_conditions_GPU();

	// y-diffusion on gpu
	M.y_diffusion_GPU_3D();

	M.apply_dirichlet_conditions_GPU();

	// z-diffusion on gpu 
	M.z_diffusion_GPU_3D();

	M.apply_dirichlet_conditions_GPU();

	// reset gradient vectors 
	//M.reset_all_gradient_vectors(); 

	return; 
}

void diffusion_decay_solver__constant_coefficients_LOD_2D( Microenvironment& M, double dt )
{
	if( M.mesh.uniform_mesh == false )
	{
		std::cout << "Error: This algorithm is written for uniform Cartesian meshes. Try: something else." << std::endl << std::endl; 
		return; 
	}
	
	// constants for the linear solver (Thomas algorithm) 
	
	if( !M.diffusion_solver_setup_done )
	{
		std::cout << std::endl << "Using method " << __FUNCTION__ << " (2D LOD with Thomas Algorithm) ... " << std::endl << std::endl;  
		
		M.thomas_denomx.resize( M.mesh.x_coordinates.size() , M.zero );
		M.thomas_cx.resize( M.mesh.x_coordinates.size() , M.zero );

		M.thomas_denomy.resize( M.mesh.y_coordinates.size() , M.zero );
		M.thomas_cy.resize( M.mesh.y_coordinates.size() , M.zero );
		
		// define constants and pre-computed quantities 

		M.thomas_i_jump = 1; 
		M.thomas_j_jump = M.mesh.x_coordinates.size(); 

		M.thomas_constant1 =  M.diffusion_coefficients; //   dt*D/dx^2 
		M.thomas_constant1a = M.zero; // -dt*D/dx^2; 
		M.thomas_constant2 =  M.decay_rates; // (1/2)*dt*lambda 
		M.thomas_constant3 = M.one; // 1 + 2*constant1 + constant2; 
		M.thomas_constant3a = M.one; // 1 + constant1 + constant2; 
		
		M.thomas_constant1 *= dt; 
		M.thomas_constant1 /= M.mesh.dx; 
		M.thomas_constant1 /= M.mesh.dx; 

		M.thomas_constant1a = M.thomas_constant1; 
		M.thomas_constant1a *= -1.0; 

		M.thomas_constant2 *= dt; 
		M.thomas_constant2 *= 0.5; // for splitting via LOD

		M.thomas_constant3 += M.thomas_constant1; 
		M.thomas_constant3 += M.thomas_constant1; 
		M.thomas_constant3 += M.thomas_constant2; 

		M.thomas_constant3a += M.thomas_constant1; 
		M.thomas_constant3a += M.thomas_constant2; 
		
		// Thomas solver coefficients 

		M.thomas_cx.assign( M.mesh.x_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomx.assign( M.mesh.x_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomx[0] = M.thomas_constant3a; 
		M.thomas_denomx[ M.mesh.x_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.x_coordinates.size() == 1 )
		{ M.thomas_denomx[0] = M.one; M.thomas_denomx[0] += M.thomas_constant2; } 

		M.thomas_cx[0] /= M.thomas_denomx[0]; 
		for( unsigned int i=1 ; i <= M.mesh.x_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomx[i] , M.thomas_constant1 , M.thomas_cx[i-1] ); 
			M.thomas_cx[i] /= M.thomas_denomx[i]; // the value at  size-1 is not actually used  
		}

		M.thomas_cy.assign( M.mesh.y_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomy.assign( M.mesh.y_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomy[0] = M.thomas_constant3a; 
		M.thomas_denomy[ M.mesh.y_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.y_coordinates.size() == 1 )
		{ M.thomas_denomy[0] = M.one; M.thomas_denomy[0] += M.thomas_constant2; } 

		M.thomas_cy[0] /= M.thomas_denomy[0]; 
		for( unsigned int i=1 ; i <= M.mesh.y_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomy[i] , M.thomas_constant1 , M.thomas_cy[i-1] ); 
			M.thomas_cy[i] /= M.thomas_denomy[i]; // the value at  size-1 is not actually used  
		}

		M.diffusion_solver_setup_done = true; 
	}

	// set the pointer
	
	M.apply_dirichlet_conditions();

	// x-diffusion 
	#pragma omp parallel for 
	for( unsigned int j=0; j < M.mesh.y_coordinates.size() ; j++ )
	{
		// Thomas solver, x-direction

		// remaining part of forward elimination, using pre-computed quantities 
		unsigned int n = M.voxel_index(0,j,0);
		(*M.p_density_vectors)[n] /= M.thomas_denomx[0]; 

		n += M.thomas_i_jump; 
		for( unsigned int i=1; i < M.mesh.x_coordinates.size() ; i++ )
		{
			axpy( &(*M.p_density_vectors)[n] , M.thomas_constant1 , (*M.p_density_vectors)[n-M.thomas_i_jump] ); 
			(*M.p_density_vectors)[n] /= M.thomas_denomx[i]; 
			n += M.thomas_i_jump; 
		}

		// back substitution 
		n = M.voxel_index( M.mesh.x_coordinates.size()-2 ,j,0); 

		for( int i = M.mesh.x_coordinates.size()-2 ; i >= 0 ; i-- )
		{
			naxpy( &(*M.p_density_vectors)[n] , M.thomas_cx[i] , (*M.p_density_vectors)[n+M.thomas_i_jump] ); 
			n -= M.thomas_i_jump; 
		}
	}

	// y-diffusion 

	M.apply_dirichlet_conditions();
	#pragma omp parallel for 
	for( unsigned int i=0; i < M.mesh.x_coordinates.size() ; i++ )
	{
		// Thomas solver, y-direction

		// remaining part of forward elimination, using pre-computed quantities 

		int n = M.voxel_index(i,0,0);
		(*M.p_density_vectors)[n] /= M.thomas_denomy[0]; 

		n += M.thomas_j_jump; 
		for( unsigned int j=1; j < M.mesh.y_coordinates.size() ; j++ )
		{
			axpy( &(*M.p_density_vectors)[n] , M.thomas_constant1 , (*M.p_density_vectors)[n-M.thomas_j_jump] ); 
			(*M.p_density_vectors)[n] /= M.thomas_denomy[j]; 
			n += M.thomas_j_jump; 
		}

		// back substitution 
		n = M.voxel_index( i,M.mesh.y_coordinates.size()-2, 0); 

		for( int j = M.mesh.y_coordinates.size()-2 ; j >= 0 ; j-- )
		{
			naxpy( &(*M.p_density_vectors)[n] , M.thomas_cy[j] , (*M.p_density_vectors)[n+M.thomas_j_jump] ); 
			n -= M.thomas_j_jump; 
		}
	}

	M.apply_dirichlet_conditions();
	
	// reset gradient vectors 
//	M.reset_all_gradient_vectors(); 
	
	return; 
}

void diffusion_decay_solver__constant_coefficients_LOD_2D_GPU( Microenvironment& M, double dt )
{
	if( M.mesh.uniform_mesh == false )
	{
		std::cout << "Error: This algorithm is written for uniform Cartesian meshes. Try: something else." << std::endl << std::endl; 
		return; 
	}
	
	// constants for the linear solver (Thomas algorithm) 
	
	if( !M.diffusion_solver_setup_done )
	{
		std::cout << std::endl << "Using method " << __FUNCTION__ << " (2D LOD with Thomas Algorithm) ... " << std::endl << std::endl;  
		
		M.thomas_denomx.resize( M.mesh.x_coordinates.size() , M.zero );
		M.thomas_cx.resize( M.mesh.x_coordinates.size() , M.zero );

		M.thomas_denomy.resize( M.mesh.y_coordinates.size() , M.zero );
		M.thomas_cy.resize( M.mesh.y_coordinates.size() , M.zero );
		
		// define constants and pre-computed quantities 

		M.thomas_i_jump = 1; 
		M.thomas_j_jump = M.mesh.x_coordinates.size(); 

		M.thomas_constant1 =  M.diffusion_coefficients; //   dt*D/dx^2 
		M.thomas_constant1a = M.zero; // -dt*D/dx^2; 
		M.thomas_constant2 =  M.decay_rates; // (1/2)*dt*lambda 
		M.thomas_constant3 = M.one; // 1 + 2*constant1 + constant2; 
		M.thomas_constant3a = M.one; // 1 + constant1 + constant2; 
		
		M.thomas_constant1 *= dt; 
		M.thomas_constant1 /= M.mesh.dx; 
		M.thomas_constant1 /= M.mesh.dx; 

		M.thomas_constant1a = M.thomas_constant1; 
		M.thomas_constant1a *= -1.0; 

		M.thomas_constant2 *= dt; 
		M.thomas_constant2 *= 0.5; // for splitting via LOD

		M.thomas_constant3 += M.thomas_constant1; 
		M.thomas_constant3 += M.thomas_constant1; 
		M.thomas_constant3 += M.thomas_constant2; 

		M.thomas_constant3a += M.thomas_constant1; 
		M.thomas_constant3a += M.thomas_constant2; 
		
		// Thomas solver coefficients 

		M.thomas_cx.assign( M.mesh.x_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomx.assign( M.mesh.x_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomx[0] = M.thomas_constant3a; 
		M.thomas_denomx[ M.mesh.x_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.x_coordinates.size() == 1 )
		{ M.thomas_denomx[0] = M.one; M.thomas_denomx[0] += M.thomas_constant2; } 

		M.thomas_cx[0] /= M.thomas_denomx[0]; 
		for( unsigned int i=1 ; i <= M.mesh.x_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomx[i] , M.thomas_constant1 , M.thomas_cx[i-1] ); 
			M.thomas_cx[i] /= M.thomas_denomx[i]; // the value at  size-1 is not actually used  
		}

		M.thomas_cy.assign( M.mesh.y_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomy.assign( M.mesh.y_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomy[0] = M.thomas_constant3a; 
		M.thomas_denomy[ M.mesh.y_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.y_coordinates.size() == 1 )
		{ M.thomas_denomy[0] = M.one; M.thomas_denomy[0] += M.thomas_constant2; } 

		M.thomas_cy[0] /= M.thomas_denomy[0]; 
		for( unsigned int i=1 ; i <= M.mesh.y_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomy[i] , M.thomas_constant1 , M.thomas_cy[i-1] ); 
			M.thomas_cy[i] /= M.thomas_denomy[i]; // the value at  size-1 is not actually used  
		}

		M.diffusion_solver_setup_done = true; 
	}
	if (M.openacc_data_bool == false){
		M.transfer_2D();
		M.openacc_data_bool = true;
	}
	else {
		//M.translate_vector_to_array() // comment out for exclusive device
	}

	// set the pointer
	
	M.apply_dirichlet_conditions_GPU();

	// x-diffusion on gpu
	M.x_diffusion_GPU_2D();

	M.apply_dirichlet_conditions_GPU();

	// y-diffusion on gpu
	M.y_diffusion_GPU_2D();

	M.apply_dirichlet_conditions_GPU();

	// reset gradient vectors 
	//M.reset_all_gradient_vectors(); 
	
	return; 
}

void diffusion_decay_explicit_uniform_rates( Microenvironment& M, double dt )
{
	using std::vector; 
	using std::cout; 
	using std::endl; 

	// static int n_jump_i = 1; 
	// static int n_jump_j = M.mesh.x_coordinates.size(); 
	// static int n_jump_k = M.mesh.x_coordinates.size() * M.mesh.y_coordinates.size(); 

	if( !M.diffusion_solver_setup_done )
	{	
		M.thomas_i_jump = 1; 
		M.thomas_j_jump = M.mesh.x_coordinates.size(); 
		M.thomas_k_jump = M.thomas_j_jump * M.mesh.y_coordinates.size(); 
	
		M.diffusion_solver_setup_done = true; 
	}
	
	if( M.mesh.uniform_mesh == false )
	{
		cout << "Error: This algorithm is written for uniform Cartesian meshes. Try: something else" << endl << endl; 
		return; 
	}

	// double buffering to reduce memory copy / allocation overhead 

	static vector< vector<double> >* pNew = &(M.temporary_density_vectors1);
	static vector< vector<double> >* pOld = &(M.temporary_density_vectors2);

	// swap the buffers 

	vector< vector<double> >* pTemp = pNew; 
	pNew = pOld; 
	pOld = pTemp; 
	M.p_density_vectors = pNew; 

	// static bool reaction_diffusion_shortcuts_are_set = false; 

	static vector<double> constant1 = (1.0 / ( M.mesh.dx * M.mesh.dx )) * M.diffusion_coefficients; 
	static vector<double> constant2 = dt * constant1; 
	static vector<double> constant3 = M.one + dt * M.decay_rates;

	static vector<double> constant4 = M.one - dt * M.decay_rates;

	#pragma omp parallel for
	for( unsigned int i=0; i < (*(M.p_density_vectors)).size() ; i++ )
	{
		unsigned int number_of_neighbors = M.mesh.connected_voxel_indices[i].size(); 

		double d1 = -1.0 * number_of_neighbors; 

		(*pNew)[i] = (*pOld)[i];  
		(*pNew)[i] *= constant4; 

		for( unsigned int j=0; j < number_of_neighbors ; j++ )
		{
			axpy( &(*pNew)[i], constant2, (*pOld)[  M.mesh.connected_voxel_indices[i][j] ] ); 
		}
		vector<double> temp = constant2; 
		temp *= d1; 
		axpy( &(*pNew)[i] , temp , (*pOld)[i] ); 
	}
	
	// reset gradient vectors 
//	M.reset_all_gradient_vectors(); 

	return; 
}

};

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>
#include <time.h>

#include "../core/PhysiCell.h"
#include "../modules/PhysiCell_standard_modules.h"   

using namespace BioFVM;
using namespace PhysiCell;


int omp_num_threads = 8; // set number of threads for parallel computing
// set this to # of CPU cores x 2 (for hyperthreading)

double o2_conc=7.1930;  

double duct_radius= 158.75;

std::vector<std::vector<double>> create_sphere(double cell_radius, double sphere_radius)
{
	std::vector<std::vector<double>> cells;
	int xc=0,yc=0,zc=0;
	double x_spacing= cell_radius*sqrt(3);
	double y_spacing= cell_radius*2;
	double z_spacing= cell_radius*sqrt(3);
	
	std::vector<double> tempPoint(3,0.0);
	// std::vector<double> cylinder_center(3,0.0);
	
	for(double z=-sphere_radius;z<sphere_radius;z+=z_spacing, zc++)
		for(double x=-sphere_radius;x<sphere_radius;x+=x_spacing, xc++)
			for(double y=-sphere_radius;y<sphere_radius;y+=y_spacing, yc++)
			{
				tempPoint[0]=x + (zc%2) * 0.5 * cell_radius;
				tempPoint[1]=y + (xc%2) * cell_radius;
				tempPoint[2]=z;
				
				if(sqrt(norm_squared(tempPoint))< sphere_radius)
				{
					cells.push_back(tempPoint);
				}
			}
	return cells;
	
}


double distance_to_membrane_duct(Cell* pCell, Phenotype& phenotype, double dummy)
{
	double epsillon= 1e-7;
	//Note that this function assumes that duct cap center is located at <0, 0, 0>
	if(pCell->position[0]>=0) // Cell is within the cylinder part of the duct
	{
		double distance_to_x_axis= sqrt(pCell->position[1]* pCell->position[1] + pCell->position[2]*pCell->position[2]);
		distance_to_x_axis = std::max(distance_to_x_axis, epsillon);		// prevents division by zero
		pCell->displacement[0]=0; 
		pCell->displacement[1]= -pCell->position[1]/ distance_to_x_axis; 
		pCell->displacement[2]= -pCell->position[2]/ distance_to_x_axis; 
		return fabs(duct_radius- distance_to_x_axis);
	}
	
	// Cell is inside the cap of the duct
	double distance_to_origin= dist(pCell->position, {0.0,0.0,0.0});  // distance to the origin 
	distance_to_origin = std::max(distance_to_origin, epsillon);			  // prevents division by zero
	pCell->displacement[0]= -pCell->position[0]/ distance_to_origin;
	pCell->displacement[1]= -pCell->position[1]/ distance_to_origin;
	pCell->displacement[2]= -pCell->position[2]/ distance_to_origin;
	return fabs(duct_radius- distance_to_origin);
}

int main( int argc, char* argv[] )
{
	bool DEBUG=false;
	double t = 0.0; 
	double dt = 0.01; // reaction-diffusion time-step
	double mechanics_dt= 0.1;
	double cell_cycle_dt= 6;
	
	double t_output_interval = 60.0; // 1.0; 
	double t_max = 365*24*60;
	double t_next_output_time = 0; 
	int next_output_index = 0; 
	
	double dx; 
	double dy;  
	double dz; 
	
	// openmp setup
	omp_set_num_threads(omp_num_threads);
	
	// PNRG setup 	
	SeedRandom(3); 
	
	// figure out the bounding box 
	std::vector<double> bounding_box( 6, 0.0 );
	bounding_box[PhysiCell_constants::mesh_min_x_index] = -200; bounding_box[PhysiCell_constants::mesh_max_x_index] = 1000; 
	bounding_box[PhysiCell_constants::mesh_min_y_index] = -200; bounding_box[PhysiCell_constants::mesh_max_y_index] = 200; 
	bounding_box[PhysiCell_constants::mesh_min_z_index] = -200; bounding_box[PhysiCell_constants::mesh_max_z_index] = 200; 
	dx=20; dy=20; dz=20;
	
	
	// create a microenvironment
	BioFVM::Microenvironment microenvironment;
	microenvironment.name="substrate scale";
	// add a microenvironment for simulating substrates 	
	// microenvironment.create_microenvironment( "substrate scale"); 
	microenvironment.set_density(0, "oxygen" , "mmHg" );
	// microenvironment.add_density( "glucose" , "dimensionless" );
	
	std::cout << bounding_box << std::endl; 
	
	microenvironment.resize_space( bounding_box[0] , bounding_box[3] , bounding_box[1], bounding_box[4] , bounding_box[2] , bounding_box[5] ,dx,dy,dz );
	microenvironment.spatial_units = "microns";
	microenvironment.time_units = "minutes";
	microenvironment.mesh.units = "microns";
	
	// Cell_Container 
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	for( int n=0; n < microenvironment.number_of_voxels() ; n++ )
	{
		microenvironment.density_vector(n)[0] = o2_conc; 	
	}
	
	// register the diffusion solver 
	microenvironment.diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_3D; 
	
	// register substrates properties 
	microenvironment.diffusion_coefficients[0] = 1.0e5; // microns^2 / min 
	microenvironment.decay_rates[0] = 0.1;

	microenvironment.display_information( std::cout );

	
	initialize_default_cell_definition(); 	
	cell_defaults.type = 0; 
	cell_defaults.name = "tumor cell"; 
	// set default cell cycle model 
	cell_defaults.functions.cycle_model = Ki67_advanced; 	
	// set default_cell_functions; 
	cell_defaults.functions.update_phenotype = update_cell_and_death_parameters_O2_based; 
	cell_defaults.phenotype.secretion.sync_to_microenvironment( &microenvironment );
	cell_defaults.phenotype.sync_to_functions( cell_defaults.functions );
	
	int Q_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_negative );
	int oxygen_substrate_index = microenvironment.find_density_index( "oxygen" ); 
	int K1_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_positive_premitotic );
	int K2_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_positive_postmitotic );
	int apoptosis_model_index = cell_defaults.phenotype.death.find_death_model_index( "apoptosis" );
	int necrosis_model_index = cell_defaults.phenotype.death.find_death_model_index( "necrosis" );
	// cells apoptose after about 7 days 
	cell_defaults.phenotype.death.rates[apoptosis_model_index] = 1.0 / (7.0 * 24.0 * 60.0); 
	// initially no necrosis 
	cell_defaults.phenotype.death.rates[necrosis_model_index] = 0.0; 

	// make sure the cells uptake oxygen at the right rate 
	cell_defaults.phenotype.secretion.uptake_rates[oxygen_substrate_index] = 10; 

	// update transition times 
	cell_defaults.phenotype.cycle.data.transition_rate(Q_index,K1_index) = 1.0 / ( 8.5 * 60.0 ); 
	cell_defaults.phenotype.cycle.data.transition_rate(K1_index,K2_index) = 1.0 / ( 13.0 * 60.0 ); 
	cell_defaults.phenotype.cycle.data.transition_rate(K2_index,Q_index) = 1.0 / ( 2.5 * 60.0 ); 
	
	// let's make necrotic cells survive 6 hours in minimal oxygen conditions  
	cell_defaults.parameters.max_necrosis_rate = 1.0 / (6.0 * 60.0); 
	

	cell_defaults. functions.calculate_distance_to_membrane= distance_to_membrane_duct;
	double cell_radius=10;
	double sphere_radius = duct_radius - 10;;
	// std::cout << __FILE__ << " custom " << __LINE__ << std::endl; 
	std::vector<std::vector<double>> cell_positions;
	cell_positions= create_sphere(cell_radius, sphere_radius);

	//add Dirichlet node for all the voxels located outside of the duct
	std::vector<double> dirichlet_o2( 1 , o2_conc );
	
	for( int i=0; i < microenvironment.number_of_voxels() ; i++ )
	{
		if(microenvironment.voxels(i).center[0]>=0)
		{
			if(sqrt(microenvironment.voxels(i).center[1]* microenvironment.voxels(i).center[1] + microenvironment.voxels(i).center[2]*microenvironment.voxels(i).center[2])>duct_radius)
				microenvironment.add_dirichlet_node( i , dirichlet_o2 );
		}
		else
		{
			if(dist(microenvironment.voxels(i).center, {0.0,0.0,0.0})>duct_radius)
				microenvironment.add_dirichlet_node( i , dirichlet_o2 );
		}
	}
	
	Cell* pCell;

	for(int i=0;i<cell_positions.size();i++)
	// for(int i=0;i<2;i++)
	{
		if(cell_positions[i][0]>0)
			continue;
		pCell = create_cell();
		pCell->register_microenvironment(&microenvironment);
		pCell->assign_position(cell_positions[i]);
		pCell->phenotype.cycle.data.current_phase_index = Q_index; 
		if( pCell->phenotype.cycle.current_phase().entry_function )                      
			pCell->phenotype.cycle.current_phase().entry_function( pCell, pCell->phenotype, dt);
		// pCell->parameters.necrosis_type= PhysiCell_constants::deterministic_necrosis;
	}
	for(int i=0;i<all_basic_agents.size();i++){
		all_basic_agents[i]->set_internal_uptake_constants(dt); 
	}
	
	
	std::cout << (*all_cells).size() <<" agents created successfully." <<std::endl;
	
	std::vector<double> position (3, 0.0);
	position[0]=0;
	position[1]=0;
	position[2]=0;
	
	int output_index =0; 
	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	std::cout << "CLOCKS_PER_SEC = " << CLOCKS_PER_SEC << "\n";
	
/*	clock_t begin = clock();
	double sum=0;
  for(int i=0;i<1000000000;i++)
  {
	  sum+= sqrt((double)i);
  }
	std::cout<<"sum: "<<sum<<std::endl;
  clock_t end = clock();
  double elapsed_secs = double(end - begin) / CLOCKS_PER_SEC;
 */
  
	std::ofstream report_file ("report.txt");
	report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	try 
	{		
		while( t < t_max )
		{
			if(  fabs( t - t_next_output_time ) < 0.0001 )
			{
				log_output(t, output_index, microenvironment, report_file);
				t_next_output_time += t_output_interval;						
			}
			// std::cout<<__LINE__<<std::endl;			
			microenvironment.simulate_cell_sources_and_sinks( dt );
			microenvironment.simulate_diffusion_decay( dt );
			((Cell_Container *)microenvironment.agent_container)->update_all_cells(t, cell_cycle_dt, mechanics_dt, dt);		
			t += dt; 
			output_index++;
		}
		log_output(t, output_index, microenvironment, report_file);
		report_file.close();
	}
	catch( const std::exception& e ) { // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>


#include "../core/PhysiCell.h"
#include "../modules/PhysiCell_standard_modules.h"   

using namespace BioFVM;
using namespace PhysiCell;


int omp_num_threads = 8; // set number of threads for parallel computing
// set this to # of CPU cores x 2 (for hyperthreading)

double o2_conc=38.0;   //check this value to make sure it has support from literature

std::vector<std::vector<double>> create_sphere(double cell_radius, double sphere_radius)
{
	std::vector<std::vector<double>> cells;
	int xc=0,yc=0,zc=0;
	double x_spacing= cell_radius*sqrt(3);
	double y_spacing= cell_radius*2;
	double z_spacing= cell_radius*sqrt(3);
	
	std::vector<double> tempPoint(3,0.0);
	// std::vector<double> cylinder_center(3,0.0);
	
	for(double z=-sphere_radius;z<sphere_radius;z+=z_spacing, zc++)
		for(double x=-sphere_radius;x<sphere_radius;x+=x_spacing, xc++)
			for(double y=-sphere_radius;y<sphere_radius;y+=y_spacing, yc++)
			{
				tempPoint[0]=x + (zc%2) * 0.5 * cell_radius;
				tempPoint[1]=y + (xc%2) * cell_radius;
				tempPoint[2]=z;
				
				if(sqrt(norm_squared(tempPoint))< sphere_radius)
				{
					cells.push_back(tempPoint);
				}
			}
	return cells;
	
}

int main( int argc, char* argv[] )
{
	bool DEBUG=false;
	double t = 0.0; 
	double dt = 0.01; // reaction-diffusion time-step
	double mechanics_dt= 0.1;
	double cell_cycle_dt= 6;
	
	double t_output_interval = 600.0; // 1.0; 
	double t_max = 365*24*60;
	double t_next_output_time = 0; 
	int next_output_index = 0; 
	
	double dx; 
	double dy;  
	double dz; 
	
	// openmp setup
	omp_set_num_threads(omp_num_threads);
	
	// PNRG setup 	
	SeedRandom(3); 
	
	// figure out the bounding box 
	std::vector<double> bounding_box( 6, 0.0 );
	bounding_box[PhysiCell_constants::mesh_min_x_index] = -1000; bounding_box[PhysiCell_constants::mesh_max_x_index] = 1000; 
	bounding_box[PhysiCell_constants::mesh_min_y_index] = -1000; bounding_box[PhysiCell_constants::mesh_max_y_index] = 1000; 
	bounding_box[PhysiCell_constants::mesh_min_z_index] = -1000; bounding_box[PhysiCell_constants::mesh_max_z_index] = 1000; 
	dx=20; dy=20; dz=20;
	

	// create a microenvironment
	BioFVM::Microenvironment microenvironment;
	microenvironment.name="substrate scale";
	// add a microenvironment for simulating substrates 	
	// microenvironment.create_microenvironment( "substrate scale"); 
	microenvironment.set_density(0, "oxygen" , "mmHg" );
	// microenvironment.add_density( "glucose" , "dimensionless" );
	
	std::cout << bounding_box << std::endl; 
	
	microenvironment.resize_space( bounding_box[0] , bounding_box[3] , bounding_box[1], bounding_box[4] , bounding_box[2] , bounding_box[5] ,dx,dy,dz );
	microenvironment.spatial_units = "microns";
	microenvironment.time_units = "minutes";
	microenvironment.mesh.units = "microns";
	
	// Cell_Container 
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	for( int n=0; n < microenvironment.number_of_voxels() ; n++ )
	{
		microenvironment.density_vector(n)[0] = o2_conc; 	
	}
	
	// register the diffusion solver 
	microenvironment.diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_3D; 
	
	// register substrates properties 
	microenvironment.diffusion_coefficients[0] = 1.0e5; // microns^2 / min 
	microenvironment.decay_rates[0] = 0.1;

	microenvironment.display_information( std::cout );

	
	initialize_default_cell_definition(); 	
	cell_defaults.type = 0; 
	cell_defaults.name = "tumor cell"; 
	// set default cell cycle model 
	cell_defaults.functions.cycle_model = Ki67_advanced; 	
	// set default_cell_functions; 
	cell_defaults.functions.update_phenotype = update_cell_and_death_parameters_O2_based; 
	cell_defaults.phenotype.secretion.sync_to_microenvironment( &microenvironment );
	cell_defaults.phenotype.sync_to_functions( cell_defaults.functions );
	
	int Q_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_negative );
	int oxygen_substrate_index = microenvironment.find_density_index( "oxygen" ); 
	int K1_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_positive_premitotic );
	int K2_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_positive_postmitotic );
	int apoptosis_model_index = cell_defaults.phenotype.death.find_death_model_index( "apoptosis" );
	int necrosis_model_index = cell_defaults.phenotype.death.find_death_model_index( "necrosis" );
	// cells apoptose after about 7 days 
	cell_defaults.phenotype.death.rates[apoptosis_model_index] = 1.0 / (7.0 * 24.0 * 60.0); 
	// initially no necrosis 
	cell_defaults.phenotype.death.rates[necrosis_model_index] = 0.0; 

	// make sure the cells uptake oxygen at the right rate 
	cell_defaults.phenotype.secretion.uptake_rates[oxygen_substrate_index] = 10; 

	// update transition times 
	cell_defaults.phenotype.cycle.data.transition_rate(Q_index,K1_index) = 1.0 / ( 8.5 * 60.0 ); 
	cell_defaults.phenotype.cycle.data.transition_rate(K1_index,K2_index) = 1.0 / ( 13.0 * 60.0 ); 
	cell_defaults.phenotype.cycle.data.transition_rate(K2_index,Q_index) = 1.0 / ( 2.5 * 60.0 ); 
	
	// let's make necrotic cells survive 6 hours in minimal oxygen conditions  
	cell_defaults.parameters.max_necrosis_rate = 1.0 / (6.0 * 60.0); 
	
	double cell_radius=10;
	double sphere_radius = 150;
	// std::cout << __FILE__ << " custom " << __LINE__ << std::endl; 
	std::vector<std::vector<double>> cell_positions;
	cell_positions= create_sphere(cell_radius, sphere_radius);

	//add Dirichlet node for all the voxels located outside of the duct
	std::vector<double> dirichlet_o2( 1 , o2_conc );
	
	double min_x=microenvironment.mesh.bounding_box[0];
	double max_x=microenvironment.mesh.bounding_box[3];
	double min_y=microenvironment.mesh.bounding_box[1];
	double max_y=microenvironment.mesh.bounding_box[4];
	double min_z=microenvironment.mesh.bounding_box[2];
	double max_z=microenvironment.mesh.bounding_box[5];
	double strip_width=40;	

	for( int i=0; i < microenvironment.number_of_voxels() ; i++ )
	{
		if( abs(max_x-microenvironment.voxels(i).center[0]) < strip_width || abs(microenvironment.voxels(i).center[0]- min_x)< strip_width  
			|| abs(max_y-microenvironment.voxels(i).center[1]) < strip_width || abs(microenvironment.voxels(i).center[1]- min_y)< strip_width  
				|| abs(max_z-microenvironment.voxels(i).center[2]) < strip_width || abs(microenvironment.voxels(i).center[2]- min_z)< strip_width )
				{
					microenvironment.add_dirichlet_node( i , dirichlet_o2 );
				}		
	}

	
	Cell* pCell;

for(int i=0;i<cell_positions.size();i++)
	// for(int i=0;i<2;i++)
	{
		if(cell_positions[i][0]>0)
			continue;
		pCell = create_cell();
		pCell->register_microenvironment(&microenvironment);
		pCell->assign_position(cell_positions[i]);
		pCell->phenotype.cycle.data.current_phase_index = Q_index; 
		if( pCell->phenotype.cycle.current_phase().entry_function )                      
			pCell->phenotype.cycle.current_phase().entry_function( pCell, pCell->phenotype, dt);
		// pCell->parameters.necrosis_type= PhysiCell_constants::deterministic_necrosis;
	}

	for(int i=0;i<all_basic_agents.size();i++){
		all_basic_agents[i]->set_internal_uptake_constants(dt); 
	}
	
	std::cout << (*all_cells).size() <<" agents created successfully." <<std::endl;
	
	std::vector<double> position (3, 0.0);
	position[0]=0;
	position[1]=0;
	position[2]=0;
	
	int output_index =0; 
	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file ("report_spheroid.txt");
	report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	try 
	{		
		while( t < t_max )
		{
			if(  fabs( t - t_next_output_time ) < 0.0001 )
			{
				log_output(t, output_index, microenvironment, report_file);
				t_next_output_time += t_output_interval;						
			}
			microenvironment.simulate_cell_sources_and_sinks( dt );
			microenvironment.simulate_diffusion_decay( dt );
			((Cell_Container *)microenvironment.agent_container)->update_all_cells(t, cell_cycle_dt, mechanics_dt, dt);		
			t += dt; 
			output_index++;
		}
		log_output(t, output_index, microenvironment, report_file);
		report_file.close();
	}
	catch( const std::exception& e ) { // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "../core/PhysiCell.h"
#include "../modules/PhysiCell_standard_modules.h" 

using namespace BioFVM;
using namespace PhysiCell;


int omp_num_threads = 8; // set number of threads for parallel computing
// set this to # of CPU cores x 2 (for hyperthreading)
double pi=3.1415926535897932384626433832795;

double o2_conc=6.06;
double min_voxel_size=30;

int write_test_report(std::vector<Cell*> all_cells, double timepoint)
{
    std::string filename; 
    filename.resize( 1024 ); 
    sprintf( (char*) filename.c_str() , "test_cycle\\cells_%08i.txt" , (int)round(timepoint) ); 
    std::ofstream outputFile (filename.c_str(), std::ofstream::out);
    //outputFile<<"\tID\tx\ty\tz\tradius\tphenotype\telapsed_time\n";
    int phenotype_code;
    for(int i=0;i<all_cells.size();i++)
    {
        phenotype_code=all_cells[i]->phenotype.cycle.current_phase().code;
        outputFile<<i<<"\t"<<all_cells[i]->ID<<"\t"<<all_cells[i]->position[0]<<"\t" << all_cells[i]->position[1] <<"\t"<< all_cells[i]->position[2]<<"\t";
        outputFile<<all_cells[i]->phenotype.geometry.radius<<"\t"<<phenotype_code<< "\t"<< all_cells[i]->
        phenotype.cycle.data.elapsed_time_in_phase <<std::endl;
         
        // std::cout<<"Cell ID #"<<all_cells[i]->ID<<" position: "<< all_cells[i]->position<<std::endl;
    }
    outputFile.close();
    return 0;
}

int main( int argc, char* argv[] )
{
	if(argc<=1)
	{
		std::cout<<"you need to provide dt as an argument"<<std::endl;
		return 0;
	}
	double t = 0.0; 
	double dt = strtod(argv[1], NULL);
	std::cout<<dt<<std::endl;
	
	double t_output_interval = std::max(60.0,dt); // 1.0; 
	double t_max = 60*24*6;
	double t_next_output_time = 0; 
	int next_output_index = 0; 
	
	double dx; 
	double dy;  
	double dz; 
	
	// openmp setup
	omp_set_num_threads(omp_num_threads);
	
	// PNRG setup 	
	SeedRandom(); 
	
	// figure out the bounding box 
	double side_length= 2000;
	std::vector<double> bounding_box( 6, 0.0 );
	bounding_box[PhysiCell_constants::mesh_min_x_index] = 0; bounding_box[PhysiCell_constants::mesh_max_x_index] = side_length; 
	bounding_box[PhysiCell_constants::mesh_min_y_index] = 0; bounding_box[PhysiCell_constants::mesh_max_y_index] = side_length; 
	bounding_box[PhysiCell_constants::mesh_min_z_index] = 0; bounding_box[PhysiCell_constants::mesh_max_z_index] = side_length; 
	dx=20; dy=20; dz=20;
		
	// create a microenvironment; 
	BioFVM::Microenvironment microenvironment;
	microenvironment.name="substrate scale";
	// add a microenvironment for simulating substrates 	
	microenvironment.set_density(0, "oxygen" , "mmHg" );
	
	std::cout << bounding_box << std::endl; 
	
	microenvironment.resize_space( bounding_box[0] , bounding_box[3] , bounding_box[1], bounding_box[4] , bounding_box[2] , bounding_box[5] ,dx,dy,dz );
	microenvironment.spatial_units = "microns";
	microenvironment.time_units = "minutes";
	microenvironment.mesh.units = "microns";
	// Cell_Container 
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	for( int n=0; n < microenvironment.number_of_voxels() ; n++ )
	{
		microenvironment.density_vector(n)[0] = o2_conc; 	
	}
	
	// register the diffusion solver 
	microenvironment.diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_3D; 
	
	initialize_default_cell_definition(); 	
	cell_defaults.type = 0; 
	cell_defaults.name = "tumor cell"; 
	// set default cell cycle model 
	cell_defaults.functions.cycle_model = Ki67_advanced; 	
	// set default_cell_functions; 
	cell_defaults.functions.update_phenotype = update_cell_and_death_parameters_O2_based; 
	
	// disable cell's movement
	cell_defaults.functions.update_velocity=empty_function;
	cell_defaults.phenotype.secretion.sync_to_microenvironment( &microenvironment );
	cell_defaults.phenotype.sync_to_functions( cell_defaults.functions ); 
	// first find index for a few key variables. 
	int apoptosis_model_index = cell_defaults.phenotype.death.find_death_model_index( "Apoptosis" );
	int necrosis_model_index = cell_defaults.phenotype.death.find_death_model_index( "Necrosis" );
	int oxygen_substrate_index = microenvironment.find_density_index( "oxygen" ); 

	int K1_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_positive_premitotic );
	int K2_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_positive_postmitotic );
	int Q_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_negative );
	int A_index = Ki67_advanced.find_phase_index( PhysiCell_constants::apoptotic );
	int N_index = Ki67_advanced.find_phase_index( PhysiCell_constants::necrotic_swelling );
	
		// cells apoptose after about 7 days 
	cell_defaults.phenotype.death.rates[apoptosis_model_index] = 1.0 / (7.0 * 24.0 * 60.0); 
	// initially no necrosis 
	cell_defaults.phenotype.death.rates[necrosis_model_index] = 0.0; 

	// make sure the cells uptake oxygen at the right rate 
	cell_defaults.phenotype.secretion.uptake_rates[oxygen_substrate_index] = 0; 

	// cells leave the Q phase and enter the K1 phase after 5 hours 
	cell_defaults.phenotype.cycle.data.transition_rate(Q_index,K1_index) = 1.0 / ( 5.0 * 60.0 ); 
	
	// let's make necrotic cells survive 6 hours in minimal oxygen conditions  
	cell_defaults.parameters.max_necrosis_rate = 1.0 / (6.0 * 60.0); 
	

	microenvironment.display_information( std::cout );

	std::vector<double> temp_position(3);
	
	int num_ki67_positive_pre= 0;
	int num_ki67_positive_post= 0;
	int num_ki67_q=1000;//;
	int num_apoptotic= 0;
	int total= num_ki67_positive_pre + num_ki67_positive_post + num_ki67_q + num_apoptotic;
	double T1= 13 * 60;
	double T2= 2.5 * 60;
	double TQ= 74.35 * 60;
	double TA= 8.6 * 60;
	double T;
	int phase_index;
	for(int i=0;i<total;i++)
	{
		
		for(int j=0;j<3;j++)
			temp_position[j]= uniform_random()*1000+500;
		Cell* pCell = create_cell();
		pCell->register_microenvironment(&microenvironment);
		pCell->assign_position(temp_position);
		//pCell->advance_cell_current_phase=ki67_advanced_cycle_model_stochastic;
		if(i<num_ki67_positive_pre)
		{
			phase_index=K1_index;
			T = T1;
		}
		else if(i< num_ki67_positive_pre+ num_ki67_positive_post)
		{
			phase_index = K2_index;	
			T = T2;			
		}
		else if(i< num_ki67_positive_pre+ num_ki67_positive_post+ num_apoptotic)
		{
			phase_index = A_index;	
			T = TA;	
			pCell->phenotype.death.trigger_death( apoptosis_model_index );
			pCell->phenotype.cycle.sync_to_cycle_model( pCell->phenotype.death.current_model() );
		}
		else
		{
			phase_index = Q_index;	
			T = TQ;			
		}
		pCell->phenotype.cycle.data.current_phase_index = phase_index; 
		if( pCell->phenotype.cycle.current_phase().entry_function )                      
			pCell->phenotype.cycle.current_phase().entry_function( pCell, pCell->phenotype, dt);
		// std::cout<<__FILE__<<","<<__LINE__<<std::endl;

	}
	for(int i=0;i<all_basic_agents.size();i++){
		all_basic_agents[i]->set_internal_uptake_constants(dt); 
	}
		
	std::cout << (*all_cells).size() <<" agents created successfully." <<std::endl;
	
	int output_index =0; 
	// std::ofstream report_file ("report.txt");
	// report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();

	try 
	{		
		while( t < t_max )
		{
			if(  fabs( t - t_next_output_time ) < 0.0001 )
			{
				write_test_report(*all_cells,t);
				t_next_output_time += t_output_interval;	
				std::cout << "t: "<<t<<", cell count: "<<(*all_cells).size()<<std::endl;
			}
	
			((Cell_Container *)microenvironment.agent_container)->update_all_cells(t, dt, dt, dt);
			t += dt; 
			output_index++;
		}
		write_test_report(*all_cells,t);
		// report_file.close();
	}
	catch( const std::exception& e ) { // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "../core/PhysiCell.h"
#include "../modules/PhysiCell_standard_modules.h" 
using namespace BioFVM;
using namespace PhysiCell;

int omp_num_threads = 8; // set number of threads for parallel computing
// set this to # of CPU cores x 2 (for hyperthreading)


void do_nothing(Cell* pCell, Phenotype& phenotype, double dt){}

int main( int argc, char* argv[] )
{
	if(argc<=1)
	{
		std::cout<<"you need to provide dt as an argument"<<std::endl;
		return 0;
	}

	double t = 0.0; 
	double dt = strtod(argv[1],NULL);
	double t_output_interval = 1; // 1.0; 
	double t_max = 60;
	double t_next_output_time = 0; 
	int next_output_index = 0; 
	
	double dx; 
	double dy;  
	double dz; 
	
	// openmp setup
	omp_set_num_threads(omp_num_threads);
	
	// PNRG setup 	
	SeedRandom(3); 
	
	// figure out the bounding box 
	std::vector<double> bounding_box( 6, 0.0 );
	bounding_box[PhysiCell_constants::mesh_min_x_index] = 0; bounding_box[PhysiCell_constants::mesh_max_x_index] = 2000; 
	bounding_box[PhysiCell_constants::mesh_min_y_index] = 0; bounding_box[PhysiCell_constants::mesh_max_y_index] = 2000; 
	bounding_box[PhysiCell_constants::mesh_min_z_index] = 0; bounding_box[PhysiCell_constants::mesh_max_z_index] = 2000; 
	dx=20; dy=20; dz=20;
	
	// create a microenvironment;
	BioFVM::Microenvironment microenvironment;
	microenvironment.name="substrate scale";
	// add a microenvironment for simulating substrates 	
	microenvironment.set_density(0, "oxygen" , "mmHg" );
	microenvironment.resize_space( bounding_box[0] , bounding_box[3] , bounding_box[1], bounding_box[4] , bounding_box[2] , bounding_box[5] ,dx,dy,dz );
	microenvironment.spatial_units = "microns";
	microenvironment.time_units = "minutes";
	microenvironment.mesh.units = "microns";
	// Since this is just a test for mechanics, the following density initialization are not needed
	/* for( int n=0; n < microenvironment.number_of_voxels() ; n++ )
	{
		microenvironment.density_vector(n)[0] = o2_conc; 	
	}*/
	
	// Cell_Container
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	//microenvironment.agent_container= (Agent_Container *) cell_container; // cell_container;
	
	initialize_default_cell_definition(); 	
	cell_defaults.type = 0; 
	cell_defaults.name = "tumor cell"; 
	cell_defaults.functions.cycle_model = Ki67_advanced; 
	cell_defaults.functions.update_phenotype = empty_function;
	cell_defaults.functions.volume_update_function = empty_function;
	
	
	int Q_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_negative );
	// register the diffusion solver 
	microenvironment.diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_3D; 
		
	microenvironment.display_information( std::cout );

	
	// std::cout << __FILE__ << " custom " << __LINE__ << std::endl; 
	std::vector<double> point1(3), point2(3);

	double num1, num2;
	num1=100;
	num2= 105.73;
	double volume=4188.790204786391;
	point1[0]= num1; point1[1]= num1; point1[2]= num1; 
	point2[0]= num2; point2[1]= num2; point2[2]= num2; 
	
	Cell* pCell1 = create_cell();
	pCell1->register_microenvironment(&microenvironment);
	pCell1->assign_position(point1);
	pCell1->phenotype.cycle.data.current_phase_index = Q_index; 
	/* NOTE: for this experiment, you need to disable volume update function 
	 to make sure that volume change are not affecting the distance we measure for the cells.*/
	//pCell1->functions.volume_update_function=do_nothing;
	pCell1->set_total_volume(volume);
	
	Cell* pCell2 = create_cell();
	 pCell2->register_microenvironment(&microenvironment);
	pCell2->assign_position(point2);
	pCell2->phenotype.cycle.data.current_phase_index = Q_index; 
	//pCell2->functions.volume_update_function=do_nothing;
	pCell2->set_total_volume(volume);
	
	std::cout << pCell1->phenotype.geometry.radius<<std::endl;
	
	std::cout << (*all_cells).size() <<" agents created successfully." <<std::endl;
	
	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::string filename; 
	filename.resize( 1024 ); 
	sprintf( (char*) filename.c_str() , "mechanics_test1_result_dt=%f.txt" , dt ); 
	std::ofstream report_file (filename.c_str(), std::ofstream::out);
	
	pCell1->functions.update_velocity(pCell1,pCell1->phenotype, dt);
	pCell2->functions.update_velocity(pCell2,pCell2->phenotype, dt);
	
	pCell1->set_previous_velocity(pCell1->velocity[0],pCell1->velocity[1],pCell1->velocity[2]);
	pCell2->set_previous_velocity(pCell2->velocity[0],pCell2->velocity[1],pCell2->velocity[2]);
		
	for(int i=0;i<10;i++)
	{
		pCell1->position += (dt/10.0)*pCell1->velocity; 
		pCell2->position += (dt/10.0)*pCell2->velocity;
		t+=dt/10.0;
	}
	std::cout<<"time: "<< t<<std::endl;
	t_next_output_time=t_output_interval;
	std::cout<<pCell1->get_total_volume()<<std::endl;
	try 
	{		
		while( t < t_max )
		{
			
			if(  fabs( t - t_next_output_time ) < dt/10.0 )
			{
				report_file<<t<<"\t"<<dist(pCell1->position,pCell2->position)<<"\n";
				t_next_output_time += t_output_interval; 
			}
			
			((Cell_Container *)microenvironment.agent_container)->update_all_cells(t, dt, dt, dt);
			t += dt; 
		}
		report_file.close();
		std::cout<<pCell1->position<<"  "<< pCell2->position<< ", distance: " <<dist(pCell1->position,pCell2->position)<<  std::endl;
		
		std::cout<<pCell1->get_total_volume()<<std::endl;
		std::cout << "total number of agents: " << (*all_cells).size()<<std::endl << std::endl;
		BioFVM::RUNTIME_TOC();
		BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() );
	}
	catch( const std::exception& e ) { // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "../core/PhysiCell.h"
#include "../modules/PhysiCell_standard_modules.h" 

using namespace BioFVM;
using namespace PhysiCell;

int omp_num_threads = 8; // set number of threads for parallel computing
// set this to # of CPU cores x 2 (for hyperthreading)
double pi=3.1415926535897932384626433832795;

double min_voxel_size=30;

void do_nothing(Cell* pCell, Phenotype& phenotype, double dt){}

std::vector<std::vector<double>> create_sphere(double cell_radius, double sphere_radius)
{
	std::vector<std::vector<double>> cells;
	int xc=0,yc=0,zc=0;
	double x_spacing= cell_radius*sqrt(3);
	double y_spacing= cell_radius*2;
	double z_spacing= cell_radius*sqrt(3);
	
	std::vector<double> tempPoint(3,0.0);
	// std::vector<double> cylinder_center(3,0.0);
	
	for(double z=-sphere_radius;z<sphere_radius;z+=z_spacing, zc++)
		for(double x=-sphere_radius;x<sphere_radius;x+=x_spacing, xc++)
			for(double y=-sphere_radius;y<sphere_radius;y+=y_spacing, yc++)
			{
				tempPoint[0]=x + (zc%2) * 0.5 * cell_radius;
				tempPoint[1]=y + (xc%2) * cell_radius;
				tempPoint[2]=z;
				
				if(sqrt(norm_squared(tempPoint))< sphere_radius)
				{
					cells.push_back(tempPoint);
				}
			}
	return cells;
	
}

int main( int argc, char* argv[] )
{
	if(argc<=1)
	{
		std::cout<<"you need to provide dt as an argument"<<std::endl;
		return 0;
	}

	double t = 0.0; 
	double dt = strtod(argv[1],NULL);
	double t_output_interval = 5.0; // 1.0; 
	double t_max = 60;
	double t_next_output_time = 0; 
	int next_output_index = 0; 
	
	double dx; 
	double dy;  
	double dz; 
	
	// openmp setup
	omp_set_num_threads(omp_num_threads);
	
	// PNRG setup 	
	SeedRandom(3); 
	
	// figure out the bounding box 
	std::vector<double> bounding_box( 6, 0.0 );
	bounding_box[PhysiCell_constants::mesh_min_x_index] = 0; bounding_box[PhysiCell_constants::mesh_max_x_index] = 2000; 
	bounding_box[PhysiCell_constants::mesh_min_y_index] = 0; bounding_box[PhysiCell_constants::mesh_max_y_index] = 2000; 
	bounding_box[PhysiCell_constants::mesh_min_z_index] = 0; bounding_box[PhysiCell_constants::mesh_max_z_index] = 2000; 
	dx=20; dy=20; dz=20;
	
	
	// create a microenvironment
	BioFVM::Microenvironment microenvironment;
	microenvironment.name="substrate scale";
	// add a microenvironment for simulating substrates 	
	microenvironment.set_density(0, "oxygen" , "mmHg" );
	
	std::cout << bounding_box << std::endl; 
	
	microenvironment.resize_space( bounding_box[0] , bounding_box[3] , bounding_box[1], bounding_box[4] , bounding_box[2] , bounding_box[5] ,dx,dy,dz );
	microenvironment.spatial_units = "microns";
	microenvironment.time_units = "minutes";
	microenvironment.mesh.units = "microns";
	// Cell_Container * 
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	microenvironment.display_information( std::cout );

	initialize_default_cell_definition(); 	
	cell_defaults.type = 0; 
	cell_defaults.name = "tumor cell"; 
	cell_defaults.functions.cycle_model = Ki67_advanced; 
	cell_defaults.functions.update_phenotype = empty_function;
	cell_defaults.functions.volume_update_function = empty_function;
	
	int Q_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_negative );
	

	double sample_cell_radius=10;
	double volume=2.4943e+03;
	double sphere_radius = 80;
	// std::cout << __FILE__ << " custom " << __LINE__ << std::endl; 
	std::vector<std::vector<double>> cell_positions;
	cell_positions= create_sphere(sample_cell_radius/5, sphere_radius);
	
	std::vector<double> tumor_center(3);
		tumor_center[0]=1000;
		tumor_center[1]=1000;
		tumor_center[2]=1000;
	
	for(int i=0;i<cell_positions.size();i++)
	{
		Cell* pCell = create_cell();
		pCell->register_microenvironment(&microenvironment);
		pCell->assign_position(tumor_center+ cell_positions[i]);
		// pCell->functions.volume_update_function=empty_function;
		// pCell->functions.update_phenotype=do_nothing;
		pCell->phenotype.cycle.data.current_phase_index = Q_index; 
		pCell->set_total_volume(volume);	
	}
	
	std::cout << (*all_cells)[0]->phenotype.geometry.radius<<std::endl;	
	std::cout << (*all_cells).size() <<" agents created successfully." <<std::endl;
	
	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	try 
	{		
		while( t < t_max )
		{
			// std::cout<<"time: "<<t<<" diff:"<<fabs( t - t_next_output_time )<<" next output time:"<<t_next_output_time<<std::endl;
			if(  fabs( t - t_next_output_time ) < 0.001 )
			{
				std::cout<<"time: "<<t<<std::endl;
				writeCellReport(*all_cells, t);
				t_next_output_time += t_output_interval;
			}
				
			((Cell_Container *)microenvironment.agent_container)->update_all_cells(t, dt, dt, dt);
			t += dt; 
		}
		double scale=1000;
		writeCellReport(*all_cells, t_max);
		std::cout << "total number of agents: " << (*all_cells).size()<<std::endl << std::endl;
		BioFVM::RUNTIME_TOC();
		BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() );
	}
	catch( const std::exception& e ) { // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "../core/PhysiCell.h"
#include "../modules/PhysiCell_standard_modules.h" 

using namespace BioFVM;
using namespace PhysiCell;

int omp_num_threads = 1; // set number of threads for parallel computing
// set this to # of CPU cores x 2 (for hyperthreading)

double o2_conc=5.01;

int main( int argc, char* argv[] )
{
	double t = 0.0; 
	double dt;
	char test_type[3];
	// -A or -a for apoptotic, -N of -n for necrotic, and -c for live cells; the command should be like "program_name dt -x" where x is from (c,n,a)
	if(argc>=2)
	{
		dt = strtod(argv[1], NULL);
		if(argc==3)
			strcpy(test_type, argv[2]);
		else
			strcpy(test_type, "-c");
	}
	else
	{
		dt=0.1;
		strcpy(test_type, "-c");
	}
	std::cout<<test_type<<", "<<dt<<std::endl;
	double t_output_interval = 60.0;
	
	// set t_max to a larger value if you want to check volume change in necrotic phase
	double t_max = 1201;
	double t_next_output_time = 0; 
	int next_output_index = 0; 
	
	double dx; 
	double dy;  
	double dz; 
	
	// openmp setup
	omp_set_num_threads(omp_num_threads);
	
	// PNRG setup 	
	SeedRandom(-35); 
	
	// figure out the bounding box 
	std::vector<double> bounding_box( 6, 0.0 );
	bounding_box[PhysiCell_constants::mesh_min_x_index] = 0; bounding_box[PhysiCell_constants::mesh_max_x_index] = 2000; 
	bounding_box[PhysiCell_constants::mesh_min_y_index] = 0; bounding_box[PhysiCell_constants::mesh_max_y_index] = 2000; 
	bounding_box[PhysiCell_constants::mesh_min_z_index] = 0; bounding_box[PhysiCell_constants::mesh_max_z_index] = 2000; 
	dx=20; dy=20; dz=20;
	
	// create a microenvironment
	BioFVM::Microenvironment microenvironment;
	microenvironment.name="substrate scale";
	// add a microenvironment for simulating substrates 	
	microenvironment.set_density(0, "oxygen" , "mmHg" );
	
	std::cout << bounding_box << std::endl; 
	
	microenvironment.resize_space( bounding_box[0] , bounding_box[3] , bounding_box[1], bounding_box[4] , bounding_box[2] , bounding_box[5] ,dx,dy,dz );
	microenvironment.spatial_units = "microns";
	microenvironment.time_units = "minutes";
	microenvironment.mesh.units = "microns";
	// Cell_Container * 
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	for( int n=0; n < microenvironment.number_of_voxels() ; n++ )
	{
		microenvironment.density_vector(n)[0] = o2_conc; 	
	}

	// register the diffusion solver 
	microenvironment.diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_3D; 
	
	initialize_default_cell_definition(); 	
	cell_defaults.type = 0; 
	cell_defaults.name = "tumor cell"; 
	// set default cell cycle model 
	cell_defaults.functions.cycle_model = Ki67_advanced; 	
	// set default_cell_functions; 
	cell_defaults.functions.update_phenotype = update_cell_and_death_parameters_O2_based; 
	//cell_defaults.functions.volume_update_function = standard_volume_update_function;
	cell_defaults.phenotype.secretion.sync_to_microenvironment( &microenvironment );
	cell_defaults.phenotype.sync_to_functions( cell_defaults.functions ); 
	// first find index for a few key variables. 
	int apoptosis_model_index = cell_defaults.phenotype.death.find_death_model_index( "Apoptosis" );
	int necrosis_model_index = cell_defaults.phenotype.death.find_death_model_index( "Necrosis" );
	int oxygen_substrate_index = microenvironment.find_density_index( "oxygen" ); 

	int K1_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_positive_premitotic );
	int K2_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_positive_postmitotic );
	int Q_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_negative );
	int A_index = Ki67_advanced.find_phase_index( PhysiCell_constants::apoptotic );
	int N_index = Ki67_advanced.find_phase_index( PhysiCell_constants::necrotic_swelling );
	
	microenvironment.display_information( std::cout );
	std::vector<double> point1(3);
	
	double a1=500;
	point1[0]= a1; point1[1]= a1; point1[2]= a1; 
	
	Cell* pCell1 = create_cell();
	pCell1->register_microenvironment(&microenvironment);
	pCell1->assign_position(point1);
	if(test_type[1]=='A' || test_type[1]=='a')
	{
		pCell1->phenotype.cycle.data.current_phase_index = A_index; 
		pCell1->phenotype.death.trigger_death( apoptosis_model_index );
		pCell1->phenotype.cycle.sync_to_cycle_model( pCell1->phenotype.death.current_model() );
	}
	else if(test_type[1]=='N' || test_type[1]=='n')
	{
		pCell1->phenotype.cycle.data.current_phase_index = N_index; 
		pCell1->phenotype.death.trigger_death( necrosis_model_index );
		pCell1->phenotype.cycle.sync_to_cycle_model( pCell1->phenotype.death.current_model() );
	}
	else if(test_type[1]=='C' || test_type[1]=='c')
	{
		pCell1->phenotype.cycle.data.current_phase_index = K1_index; 
		// disable apoptosis
		cell_defaults.phenotype.death.rates[apoptosis_model_index] =0;
		// set Q duration to a large value
		cell_defaults.phenotype.cycle.data.transition_rate(Q_index,K1_index) = 1e9;
		
	}

	pCell1->phenotype.cycle.current_phase().entry_function( pCell1, pCell1->phenotype, dt);

	
	
	
	for(int i=0;i<all_basic_agents.size();i++){
		all_basic_agents[i]->set_internal_uptake_constants(dt); 
	}
		
	std::cout << (*all_cells).size() <<" agent(s) created successfully." <<std::endl;
	
	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	std::ofstream vol_report ("vol_report.txt", std::ofstream::out);
	try 
	{		
		while( t < t_max )
		{
			if(  fabs( t - t_next_output_time ) < 0.001 )
			{
				vol_report<<t<<"\t"<<pCell1->get_total_volume()<<"\t"<<pCell1->phenotype.volume.fluid<<"\t"<<pCell1->phenotype.volume.nuclear_solid<<"\t"<<pCell1->phenotype.volume.cytoplasmic_solid<<"\n";
				t_next_output_time += t_output_interval;
			}
			if((*all_cells).size()>1)
			{
				delete_cell((Cell*)all_basic_agents[1]);
				std::cout << "cell deleted " << std::endl;
			}
			((Cell_Container *)microenvironment.agent_container)->update_all_cells(t, dt, dt, dt);
			t += dt; 
		}

		std::cout << "total number of agents: " << (*all_cells).size()<<std::endl << std::endl;
		BioFVM::RUNTIME_TOC();
		BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() );
		vol_report.close();
		std::cout<<"\nTotal volume: " << pCell1->get_total_volume()<<std::endl;
	}
	
	catch( const std::exception& e ) { // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>
#include <string> 

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// custom user modules 

#include "./custom_modules/heterogeneity.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }

	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// PNRG setup 
	SeedRandom(); 
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); 

	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	create_cell_types();
	setup_tissue();
	
	/* Users typically start modifying here. START USERMODS */ 
	
	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );
	
	// save a simulation snapshot 
	
	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = heterogeneity_coloring_function;
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	display_citations(); 
	
	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}
	
	// main loop 
	
	try 
	{	
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
			}
			
			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			
			// run PhysiCell 
			((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			PhysiCell_globals.current_time += diffusion_dt;
		}
		
		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	// timer 
	
	std::cout << std::endl << "Total simulation runtime: " << std::endl; 
	BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() ); 

	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// custom user modules 

#include "./custom_modules/biorobots.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }
	
	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// PNRG setup 
	SeedRandom(); 
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); 

	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	create_cell_types();
	setup_tissue();
	
	/* Users typically start modifying here. START USERMODS */ 
	
	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );
	
	// save a simulation snapshot 

	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = robot_coloring_function;
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	display_citations(); 
	
	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}
	
	// main loop 
	
	try 
	{	
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
			}
			
			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			
			// run PhysiCell 
			((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			PhysiCell_globals.current_time += diffusion_dt;
		}
		
		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	// timer 
	
	std::cout << std::endl << "Total simulation runtime: " << std::endl; 
	BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() ); 

	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// custom user modules 

#include "./custom_modules/cancer_biorobots.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }
	
	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// PNRG setup 
	SeedRandom(); 
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); 

	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	create_cell_types();
	setup_tissue();
	
	/* Users typically start modifying here. START USERMODS */ 

	double therapy_activation_time = parameters.doubles("therapy_activation_time"); // 60 * 24 * 7; // inject therapy at 7 days 

	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );
	
	// save a simulation snapshot 

	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = cancer_biorobots_coloring_function;
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	display_citations(); 
	
	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}	
	
	// main loop 
	
	try 
	{	
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			static bool therapy_introduced = false; 
			if( PhysiCell_globals.current_time > therapy_activation_time - 0.01*diffusion_dt && therapy_introduced == false )
			{
				std::cout << "Therapy started!" << std::endl; 
				therapy_introduced = true; 
				PhysiCell_settings.full_save_interval = parameters.doubles("save_interval_after_therapy_start"); // 3.0; 
				PhysiCell_settings.SVG_save_interval = parameters.doubles("save_interval_after_therapy_start"); // 3.0; 
				
				PhysiCell_globals.next_full_save_time = PhysiCell_globals.current_time; 
				PhysiCell_globals.next_SVG_save_time = PhysiCell_globals.current_time; 
				
				introduce_biorobots();
			} 	

			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
			}

			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			
			// run PhysiCell 
			((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			PhysiCell_globals.current_time += diffusion_dt;
		}
		
		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	// timer 
	
	std::cout << std::endl << "Total simulation runtime: " << std::endl; 
	BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() ); 

	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// custom user modules 

#include "./custom_modules/cancer_immune_3D.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }
	
	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// PNRG setup 
	SeedRandom(); 
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); 

	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	create_cell_types();
	setup_tissue();
	
	/* Users typically start modifying here. START USERMODS */ 

	double immune_activation_time = 
		parameters.doubles("immune_activation_time"); // 60 * 24 * 14; // activate immune response at 14 days 
	
	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );
	
	// save a simulation snapshot 

	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = cancer_immune_coloring_function;
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	display_citations(); 
	
	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}

	//set the diffusion solver to GPU
	microenvironment.diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_3D_GPU;
	
	// main loop 
	
	try 
	{	
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			static bool immune_cells_introduced = false; 
			if( PhysiCell_globals.current_time > immune_activation_time - 0.01*diffusion_dt && immune_cells_introduced == false )
			{
				std::cout << "Therapy activated!" << std::endl << std::endl; 
				immune_cells_introduced = true; 
				
				PhysiCell_settings.full_save_interval = 
					parameters.doubles("save_interval_after_therapy_start"); // 3.0; 
				PhysiCell_settings.SVG_save_interval = 
					parameters.doubles("save_interval_after_therapy_start"); // 3.0; 
				
				PhysiCell_globals.next_full_save_time = PhysiCell_globals.current_time; 
				PhysiCell_globals.next_SVG_save_time = PhysiCell_globals.current_time; 
				
				introduce_immune_cells();
			} 

			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				std::cout << "1" << std::endl;
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				std::cout << "2" << std::endl;
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
			}
			
			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			// if( default_microenvironment_options.calculate_gradients )
			// { microenvironment.compute_all_gradient_vectors(); }
			
			// run PhysiCell 
			// ((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			
			// manually call the code for cell sources and sinks, 
			// since these are ordinarily automatically done as part of phenotype.secretion in the 
			// PhysiCell update that we commented out above. Remove this when we go 
			// back to main code 

			#pragma omp parallel for 
			for( int i=0; i < (*all_cells).size(); i++ )
			{
				(*all_cells)[i]->phenotype.secretion.advance( (*all_cells)[i], (*all_cells)[i]->phenotype , diffusion_dt );
			}			
			
			PhysiCell_globals.current_time += diffusion_dt;
		}
		
		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );

	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>
#include <string> 

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// custom user modules 

#include "./custom_modules/heterogeneity.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }

	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// PNRG setup 
	SeedRandom(); 
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); 

	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	create_cell_types();
	setup_tissue();
	
	/* Users typically start modifying here. START USERMODS */ 
	
	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );
	
	// save a simulation snapshot 
	
	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = heterogeneity_coloring_function;
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	display_citations(); 
	
	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}
	
	// main loop 
	
	try 
	{	
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
			}
			
			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			
			// run PhysiCell 
			((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			PhysiCell_globals.current_time += diffusion_dt;
		}
		
		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	// timer 
	
	std::cout << std::endl << "Total simulation runtime: " << std::endl; 
	BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() ); 

	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// put custom code modules here! 

#include "./custom_modules/custom.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }
	
	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); // modify this in the custom code 
	
	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	/* Users typically start modifying here. START USERMODS */ 
	
	create_cell_types();
	
	setup_tissue();

	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );
	
	// save a simulation snapshot 
	
	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = my_coloring_function; 
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	display_citations(); 
	
	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}
	
	// main loop 
	
	try 
	{		
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
			}

			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			
			// run PhysiCell 
			((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			/*
			  Custom add-ons could potentially go here. 
			*/
			
			PhysiCell_globals.current_time += diffusion_dt;
		}
		
		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	// timer 
	
	std::cout << std::endl << "Total simulation runtime: " << std::endl; 
	BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() ); 

	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// put custom code modules here! 

#include "./custom_modules/custom.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }
	
	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// PNRG setup 
	SeedRandom(); 
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); // modify this in the custom code 
	
	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	/* Users typically start modifying here. START USERMODS */ 
	
	create_cell_types();
	
	setup_tissue();

	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );
	
	// save a simulation snapshot 
	
	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = my_coloring_function;
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	display_citations(); 
	
	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}
	
	// main loop 
	
	try 
	{		
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
			}

			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			
			// run PhysiCell 
			((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			/*
			  Custom add-ons could potentially go here. 
			*/			
			
			PhysiCell_globals.current_time += diffusion_dt;
		}

		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );

	
	// timer 
	
	std::cout << std::endl << "Total simulation runtime: " << std::endl; 
	BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() ); 

	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// put custom code modules here! 

#include "./custom_modules/custom.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }

	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); // modify this in the custom code 

	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );

	/* Users typically start modifying here. START USERMODS */ 
	
	create_cell_types();

	setup_tissue();

	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );

	// save a simulation snapshot 
	
	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = viral_coloring_function; 
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );

	display_citations(); 

	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}
	
	// main loop 
	
	try 
	{		
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
				
				std::cout << "Total substrates " << integrate_total_substrates() << std::endl; 
			}

			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			
			// run PhysiCell 
			((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			/*
			  Custom add-ons could potentially go here. 
			*/
			
			PhysiCell_globals.current_time += diffusion_dt;
		}
		
		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	// timer 
	
	std::cout << std::endl << "Total simulation runtime: " << std::endl; 
	BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() ); 

	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// put custom code modules here! 

#include "./custom_modules/custom.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }
	
	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); // modify this in the custom code 
	
	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	/* Users typically start modifying here. START USERMODS */ 
	
	create_cell_types();
	
	setup_tissue();

	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );
	
	// save a simulation snapshot 
	
	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = my_coloring_function; 
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	display_citations(); 
	
	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}
	
	// main loop 
	
	std::cout << "Unit test: conservation with individual agent substrate internalization " << std::endl 
		<< "If this works, the total amount of each substrate should stay fixed at each output " << std::endl << std::endl ; 
	
	try 
	{		
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
				
				std::cout << "Total substrates " << integrate_total_substrates() << std::endl; 
			}

			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			
			// run PhysiCell 
			((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			/*
			  Custom add-ons could potentially go here. 
			*/
			
			PhysiCell_globals.current_time += diffusion_dt;
		}
		
		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	// timer 
	
	std::cout << std::endl << "Total simulation runtime: " << std::endl; 
	BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() ); 

	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

// set number of threads for OpenMP (parallel computing)
int omp_num_threads = 8; // set this to # of CPU cores x 2 (for hyperthreading)

int main( int argc, char* argv[] )
{
	// OpenMP setup
	omp_set_num_threads(omp_num_threads);

	#pragma omp parallel for 
	for( int i= atoi( argv[1] ) ; i <= atoi( argv[2] ); i++ )
	{
		char str [1024]; 
		sprintf( str , "CI_vis %i", i ); 
		system( str ); 
		
		std::cout << i << " " << str << std::endl; 
		
		
	}
	

	
	return 0; 
}
########## NEXT FILE ##########
