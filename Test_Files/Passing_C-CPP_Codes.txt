#define BENCHMARK

#define ENABLE_ACC_COMPARE
#define ENABLE_PGI_COMPARE

#ifdef USE_NVTX
#include "nvToolsExt.h"

const uint32_t ProfilerColors[] = { 0xff00ff00, 0xff0000ff, 0xffffff00, 0xffff00ff, 0xff00ffff, 0xffff0000, 0xffffffff };

#define NVPROF_PUSH_RANGE(name,cid) { \
    int color_id = cid; \
    nvtxEventAttributes_t eventAttrib = {0}; \
    eventAttrib.version = NVTX_VERSION; \
    eventAttrib.size = NVTX_EVENT_ATTRIB_STRUCT_SIZE; \
    eventAttrib.colorType = NVTX_COLOR_ARGB; \
    eventAttrib.color = ProfilerColors[color_id]; \
    eventAttrib.messageType = NVTX_MESSAGE_TYPE_ASCII; \
    eventAttrib.message.ascii = name; \
    nvtxRangePushEx(&eventAttrib); \
}
#define NVPROF_POP_RANGE nvtxRangePop();
#else
#define NVPROF_PUSH_RANGE(name,cid)
#define NVPROF_POP_RANGE
#endif

#if defined(ENABLE_PGI_COMPARE) && defined(USE_PGI_COMPARE) && defined(_OPENACC) && defined(__PGI)
#include <openacc.h>
#define PGI_COMPARE(ptr,type,size,name,file,func,line) {\
    type* pgi_compare_ptr = (type*)ptr;\
    pgi_compare(ptr, "type", size, \
    name, file, func, line);\
}
#else
#define PGI_COMPARE(ptr,size,name,file,func,line)
#endif

#if defined(ENABLE_ACC_COMPARE) && defined(USE_ACC_COMPARE) && defined(_OPENACC) && defined(__PGI)
#include <openacc.h>
#define ACC_COMPARE(ptr,type,size) {\
    type* acc_compare_ptr = (type*) ptr;\
    acc_compare(acc_compare_ptr, size);\
}
#else
#define ACC_COMPARE(ptr,type,size)
#endif


########## NEXT FILE ##########
/*
 * Library:   lmfit (Levenberg-Marquardt least squares fitting)
 *
 * File:      lmcurve.c
 *
 * Contents:  Levenberg-Marquardt curve-fitting
 *
 * Copyright: Joachim Wuttke, Forschungszentrum Juelich GmbH (2004-2013)
 *
 * License:   see ../COPYING (FreeBSD)
 * 
 * Homepage:  apps.jcns.fz-juelich.de/lmfit
 */

#include "lmmin.h"

#ifdef USE_OPENMP
#include "omp.h"
#endif

typedef struct {
    const double *t;
    const double *y;
    double (*f) (double t, const double *par);
} lmcurve_data_struct;


void lmcurve_evaluate( const double *par, int m_dat, const void *data,
                       double *fvec, int *info )
{
    int i;
    for ( i = 0; i < m_dat; i++ )
        fvec[i] =
            ((lmcurve_data_struct*)data)->y[i] -
            ((lmcurve_data_struct*)data)->f(
                ((lmcurve_data_struct*)data)->t[i], par );
}


void lmcurve( int n_par, double *par, int m_dat, 
              const double *t, const double *y,
              double (*f)( double t, const double *par ),
              const lm_control_struct *control,
              lm_status_struct *status )
{
    lmcurve_data_struct data;
    data.t = t;
    data.y = y;
    data.f = f;

    lmmin( n_par, par, m_dat, (const void*) &data,m_dat, (const void*) &data,
           lmcurve_evaluate, control, status );
}

########## NEXT FILE ##########
/*
 * Library:   lmfit (Levenberg-Marquardt least squares fitting)
 *
 * File:      lmcurve.c
 *
 * Contents:  Levenberg-Marquardt curve-fitting
 *
 * Copyright: Joachim Wuttke, Forschungszentrum Juelich GmbH (2004-2013)
 *
 * License:   see ../COPYING (FreeBSD)
 * 
 * Homepage:  apps.jcns.fz-juelich.de/lmfit
 */

#include "lmmin.h"

#ifdef USE_OPENMP
#include "omp.h"
#endif

typedef struct {
    const double *t;
    const double *y;
    double (*f) (double t, const double *par);
} lmcurve_data_struct;


void lmcurve_evaluate( const double *par, int m_dat, const void *data,
                       double *fvec, int *info )
{
    int i;
    for ( i = 0; i < m_dat; i++ )
        fvec[i] =
            ((lmcurve_data_struct*)data)->y[i] -
            ((lmcurve_data_struct*)data)->f(
                ((lmcurve_data_struct*)data)->t[i], par );
}


void lmcurve( int n_par, double *par, int m_dat, 
              const double *t, const double *y,
              double (*f)( double t, const double *par ),
              const lm_control_struct *control,
              lm_status_struct *status )
{
    lmcurve_data_struct data;
    data.t = t;
    data.y = y;
    data.f = f;

    lmmin( n_par, par, m_dat, (const void*) &data,m_dat, (const void*) &data,
           lmcurve_evaluate, control, status );
}

########## NEXT FILE ##########
/*
 * Library:   lmfit (Levenberg-Marquardt least squares fitting)
 *
 * File:      lmmin.c
 *
 * Contents:  Levenberg-Marquardt minimization.
 *
 * Copyright: MINPACK authors, The University of Chikago (1980-1999)
 *            Joachim Wuttke, Forschungszentrum Juelich GmbH (2004-2013)
 *
 * License:   see ../COPYING (FreeBSD)
 * 
 * Homepage:  apps.jcns.fz-juelich.de/lmfit
 */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <float.h>
#include "lmmin.h"

#ifdef USE_OPENMP
#include "omp.h"
#endif


#define MIN(a,b) (((a)<=(b)) ? (a) : (b))
#define MAX(a,b) (((a)>=(b)) ? (a) : (b))
#define SQR(x)   (x)*(x)

/* function declarations (implemented below). */
void lm_lmpar( int n, double *r, int ldr, int *ipvt, double *diag,
               double *qtb, double delta, double *par, double *x,
               double *sdiag, double *aux, double *xdi );
void lm_qrfac( int m, int n, double *a, int *ipvt,
               double *rdiag, double *acnorm, double *wa );
void lm_qrsolv( int n, double *r, int ldr, int *ipvt, double *diag,
                double *qtb, double *x, double *sdiag, double *wa );


/*****************************************************************************/
/*  Numeric constants                                                        */
/*****************************************************************************/

/* machine-dependent constants from float.h */
#define LM_MACHEP     DBL_EPSILON   /* resolution of arithmetic */
#define LM_DWARF      DBL_MIN       /* smallest nonzero number */
#define LM_SQRT_DWARF sqrt(DBL_MIN) /* square should not underflow */
#define LM_SQRT_GIANT sqrt(DBL_MAX) /* square should not overflow */
#define LM_USERTOL    30*LM_MACHEP  /* users are recommended to require this */

/* If the above values do not work, the following seem good for an x86:
 LM_MACHEP     .555e-16
 LM_DWARF      9.9e-324 
 LM_SQRT_DWARF 1.e-160   
 LM_SQRT_GIANT 1.e150 
 LM_USER_TOL   1.e-14
   The following values should work on any machine:
 LM_MACHEP     1.2e-16
 LM_DWARF      1.0e-38
 LM_SQRT_DWARF 3.834e-20
 LM_SQRT_GIANT 1.304e19
 LM_USER_TOL   1.e-14
*/

const lm_control_struct lm_control_double = {
    LM_USERTOL, LM_USERTOL, LM_USERTOL, LM_USERTOL, 1.00 , 100, 1, 
    NULL, 0, -1, -1, 4 };
const lm_control_struct lm_control_float = {
    1.e-7,      1.e-7,      1.e-7,      1.e-7,      1.00 , 100, 1,
    NULL, 0, -1, -1, 4 };


/*****************************************************************************/
/*  Message texts (indexed by status.info)                                   */
/*****************************************************************************/

const char *lm_infmsg[] = {
    "found zero (sum of squares below underflow limit)",
    "converged  (the relative error in the sum of squares is at most tol)",
    "converged  (the relative error of the parameter vector is at most tol)",
    "converged  (both errors are at most tol)",
    "trapped    (by degeneracy; increasing epsilon might help)",
    "exhausted  (number of function calls exceeding preset patience)",
    "failed     (ftol<tol: cannot reduce sum of squares any further)",
    "failed     (xtol<tol: cannot improve approximate solution any further)",
    "failed     (gtol<tol: cannot improve approximate solution any further)",
    "crashed    (not enough memory)",
    "exploded   (fatal coding error: improper input parameters)",
    "stopped    (break requested within function evaluation)",
	"stopped    (break because validation set fail to improve)"
};

const char *lm_shortmsg[] = {
    "found zero",
    "converged (f)",
    "converged (p)",
    "converged (2)",
    "degenerate",
    "call limit",
    "failed (f)",
    "failed (p)",
    "failed (o)",
    "no memory",
    "invalid input",
    "user break"
	"validation check break"
};


/*****************************************************************************/
/*  Monitoring auxiliaries.                                                  */
/*****************************************************************************/

void lm_print_pars( int nout, const double *par, double fval, double fnorm, FILE* fout )
{
    int i;
    for (i = 0; i < nout; ++i)
        fprintf( fout, " %16.9g", par[i] );
    fprintf( fout, " => %18.11g ", fval );
    fprintf( fout, " => %18.11g\n", fnorm );
}


/*****************************************************************************/
/*  lmmin (main minimization routine)                                        */
/*****************************************************************************/

void lmmin( int n, double *x, int m, const void *data, int m2, const void * data2,
            void (*evaluate) (const double *par, int m_dat, const void *data,
                              double *fvec, int *userbreak),
            const lm_control_struct *C, lm_status_struct *S )
{
	int nalert;    /* added by dawei li */
	double *fvec2, validation_sum, temp_validation, *xback; /* added by dawei li */
    double *fvec, *diag, *fjac, *qtf, *wa1, *wa2, *wa3, *wf;
    int *ipvt;
    int j, i;
    double actred, dirder, fnorm, fnorm1, gnorm, pnorm,
        prered, ratio, step, sum, temp, temp1, temp2, temp3;
    static double p0001 = 1.0e-4;

    int maxfev = C->patience * (n+1);

    int    outer, inner;  /* loop counters, for monitoring */
    int    inner_success; /* flag for loop control */
    double lmpar = 0;     /* Levenberg-Marquardt parameter */
    double delta = 0;
    double xnorm = 0;
    double eps = sqrt(MAX(C->epsilon, LM_MACHEP)); /* for forward differences */

    int nout = C->n_maxpri==-1 ? n : MIN( C->n_maxpri, n );

    /* The workaround msgfile=NULL is needed for default initialization */
    FILE* msgfile = C->msgfile ? C->msgfile : stdout;

    /* Default status info; must be set ahead of first return statements */    
    S->outcome = 0;      /* status code */
    S->userbreak = 0;
    S->nfev = 0;      /* function evaluation counter */

/***  Check input parameters for errors.  ***/

    if ( n <= 0 ) {
        fprintf( stderr, "lmmin: invalid number of parameters %i\n", n );
        S->outcome = 10; /* invalid parameter */
        return;
    }
    if (m < n) {
        fprintf( stderr, "lmmin: number of data points (%i) "
                 "smaller than number of parameters (%i)\n", m, n );
        S->outcome = 10;
        return;
    }
    if (C->ftol < 0. || C->xtol < 0. || C->gtol < 0.) {
        fprintf( stderr,
                 "lmmin: negative tolerance (at least one of %g %g %g)\n",
                 C->ftol, C->xtol, C->gtol );
        S->outcome = 10;
        return;
    }
    if (maxfev <= 0) {
        fprintf( stderr, "lmmin: nonpositive function evaluations limit %i\n",
                 maxfev );
        S->outcome = 10;
        return;
    }
    if (C->stepbound <= 0.) {
        fprintf( stderr, "lmmin: nonpositive stepbound %g\n", C->stepbound );
        S->outcome = 10;
        return;
    }
    if (C->scale_diag != 0 && C->scale_diag != 1) {
        fprintf( stderr, "lmmin: logical variable scale_diag=%i, "
                 "should be 0 or 1\n", C->scale_diag );
        S->outcome = 10;
        return;
    }

/***  Allocate work space.  ***/

    if ( (fvec = (double *) malloc(m * sizeof(double))) == NULL ||
		 (fvec2= (double *) malloc(m2* sizeof(double))) == NULL ||  /*added by dawei*/
		 (xback= (double *) malloc(n * sizeof(double))) == NULL ||  /*added by dawei*/
         (diag = (double *) malloc(n * sizeof(double))) == NULL ||
         (qtf  = (double *) malloc(n * sizeof(double))) == NULL ||
         (fjac = (double *) malloc(n*m*sizeof(double))) == NULL ||
         (wa1  = (double *) malloc(n * sizeof(double))) == NULL ||
         (wa2  = (double *) malloc(n * sizeof(double))) == NULL ||
         (wa3  = (double *) malloc(n * sizeof(double))) == NULL ||
         (wf  = (double *)  malloc(m * sizeof(double))) == NULL ||
         (ipvt = (int *)    malloc(n * sizeof(int)   )) == NULL    ) {
        S->outcome = 9;
        return;
    }

    if (!C->scale_diag) {
        for (j = 0; j < n; j++)
            diag[j] = 1.;
    }

	/* get the sum of validation */
	
	(*evaluate)(x,m2,data2,fvec2, &(S->userbreak) );
	temp_validation=0.0;
	for(j=0;j<m2;j++)
		temp_validation+=fvec2[j]*fvec2[j];
	validation_sum=temp_validation;
	nalert=0;

/* above code block is added by dawei li*/

/***  Evaluate function at starting point and calculate norm.  ***/

    (*evaluate)( x, m, data, fvec, &(S->userbreak) );
    S->nfev = 1;
    if ( S->userbreak )
        goto terminate;
    fnorm = lm_enorm(m, fvec);
    if( C->verbosity ) {
        fprintf( msgfile, "lmmin start " );
        lm_print_pars( nout, x, validation_sum, fnorm, msgfile );
    }
    if( fnorm <= LM_DWARF ){
        S->outcome = 0; /* sum of squares almost zero, nothing to do */
        goto terminate;
    }



/***  The outer loop: compute gradient, then descend.  ***/

    for( outer=0; ; ++outer ) {

/* validation check added by dawei li */
		
		(*evaluate)(x,m2,data2,fvec2, &(S->userbreak) );
		temp_validation=0.0;
		for(j=0;j<m2;j++)
			temp_validation+=fvec2[j]*fvec2[j];

		if(temp_validation>validation_sum)  
		{
			nalert++;
			if(nalert>4) 
			{
				S->outcome = 12;
				/*restor x from x_back because x is not good but xback is the best set*/
				for(j=0;j<n;j++)
					x[j]=xback[j];
                goto terminate;
			}
		}
		else
		{
			nalert=0;
			validation_sum=temp_validation;
			
			/*backup x to xback*/
			for(j=0;j<n;j++)
				xback[j]=x[j];
		}


/***  [outer]  Calculate the Jacobian.  ***/

        for (j = 0; j < n; j++) {
            temp = x[j];
            step = MAX(eps*eps, eps * fabs(temp));
            x[j] += step; /* replace temporarily */
            (*evaluate)( x, m, data, wf, &(S->userbreak) );
            ++(S->nfev);
            if ( S->userbreak )
                goto terminate;
            for (i = 0; i < m; i++)
                fjac[j*m+i] = (wf[i] - fvec[i]) / step;
            x[j] = temp; /* restore */
        }
        if ( C->verbosity >=10 ) {
            /* print the entire matrix */
            printf("\nlmmin Jacobian\n");
            for (i = 0; i < m; i++) {
                printf("  ");
                for (j = 0; j < n; j++)
                    printf("%.5e ", fjac[j*m+i]);
                printf("\n");
            }
        }

/***  [outer]  Compute the QR factorization of the Jacobian.  ***/

/*      fjac is an m by n array. The upper n by n submatrix of fjac 
 *        is made to contain an upper triangular matrix r with diagonal
 *        elements of nonincreasing magnitude such that
 *
 *              p^T*(jac^T*jac)*p = r^T*r
 *
 *              (NOTE: ^T stands for matrix transposition),
 *
 *        where p is a permutation matrix and jac is the final calculated
 *        Jacobian. Column j of p is column ipvt(j) of the identity matrix.
 *        The lower trapezoidal part of fjac contains information generated
 *        during the computation of r.
 *
 *      ipvt is an integer array of length n. It defines a permutation
 *        matrix p such that jac*p = q*r, where jac is the final calculated
 *        Jacobian, q is orthogonal (not stored), and r is upper triangular
 *        with diagonal elements of nonincreasing magnitude. Column j of p
 *        is column ipvt(j) of the identity matrix.
 */

        lm_qrfac(m, n, fjac, ipvt, wa1, wa2, wa3);
        /* return values are ipvt, wa1=rdiag, wa2=acnorm */

/***  [outer]  Form q^T * fvec and store first n components in qtf.  ***/

        for (i = 0; i < m; i++)
            wf[i] = fvec[i];

        for (j = 0; j < n; j++) {
            temp3 = fjac[j*m+j];
            if (temp3 != 0.) {
                sum = 0;
                for (i = j; i < m; i++)
                    sum += fjac[j*m+i] * wf[i];
                temp = -sum / temp3;
                for (i = j; i < m; i++)
                    wf[i] += fjac[j*m+i] * temp;
            }
            fjac[j*m+j] = wa1[j];
            qtf[j] = wf[j];
        }

/***  [outer]  Compute norm of scaled gradient and detect degeneracy.  ***/

        gnorm = 0;
        for (j = 0; j < n; j++) {
            if (wa2[ipvt[j]] == 0)
                continue;
            sum = 0.;
            for (i = 0; i <= j; i++)
                sum += fjac[j*m+i] * qtf[i];
            gnorm = MAX( gnorm, fabs( sum / wa2[ipvt[j]] / fnorm ) );
        }

        if (gnorm <= C->gtol) {
            S->outcome = 4;
            goto terminate;
        }

/***  [outer]  Initialize / update diag and delta. ***/

        if ( !outer ) { 
            /* first iteration only */
            if (C->scale_diag) {
                /* diag := norms of the columns of the initial Jacobian */
                for (j = 0; j < n; j++)
                    diag[j] = wa2[j] ? wa2[j] : 1;
                /* xnorm := || D x || */
                for (j = 0; j < n; j++)
                    wa3[j] = diag[j] * x[j];
                xnorm = lm_enorm(n, wa3);
                if( C->verbosity >= 2 ) {
                    fprintf( msgfile, "lmmin diag  " );
                    lm_print_pars( nout, x, validation_sum, xnorm, msgfile );
                }
                /* only now print the header for the loop table */
                if( C->verbosity >=3 ) {
                    fprintf( msgfile, "  o  i     lmpar    prered"
                             "          ratio    dirder      delta"
                             "      pnorm                 fnorm" );
                    for (i = 0; i < nout; ++i)
                        fprintf( msgfile, "               p%i", i );
                    fprintf( msgfile, "\n" );
                }
            } else {
                xnorm = lm_enorm(n, x);
            }
            /* initialize the step bound delta. */
            if ( xnorm )
                delta = C->stepbound * xnorm;
            else
                delta = C->stepbound;
        } else {
            if (C->scale_diag) {
                for (j = 0; j < n; j++)
                    diag[j] = MAX( diag[j], wa2[j] );
            }
        }

/***  The inner loop. ***/
        inner = 0;
        do {

/***  [inner]  Determine the Levenberg-Marquardt parameter.  ***/

            lm_lmpar( n, fjac, m, ipvt, diag, qtf, delta, &lmpar,
                      wa1, wa2, wf, wa3 );
            /* used return values are fjac (partly), lmpar, wa1=x, wa3=diag*x */

            /* predict scaled reduction */
            pnorm = lm_enorm(n, wa3);
            temp2 = lmpar * SQR( pnorm / fnorm );
            for (j = 0; j < n; j++) {
                wa3[j] = 0;
                for (i = 0; i <= j; i++)
                    wa3[i] -= fjac[j*m+i] * wa1[ipvt[j]];
            }
            temp1 = SQR( lm_enorm(n, wa3) / fnorm );
            prered = temp1 + 2 * temp2;
            dirder = -temp1 + temp2; /* scaled directional derivative */

            /* at first call, adjust the initial step bound. */
            if ( !outer && pnorm < delta )
                delta = pnorm;

/***  [inner]  Evaluate the function at x + p.  ***/

            for (j = 0; j < n; j++)
                wa2[j] = x[j] - wa1[j];

            (*evaluate)( wa2, m, data, wf, &(S->userbreak) );
            ++(S->nfev);
            if ( S->userbreak )
                goto terminate;
            fnorm1 = lm_enorm(m, wf);

/***  [inner]  Evaluate the scaled reduction.  ***/

            /* actual scaled reduction */
            actred = 1 - SQR(fnorm1/fnorm);

            /* ratio of actual to predicted reduction */
            ratio = prered ? actred/prered : 0;

            if( C->verbosity == 2 ) {
                fprintf( msgfile, "lmmin (%i:%i) ", outer, inner );
                lm_print_pars( nout, wa2, validation_sum, fnorm1, msgfile );
            } else if( C->verbosity >= 3 ) {
                printf( "%3i %2i %9.2g %9.2g %14.6g"
                        " %9.2g %10.3e %10.3e %21.15e",
                        outer, inner, lmpar, prered, ratio,
                        dirder, delta, pnorm, fnorm1 );
                for (i = 0; i < nout; ++i)
                    fprintf( msgfile, " %16.9g", wa2[i] );
                fprintf( msgfile, "\n" );
            }

            /* update the step bound */
            if        ( ratio <= 0.25 ) {
                if      ( actred >= 0 )
                    temp = 0.5;
                else if ( actred > -99 ) /* -99 = 1-1/0.1^2 */
                    temp = MAX( dirder / (2*dirder + actred), 0.1 );
                else
                    temp = 0.1;
                delta = temp * MIN(delta, pnorm / 0.1);
                lmpar /= temp;
            } else if ( ratio >= 0.75 ) {
                delta = 2*pnorm;
                lmpar *= 0.5;
            } else if ( !lmpar ) {
                delta = 2*pnorm;
            }

/***  [inner]  On success, update solution, and test for convergence.  ***/

            inner_success = ratio >= p0001;
            if ( inner_success ) {

                /* update x, fvec, and their norms */
                if (C->scale_diag) {
                    for (j = 0; j < n; j++) {
                        x[j] = wa2[j];
                        wa2[j] = diag[j] * x[j];
                    }
                } else {
                    for (j = 0; j < n; j++)
                        x[j] = wa2[j];
                }
                for (i = 0; i < m; i++)
                    fvec[i] = wf[i];
                xnorm = lm_enorm(n, wa2);
                fnorm = fnorm1;
            }

            /* convergence tests */ 
            S->outcome = 0;
            if( fnorm<=LM_DWARF )
                goto terminate;  /* success: sum of squares almost zero */
            /* test two criteria (both may be fulfilled) */
            if (fabs(actred) <= C->ftol && prered <= C->ftol && ratio <= 2)
                S->outcome = 1;  /* success: x almost stable */
            if (delta <= C->xtol * xnorm)
                S->outcome += 2; /* success: sum of squares almost stable */
            if (S->outcome != 0) {
                goto terminate;
            }

/***  [inner]  Tests for termination and stringent tolerances.  ***/

            if ( S->nfev >= maxfev ){
                S->outcome = 5;
                goto terminate;
            }
            if ( fabs(actred) <= LM_MACHEP &&
                 prered <= LM_MACHEP && ratio <= 2 ){
                S->outcome = 6;
                goto terminate;
            }
            if ( delta <= LM_MACHEP*xnorm ){
                S->outcome = 7;
                goto terminate;
            }
            if ( gnorm <= LM_MACHEP ){
                S->outcome = 8;
                goto terminate;
            }

/***  [inner]  End of the loop. Repeat if iteration unsuccessful.  ***/

            ++inner;
        } while ( !inner_success );

/***  [outer]  End of the loop. ***/

    };

terminate:
    S->fnorm = lm_enorm(m, fvec);
    if ( C->verbosity >= 2 )
        printf("lmmin outcome (%i) xnorm %g ftol %g xtol %g\n",
               S->outcome, xnorm, C->ftol, C->xtol );
    if( C->verbosity & 1 ) {
        fprintf( msgfile, "lmmin final " );
        lm_print_pars( nout, x, validation_sum, S->fnorm, msgfile );
    }
    if ( S->userbreak ) /* user-requested break */
        S->outcome = 11;

/***  Deallocate the workspace.  ***/
    free(fvec);
    free(diag);
    free(qtf);
    free(fjac);
    free(wa1);
    free(wa2);
    free(wa3);
    free(wf);
    free(ipvt);

} /*** lmmin. ***/


/*****************************************************************************/
/*  lm_lmpar (determine Levenberg-Marquardt parameter)                       */
/*****************************************************************************/

void lm_lmpar(int n, double *r, int ldr, int *ipvt, double *diag,
              double *qtb, double delta, double *par, double *x,
              double *sdiag, double *aux, double *xdi)
{
/*     Given an m by n matrix a, an n by n nonsingular diagonal
 *     matrix d, an m-vector b, and a positive number delta,
 *     the problem is to determine a value for the parameter
 *     par such that if x solves the system
 *
 *          a*x = b  and  sqrt(par)*d*x = 0
 *
 *     in the least squares sense, and dxnorm is the euclidean
 *     norm of d*x, then either par=0 and (dxnorm-delta) < 0.1*delta,
 *     or par>0 and abs(dxnorm-delta) < 0.1*delta.
 *
 *     Using lm_qrsolv, this subroutine completes the solution of the problem
 *     if it is provided with the necessary information from the
 *     qr factorization, with column pivoting, of a. That is, if
 *     a*p = q*r, where p is a permutation matrix, q has orthogonal
 *     columns, and r is an upper triangular matrix with diagonal
 *     elements of nonincreasing magnitude, then lmpar expects
 *     the full upper triangle of r, the permutation matrix p,
 *     and the first n components of qT*b. On output
 *     lmpar also provides an upper triangular matrix s such that
 *
 *          p^T*(a^T*a + par*d*d)*p = s^T*s.
 *
 *     s is employed within lmpar and may be of separate interest.
 *
 *     Only a few iterations are generally needed for convergence
 *     of the algorithm. If, however, the limit of 10 iterations
 *     is reached, then the output par will contain the best
 *     value obtained so far.
 *
 *     parameters:
 *
 *      n is a positive integer input variable set to the order of r.
 *
 *      r is an n by n array. on input the full upper triangle
 *        must contain the full upper triangle of the matrix r.
 *        on OUTPUT the full upper triangle is unaltered, and the
 *        strict lower triangle contains the strict upper triangle
 *        (transposed) of the upper triangular matrix s.
 *
 *      ldr is a positive integer input variable not less than n
 *        which specifies the leading dimension of the array r.
 *
 *      ipvt is an integer input array of length n which defines the
 *        permutation matrix p such that a*p = q*r. column j of p
 *        is column ipvt(j) of the identity matrix.
 *
 *      diag is an input array of length n which must contain the
 *        diagonal elements of the matrix d.
 *
 *      qtb is an input array of length n which must contain the first
 *        n elements of the vector (q transpose)*b.
 *
 *      delta is a positive input variable which specifies an upper
 *        bound on the euclidean norm of d*x.
 *
 *      par is a nonnegative variable. on input par contains an
 *        initial estimate of the levenberg-marquardt parameter.
 *        on OUTPUT par contains the final estimate.
 *
 *      x is an OUTPUT array of length n which contains the least
 *        squares solution of the system a*x = b, sqrt(par)*d*x = 0,
 *        for the output par.
 *
 *      sdiag is an array of length n needed as workspace; on OUTPUT
 *        it contains the diagonal elements of the upper triangular matrix s.
 *
 *      aux is a multi-purpose work array of length n.
 *
 *      xdi is a work array of length n. On OUTPUT: diag[j] * x[j].
 *
 */
    int i, iter, j, nsing;
    double dxnorm, fp, fp_old, gnorm, parc, parl, paru;
    double sum, temp;
    static double p1 = 0.1;

/*** lmpar: compute and store in x the gauss-newton direction. if the
     jacobian is rank-deficient, obtain a least squares solution. ***/

    nsing = n;
    for (j = 0; j < n; j++) {
        aux[j] = qtb[j];        
        if (r[j * ldr + j] == 0 && nsing == n)
            nsing = j;
        if (nsing < n)
            aux[j] = 0;
    }
    for (j = nsing - 1; j >= 0; j--) {
        aux[j] = aux[j] / r[j + ldr * j];
        temp = aux[j];
        for (i = 0; i < j; i++)
            aux[i] -= r[j * ldr + i] * temp;
    }

    for (j = 0; j < n; j++)
        x[ipvt[j]] = aux[j];

/*** lmpar: initialize the iteration counter, evaluate the function at the
     origin, and test for acceptance of the gauss-newton direction. ***/

    for (j = 0; j < n; j++)
        xdi[j] = diag[j] * x[j];
    dxnorm = lm_enorm(n, xdi);
    fp = dxnorm - delta;
    if (fp <= p1 * delta) {
#ifdef LMFIT_DEBUG_MESSAGES
        printf("debug lmpar nsing %d n %d, terminate (fp<p1*delta)\n",
               nsing, n);
#endif
        *par = 0;
        return;
    }

/*** lmpar: if the jacobian is not rank deficient, the newton
     step provides a lower bound, parl, for the 0. of
     the function. otherwise set this bound to 0.. ***/

    parl = 0;
    if (nsing >= n) {
        for (j = 0; j < n; j++)
            aux[j] = diag[ipvt[j]] * xdi[ipvt[j]] / dxnorm;

        for (j = 0; j < n; j++) {
            sum = 0.;
            for (i = 0; i < j; i++)
                sum += r[j * ldr + i] * aux[i];
            aux[j] = (aux[j] - sum) / r[j + ldr * j];
        }
        temp = lm_enorm(n, aux);
        parl = fp / delta / temp / temp;
    }

/*** lmpar: calculate an upper bound, paru, for the 0. of the function. ***/

    for (j = 0; j < n; j++) {
        sum = 0;
        for (i = 0; i <= j; i++)
            sum += r[j * ldr + i] * qtb[i];
        aux[j] = sum / diag[ipvt[j]];
    }
    gnorm = lm_enorm(n, aux);
    paru = gnorm / delta;
    if (paru == 0.)
        paru = LM_DWARF / MIN(delta, p1);

/*** lmpar: if the input par lies outside of the interval (parl,paru),
     set par to the closer endpoint. ***/

    *par = MAX(*par, parl);
    *par = MIN(*par, paru);
    if (*par == 0.)
        *par = gnorm / dxnorm;

/*** lmpar: iterate. ***/

    for (iter=0; ; iter++) {

        /** evaluate the function at the current value of par. **/

        if (*par == 0.)
            *par = MAX(LM_DWARF, 0.001 * paru);
        temp = sqrt(*par);
        for (j = 0; j < n; j++)
            aux[j] = temp * diag[j];

        lm_qrsolv( n, r, ldr, ipvt, aux, qtb, x, sdiag, xdi );
        /* return values are r, x, sdiag */

        for (j = 0; j < n; j++)
            xdi[j] = diag[j] * x[j]; /* used as output */
        dxnorm = lm_enorm(n, xdi);
        fp_old = fp;
        fp = dxnorm - delta;
        
        /** if the function is small enough, accept the current value
            of par. Also test for the exceptional cases where parl
            is zero or the number of iterations has reached 10. **/

        if (fabs(fp) <= p1 * delta
            || (parl == 0. && fp <= fp_old && fp_old < 0.)
            || iter == 10) {
#ifdef LMFIT_DEBUG_MESSAGES
            printf("debug lmpar nsing %d iter %d "
                   "par %.4e [%.4e %.4e] delta %.4e fp %.4e\n",
                   nsing, iter, *par, parl, paru, delta, fp);
#endif
            break; /* the only exit from the iteration. */
        }
        
        /** compute the Newton correction. **/

        for (j = 0; j < n; j++)
            aux[j] = diag[ipvt[j]] * xdi[ipvt[j]] / dxnorm;

        for (j = 0; j < n; j++) {
            aux[j] = aux[j] / sdiag[j];
            for (i = j + 1; i < n; i++)
                aux[i] -= r[j * ldr + i] * aux[j];
        }
        temp = lm_enorm(n, aux);
        parc = fp / delta / temp / temp;

        /** depending on the sign of the function, update parl or paru. **/

        if (fp > 0)
            parl = MAX(parl, *par);
        else if (fp < 0)
            paru = MIN(paru, *par);
        /* the case fp==0 is precluded by the break condition  */
        
        /** compute an improved estimate for par. **/
        
        *par = MAX(parl, *par + parc);
        
    }

} /*** lm_lmpar. ***/

/*****************************************************************************/
/*  lm_qrfac (QR factorization, from lapack)                                 */
/*****************************************************************************/

void lm_qrfac(int m, int n, double *a, int *ipvt,
              double *rdiag, double *acnorm, double *wa)
{
/*
 *     This subroutine uses Householder transformations with column
 *     pivoting (optional) to compute a qr factorization of the
 *     m by n matrix a. That is, qrfac determines an orthogonal
 *     matrix q, a permutation matrix p, and an upper trapezoidal
 *     matrix r with diagonal elements of nonincreasing magnitude,
 *     such that a*p = q*r. The Householder transformation for
 *     column k, k = 1,2,...,min(m,n), is of the form
 *
 *          i - (1/u(k))*u*uT
 *
 *     where u has zeroes in the first k-1 positions. The form of
 *     this transformation and the method of pivoting first
 *     appeared in the corresponding linpack subroutine.
 *
 *     Parameters:
 *
 *      m is a positive integer input variable set to the number
 *        of rows of a.
 *
 *      n is a positive integer input variable set to the number
 *        of columns of a.
 *
 *      a is an m by n array. On input a contains the matrix for
 *        which the qr factorization is to be computed. On OUTPUT
 *        the strict upper trapezoidal part of a contains the strict
 *        upper trapezoidal part of r, and the lower trapezoidal
 *        part of a contains a factored form of q (the non-trivial
 *        elements of the u vectors described above).
 *
 *      ipvt is an integer OUTPUT array of length lipvt. This array
 *        defines the permutation matrix p such that a*p = q*r.
 *        Column j of p is column ipvt(j) of the identity matrix.
 *
 *      rdiag is an OUTPUT array of length n which contains the
 *        diagonal elements of r.
 *
 *      acnorm is an OUTPUT array of length n which contains the
 *        norms of the corresponding columns of the input matrix a.
 *        If this information is not needed, then acnorm can coincide
 *        with rdiag.
 *
 *      wa is a work array of length n.
 *
 */
    int i, j, k, kmax, minmn;
    double ajnorm, sum, temp;

/*** qrfac: compute initial column norms and initialize several arrays. ***/

    for (j = 0; j < n; j++) {
        acnorm[j] = lm_enorm(m, &a[j*m]);
        rdiag[j] = acnorm[j];
        wa[j] = rdiag[j];
        ipvt[j] = j;
    }
#ifdef LMFIT_DEBUG_MESSAGES
    printf("debug qrfac\n");
#endif

/*** qrfac: reduce a to r with Householder transformations. ***/

    minmn = MIN(m, n);
    for (j = 0; j < minmn; j++) {

        /** bring the column of largest norm into the pivot position. **/

        kmax = j;
        for (k = j + 1; k < n; k++)
            if (rdiag[k] > rdiag[kmax])
                kmax = k;
        if (kmax == j)
            goto pivot_ok;

        for (i = 0; i < m; i++) {
            temp = a[j*m+i];
            a[j*m+i] = a[kmax*m+i];
            a[kmax*m+i] = temp;
        }
        rdiag[kmax] = rdiag[j];
        wa[kmax] = wa[j];
        k = ipvt[j];
        ipvt[j] = ipvt[kmax];
        ipvt[kmax] = k;

      pivot_ok:
        /** compute the Householder transformation to reduce the
            j-th column of a to a multiple of the j-th unit vector. **/

        ajnorm = lm_enorm(m-j, &a[j*m+j]);
        if (ajnorm == 0.) {
            rdiag[j] = 0;
            continue;
        }

        if (a[j*m+j] < 0.)
            ajnorm = -ajnorm;
        for (i = j; i < m; i++)
            a[j*m+i] /= ajnorm;
        a[j*m+j] += 1;

        /** apply the transformation to the remaining columns
            and update the norms. **/
#pragma omp parallel for private(k,sum,temp,i)
        for (k = j + 1; k < n; k++) {
            sum = 0;

            for (i = j; i < m; i++)
                sum += a[j*m+i] * a[k*m+i];

            temp = sum / a[j + m * j];

#pragma ivdep
            for (i = j; i < m; i++)
                a[k*m+i] -= temp * a[j*m+i];

            if (rdiag[k] != 0.) {
                temp = a[m * k + j] / rdiag[k];
                temp = MAX(0., 1 - temp * temp);
                rdiag[k] *= sqrt(temp);
                temp = rdiag[k] / wa[k];
                if ( 0.05 * SQR(temp) <= LM_MACHEP ) {
                    rdiag[k] = lm_enorm(m-j-1, &a[m*k+j+1]);
                    wa[k] = rdiag[k];
                }
            }
        }

        rdiag[j] = -ajnorm;
    }
} /*** lm_qrfac. ***/


/*****************************************************************************/
/*  lm_qrsolv (linear least-squares)                                         */
/*****************************************************************************/

void lm_qrsolv(int n, double *r, int ldr, int *ipvt, double *diag,
               double *qtb, double *x, double *sdiag, double *wa)
{
/*
 *     Given an m by n matrix a, an n by n diagonal matrix d,
 *     and an m-vector b, the problem is to determine an x which
 *     solves the system
 *
 *          a*x = b  and  d*x = 0
 *
 *     in the least squares sense.
 *
 *     This subroutine completes the solution of the problem
 *     if it is provided with the necessary information from the
 *     qr factorization, with column pivoting, of a. That is, if
 *     a*p = q*r, where p is a permutation matrix, q has orthogonal
 *     columns, and r is an upper triangular matrix with diagonal
 *     elements of nonincreasing magnitude, then qrsolv expects
 *     the full upper triangle of r, the permutation matrix p,
 *     and the first n components of (q transpose)*b. The system
 *     a*x = b, d*x = 0, is then equivalent to
 *
 *          r*z = q^T*b,  p^T*d*p*z = 0,
 *
 *     where x = p*z. If this system does not have full rank,
 *     then a least squares solution is obtained. On output qrsolv
 *     also provides an upper triangular matrix s such that
 *
 *          p^T *(a^T *a + d*d)*p = s^T *s.
 *
 *     s is computed within qrsolv and may be of separate interest.
 *
 *     Parameters
 *
 *      n is a positive integer input variable set to the order of r.
 *
 *      r is an n by n array. On input the full upper triangle
 *        must contain the full upper triangle of the matrix r.
 *        On OUTPUT the full upper triangle is unaltered, and the
 *        strict lower triangle contains the strict upper triangle
 *        (transposed) of the upper triangular matrix s.
 *
 *      ldr is a positive integer input variable not less than n
 *        which specifies the leading dimension of the array r.
 *
 *      ipvt is an integer input array of length n which defines the
 *        permutation matrix p such that a*p = q*r. Column j of p
 *        is column ipvt(j) of the identity matrix.
 *
 *      diag is an input array of length n which must contain the
 *        diagonal elements of the matrix d.
 *
 *      qtb is an input array of length n which must contain the first
 *        n elements of the vector (q transpose)*b.
 *
 *      x is an OUTPUT array of length n which contains the least
 *        squares solution of the system a*x = b, d*x = 0.
 *
 *      sdiag is an OUTPUT array of length n which contains the
 *        diagonal elements of the upper triangular matrix s.
 *
 *      wa is a work array of length n.
 *
 */
    int i, kk, j, k, nsing;
    double qtbpj, sum, temp;
    double _sin, _cos, _tan, _cot; /* local variables, not functions */

/*** qrsolv: copy r and q^T*b to preserve input and initialize s.
     in particular, save the diagonal elements of r in x. ***/

    for (j = 0; j < n; j++) {
        for (i = j; i < n; i++)
            r[j * ldr + i] = r[i * ldr + j];
        x[j] = r[j * ldr + j];
        wa[j] = qtb[j];
    }
/*** qrsolv: eliminate the diagonal matrix d using a Givens rotation. ***/

    for (j = 0; j < n; j++) {

/*** qrsolv: prepare the row of d to be eliminated, locating the
     diagonal element using p from the qr factorization. ***/

        if (diag[ipvt[j]] == 0.)
            goto L90;
        for (k = j; k < n; k++)
            sdiag[k] = 0.;
        sdiag[j] = diag[ipvt[j]];

/*** qrsolv: the transformations to eliminate the row of d modify only 
     a single element of qT*b beyond the first n, which is initially 0. ***/

        qtbpj = 0.;
        for (k = j; k < n; k++) {

            /** determine a Givens rotation which eliminates the
                appropriate element in the current row of d. **/

            if (sdiag[k] == 0.)
                continue;
            kk = k + ldr * k;
            if (fabs(r[kk]) < fabs(sdiag[k])) {
                _cot = r[kk] / sdiag[k];
                _sin = 1 / sqrt(1 + SQR(_cot));
                _cos = _sin * _cot;
            } else {
                _tan = sdiag[k] / r[kk];
                _cos = 1 / sqrt(1 + SQR(_tan));
                _sin = _cos * _tan;
            }

            /** compute the modified diagonal element of r and
                the modified element of ((q^T)*b,0). **/

            r[kk] = _cos * r[kk] + _sin * sdiag[k];
            temp = _cos * wa[k] + _sin * qtbpj;
            qtbpj = -_sin * wa[k] + _cos * qtbpj;
            wa[k] = temp;

            /** accumulate the tranformation in the row of s. **/

            for (i = k + 1; i < n; i++) {
                temp = _cos * r[k * ldr + i] + _sin * sdiag[i];
                sdiag[i] = -_sin * r[k * ldr + i] + _cos * sdiag[i];
                r[k * ldr + i] = temp;
            }
        }

      L90:
        /** store the diagonal element of s and restore
            the corresponding diagonal element of r. **/

        sdiag[j] = r[j * ldr + j];
        r[j * ldr + j] = x[j];
    }

/*** qrsolv: solve the triangular system for z. if the system is
     singular, then obtain a least squares solution. ***/

    nsing = n;
    for (j = 0; j < n; j++) {
        if (sdiag[j] == 0. && nsing == n)
            nsing = j;
        if (nsing < n)
            wa[j] = 0;
    }

    for (j = nsing - 1; j >= 0; j--) {
        sum = 0;
        for (i = j + 1; i < nsing; i++)
            sum += r[j * ldr + i] * wa[i];
        wa[j] = (wa[j] - sum) / sdiag[j];
    }

/*** qrsolv: permute the components of z back to components of x. ***/

    for (j = 0; j < n; j++)
        x[ipvt[j]] = wa[j];

} /*** lm_qrsolv. ***/


/*****************************************************************************/
/*  lm_enorm (Euclidean norm)                                                */
/*****************************************************************************/

double lm_enorm(int n, const double *x)
{
/*     Given an n-vector x, this function calculates the
 *     euclidean norm of x.
 *
 *     The euclidean norm is computed by accumulating the sum of
 *     squares in three different sums. The sums of squares for the
 *     small and large components are scaled so that no overflows
 *     occur. Non-destructive underflows are permitted. Underflows
 *     and overflows do not occur in the computation of the unscaled
 *     sum of squares for the intermediate components.
 *     The definitions of small, intermediate and large components
 *     depend on two constants, LM_SQRT_DWARF and LM_SQRT_GIANT. The main
 *     restrictions on these constants are that LM_SQRT_DWARF**2 not
 *     underflow and LM_SQRT_GIANT**2 not overflow.
 *
 *     Parameters
 *
 *      n is a positive integer input variable.
 *
 *      x is an input array of length n.
 */
    int i;
    double agiant, s1, s2, s3, xabs, x1max, x3max, temp;

    s1 = 0;
    s2 = 0;
    s3 = 0;
    x1max = 0;
    x3max = 0;
    agiant = LM_SQRT_GIANT / n;

    /** sum squares. **/

    for (i = 0; i < n; i++) {
        xabs = fabs(x[i]);
        if (xabs > LM_SQRT_DWARF) {
            if ( xabs < agiant ) {
                s2 += xabs * xabs;
            } else if ( xabs > x1max ) {
                temp = x1max / xabs;
                s1 = 1 + s1 * SQR(temp);
                x1max = xabs;
            } else {
                temp = xabs / x1max;
                s1 += SQR(temp);
            }
        } else if ( xabs > x3max ) {
            temp = x3max / xabs;
            s3 = 1 + s3 * SQR(temp);
            x3max = xabs;
        } else if (xabs != 0.) {
            temp = xabs / x3max;
            s3 += SQR(temp);
        }
    }

    /** calculation of norm. **/

    if (s1 != 0)
        return x1max * sqrt(s1 + (s2 / x1max) / x1max);
    else if (s2 != 0)
        if (s2 >= x3max)
            return sqrt(s2 * (1 + (x3max / s2) * (x3max * s3)));
        else
            return sqrt(x3max * ((s2 / x3max) + (x3max * s3)));
    else
        return x3max * sqrt(s3);

} /*** lm_enorm. ***/

########## NEXT FILE ##########
/*
 * Library:   lmfit (Levenberg-Marquardt least squares fitting)
 *
 * File:      lmmin.c
 *
 * Contents:  Levenberg-Marquardt minimization.
 *
 * Copyright: MINPACK authors, The University of Chikago (1980-1999)
 *            Joachim Wuttke, Forschungszentrum Juelich GmbH (2004-2013)
 *
 * License:   see ../COPYING (FreeBSD)
 * 
 * Homepage:  apps.jcns.fz-juelich.de/lmfit
 */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <float.h>
#include "lmmin.h"

#ifdef USE_OPENMP
#include "omp.h"
#endif


#define MIN(a,b) (((a)<=(b)) ? (a) : (b))
#define MAX(a,b) (((a)>=(b)) ? (a) : (b))
#define SQR(x)   (x)*(x)

/* function declarations (implemented below). */
void lm_lmpar( int n, double *r, int ldr, int *ipvt, double *diag,
               double *qtb, double delta, double *par, double *x,
               double *sdiag, double *aux, double *xdi );
void lm_qrfac( int m, int n, double *a, int *ipvt,
               double *rdiag, double *acnorm, double *wa );
void lm_qrsolv( int n, double *r, int ldr, int *ipvt, double *diag,
                double *qtb, double *x, double *sdiag, double *wa );


/*****************************************************************************/
/*  Numeric constants                                                        */
/*****************************************************************************/

/* machine-dependent constants from float.h */
#define LM_MACHEP     DBL_EPSILON   /* resolution of arithmetic */
#define LM_DWARF      DBL_MIN       /* smallest nonzero number */
#define LM_SQRT_DWARF sqrt(DBL_MIN) /* square should not underflow */
#define LM_SQRT_GIANT sqrt(DBL_MAX) /* square should not overflow */
#define LM_USERTOL    30*LM_MACHEP  /* users are recommended to require this */

/* If the above values do not work, the following seem good for an x86:
 LM_MACHEP     .555e-16
 LM_DWARF      9.9e-324 
 LM_SQRT_DWARF 1.e-160   
 LM_SQRT_GIANT 1.e150 
 LM_USER_TOL   1.e-14
   The following values should work on any machine:
 LM_MACHEP     1.2e-16
 LM_DWARF      1.0e-38
 LM_SQRT_DWARF 3.834e-20
 LM_SQRT_GIANT 1.304e19
 LM_USER_TOL   1.e-14
*/

const lm_control_struct lm_control_double = {
    LM_USERTOL, LM_USERTOL, LM_USERTOL, LM_USERTOL, 1.00 , 100, 1, 
    NULL, 0, -1, -1, 4 };
const lm_control_struct lm_control_float = {
    1.e-7,      1.e-7,      1.e-7,      1.e-7,      1.00 , 100, 1,
    NULL, 0, -1, -1, 4 };


/*****************************************************************************/
/*  Message texts (indexed by status.info)                                   */
/*****************************************************************************/

const char *lm_infmsg[] = {
    "found zero (sum of squares below underflow limit)",
    "converged  (the relative error in the sum of squares is at most tol)",
    "converged  (the relative error of the parameter vector is at most tol)",
    "converged  (both errors are at most tol)",
    "trapped    (by degeneracy; increasing epsilon might help)",
    "exhausted  (number of function calls exceeding preset patience)",
    "failed     (ftol<tol: cannot reduce sum of squares any further)",
    "failed     (xtol<tol: cannot improve approximate solution any further)",
    "failed     (gtol<tol: cannot improve approximate solution any further)",
    "crashed    (not enough memory)",
    "exploded   (fatal coding error: improper input parameters)",
    "stopped    (break requested within function evaluation)",
	"stopped    (break because validation set fail to improve)"
};

const char *lm_shortmsg[] = {
    "found zero",
    "converged (f)",
    "converged (p)",
    "converged (2)",
    "degenerate",
    "call limit",
    "failed (f)",
    "failed (p)",
    "failed (o)",
    "no memory",
    "invalid input",
    "user break"
	"validation check break"
};


/*****************************************************************************/
/*  Monitoring auxiliaries.                                                  */
/*****************************************************************************/

void lm_print_pars( int nout, const double *par, double fval, double fnorm, FILE* fout )
{
    int i;
    for (i = 0; i < nout; ++i)
        fprintf( fout, " %16.9g", par[i] );
    fprintf( fout, " => %18.11g ", fval );
    fprintf( fout, " => %18.11g\n", fnorm );
}


/*****************************************************************************/
/*  lmmin (main minimization routine)                                        */
/*****************************************************************************/

void lmmin( int n, double *x, int m, const void *data, int m2, const void * data2,
            void (*evaluate) (const double *par, int m_dat, const void *data,
                              double *fvec, int *userbreak),
            const lm_control_struct *C, lm_status_struct *S )
{
	int nalert;    /* added by dawei li */
	double *fvec2, validation_sum, temp_validation, *xback; /* added by dawei li */
    double *fvec, *diag, *fjac, *qtf, *wa1, *wa2, *wa3, *wf;
    int *ipvt;
    int j, i;
    double actred, dirder, fnorm, fnorm1, gnorm, pnorm,
        prered, ratio, step, sum, temp, temp1, temp2, temp3;
    static double p0001 = 1.0e-4;

    int maxfev = C->patience * (n+1);

    int    outer, inner;  /* loop counters, for monitoring */
    int    inner_success; /* flag for loop control */
    double lmpar = 0;     /* Levenberg-Marquardt parameter */
    double delta = 0;
    double xnorm = 0;
    double eps = sqrt(MAX(C->epsilon, LM_MACHEP)); /* for forward differences */

    int nout = C->n_maxpri==-1 ? n : MIN( C->n_maxpri, n );

    /* The workaround msgfile=NULL is needed for default initialization */
    FILE* msgfile = C->msgfile ? C->msgfile : stdout;

    /* Default status info; must be set ahead of first return statements */    
    S->outcome = 0;      /* status code */
    S->userbreak = 0;
    S->nfev = 0;      /* function evaluation counter */

/***  Check input parameters for errors.  ***/

    if ( n <= 0 ) {
        fprintf( stderr, "lmmin: invalid number of parameters %i\n", n );
        S->outcome = 10; /* invalid parameter */
        return;
    }
    if (m < n) {
        fprintf( stderr, "lmmin: number of data points (%i) "
                 "smaller than number of parameters (%i)\n", m, n );
        S->outcome = 10;
        return;
    }
    if (C->ftol < 0. || C->xtol < 0. || C->gtol < 0.) {
        fprintf( stderr,
                 "lmmin: negative tolerance (at least one of %g %g %g)\n",
                 C->ftol, C->xtol, C->gtol );
        S->outcome = 10;
        return;
    }
    if (maxfev <= 0) {
        fprintf( stderr, "lmmin: nonpositive function evaluations limit %i\n",
                 maxfev );
        S->outcome = 10;
        return;
    }
    if (C->stepbound <= 0.) {
        fprintf( stderr, "lmmin: nonpositive stepbound %g\n", C->stepbound );
        S->outcome = 10;
        return;
    }
    if (C->scale_diag != 0 && C->scale_diag != 1) {
        fprintf( stderr, "lmmin: logical variable scale_diag=%i, "
                 "should be 0 or 1\n", C->scale_diag );
        S->outcome = 10;
        return;
    }

/***  Allocate work space.  ***/

    if ( (fvec = (double *) malloc(m * sizeof(double))) == NULL ||
		 (fvec2= (double *) malloc(m2* sizeof(double))) == NULL ||  /*added by dawei*/
		 (xback= (double *) malloc(n * sizeof(double))) == NULL ||  /*added by dawei*/
         (diag = (double *) malloc(n * sizeof(double))) == NULL ||
         (qtf  = (double *) malloc(n * sizeof(double))) == NULL ||
         (fjac = (double *) malloc(n*m*sizeof(double))) == NULL ||
         (wa1  = (double *) malloc(n * sizeof(double))) == NULL ||
         (wa2  = (double *) malloc(n * sizeof(double))) == NULL ||
         (wa3  = (double *) malloc(n * sizeof(double))) == NULL ||
         (wf  = (double *)  malloc(m * sizeof(double))) == NULL ||
         (ipvt = (int *)    malloc(n * sizeof(int)   )) == NULL    ) {
        S->outcome = 9;
        return;
    }

    if (!C->scale_diag) {
        for (j = 0; j < n; j++)
            diag[j] = 1.;
    }

	/* get the sum of validation */
	
	(*evaluate)(x,m2,data2,fvec2, &(S->userbreak) );
	temp_validation=0.0;
	for(j=0;j<m2;j++)
		temp_validation+=fvec2[j]*fvec2[j];
	validation_sum=temp_validation;
	nalert=0;

/* above code block is added by dawei li*/

/***  Evaluate function at starting point and calculate norm.  ***/

    (*evaluate)( x, m, data, fvec, &(S->userbreak) );
    S->nfev = 1;
    if ( S->userbreak )
        goto terminate;
    fnorm = lm_enorm(m, fvec);
    if( C->verbosity ) {
        fprintf( msgfile, "lmmin start " );
        lm_print_pars( nout, x, validation_sum, fnorm, msgfile );
    }
    if( fnorm <= LM_DWARF ){
        S->outcome = 0; /* sum of squares almost zero, nothing to do */
        goto terminate;
    }



/***  The outer loop: compute gradient, then descend.  ***/

    for( outer=0; ; ++outer ) {

/* validation check added by dawei li */
		
		(*evaluate)(x,m2,data2,fvec2, &(S->userbreak) );
		temp_validation=0.0;
		for(j=0;j<m2;j++)
			temp_validation+=fvec2[j]*fvec2[j];

		if(temp_validation>validation_sum)  
		{
			nalert++;
			if(nalert>4) 
			{
				S->outcome = 12;
				/*restor x from x_back because x is not good but xback is the best set*/
				for(j=0;j<n;j++)
					x[j]=xback[j];
                goto terminate;
			}
		}
		else
		{
			nalert=0;
			validation_sum=temp_validation;
			
			/*backup x to xback*/
			for(j=0;j<n;j++)
				xback[j]=x[j];
		}


/***  [outer]  Calculate the Jacobian.  ***/

        for (j = 0; j < n; j++) {
            temp = x[j];
            step = MAX(eps*eps, eps * fabs(temp));
            x[j] += step; /* replace temporarily */
            (*evaluate)( x, m, data, wf, &(S->userbreak) );
            ++(S->nfev);
            if ( S->userbreak )
                goto terminate;
            for (i = 0; i < m; i++)
                fjac[j*m+i] = (wf[i] - fvec[i]) / step;
            x[j] = temp; /* restore */
        }
        if ( C->verbosity >=10 ) {
            /* print the entire matrix */
            printf("\nlmmin Jacobian\n");
            for (i = 0; i < m; i++) {
                printf("  ");
                for (j = 0; j < n; j++)
                    printf("%.5e ", fjac[j*m+i]);
                printf("\n");
            }
        }

/***  [outer]  Compute the QR factorization of the Jacobian.  ***/

/*      fjac is an m by n array. The upper n by n submatrix of fjac 
 *        is made to contain an upper triangular matrix r with diagonal
 *        elements of nonincreasing magnitude such that
 *
 *              p^T*(jac^T*jac)*p = r^T*r
 *
 *              (NOTE: ^T stands for matrix transposition),
 *
 *        where p is a permutation matrix and jac is the final calculated
 *        Jacobian. Column j of p is column ipvt(j) of the identity matrix.
 *        The lower trapezoidal part of fjac contains information generated
 *        during the computation of r.
 *
 *      ipvt is an integer array of length n. It defines a permutation
 *        matrix p such that jac*p = q*r, where jac is the final calculated
 *        Jacobian, q is orthogonal (not stored), and r is upper triangular
 *        with diagonal elements of nonincreasing magnitude. Column j of p
 *        is column ipvt(j) of the identity matrix.
 */

        lm_qrfac(m, n, fjac, ipvt, wa1, wa2, wa3);
        /* return values are ipvt, wa1=rdiag, wa2=acnorm */

/***  [outer]  Form q^T * fvec and store first n components in qtf.  ***/

        for (i = 0; i < m; i++)
            wf[i] = fvec[i];

        for (j = 0; j < n; j++) {
            temp3 = fjac[j*m+j];
            if (temp3 != 0.) {
                sum = 0;
                for (i = j; i < m; i++)
                    sum += fjac[j*m+i] * wf[i];
                temp = -sum / temp3;
                for (i = j; i < m; i++)
                    wf[i] += fjac[j*m+i] * temp;
            }
            fjac[j*m+j] = wa1[j];
            qtf[j] = wf[j];
        }

/***  [outer]  Compute norm of scaled gradient and detect degeneracy.  ***/

        gnorm = 0;
        for (j = 0; j < n; j++) {
            if (wa2[ipvt[j]] == 0)
                continue;
            sum = 0.;
            for (i = 0; i <= j; i++)
                sum += fjac[j*m+i] * qtf[i];
            gnorm = MAX( gnorm, fabs( sum / wa2[ipvt[j]] / fnorm ) );
        }

        if (gnorm <= C->gtol) {
            S->outcome = 4;
            goto terminate;
        }

/***  [outer]  Initialize / update diag and delta. ***/

        if ( !outer ) { 
            /* first iteration only */
            if (C->scale_diag) {
                /* diag := norms of the columns of the initial Jacobian */
                for (j = 0; j < n; j++)
                    diag[j] = wa2[j] ? wa2[j] : 1;
                /* xnorm := || D x || */
                for (j = 0; j < n; j++)
                    wa3[j] = diag[j] * x[j];
                xnorm = lm_enorm(n, wa3);
                if( C->verbosity >= 2 ) {
                    fprintf( msgfile, "lmmin diag  " );
                    lm_print_pars( nout, x, validation_sum, xnorm, msgfile );
                }
                /* only now print the header for the loop table */
                if( C->verbosity >=3 ) {
                    fprintf( msgfile, "  o  i     lmpar    prered"
                             "          ratio    dirder      delta"
                             "      pnorm                 fnorm" );
                    for (i = 0; i < nout; ++i)
                        fprintf( msgfile, "               p%i", i );
                    fprintf( msgfile, "\n" );
                }
            } else {
                xnorm = lm_enorm(n, x);
            }
            /* initialize the step bound delta. */
            if ( xnorm )
                delta = C->stepbound * xnorm;
            else
                delta = C->stepbound;
        } else {
            if (C->scale_diag) {
                for (j = 0; j < n; j++)
                    diag[j] = MAX( diag[j], wa2[j] );
            }
        }

/***  The inner loop. ***/
        inner = 0;
        do {

/***  [inner]  Determine the Levenberg-Marquardt parameter.  ***/

            lm_lmpar( n, fjac, m, ipvt, diag, qtf, delta, &lmpar,
                      wa1, wa2, wf, wa3 );
            /* used return values are fjac (partly), lmpar, wa1=x, wa3=diag*x */

            /* predict scaled reduction */
            pnorm = lm_enorm(n, wa3);
            temp2 = lmpar * SQR( pnorm / fnorm );
            for (j = 0; j < n; j++) {
                wa3[j] = 0;
                for (i = 0; i <= j; i++)
                    wa3[i] -= fjac[j*m+i] * wa1[ipvt[j]];
            }
            temp1 = SQR( lm_enorm(n, wa3) / fnorm );
            prered = temp1 + 2 * temp2;
            dirder = -temp1 + temp2; /* scaled directional derivative */

            /* at first call, adjust the initial step bound. */
            if ( !outer && pnorm < delta )
                delta = pnorm;

/***  [inner]  Evaluate the function at x + p.  ***/

            for (j = 0; j < n; j++)
                wa2[j] = x[j] - wa1[j];

            (*evaluate)( wa2, m, data, wf, &(S->userbreak) );
            ++(S->nfev);
            if ( S->userbreak )
                goto terminate;
            fnorm1 = lm_enorm(m, wf);

/***  [inner]  Evaluate the scaled reduction.  ***/

            /* actual scaled reduction */
            actred = 1 - SQR(fnorm1/fnorm);

            /* ratio of actual to predicted reduction */
            ratio = prered ? actred/prered : 0;

            if( C->verbosity == 2 ) {
                fprintf( msgfile, "lmmin (%i:%i) ", outer, inner );
                lm_print_pars( nout, wa2, validation_sum, fnorm1, msgfile );
            } else if( C->verbosity >= 3 ) {
                printf( "%3i %2i %9.2g %9.2g %14.6g"
                        " %9.2g %10.3e %10.3e %21.15e",
                        outer, inner, lmpar, prered, ratio,
                        dirder, delta, pnorm, fnorm1 );
                for (i = 0; i < nout; ++i)
                    fprintf( msgfile, " %16.9g", wa2[i] );
                fprintf( msgfile, "\n" );
            }

            /* update the step bound */
            if        ( ratio <= 0.25 ) {
                if      ( actred >= 0 )
                    temp = 0.5;
                else if ( actred > -99 ) /* -99 = 1-1/0.1^2 */
                    temp = MAX( dirder / (2*dirder + actred), 0.1 );
                else
                    temp = 0.1;
                delta = temp * MIN(delta, pnorm / 0.1);
                lmpar /= temp;
            } else if ( ratio >= 0.75 ) {
                delta = 2*pnorm;
                lmpar *= 0.5;
            } else if ( !lmpar ) {
                delta = 2*pnorm;
            }

/***  [inner]  On success, update solution, and test for convergence.  ***/

            inner_success = ratio >= p0001;
            if ( inner_success ) {

                /* update x, fvec, and their norms */
                if (C->scale_diag) {
                    for (j = 0; j < n; j++) {
                        x[j] = wa2[j];
                        wa2[j] = diag[j] * x[j];
                    }
                } else {
                    for (j = 0; j < n; j++)
                        x[j] = wa2[j];
                }
                for (i = 0; i < m; i++)
                    fvec[i] = wf[i];
                xnorm = lm_enorm(n, wa2);
                fnorm = fnorm1;
            }

            /* convergence tests */ 
            S->outcome = 0;
            if( fnorm<=LM_DWARF )
                goto terminate;  /* success: sum of squares almost zero */
            /* test two criteria (both may be fulfilled) */
            if (fabs(actred) <= C->ftol && prered <= C->ftol && ratio <= 2)
                S->outcome = 1;  /* success: x almost stable */
            if (delta <= C->xtol * xnorm)
                S->outcome += 2; /* success: sum of squares almost stable */
            if (S->outcome != 0) {
                goto terminate;
            }

/***  [inner]  Tests for termination and stringent tolerances.  ***/

            if ( S->nfev >= maxfev ){
                S->outcome = 5;
                goto terminate;
            }
            if ( fabs(actred) <= LM_MACHEP &&
                 prered <= LM_MACHEP && ratio <= 2 ){
                S->outcome = 6;
                goto terminate;
            }
            if ( delta <= LM_MACHEP*xnorm ){
                S->outcome = 7;
                goto terminate;
            }
            if ( gnorm <= LM_MACHEP ){
                S->outcome = 8;
                goto terminate;
            }

/***  [inner]  End of the loop. Repeat if iteration unsuccessful.  ***/

            ++inner;
        } while ( !inner_success );

/***  [outer]  End of the loop. ***/

    };

terminate:
    S->fnorm = lm_enorm(m, fvec);
    if ( C->verbosity >= 2 )
        printf("lmmin outcome (%i) xnorm %g ftol %g xtol %g\n",
               S->outcome, xnorm, C->ftol, C->xtol );
    if( C->verbosity & 1 ) {
        fprintf( msgfile, "lmmin final " );
        lm_print_pars( nout, x, validation_sum, S->fnorm, msgfile );
    }
    if ( S->userbreak ) /* user-requested break */
        S->outcome = 11;

/***  Deallocate the workspace.  ***/
    free(fvec);
    free(diag);
    free(qtf);
    free(fjac);
    free(wa1);
    free(wa2);
    free(wa3);
    free(wf);
    free(ipvt);

} /*** lmmin. ***/


/*****************************************************************************/
/*  lm_lmpar (determine Levenberg-Marquardt parameter)                       */
/*****************************************************************************/

void lm_lmpar(int n, double *r, int ldr, int *ipvt, double *diag,
              double *qtb, double delta, double *par, double *x,
              double *sdiag, double *aux, double *xdi)
{
/*     Given an m by n matrix a, an n by n nonsingular diagonal
 *     matrix d, an m-vector b, and a positive number delta,
 *     the problem is to determine a value for the parameter
 *     par such that if x solves the system
 *
 *          a*x = b  and  sqrt(par)*d*x = 0
 *
 *     in the least squares sense, and dxnorm is the euclidean
 *     norm of d*x, then either par=0 and (dxnorm-delta) < 0.1*delta,
 *     or par>0 and abs(dxnorm-delta) < 0.1*delta.
 *
 *     Using lm_qrsolv, this subroutine completes the solution of the problem
 *     if it is provided with the necessary information from the
 *     qr factorization, with column pivoting, of a. That is, if
 *     a*p = q*r, where p is a permutation matrix, q has orthogonal
 *     columns, and r is an upper triangular matrix with diagonal
 *     elements of nonincreasing magnitude, then lmpar expects
 *     the full upper triangle of r, the permutation matrix p,
 *     and the first n components of qT*b. On output
 *     lmpar also provides an upper triangular matrix s such that
 *
 *          p^T*(a^T*a + par*d*d)*p = s^T*s.
 *
 *     s is employed within lmpar and may be of separate interest.
 *
 *     Only a few iterations are generally needed for convergence
 *     of the algorithm. If, however, the limit of 10 iterations
 *     is reached, then the output par will contain the best
 *     value obtained so far.
 *
 *     parameters:
 *
 *      n is a positive integer input variable set to the order of r.
 *
 *      r is an n by n array. on input the full upper triangle
 *        must contain the full upper triangle of the matrix r.
 *        on OUTPUT the full upper triangle is unaltered, and the
 *        strict lower triangle contains the strict upper triangle
 *        (transposed) of the upper triangular matrix s.
 *
 *      ldr is a positive integer input variable not less than n
 *        which specifies the leading dimension of the array r.
 *
 *      ipvt is an integer input array of length n which defines the
 *        permutation matrix p such that a*p = q*r. column j of p
 *        is column ipvt(j) of the identity matrix.
 *
 *      diag is an input array of length n which must contain the
 *        diagonal elements of the matrix d.
 *
 *      qtb is an input array of length n which must contain the first
 *        n elements of the vector (q transpose)*b.
 *
 *      delta is a positive input variable which specifies an upper
 *        bound on the euclidean norm of d*x.
 *
 *      par is a nonnegative variable. on input par contains an
 *        initial estimate of the levenberg-marquardt parameter.
 *        on OUTPUT par contains the final estimate.
 *
 *      x is an OUTPUT array of length n which contains the least
 *        squares solution of the system a*x = b, sqrt(par)*d*x = 0,
 *        for the output par.
 *
 *      sdiag is an array of length n needed as workspace; on OUTPUT
 *        it contains the diagonal elements of the upper triangular matrix s.
 *
 *      aux is a multi-purpose work array of length n.
 *
 *      xdi is a work array of length n. On OUTPUT: diag[j] * x[j].
 *
 */
    int i, iter, j, nsing;
    double dxnorm, fp, fp_old, gnorm, parc, parl, paru;
    double sum, temp;
    static double p1 = 0.1;

/*** lmpar: compute and store in x the gauss-newton direction. if the
     jacobian is rank-deficient, obtain a least squares solution. ***/

    nsing = n;
    for (j = 0; j < n; j++) {
        aux[j] = qtb[j];        
        if (r[j * ldr + j] == 0 && nsing == n)
            nsing = j;
        if (nsing < n)
            aux[j] = 0;
    }
    for (j = nsing - 1; j >= 0; j--) {
        aux[j] = aux[j] / r[j + ldr * j];
        temp = aux[j];
        for (i = 0; i < j; i++)
            aux[i] -= r[j * ldr + i] * temp;
    }

    for (j = 0; j < n; j++)
        x[ipvt[j]] = aux[j];

/*** lmpar: initialize the iteration counter, evaluate the function at the
     origin, and test for acceptance of the gauss-newton direction. ***/

    for (j = 0; j < n; j++)
        xdi[j] = diag[j] * x[j];
    dxnorm = lm_enorm(n, xdi);
    fp = dxnorm - delta;
    if (fp <= p1 * delta) {
#ifdef LMFIT_DEBUG_MESSAGES
        printf("debug lmpar nsing %d n %d, terminate (fp<p1*delta)\n",
               nsing, n);
#endif
        *par = 0;
        return;
    }

/*** lmpar: if the jacobian is not rank deficient, the newton
     step provides a lower bound, parl, for the 0. of
     the function. otherwise set this bound to 0.. ***/

    parl = 0;
    if (nsing >= n) {
        for (j = 0; j < n; j++)
            aux[j] = diag[ipvt[j]] * xdi[ipvt[j]] / dxnorm;

        for (j = 0; j < n; j++) {
            sum = 0.;
            for (i = 0; i < j; i++)
                sum += r[j * ldr + i] * aux[i];
            aux[j] = (aux[j] - sum) / r[j + ldr * j];
        }
        temp = lm_enorm(n, aux);
        parl = fp / delta / temp / temp;
    }

/*** lmpar: calculate an upper bound, paru, for the 0. of the function. ***/

    for (j = 0; j < n; j++) {
        sum = 0;
        for (i = 0; i <= j; i++)
            sum += r[j * ldr + i] * qtb[i];
        aux[j] = sum / diag[ipvt[j]];
    }
    gnorm = lm_enorm(n, aux);
    paru = gnorm / delta;
    if (paru == 0.)
        paru = LM_DWARF / MIN(delta, p1);

/*** lmpar: if the input par lies outside of the interval (parl,paru),
     set par to the closer endpoint. ***/

    *par = MAX(*par, parl);
    *par = MIN(*par, paru);
    if (*par == 0.)
        *par = gnorm / dxnorm;

/*** lmpar: iterate. ***/

    for (iter=0; ; iter++) {

        /** evaluate the function at the current value of par. **/

        if (*par == 0.)
            *par = MAX(LM_DWARF, 0.001 * paru);
        temp = sqrt(*par);
        for (j = 0; j < n; j++)
            aux[j] = temp * diag[j];

        lm_qrsolv( n, r, ldr, ipvt, aux, qtb, x, sdiag, xdi );
        /* return values are r, x, sdiag */

        for (j = 0; j < n; j++)
            xdi[j] = diag[j] * x[j]; /* used as output */
        dxnorm = lm_enorm(n, xdi);
        fp_old = fp;
        fp = dxnorm - delta;
        
        /** if the function is small enough, accept the current value
            of par. Also test for the exceptional cases where parl
            is zero or the number of iterations has reached 10. **/

        if (fabs(fp) <= p1 * delta
            || (parl == 0. && fp <= fp_old && fp_old < 0.)
            || iter == 10) {
#ifdef LMFIT_DEBUG_MESSAGES
            printf("debug lmpar nsing %d iter %d "
                   "par %.4e [%.4e %.4e] delta %.4e fp %.4e\n",
                   nsing, iter, *par, parl, paru, delta, fp);
#endif
            break; /* the only exit from the iteration. */
        }
        
        /** compute the Newton correction. **/

        for (j = 0; j < n; j++)
            aux[j] = diag[ipvt[j]] * xdi[ipvt[j]] / dxnorm;

        for (j = 0; j < n; j++) {
            aux[j] = aux[j] / sdiag[j];
            for (i = j + 1; i < n; i++)
                aux[i] -= r[j * ldr + i] * aux[j];
        }
        temp = lm_enorm(n, aux);
        parc = fp / delta / temp / temp;

        /** depending on the sign of the function, update parl or paru. **/

        if (fp > 0)
            parl = MAX(parl, *par);
        else if (fp < 0)
            paru = MIN(paru, *par);
        /* the case fp==0 is precluded by the break condition  */
        
        /** compute an improved estimate for par. **/
        
        *par = MAX(parl, *par + parc);
        
    }

} /*** lm_lmpar. ***/

/*****************************************************************************/
/*  lm_qrfac (QR factorization, from lapack)                                 */
/*****************************************************************************/

void lm_qrfac(int m, int n, double *a, int *ipvt,
              double *rdiag, double *acnorm, double *wa)
{
/*
 *     This subroutine uses Householder transformations with column
 *     pivoting (optional) to compute a qr factorization of the
 *     m by n matrix a. That is, qrfac determines an orthogonal
 *     matrix q, a permutation matrix p, and an upper trapezoidal
 *     matrix r with diagonal elements of nonincreasing magnitude,
 *     such that a*p = q*r. The Householder transformation for
 *     column k, k = 1,2,...,min(m,n), is of the form
 *
 *          i - (1/u(k))*u*uT
 *
 *     where u has zeroes in the first k-1 positions. The form of
 *     this transformation and the method of pivoting first
 *     appeared in the corresponding linpack subroutine.
 *
 *     Parameters:
 *
 *      m is a positive integer input variable set to the number
 *        of rows of a.
 *
 *      n is a positive integer input variable set to the number
 *        of columns of a.
 *
 *      a is an m by n array. On input a contains the matrix for
 *        which the qr factorization is to be computed. On OUTPUT
 *        the strict upper trapezoidal part of a contains the strict
 *        upper trapezoidal part of r, and the lower trapezoidal
 *        part of a contains a factored form of q (the non-trivial
 *        elements of the u vectors described above).
 *
 *      ipvt is an integer OUTPUT array of length lipvt. This array
 *        defines the permutation matrix p such that a*p = q*r.
 *        Column j of p is column ipvt(j) of the identity matrix.
 *
 *      rdiag is an OUTPUT array of length n which contains the
 *        diagonal elements of r.
 *
 *      acnorm is an OUTPUT array of length n which contains the
 *        norms of the corresponding columns of the input matrix a.
 *        If this information is not needed, then acnorm can coincide
 *        with rdiag.
 *
 *      wa is a work array of length n.
 *
 */
    int i, j, k, kmax, minmn;
    double ajnorm, sum, temp;

/*** qrfac: compute initial column norms and initialize several arrays. ***/

    for (j = 0; j < n; j++) {
        acnorm[j] = lm_enorm(m, &a[j*m]);
        rdiag[j] = acnorm[j];
        wa[j] = rdiag[j];
        ipvt[j] = j;
    }
#ifdef LMFIT_DEBUG_MESSAGES
    printf("debug qrfac\n");
#endif

/*** qrfac: reduce a to r with Householder transformations. ***/

    minmn = MIN(m, n);
    for (j = 0; j < minmn; j++) {

        /** bring the column of largest norm into the pivot position. **/

        kmax = j;
        for (k = j + 1; k < n; k++)
            if (rdiag[k] > rdiag[kmax])
                kmax = k;
        if (kmax == j)
            goto pivot_ok;

        for (i = 0; i < m; i++) {
            temp = a[j*m+i];
            a[j*m+i] = a[kmax*m+i];
            a[kmax*m+i] = temp;
        }
        rdiag[kmax] = rdiag[j];
        wa[kmax] = wa[j];
        k = ipvt[j];
        ipvt[j] = ipvt[kmax];
        ipvt[kmax] = k;

      pivot_ok:
        /** compute the Householder transformation to reduce the
            j-th column of a to a multiple of the j-th unit vector. **/

        ajnorm = lm_enorm(m-j, &a[j*m+j]);
        if (ajnorm == 0.) {
            rdiag[j] = 0;
            continue;
        }

        if (a[j*m+j] < 0.)
            ajnorm = -ajnorm;
        for (i = j; i < m; i++)
            a[j*m+i] /= ajnorm;
        a[j*m+j] += 1;

        /** apply the transformation to the remaining columns
            and update the norms. **/
#pragma omp parallel for private(k,sum,temp,i)
        for (k = j + 1; k < n; k++) {
            sum = 0;

            for (i = j; i < m; i++)
                sum += a[j*m+i] * a[k*m+i];

            temp = sum / a[j + m * j];

#pragma ivdep
            for (i = j; i < m; i++)
                a[k*m+i] -= temp * a[j*m+i];

            if (rdiag[k] != 0.) {
                temp = a[m * k + j] / rdiag[k];
                temp = MAX(0., 1 - temp * temp);
                rdiag[k] *= sqrt(temp);
                temp = rdiag[k] / wa[k];
                if ( 0.05 * SQR(temp) <= LM_MACHEP ) {
                    rdiag[k] = lm_enorm(m-j-1, &a[m*k+j+1]);
                    wa[k] = rdiag[k];
                }
            }
        }

        rdiag[j] = -ajnorm;
    }
} /*** lm_qrfac. ***/


/*****************************************************************************/
/*  lm_qrsolv (linear least-squares)                                         */
/*****************************************************************************/

void lm_qrsolv(int n, double *r, int ldr, int *ipvt, double *diag,
               double *qtb, double *x, double *sdiag, double *wa)
{
/*
 *     Given an m by n matrix a, an n by n diagonal matrix d,
 *     and an m-vector b, the problem is to determine an x which
 *     solves the system
 *
 *          a*x = b  and  d*x = 0
 *
 *     in the least squares sense.
 *
 *     This subroutine completes the solution of the problem
 *     if it is provided with the necessary information from the
 *     qr factorization, with column pivoting, of a. That is, if
 *     a*p = q*r, where p is a permutation matrix, q has orthogonal
 *     columns, and r is an upper triangular matrix with diagonal
 *     elements of nonincreasing magnitude, then qrsolv expects
 *     the full upper triangle of r, the permutation matrix p,
 *     and the first n components of (q transpose)*b. The system
 *     a*x = b, d*x = 0, is then equivalent to
 *
 *          r*z = q^T*b,  p^T*d*p*z = 0,
 *
 *     where x = p*z. If this system does not have full rank,
 *     then a least squares solution is obtained. On output qrsolv
 *     also provides an upper triangular matrix s such that
 *
 *          p^T *(a^T *a + d*d)*p = s^T *s.
 *
 *     s is computed within qrsolv and may be of separate interest.
 *
 *     Parameters
 *
 *      n is a positive integer input variable set to the order of r.
 *
 *      r is an n by n array. On input the full upper triangle
 *        must contain the full upper triangle of the matrix r.
 *        On OUTPUT the full upper triangle is unaltered, and the
 *        strict lower triangle contains the strict upper triangle
 *        (transposed) of the upper triangular matrix s.
 *
 *      ldr is a positive integer input variable not less than n
 *        which specifies the leading dimension of the array r.
 *
 *      ipvt is an integer input array of length n which defines the
 *        permutation matrix p such that a*p = q*r. Column j of p
 *        is column ipvt(j) of the identity matrix.
 *
 *      diag is an input array of length n which must contain the
 *        diagonal elements of the matrix d.
 *
 *      qtb is an input array of length n which must contain the first
 *        n elements of the vector (q transpose)*b.
 *
 *      x is an OUTPUT array of length n which contains the least
 *        squares solution of the system a*x = b, d*x = 0.
 *
 *      sdiag is an OUTPUT array of length n which contains the
 *        diagonal elements of the upper triangular matrix s.
 *
 *      wa is a work array of length n.
 *
 */
    int i, kk, j, k, nsing;
    double qtbpj, sum, temp;
    double _sin, _cos, _tan, _cot; /* local variables, not functions */

/*** qrsolv: copy r and q^T*b to preserve input and initialize s.
     in particular, save the diagonal elements of r in x. ***/

    for (j = 0; j < n; j++) {
        for (i = j; i < n; i++)
            r[j * ldr + i] = r[i * ldr + j];
        x[j] = r[j * ldr + j];
        wa[j] = qtb[j];
    }
/*** qrsolv: eliminate the diagonal matrix d using a Givens rotation. ***/

    for (j = 0; j < n; j++) {

/*** qrsolv: prepare the row of d to be eliminated, locating the
     diagonal element using p from the qr factorization. ***/

        if (diag[ipvt[j]] == 0.)
            goto L90;
        for (k = j; k < n; k++)
            sdiag[k] = 0.;
        sdiag[j] = diag[ipvt[j]];

/*** qrsolv: the transformations to eliminate the row of d modify only 
     a single element of qT*b beyond the first n, which is initially 0. ***/

        qtbpj = 0.;
        for (k = j; k < n; k++) {

            /** determine a Givens rotation which eliminates the
                appropriate element in the current row of d. **/

            if (sdiag[k] == 0.)
                continue;
            kk = k + ldr * k;
            if (fabs(r[kk]) < fabs(sdiag[k])) {
                _cot = r[kk] / sdiag[k];
                _sin = 1 / sqrt(1 + SQR(_cot));
                _cos = _sin * _cot;
            } else {
                _tan = sdiag[k] / r[kk];
                _cos = 1 / sqrt(1 + SQR(_tan));
                _sin = _cos * _tan;
            }

            /** compute the modified diagonal element of r and
                the modified element of ((q^T)*b,0). **/

            r[kk] = _cos * r[kk] + _sin * sdiag[k];
            temp = _cos * wa[k] + _sin * qtbpj;
            qtbpj = -_sin * wa[k] + _cos * qtbpj;
            wa[k] = temp;

            /** accumulate the tranformation in the row of s. **/

            for (i = k + 1; i < n; i++) {
                temp = _cos * r[k * ldr + i] + _sin * sdiag[i];
                sdiag[i] = -_sin * r[k * ldr + i] + _cos * sdiag[i];
                r[k * ldr + i] = temp;
            }
        }

      L90:
        /** store the diagonal element of s and restore
            the corresponding diagonal element of r. **/

        sdiag[j] = r[j * ldr + j];
        r[j * ldr + j] = x[j];
    }

/*** qrsolv: solve the triangular system for z. if the system is
     singular, then obtain a least squares solution. ***/

    nsing = n;
    for (j = 0; j < n; j++) {
        if (sdiag[j] == 0. && nsing == n)
            nsing = j;
        if (nsing < n)
            wa[j] = 0;
    }

    for (j = nsing - 1; j >= 0; j--) {
        sum = 0;
        for (i = j + 1; i < nsing; i++)
            sum += r[j * ldr + i] * wa[i];
        wa[j] = (wa[j] - sum) / sdiag[j];
    }

/*** qrsolv: permute the components of z back to components of x. ***/

    for (j = 0; j < n; j++)
        x[ipvt[j]] = wa[j];

} /*** lm_qrsolv. ***/


/*****************************************************************************/
/*  lm_enorm (Euclidean norm)                                                */
/*****************************************************************************/

double lm_enorm(int n, const double *x)
{
/*     Given an n-vector x, this function calculates the
 *     euclidean norm of x.
 *
 *     The euclidean norm is computed by accumulating the sum of
 *     squares in three different sums. The sums of squares for the
 *     small and large components are scaled so that no overflows
 *     occur. Non-destructive underflows are permitted. Underflows
 *     and overflows do not occur in the computation of the unscaled
 *     sum of squares for the intermediate components.
 *     The definitions of small, intermediate and large components
 *     depend on two constants, LM_SQRT_DWARF and LM_SQRT_GIANT. The main
 *     restrictions on these constants are that LM_SQRT_DWARF**2 not
 *     underflow and LM_SQRT_GIANT**2 not overflow.
 *
 *     Parameters
 *
 *      n is a positive integer input variable.
 *
 *      x is an input array of length n.
 */
    int i;
    double agiant, s1, s2, s3, xabs, x1max, x3max, temp;

    s1 = 0;
    s2 = 0;
    s3 = 0;
    x1max = 0;
    x3max = 0;
    agiant = LM_SQRT_GIANT / n;

    /** sum squares. **/

    for (i = 0; i < n; i++) {
        xabs = fabs(x[i]);
        if (xabs > LM_SQRT_DWARF) {
            if ( xabs < agiant ) {
                s2 += xabs * xabs;
            } else if ( xabs > x1max ) {
                temp = x1max / xabs;
                s1 = 1 + s1 * SQR(temp);
                x1max = xabs;
            } else {
                temp = xabs / x1max;
                s1 += SQR(temp);
            }
        } else if ( xabs > x3max ) {
            temp = x3max / xabs;
            s3 = 1 + s3 * SQR(temp);
            x3max = xabs;
        } else if (xabs != 0.) {
            temp = xabs / x3max;
            s3 += SQR(temp);
        }
    }

    /** calculation of norm. **/

    if (s1 != 0)
        return x1max * sqrt(s1 + (s2 / x1max) / x1max);
    else if (s2 != 0)
        if (s2 >= x3max)
            return sqrt(s2 * (1 + (x3max / s2) * (x3max * s3)));
        else
            return sqrt(x3max * ((s2 / x3max) + (x3max * s3)));
    else
        return x3max * sqrt(s3);

} /*** lm_enorm. ***/

########## NEXT FILE ##########
#include <iostream>
#include <cstdlib>
#include <fstream>
#include <string>
#include <cstring>
#include <vector>
#include <math.h>
#include <time.h>
using namespace std;


#include "aa.h"

#include "debug.h"


void CAminoacid::methyl_ambig(int flag)
{
	return;
}

void CAminoacid::printpdb(FILE *fp,vector<string> atomname,vector<double> x,vector<double> y,vector<double> z,vector<double> b, int &n)
{
	int i;
	struct Atom t;

	for(i=0;i<(int)atoms.size();i++)
	{
		t=atoms.at(i);
		if(t.index>0)
		{
			t.index--;
			fprintf(fp,"%6s","ATOM  ");
			fprintf(fp,"%5d",n); n++;
			fprintf(fp," ");
			fprintf(fp,"%4s",atomname.at(t.index).c_str());
			fprintf(fp," ");
			fprintf(fp,"%3s",ThreeLetterName);
			fprintf(fp," "); //reserved space
			fprintf(fp," "); //chain ID
			fprintf(fp,"%4d",residue);
			fprintf(fp,"    ");
			fprintf(fp,"%8.3f%8.3f%8.3f",x.at(t.index),y.at(t.index),z.at(t.index));
			fprintf(fp,"%6.2f",1.00); //occu
			fprintf(fp,"%6.2f",b.at(t.index));
			fprintf(fp,"\n");
		}
	}
	return;
}

int CAminoacid::get_proton(struct proton *t)
{
	int i;
	int n;
	int b;
	string cname;

	t->code=OneLetterName;
	t->id=residue;
	t->multy=0;

	b=1;
	n=0;
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).cs_name==t->name)
		{
			t->hpos[n]=atoms.at(i).index;
			if(atoms.at(i).index<0)
			{
				b=0;
			}
			t->exp=atoms.at(i).cs_exp;
			t->type=atoms.at(i).proton_type;
			cname=atoms.at(i).carbon_name;
			n++;

		}
	}
	t->nh=n;

	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).name==cname)
		{
			t->cpos=atoms.at(i).index;
			t->exp_c=atoms.at(i).cs_exp;
			break;
		}
	}

	return b;
}

int CAminoacid::get_proton3(struct proton *t)
{
	int i;
	int n;
	int b;
	string cname;

	t->code=OneLetterName;
	t->id=residue;
	t->exp=0.0;
	t->multy=0;


	b=1;
	n=0;
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).cs_name==t->name)
		{
			t->hpos[n]=atoms.at(i).index;
			if(atoms.at(i).index<0)
			{
				b=0;
			}
			t->exp=atoms.at(i).cs_exp;
			t->type=atoms.at(i).proton_type;
			cname=atoms.at(i).carbon_name;
			n++;

		}
	}
	t->nh=n;

	
	
	if(n==1) //not a methyl group or NH2 group or aromatic ring group
	{
		t->exp=0.0;
		b=1;
		n=0;
		for(i=0;i<(int)atoms.size();i++)
		{
			if(atoms.at(i).carbon_name==t->cname )
			{
				t->hpos[n]=atoms.at(i).index;
				if(atoms.at(i).index<0)
				{
					b=0;
				
				}
				t->exp+=atoms.at(i).cs_exp;
				if(n==0)
				{
					t->name=atoms.at(i).name;
					t->exp1=atoms.at(i).cs_exp;
					t->type=atoms.at(i).proton_type;
					cname=atoms.at(i).carbon_name;
				}
				else if(n==1)
				{
					t->multy=1;
					t->name2=atoms.at(i).name;
					t->exp2=atoms.at(i).cs_exp;
					t->type2=atoms.at(i).proton_type;
				}
				n++;
			}
		}
		t->nh=n;
		t->exp/=n;
	}






	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).name==cname)
		{
			t->cpos=atoms.at(i).index;
			t->exp_c=atoms.at(i).cs_exp;
			break;
		}
	}

	return b;
}

void CAminoacid::remove_ambig(int flag)
{
	int i;
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).ambig>1 && atoms.at(i).ambig!=3 )
		{
			if(atoms.at(i).cs_exp>0.0)
				atoms.at(i).cs_exp=999.0;
		}
	}
	return;
};

//
void CAminoacid::combine_hsamec(int flag)
{
	int i,j;
	string oldname,old_basename;
	double cs;

	oldname=atoms.at(0).carbon_name;
	old_basename=atoms.at(0).base_name;
	j=0;

	for(i=1;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).proton==1 && atoms.at(i).bb==0 
			&&  atoms.at(j).proton==1 && atoms.at(j).bb==0 
			&&  atoms.at(i).carbon_name==oldname && atoms.at(i).base_name!=old_basename)
		{
			//mix i and j here
			cs=(atoms.at(i).cs_exp+atoms.at(j).cs_exp)/2.0;
			atoms.at(i).cs_exp=cs;
			atoms.at(j).cs_exp=cs;
		}
		oldname=atoms.at(i).carbon_name;
		old_basename=atoms.at(i).base_name;
		j=i;
	}

	return;
};


void CAminoacid::heavycoor(vector<int> *t)
{
	int i;
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).bb==0 && atoms.at(i).proton==0)
			t->push_back(atoms.at(i).index);
	}
	return;
}

void CAminoacid::bbheavycoor(vector<int> *t)
{
	int i;
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).bb==1 && atoms.at(i).proton==0 && atoms.at(i).name.compare("OXT")!=0)
			t->push_back(atoms.at(i).index);
	}
	return;
}


void CAminoacid::allcoor(vector<int> *t)
{
	int i;
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).index>0)
			t->push_back(atoms.at(i).index);
	}
	return;
}

struct noeatoms CAminoacid::query(string name)
{
	struct noeatoms t;
	vector<int> tt;
	int index;

	if(name=="HN")
		name="H";

	tt.clear();
	index=get(name.c_str()).index;
	if(index<=0 && name=="H")
		index=get("H1").index; 
	if(index>0)
	{
		tt.push_back(index);
		t.atoms.push_back(tt);
		t.length=0.0;
	}
	return t;
}



void CAminoacid::attach_bbprediction(double pre[5])
{
	int i;

	pre_ca=pre[0];
	pre_cb=pre[1];
	pre_c=pre[2];
	pre_h=pre[3];
	pre_n=pre[4];
	pre_ha=pre[5];

	if(OneLetterName=='G')
		pre_cb=999.0;
	else if(OneLetterName=='C')
		pre_ca=pre_cb=pre_c=pre_h=pre_n=999.0;
	else if(OneLetterName=='P')
		pre_h=pre_n=999.0;
	else if(OneLetterName=='U')
		pre_ca=pre_cb=pre_c=pre_h=pre_n=999.0;


	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).name=="CA")
			atoms.at(i).cs_pre=pre_ca;
		if(atoms.at(i).name=="CB")
			atoms.at(i).cs_pre=pre_cb;
		if(atoms.at(i).name=="C")
			atoms.at(i).cs_pre=pre_c;
		if(atoms.at(i).name=="H")
			atoms.at(i).cs_pre=pre_h;
		if(atoms.at(i).name=="N")
			atoms.at(i).cs_pre=pre_n;
		if(atoms.at(i).name=="HA" || atoms.at(i).name=="HA2" || atoms.at(i).name=="HA3")
			atoms.at(i).cs_pre=pre_ha;
	}

}

void  CAminoacid::attach_protonprediction(string name,double cs)
{	
	int i;
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).cs_name==name)
		{
			atoms.at(i).cs_pre=cs;
		}
	}
	return;
}



void CAminoacid::print_prediction(int *index,FILE *fbmrb)
{
	int i;
	string oldname;

	oldname="xxx";
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).cs_pre<450 && atoms.at(i).cs_name!=oldname)
		{
			fprintf(fbmrb,"%8d %8d %8s %8s %8s %8.3f . 1\n",*index,original_residue,ThreeLetterName,atoms.at(i).cs_name.c_str(),
				atoms.at(i).cs_name.c_str(),atoms.at(i).cs_pre);
			(*index)++;
			oldname=atoms.at(i).cs_name;
		}
	}
	return;
}

void CAminoacid::print_bbprediction(FILE *fbmrb)
{
	fprintf(fbmrb,"%8d%8s",original_residue,ThreeLetterName);
	fprintf(fbmrb,"%8.3f%8.3f",get("CA").cs_pre,get("CA").cs_exp);
	fprintf(fbmrb,"%8.3f%8.3f",get("CB").cs_pre,get("CB").cs_exp);
	fprintf(fbmrb,"%8.3f%8.3f",get("C").cs_pre,get("C").cs_exp);
	fprintf(fbmrb,"%8.3f%8.3f",get("H").cs_pre,get("H").cs_exp);
	fprintf(fbmrb,"%8.3f%8.3f",get("N").cs_pre,get("N").cs_exp);
	if(OneLetterName=='G')
		fprintf(fbmrb,"%8.3f%8.3f",get("HA2").cs_pre,get("HA2").cs_exp);
	else
		fprintf(fbmrb,"%8.3f%8.3f",get("HA").cs_pre,get("HA").cs_exp);
	fprintf(fbmrb,"\n");
}

void CAminoacid::print_protonprediction(FILE *fbmrb)
{
	int i;
	string oldname;

	oldname="xxx";
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).cs_pre<990 && atoms.at(i).proton==1 && atoms.at(i).bb==0 && atoms.at(i).cs_name!=oldname)
		{
			oldname=atoms.at(i).cs_name;
			fprintf(fbmrb,"%8d %8c %8s %8.3f %8.3f\n",original_residue,OneLetterName,atoms.at(i).cs_name.c_str(),
				atoms.at(i).cs_pre,atoms.at(i).cs_exp);
		}
	}
	return;
}


void CAminoacid::attach_rmsf(vector<double> t)
{
	int i,j;

	for(i=0;i<atoms.size();i++)
	{
		j=atoms.at(i).index;
		if(j>0)
			atoms.at(i).rmsf=t.at(j-1);
	}
	return;
}

void CAminoacid::print_rmsf(FILE *fp)
{
	int i;

	for(i=0;i<atoms.size();i++)
	{
		if(atoms.at(i).rmsf>0)
			fprintf(fp,"%10d %9c %9s %10.4f\n",residue,OneLetterName,atoms.at(i).name.c_str(),atoms.at(i).rmsf);
	}
	return;
}


int CAminoacid::wang_correct_index(char c)
{
	int index;
	switch(c)
		{
			case 'A': index=0; break;
			case 'C': index=1; break;
			case 'D': index=2; break;
			case 'E': index=3; break;
			case 'F': index=4; break;
			case 'G': index=5; break;
			case 'H': index=6; break;
			case 'I': index=7; break;
			case 'K': index=8; break;
			case 'L': index=9; break;
			case 'M': index=10; break;
			case 'N': index=11; break;
			case 'P': index=12; break;
			case 'Q': index=13; break;
			case 'R': index=14; break;
			case 'S': index=15; break;
			case 'T': index=16; break;
			case 'V': index=17; break;
			case 'W': index=18; break;
			case 'Y': index=19; break;
			default: index=20;
		}

	return index;
}

void CAminoacid::set_coil_wc(char pre, char fol)
{
	int index,index1,index2;
	int i;
	double t[6];

	set_coil(2);
	index1=wang_correct_index(pre);
	index2=wang_correct_index(fol);
	index=wang_rc_index(OneLetterName);

	for(i=0;i<6;i++)
	{
		t[i]=wang_rc[index][i]+wang_c1[index1][i]+wang_c2[index2][i];
	}
	set_wang(t,index);
	return;
}

int CAminoacid::wang_rc_index(char c)
{
	int index;
	switch(c)
		{
			case 'I': index=0; break;
			case 'V': index=1; break;
			case 'D': index=2; break;
			case 'N': index=3; break;
			case 'F': index=4; break;
			case 'H': index=5; break;
			case 'W': index=6; break;
			case 'Y': index=7; break;
			case 'K': index=8; break;
			case 'L': index=9; break;
			case 'M': index=10; break;
			case 'Q': index=11; break;
			case 'R': index=12; break;
			case 'E': index=13; break;
			case 'T': index=14; break;
			case 'C': index=15; break;
			case 'S': index=16; break;
			case 'A': index=17; break;
			case 'G': index=18; break;
			case 'P': index=19; break;
			default: index=20;
		}

	return index;
}

void CAminoacid::set_wang(double *t,int index)
{
	int i;
	//unknown or missing residue. 
	if(index==20)
		return;


	get_address("C")->cs_wang=t[1];
	get_address("CA")->cs_wang=t[2];

	if(index!=19)
	{
		get_address("H")->cs_wang=t[4];
		get_address("N")->cs_wang=t[0];
	}

	if(index!=18) 
	{
		get_address("HA")->cs_wang=t[5];
		get_address("CB")->cs_wang=t[3];
	}
	else
	{
		get_address("HA1")->cs_wang=t[5];
		get_address("HA2")->cs_wang=t[5];
	}

	for(i=0;i<(int)atoms.size();i++)
	{
		atoms.at(i).cs_exp=atoms.at(i).cs_wang;
	}

	return;
}

void CAminoacid::set_coil(int flag=1)
{
	int i;
	if(flag==1)
	{
		for(i=0;i<(int)atoms.size();i++)
		{
			atoms.at(i).cs_exp=atoms.at(i).cs_coil;
		}
	}
	else if(flag==2)
	{
		int index=wang_rc_index(OneLetterName);
		set_wang(wang_rc[index],index);	
	}

	return;
}

void CAminoacid::set_mean()
{
	int i;
	for(i=0;i<(int)atoms.size();i++)
	{
		atoms.at(i).cs_exp=atoms.at(i).cs_mean;
	}
	return;
}

void CAminoacid::clearexp()
{
	int i;
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).cs_exp>0.0)
			atoms.at(i).cs_exp=999.0;
	}
	bexploaded=0;
	exploaded=0;
	return;
}



void CAminoacid::loadexp(struct CBmrbdata data)
{
	int i,j;
	bool bused;
	string name;
	string dataname;

	if(data.name.compare(ThreeLetterName)!=0)
	{
		cout<<"Error. at pos "<<residue<<" PDB is "<<ThreeLetterName<<" while BMRB is "<<data.name<<endl;
		bexploaded=0;
		exploaded=-1;
		for(i=0;i<(int)atoms.size();i++)
		{
			if(atoms.at(i).cs_exp>0.0)
				atoms.at(i).cs_exp=9999.0;
		}
		return;
	}

	for(i=0;i<(int)data.block.size();i++)
	{
		data.block.at(i).used=1;
		bused=0;
		dataname=data.block.at(i).type;

		for(j=0;j<(int)atoms.size();j++)
		{
			name=atoms.at(j).cs_name;
			if(dataname.at(0)=='H' && dataname.size()>1)
			{
				if(data.block.at(i).type.find(name)==0 && name!="H" )
				{
					bused=1;
					if(data.block.at(i).ambig<=3)
					{
						atoms.at(j).cs_exp=data.block.at(i).cs;
						atoms.at(j).ambig=data.block.at(i).ambig;
						data.block.at(i).used=1;
					}
				}
			}

			else if(dataname.at(0)=='C' && dataname.size()>2 && name.size()>1)
			{
				if(data.block.at(i).type.find(name)==0 )
				{
					bused=1;
					if(data.block.at(i).ambig<=3)
					{
						atoms.at(j).cs_exp=data.block.at(i).cs;
						atoms.at(j).ambig=data.block.at(i).ambig;
						data.block.at(i).used=1;
					}
				}
			}

			else if(dataname.at(0)=='C' && dataname.size()>1)
			{
				if(data.block.at(i).type.compare(name)==0 )
				{
					bused=1;
					if(data.block.at(i).ambig<=3)
					{
						atoms.at(j).cs_exp=data.block.at(i).cs;
						atoms.at(j).ambig=data.block.at(i).ambig;
						data.block.at(i).used=1;
					}
				}
			}

			else
			{
				if(data.block.at(i).type.compare(name)==0 )
				{
					bused=1;
					if(data.block.at(i).ambig<=3)
					{
						atoms.at(j).cs_exp=data.block.at(i).cs;
						atoms.at(j).ambig=data.block.at(i).ambig;
						data.block.at(i).used=1;
					}
				}
			}
		}
		if(bused==0)
			cout<<"In "<<residue<<" "<<ThreeLetterName<<", unmatched bmrb data point for "<<data.block.at(i).type.c_str()<<" cs is "<<data.block.at(i).cs<<endl;
	}
	bexploaded=1;
	exploaded=1;
	return;
}

void CAminoacid::set_mismatch(void)
{
	int i;

	bexploaded=0;
	exploaded=-1;

	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).cs_exp>0.0)
			atoms.at(i).cs_exp=9999.0;
	}

	return;
}


void CAminoacid::dihe(vector<dihe_group> * dihe_index)
{
	cout<<"run virtual fuction of base class, sth is wrong!"<<endl;
	return;
}

void CAminoacid::proton(vector<struct proton> *sel)
{
	struct proton t;
	int i;
	string oldname;

	oldname="XXX";
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).bb==0 && atoms.at(i).proton==1 && atoms.at(i).cs_name!=oldname)
		{
			oldname=atoms.at(i).cs_name;
			t.name=atoms.at(i).cs_name;
			if(get_proton(&t))
				sel->push_back(t);
		}
	}
	return;
}


//combine hb2 and hb3 into one.
void CAminoacid::proton3(vector<struct proton> *sel)
{
	struct proton t;
	int i;
	string oldname,cname;

	oldname="XXX";
	cname="YYYY";
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).bb==0 && atoms.at(i).proton==1 && atoms.at(i).cs_name!=oldname && atoms.at(i).carbon_name!=cname)
		{
			oldname=atoms.at(i).cs_name;
			cname=atoms.at(i).carbon_name;
			t.name=atoms.at(i).cs_name;
			t.cname=atoms.at(i).carbon_name;

			t.exp=t.exp1=t.exp2=0.0;
			t.cname2="";
			t.name2="";
			t.cpos=-1;
			t.nh=0;
			t.multy=0;
			t.type=t.type2=0;

			if(get_proton3(&t))
				sel->push_back(t);
		}
	}
	return;
}

void CAminoacid::proton2(vector<struct proton> *)
{
	return;
}

void CAminoacid::ring(vector<ring_group> *ring)
{
	return;
}

void CAminoacid::previous_bb(vector<bb_group> *bb)
{
	if(exploaded==-1)
		bb->at(bb->size()-1).previous_mut=1;
}


void CAminoacid::follow_bb(vector<bb_group> *bb)
{
	if(exploaded==-1)
		bb->at(bb->size()-1).follow_mut=1;

	bb->at(bb->size()-1).follow_hpos=get("H").index;
	bb->at(bb->size()-1).follow_npos=get("N").index;
	bb->at(bb->size()-1).follow_exp_n=get("N").cs_exp;
	bb->at(bb->size()-1).follow_exp_h=get("H").cs_exp;
	bb->at(bb->size()-1).follow_exp_ca=get("CA").cs_exp;
	
	if(OneLetterName=='P')
	{
		bb->at(bb->size()-1).follow_exp_n=999.0;
		bb->at(bb->size()-1).follow_exp_h=999.0;
	}

}

void CAminoacid::follow_bb_assign(vector<bb_group> *bb)
{
    if(exploaded==-1)
        bb->at(bb->size()-1).follow_mut=1;
    
    bb->at(bb->size()-1).follow_hpos=get("H").index;
    bb->at(bb->size()-1).follow_npos=get("N").index;
    bb->at(bb->size()-1).follow_exp_n=get("N").cs_exp;
    bb->at(bb->size()-1).follow_exp_h=get("H").cs_exp;
    bb->at(bb->size()-1).follow_exp_ca=get("CA").cs_exp;
    
    if(OneLetterName=='P')   //Proline won't have peaks in 3D experiments
    {
        bb->at(bb->size()-1).follow_exp_n=999.0;
        bb->at(bb->size()-1).follow_exp_h=999.0;
        
    
         bb->at(bb->size()-1).follow_exp_ca=999.0;
         bb->at(bb->size()-1).exp_ca=999.0;
         bb->at(bb->size()-1).exp_cb=999.0;
         bb->at(bb->size()-1).exp_co=999.0;
    
    }
    
}


void CAminoacid::bb(vector<bb_group> *bb)
{
	struct bb_group t;

	t.chain=chain;
	t.id=residue;
	t.id0=original_residue;
	t.code=OneLetterName;
	t.ss=ss;
	
	t.exploaded=1;
	t.previous_mut=0;
	t.follow_mut=0;

	if(exploaded!=1)
		t.exploaded=0;
	
	t.hpos=get("H").index;
	t.npos=get("N").index;
	t.capos=get("CA").index;
	t.cbpos=get("CB").index;
	t.copos=get("C").index;
	t.opos=get("O").index;
	

	t.exp_ca=get("CA").cs_exp;
	t.exp_cb=get("CB").cs_exp;
	t.exp_co=get("C").cs_exp;
	t.exp_n=get("N").cs_exp;
	t.exp_h=get("H").cs_exp;
	

	if(OneLetterName=='G')
	{
		t.exp_ha=get("HA2").cs_exp;
		t.hapos=get("HA2").index;
		t.exp_ha2=get("HA3").cs_exp;
		t.hapos2=get("HA3").index;
	}
	else
	{
		t.exp_ha=get("HA").cs_exp;
		t.hapos=get("HA").index;
	}


	if(t.cbpos==-2)
		t.exp_cb=-999.0; //GLY
	if(t.hpos==-2)
		t.exp_h=-999.0; //PRO

	t.pre_ca=get("CA").cs_pre;
	t.pre_cb=get("CB").cs_pre;
	t.pre_c=get("C").cs_pre;
	t.pre_n=get("N").cs_pre;
	t.pre_h=get("H").cs_pre;
	

	if(OneLetterName=='G')
	{
		t.pre_ha=get("HA2").cs_pre;
	}
	else
	{
		t.pre_ha=get("HA").cs_pre;
	}

	bb->push_back(t);
	return;
}

void CAminoacid::bbco(vector<struct co_group> *co)
{
	struct co_group t;

	t.id=residue;
	t.code=OneLetterName;
	t.cpos=get("C").index;
	t.opos=get("O").index;
	t.exp_c=get("C").cs_exp;
	t.exp_o=get("O").cs_exp;

	co->push_back(t);
	
	return;
}


void CAminoacid::ired(vector<struct ired> *t, int pos)
{
	int i;
	string s1,s2;
	struct ired red;

	red.id=residue;
	red.id0=original_residue;
	red.chain=chain;
	red.pos=pos;
	red.code=OneLetterName;

	for(i=0;i<(int)order_parameters.size();i++)
	{
		if(order_parameters.at(i).name1=="C0")
			red.index1=previousc;
		else
			red.index1=get(order_parameters.at(i).name1.c_str()).index;
		red.index2=get(order_parameters.at(i).name2.c_str()).index;

		red.s2=order_parameters.at(i);

		if(red.index1>=0 && red.index2>=0)
			t->push_back(red);
	}



	return;
}


void CAminoacid::clearred()
{
	int i;
	for(i=0;i<(int)order_parameters.size();i++)
	{	
		order_parameters.at(i).pre=0.0;
		order_parameters.at(i).exp=0.0;	
	}
	return;
}



void CAminoacid::loadred(struct ired red)
{
	int i;
	struct S2 t;


	{
		for(i=0;i<(int)order_parameters.size();i++)
		{
			t=order_parameters.at(i);
			if( (t.name1==red.s2.name1 && t.name2==red.s2.name2) || (t.name1==red.s2.name2 && t.name2==red.s2.name1) )
			{
				order_parameters.at(i).pre=red.s2.pre;
				order_parameters.at(i).exp=red.s2.exp;
			}
		}
	}

	return;
}



void CAminoacid::bbnh(vector<struct nh_group> *nh)
{
	struct nh_group t;

	t.id=residue;
	t.code=OneLetterName;
	t.hpos=get("H").index;
	t.npos=get("N").index;
	t.exp_h=get("H").cs_exp;
	t.exp_n=get("N").cs_exp;

	if(OneLetterName!='P')
		nh->push_back(t);
	
	return;
}

void CAminoacid::caha(vector<struct index_three> *caha)
{
	struct index_three t;
	t.x1=residue;
	t.x2=get("CA").index;
	t.x3=get("HA").index;
	if(OneLetterName!='G')
		caha->push_back(t);
	return;
}

void CAminoacid::bbhbond(vector<bbhbond_group> *bb)
{
	struct bbhbond_group t;

	t.id=residue;
	t.code=OneLetterName;
	t.npos=get("N").index;
	t.hpos=get("H").index;
	t.cpos=get("C").index;
	t.opos=get("O").index;
	t.type=1;

	bb->push_back(t);
	return;
}

void CAminoacid::schbond(vector<bbhbond_group> *)
{
	//remaining AA don't have sc donor or acceptor group.
	return;
}


void CAminoacid::bbani(vector<struct ani_group> *anistropy)
{
	struct ani_group t;
	t.type=1;
	t.id=residue;
	t.code=OneLetterName;
	t.pos[0]=followingn;
	t.pos[1]=get("C").index;
	t.pos[2]=get("O").index;

	anistropy->push_back(t);
}

void CAminoacid::ani(vector<struct ani_group> *anistropy)
{
	return;
}

void CAminoacid::sccoor(vector<int> *t)
{
	int i;
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).bb==0 && atoms.at(i).proton==0)
			t->push_back(atoms.at(i).index);
	}
	return;
}


void CAminoacid::setcterminal(void)
{
	struct Atom t;
	
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;
	t.bb=0;
	t.proton=0;
	t.ambig=0;
	t.name="OXT";t.cs_name="OXT";t.base_name="OXT";atoms.push_back(t);

	return;
}


void CAminoacid::setnterminal(void)
{
	struct Atom t;
	int i;

	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).name=="H")
			atoms.erase(atoms.begin()+i);
	}

	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;
	t.bb=1;
	t.proton=1;
	t.ambig=0;
	t.name="H1";t.cs_name="H";t.base_name="H";atoms.push_back(t);
	t.name="H2";t.cs_name="H";t.base_name="H";atoms.push_back(t);
	t.name="H3";t.cs_name="H";t.base_name="H";atoms.push_back(t);
}


void CAminoacid::process(vector<string> block)
{
	int i,j,k;
	int index;
	char c;
	bool bmatch;
	string t,t2;
	string atomname,atomname2;
	string part;
	string name;
	vector<string> subblock;

	original_residue=atoi(block.at(0).substr(22,4).c_str());


	vector<int> toremove;
	toremove.resize(block.size(),0);
	for(i=0;i<(int)block.size();i++)
	{
		for(j=i+1;j<(int)block.size();j++)
		{
			atomname=block.at(i).substr(11,5);
			atomname2=block.at(j).substr(11,5);
			if(atomname2==atomname)
			{
				toremove.at(j)=1;
			}
		}
	}

	for(i=(int)toremove.size()-1;i>0;i--)
	{
		if(toremove.at(i)==1)
			block.erase(block.begin()+i);
	}
	toremove.clear();



	
	//replace D to H
	for(i=0;i<(int)block.size();i++)
	{
		t=block[i];
		atomname=t.substr(11,3);
		if(atomname.compare("  D")==0)
		{
			t2=t.substr(0,11);
			t2=t2.append("  H");
			t2=t2.append(t.substr(14));
			//cout<<"Atomname is: "<<atomname<<endl;
			//cout<<"from: "<<t<<endl;
			//cout<<"to:   "<<t2<<endl;
			block.at(i)=t2;
		}
	}

	for(i=0;i<(int)block.size();i++)
	{
		t=block[i];
		atomname=t.substr(11,2);
		if(atomname.compare(" D")==0)
		{
			t2=t.substr(0,11);
			t2=t2.append(" H");
			t2=t2.append(t.substr(13));
			//cout<<"Atomname is: "<<atomname<<endl;
			//cout<<"from: "<<t<<endl;
			//cout<<"to:   "<<t2<<endl;
			block.at(i)=t2;
		}
	}





	for(i=0;i<(int)block.size();i++)
	{
		t=block[i];
		atomname=t.substr(11,5);  //atom name here
		while((j=atomname.find(" ")) != string::npos)
		{
			atomname.replace(j, 1, "");
		}	
		part=t.substr(6,5); //atom index
		index=atoi(part.c_str());

		if(atomname=="OC1")  //C-terminal atoms 
			atomname="O";
		if(atomname=="OC2")
			atomname="OXT";

		if(atomname=="HN")
			atomname="H";


		c=atomname.at(0);
		if(c>'0' && c<'9')  //if name started with number, move that number to the end
		{
			atomname.erase(0,1);
			atomname.append(1,c);
		}

		
		if(OneLetterName=='I')   //gromacs use CD in ILE, should be CD1
		{
			if( atomname=="CD") atomname="CD1"; 	
			if( atomname=="HD1")atomname="HD11"; 	
			if( atomname=="HD2")atomname="HD12"; 	
			if( atomname=="HD3")atomname="HD13"; 	
		}

		c=atomname.at(0);
		if(c=='H' && atomname.compare("H")!=0 && atomname.compare("H1")!=0 && atomname.compare("H2")!=0 && atomname.compare("H3")!=0 )  //started with H, but it is not HN,h1,h2,or h3
		{
			//process protons
			bmatch=0;
			for(j=0;j<(int)atoms.size()  && bmatch==0 ;j++)
			{
				name=atoms.at(j).base_name;
				k=atoms.at(j).index;
				if(name.compare("H")!=0 && atomname.find(name)==0 && k<0)
				{
					atoms.at(j).index=index;
					bmatch=1;
				}
			}
#ifndef BENCHMARK
			if(bmatch==0)  //cannot match atomname, print out error message.
				cout<<"Unknown atom name "<<atomname.c_str()<<" in residue "<<residue<<" "<<ThreeLetterName<<endl;
#endif
		}
		else  //heavy atoms or HN atom. try to match name directly.
		{
			bmatch=0;
			for(j=0;j<(int)atoms.size();j++)
			{
				if(atomname==atoms.at(j).name)
				{
					atoms.at(j).index=index;
					bmatch=1;
				}
			}
#ifndef BENCHMARK
		if(bmatch==0)  //cannot match atomname, print out error message.
			cout<<"Unknown atom name "<<atomname.c_str()<<" in residue "<<residue<<" "<<ThreeLetterName<<endl;
#endif
		}
	}
	return;
}


void CAminoacid::bbdihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;

	t.id=residue;
	t.code=OneLetterName;
	t.type=1;
	t.x1=previousc;
	t.x2=get("N").index;
	t.x3=get("CA").index;
	t.x4=get("C").index;
	t.bgood=0;

	if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0)
		t.bgood=1;
	dihe_index->push_back(t);

	t.id=residue;
	t.code=OneLetterName;
	t.type=2;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("C").index;
	t.x4=followingn;
	t.bgood=0;
	if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0)
		t.bgood=1;
	dihe_index->push_back(t);

	
	return;
}

struct Atom  CAminoacid::get(const char* name)
{
	int i;
	struct Atom t;

	t.index=-2;
	t.cs_exp=-999.0;
	t.cs_pre=-999.0;
	t.name="NO_EXIST";

	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).name==name)
		{
			t=atoms.at(i);
			break;
		}
	}

	if(i==atoms.size())  //didn't find it, so ...
	{
		t.index=-2;
		t.cs_exp=-999.0;
		t.cs_pre=-999.0;
		t.name="NO_EXIST";
	}
	return t;
}

struct Atom*  CAminoacid::get_address(const char* name)
{
	int i;
	struct Atom *t;


	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).name==name)
		{
			t=&(atoms.at(i));
			break;
		}
	}

	if(i==atoms.size())  //didn't find it, so ...
	{
		t=&atom_nouse;
	}
	return t;
}




CAminoacid::CAminoacid() 
{
	OneLetterName='B';
	bexploaded=0;
	exploaded=0;
	ss=0;
	
	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=1;
	t.proton=0;
	t.ambig=0;
	t.proton=0;t.name="N";t.cs_name="N";t.base_name="N";atoms.push_back(t);
	t.proton=1;t.name="H";t.cs_name="H";t.base_name="H";atoms.push_back(t);
	t.proton=0;t.name="CA";t.cs_name="CA";t.base_name="CA";atoms.push_back(t);
	t.proton=1;t.name="HA";t.cs_name="HA";t.base_name="HA";t.carbon_name="CA";atoms.push_back(t);
	t.proton=0;t.name="C";t.cs_name="C";t.base_name="C";atoms.push_back(t);
	t.proton=0;t.name="O";t.cs_name="O";t.base_name="O";atoms.push_back(t);

	struct S2 s2;
	s2.name1="N";s2.name2="H";s2.exp=999.0;s2.pre=999.0;order_parameters.push_back(s2);
	s2.name1="CA";s2.name2="HA";s2.exp=999.0;s2.pre=999.0;order_parameters.push_back(s2);
	s2.name1="N";s2.name2="CA";s2.exp=999.0;s2.pre=999.0;order_parameters.push_back(s2);
	s2.name1="CA";s2.name2="C";s2.exp=999.0;s2.pre=999.0;order_parameters.push_back(s2);
	s2.name1="C0";s2.name2="N";s2.exp=999.0;s2.pre=999.0;order_parameters.push_back(s2);

	for(int i=0;i<6;i++)
	{
		coil_pre[i]=coil_fol[i]=0.0;
	}

}

int CAminoacid::wishart_index()
{
	int index;

	switch(OneLetterName)
	{
		case 'A': index=0;break;
		case 'R': index=1;break;
		case 'N': index=2;break;
		case 'D': index=3;break;
		case 'Q': index=4;break;
		case 'E': index=5;break;
		case 'G': index=6;break;
		case 'H': index=7;break;
		case 'I': index=8;break;
		case 'L': index=9;break;
		case 'K': index=10;break;
		case 'M': index=11;break;
		case 'F': index=12;break;
		case 'P': index=13;break;
		case 'S': index=14;break;
		case 'T': index=15;break;
		case 'W': index=16;break;
		case 'Y': index=17;break;
		case 'V': index=18;break;
		case 'C': index=20;break;
		default: index=21;
	}
	if(strcmp(ThreeLetterName,"XYX")==0) index=19;

	return index;
}



vector<double> CAminoacid::get_wishart()
{
	vector <double> t;
	for(int i=0;i<12;i++)
		t.push_back(wishart[wishart_index()][i]);
	return t;
}


CAminoacid::~CAminoacid() {}



//ALA

struct noeatoms CAla::query(string name)
{
	struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("MB")==0 || name.compare("QB")==0)
	{
		tt.push_back(get("HB1").index);
		tt.push_back(get("HB2").index);
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=0.0;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}


void CAla::dihe(vector<dihe_group> * dihe_index)
{
	return;
}


void CAla::proton2(vector<struct proton> *sel)
{
	struct proton t;

	t.type=1;
	t.name="HB";
	get_proton(&t);
	sel->push_back(t);

	return;
}


CAla::CAla() 
{
	//CAminoacid::CAminoacid();
	OneLetterName='A';	strcpy(ThreeLetterName,"ALA");

	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;
	t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.proton=1;t.carbon_name="CB";
	t.proton_type=1;t.name="HB1";t.cs_name="HB";t.base_name="HB";atoms.push_back(t);
	t.proton_type=1;t.name="HB2";t.cs_name="HB";t.base_name="HB";atoms.push_back(t);
	t.proton_type=1;t.name="HB3";t.cs_name="HB";t.base_name="HB";atoms.push_back(t);

	get_address("H")->cs_coil=8.24;
	get_address("N")->cs_coil=124.2;
	get_address("CA")->cs_coil=52.1;
	get_address("HA")->cs_coil=4.39;
	get_address("CB")->cs_coil=19.3;
	get_address("C")->cs_coil=176.8;

	get_address("H")->cs_mean=8.19;
	get_address("N")->cs_mean=123.22;
	get_address("CA")->cs_mean=53.19;
	get_address("HA")->cs_mean=4.25;
	get_address("CB")->cs_mean=18.98;
	get_address("C")->cs_mean=177.79;

	get_address("N")->cs_wang=123.82;
	get_address("C")->cs_wang=177.28;
	get_address("CA")->cs_wang=52.46;
	get_address("CB")->cs_wang=18.98;
	get_address("H")->cs_wang=8.09;
	get_address("HA")->cs_wang=4.31;

	coil_pre[0]=-2.21;
	coil_pre[1]= 0.14;
	coil_pre[2]=-0.01;
	coil_pre[3]=-0.04;
	coil_pre[4]=-0.07;
	coil_pre[5]=-0.01;

	coil_fol[0]=-0.11;
	coil_fol[1]= 0.05;
	coil_fol[2]= 0.07;
	coil_fol[3]=-0.09;
	coil_fol[4]=-0.01;
	coil_fol[5]=-0.03;
}
CAla::~CAla() {}


//ARG
void CArg::schbond(vector<bbhbond_group> *grp)
{
	bbhbond_group t;
	t.id=residue;
	t.code=OneLetterName;
	t.cpos=-1;
	t.opos=-1;
	t.npos=get("NE").index;
	t.hpos=get("HE").index;
	t.type=13; 

	grp->push_back(t);
	return;
}

struct noeatoms CArg::query(string name)
{
	struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QG")==0)
	{
		tt.clear();
		tt.push_back(get("HG2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HG3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QD")==0)
	{
		tt.clear();
		tt.push_back(get("HD2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HD3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QH1")==0)
	{
		tt.clear();
		tt.push_back(get("HH11").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HH12").index);
		t.atoms.push_back(tt);
	}
	else if(name.compare("QH2")==0)
	{
		tt.clear();
		tt.push_back(get("HH21").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HH22").index);
		t.atoms.push_back(tt);
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}


void CArg::ani(vector<struct ani_group> *anistropy)
{
	struct ani_group t;
	CAminoacid::ani(anistropy);

	t.type=4;
	t.id=residue;
	t.code=OneLetterName;
	t.pos[0]=get("NH1").index;
	t.pos[1]=get("CZ").index;
	t.pos[2]=get("NH2").index;
	anistropy->push_back(t);
	
	return ;
}



void CArg::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;

	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;;
	t.x3=get("CB").index;;
	t.x4=get("CG").index;;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=4;
	t.x1=get("CA").index;
	t.x2=get("CB").index;
	t.x3=get("CG").index;
	t.x4=get("CD").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);
	
	t.type=5;
	t.x1=get("CB").index;
	t.x2=get("CG").index;
	t.x3=get("CD").index;
	t.x4=get("NE").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);
	
	t.type=6;
	t.x1=get("CG").index;
	t.x2=get("CD").index;
	t.x3=get("NE").index;
	t.x4=get("CZ").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);
	
	t.type=7;
	t.x1=get("CD").index;
	t.x2=get("NE").index;
	t.x3=get("CZ").index;
	t.x4=get("NH2").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);
	
	return;
}


CArg::CArg() 
{
	//CAminoacid::CAminoacid();
	OneLetterName='R';strcpy(ThreeLetterName,"ARG");

	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;
	t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG";t.cs_name="CG";t.base_name="CB";atoms.push_back(t);
	t.name="CD";t.cs_name="CD";t.base_name="CB";atoms.push_back(t);
	t.name="NE";t.cs_name="NE";t.base_name="CB";atoms.push_back(t);
	t.name="CZ";t.cs_name="CZ";t.base_name="CB";atoms.push_back(t);
	t.name="NH1";t.cs_name="NH1";t.base_name="CB";atoms.push_back(t);
	t.name="NH2";t.cs_name="NH2";t.base_name="CB";atoms.push_back(t);
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=11;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=12;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);
	t.carbon_name="CG";
	t.proton_type=13;t.name="HG2";t.cs_name="HG2";t.base_name="HG";atoms.push_back(t);
	t.proton_type=14;t.name="HG3";t.cs_name="HG3";t.base_name="HG";atoms.push_back(t);
	t.carbon_name="CD";
	t.proton_type=15;t.name="HD2";t.cs_name="HD2";t.base_name="HD";atoms.push_back(t);
	t.proton_type=16;t.name="HD3";t.cs_name="HD3";t.base_name="HD";atoms.push_back(t);
	t.carbon_name="NE";
	t.proton_type=17;t.name="HE";t.cs_name="HE";t.base_name="HE";atoms.push_back(t);
	t.carbon_name="NH1";
	t.proton_type=18;t.name="HH11";t.cs_name="HH1";t.base_name="HH1";atoms.push_back(t);
	t.proton_type=18;t.name="HH12";t.cs_name="HH1";t.base_name="HH1";atoms.push_back(t);
	t.carbon_name="NH2";
	t.proton_type=19;t.name="HH21";t.cs_name="HH2";t.base_name="HH2";atoms.push_back(t);
	t.proton_type=19;t.name="HH22";t.cs_name="HH2";t.base_name="HH2";atoms.push_back(t);
	
	get_address("H")->cs_coil=8.24;
	get_address("N")->cs_coil=121.7;
	get_address("CA")->cs_coil=55.9;
	get_address("HA")->cs_coil=4.47;
	get_address("CB")->cs_coil=31.0;
	get_address("C")->cs_coil=175.3;

	get_address("H")->cs_mean=8.23;
	get_address("N")->cs_mean=120.76;
	get_address("CA")->cs_mean=56.82;
	get_address("HA")->cs_mean=4.29;
	get_address("CB")->cs_mean=30.65;
	get_address("C")->cs_mean=176.46;

	get_address("H")->cs_wang=8.21;
	get_address("N")->cs_wang=120.75;
	get_address("CA")->cs_wang=56.18;
	get_address("HA")->cs_wang=4.26;
	get_address("CB")->cs_wang=30.36;
	get_address("C")->cs_wang=176.01;

	coil_pre[0]=-0.45;
	coil_pre[1]=-0.07;
	coil_pre[2]= 0.00;
	coil_pre[3]= 0.01;
	coil_pre[4]=-0.03;
	coil_pre[5]= 0.01;

	coil_fol[0]=-0.09;
	coil_fol[1]= 0.16;
	coil_fol[2]= 0.19;
	coil_fol[3]=-0.12;
	coil_fol[4]=-0.01;
	coil_fol[5]=-0.02;
}
CArg::~CArg() {}


// ASN
void CAsn::schbond(vector<bbhbond_group> *grp)
{
	bbhbond_group t;
	t.id=residue;
	t.code=OneLetterName;
	t.npos=-1;
	t.hpos=-1;
	t.cpos=get("CG").index;
	t.opos=get("OD1").index;
	t.type=23; 

	grp->push_back(t);
	return;
}


struct noeatoms CAsn::query(string name)
{
	struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QD")==0)
	{
		tt.clear();
		tt.push_back(get("HD21").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HD22").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}



void CAsn::ani(vector<struct ani_group> *anistropy)
{
	struct ani_group t;
	CAminoacid::ani(anistropy);

	t.type=2;
	t.id=residue;
	t.code=OneLetterName;
	t.pos[0]=get("OD1").index;
	t.pos[1]=get("CG").index;
	t.pos[2]=get("ND2").index;
	anistropy->push_back(t);
	
	return ;
}



void CAsn::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=4;
	t.x1=get("CA").index;
	t.x2=get("CB").index;
	t.x3=get("CG").index;
	t.x4=get("ND2").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	return;
}


CAsn::CAsn() 
{
	//CAminoacid::CAminoacid();
	OneLetterName='N';strcpy(ThreeLetterName,"ASN");
	
	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;
	t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG";t.cs_name="CG";t.base_name="CB";atoms.push_back(t);
	t.name="OD1";t.cs_name="OD1";t.base_name="CB";atoms.push_back(t);
	t.name="ND2";t.cs_name="ND2";t.base_name="CB";atoms.push_back(t);
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=20;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=21;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);
	t.carbon_name="ND2";
	t.proton_type=22;t.name="HD21";t.cs_name="HD21";t.base_name="HD2";atoms.push_back(t);
	t.proton_type=23;t.name="HD22";t.cs_name="HD22";t.base_name="HD2";atoms.push_back(t);

	get_address("H")->cs_coil=8.42;
	get_address("N")->cs_coil=119.4;
	get_address("CA")->cs_coil=53.0;
	get_address("HA")->cs_coil=4.75;
	get_address("CB")->cs_coil=38.9;
	get_address("C")->cs_coil=174.9;

	get_address("H")->cs_mean=8.33;
	get_address("N")->cs_mean=118.89;
	get_address("CA")->cs_mean=53.57;
	get_address("HA")->cs_mean=4.66;
	get_address("CB")->cs_mean=38.69;
	get_address("C")->cs_mean=175.30;


	get_address("H")->cs_wang=8.35;
	get_address("N")->cs_wang=118.50;
	get_address("CA")->cs_wang=53.00;
	get_address("HA")->cs_wang=4.66;
	get_address("CB")->cs_wang=38.43;
	get_address("C")->cs_wang=174.84;

	coil_pre[0]=-0.76;
	coil_pre[1]=-0.19;
	coil_pre[2]= 0.18;
	coil_pre[3]=-0.20;
	coil_pre[4]= 0.01;
	coil_pre[5]=-0.03;


	coil_fol[0]=-0.03;
	coil_fol[1]=-0.23;
	coil_fol[2]=+0.24;
	coil_fol[3]=-0.06;
	coil_fol[4]= 0.04;
	coil_fol[5]=-0.04;
}
	
CAsn::~CAsn() {}




//ASP
void CAsp::schbond(vector<bbhbond_group> *grp)
{
	bbhbond_group t;
	t.id=residue;
	t.code=OneLetterName;
	t.npos=-1;
	t.hpos=-1;
	t.cpos=get("CG").index;
	t.opos=get("OD1").index;
	t.type=22; 

	grp->push_back(t);
	return;
}

	

	


struct noeatoms CAsp::query(string name)
{
	struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}


void CAsp::ani(vector<struct ani_group> *anistropy)
{
	struct ani_group t;
	CAminoacid::ani(anistropy);


	t.type=3;
	t.id=residue;
	t.code=OneLetterName;
	t.pos[0]=get("OD1").index;
	t.pos[1]=get("CG").index;
	t.pos[2]=get("OD2").index;
	anistropy->push_back(t);
	
	return ;
}

void CAsp::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=4;
	t.x1=get("CA").index;
	t.x2=get("CB").index;
	t.x3=get("CG").index;
	t.x4=get("OD1").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	return;
}

CAsp::CAsp() 
{
    //CAminoacid::CAminoacid();
	OneLetterName='D';strcpy(ThreeLetterName,"ASP");

	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;

	t.bb=0;
	t.proton=0;
	t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG";t.cs_name="CG";t.base_name="CB";atoms.push_back(t);
	t.name="OD1";t.cs_name="OD1";t.base_name="CB";atoms.push_back(t);
	t.name="OD2";t.cs_name="OD2";t.base_name="CB";atoms.push_back(t);
	
	t.proton=1;t.carbon_name="CB";
	t.proton_type=24;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=25;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);
		
	get_address("H")->cs_coil=8.31;
	get_address("N")->cs_coil=121.5;
	get_address("CA")->cs_coil=53.8;
	get_address("HA")->cs_coil=4.71;
	get_address("CB")->cs_coil=41.2;
	get_address("C")->cs_coil=175.7;

	get_address("H")->cs_mean=8.30;
	get_address("N")->cs_mean=120.63;
	get_address("CA")->cs_mean=54.71;
	get_address("HA")->cs_mean=4.59;
	get_address("CB")->cs_mean=40.87;
	get_address("C")->cs_mean=176.43;

	get_address("H")->cs_wang=8.31;
	get_address("N")->cs_wang=120.37;
	get_address("CA")->cs_wang=54.00;
	get_address("HA")->cs_wang=4.62;
	get_address("CB")->cs_wang=40.78;
	get_address("C")->cs_wang=176.00;

	coil_pre[0]=-0.43;
	coil_pre[1]= 0.07;
	coil_pre[2]= 0.20;
	coil_pre[3]=-0.07;
	coil_pre[4]=-0.01;
	coil_pre[5]=-0.03;

	coil_fol[0]= 0.23;
	coil_fol[1]=-0.11;
	coil_fol[2]= 0.28;
	coil_fol[3]= 0.11;
	coil_fol[4]= 0.04;
	coil_fol[5]=-0.03;
}
CAsp::~CAsp() {}


//CYS
struct noeatoms CCys::query(string name)
{	
	struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}




void CCys::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("SG").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	return;
}

CCys::CCys() 
{
	//CAminoacid::CAminoacid();
	OneLetterName='C';strcpy(ThreeLetterName,"CYS");
	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;
	t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="SG";t.cs_name="SG";t.base_name="CB";atoms.push_back(t);
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=26;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=27;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);
	t.carbon_name="SG";
	t.proton_type=28;t.name="HG";t.cs_name="HG";t.base_name="HG";atoms.push_back(t);


	get_address("H")->cs_coil=8.20;
	get_address("N")->cs_coil=120.1;
	get_address("CA")->cs_coil=58.2;
	get_address("HA")->cs_coil=4.96;
	get_address("CB")->cs_coil=29.4;
	get_address("C")->cs_coil=174.7;

	get_address("H")->cs_mean=8.38;
	get_address("N")->cs_mean=120.09;
	get_address("CA")->cs_mean=58.31;
	get_address("HA")->cs_mean=4.64;
	get_address("CB")->cs_mean=32.66;
	get_address("C")->cs_mean=174.98;

	get_address("H")->cs_wang=8.10;
	get_address("N")->cs_wang=118.10;
	get_address("CA")->cs_wang=58.24;
	get_address("HA")->cs_wang=4.59;
	get_address("CB")->cs_wang=29.54;
	get_address("C")->cs_wang=175.11;


	coil_pre[0]= 1.36;
	coil_pre[1]=-0.00;
	coil_pre[2]= 0.44;
	coil_pre[3]=-0.18;
	coil_pre[4]= 0.03;
	coil_pre[5]=-0.00;

	coil_fol[0]=-1.17;
	coil_fol[1]= 0.10;
	coil_fol[2]= 0.17;
	coil_fol[3]= 0.21;
	coil_fol[4]= 0.01;
	coil_fol[5]= 0.03;

}
CCys::~CCys() {}




struct noeatoms CCyx::query(string name)
{
	struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}



void CCyx::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("SG").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	return;
}


CCyx::CCyx() 
{
	//CAminoacid::CAminoacid();
	OneLetterName='C';strcpy(ThreeLetterName,"CYX");
	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;
	t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="SG";t.cs_name="SG";t.base_name="CB";atoms.push_back(t);
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=29;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=30;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);
	t.carbon_name="SG";
	t.proton_type=31;t.name="HG";t.cs_name="HG";t.base_name="HG";atoms.push_back(t);


	get_address("H")->cs_coil=8.20;
	get_address("N")->cs_coil=120.1;
	get_address("CA")->cs_coil=58.2;
	get_address("HA")->cs_coil=4.96;
	get_address("CB")->cs_coil=29.4;
	get_address("C")->cs_coil=174.7;

	get_address("H")->cs_mean=8.38;
	get_address("N")->cs_mean=120.09;
	get_address("CA")->cs_mean=58.31;
	get_address("HA")->cs_mean=4.64;
	get_address("CB")->cs_mean=32.66;
	get_address("C")->cs_mean=174.98;

	get_address("H")->cs_wang=8.10;
	get_address("N")->cs_wang=118.10;
	get_address("CA")->cs_wang=58.24;
	get_address("HA")->cs_wang=4.59;
	get_address("CB")->cs_wang=29.54;
	get_address("C")->cs_wang=175.11;

	coil_pre[0]= 1.36;
	coil_pre[1]=-0.00;
	coil_pre[2]= 0.44;
	coil_pre[3]=-0.18;
	coil_pre[4]= 0.03;
	coil_pre[5]=-0.00;

	coil_fol[0]=-1.17;
	coil_fol[1]= 0.10;
	coil_fol[2]= 0.17;
	coil_fol[3]= 0.21;
	coil_fol[4]= 0.01;
	coil_fol[5]= 0.03;
}
CCyx::~CCyx() {}


//GLN
void CGln::schbond(vector<bbhbond_group> *grp)
{
	bbhbond_group t;
	t.id=residue;
	t.code=OneLetterName;
	t.npos=-1;
	t.hpos=-1;
	t.cpos=get("CD").index;
	t.opos=get("OE1").index;
	t.type=23; 

	grp->push_back(t);
	return;
}


struct noeatoms CGln::query(string name)
{
	struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QG")==0)
	{
		tt.clear();
		tt.push_back(get("HG2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HG3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QE")==0)
	{
		tt.clear();
		tt.push_back(get("HE21").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HE22").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}

void CGln::ani(vector<struct ani_group> *anistropy)
{
	struct ani_group t;
	CAminoacid::ani(anistropy);

	t.type=2;
	t.id=residue;
	t.code=OneLetterName;
	t.pos[0]=get("OE1").index;
	t.pos[1]=get("CD").index;
	t.pos[2]=get("NE2").index;
	anistropy->push_back(t);
	
	return ;
}

void CGln::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=4;
	t.x1=get("CA").index;
	t.x2=get("CB").index;
	t.x3=get("CG").index;
	t.x4=get("CD").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=5;
	t.x1=get("CB").index;
	t.x2=get("CG").index;
	t.x3=get("CD").index;
	t.x4=get("NE2").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	return;
}


CGln::CGln() 
{
    //CAminoacid::CAminoacid();
	OneLetterName='Q';strcpy(ThreeLetterName,"GLN");
	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;
	t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG";t.cs_name="CG";t.base_name="CB";atoms.push_back(t);
	t.name="CD";t.cs_name="CD";t.base_name="CB";atoms.push_back(t);
	t.name="OE1";t.cs_name="OE1";t.base_name="CB";atoms.push_back(t);
	t.name="NE2";t.cs_name="NE2";t.base_name="CB";atoms.push_back(t);

	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=32;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=33;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);
	t.carbon_name="CG";
	t.proton_type=34;t.name="HG2";t.cs_name="HG2";t.base_name="HG";atoms.push_back(t);
	t.proton_type=35;t.name="HG3";t.cs_name="HG3";t.base_name="HG";atoms.push_back(t);
	t.carbon_name="NE2";
	t.proton_type=36;t.name="HE21";t.cs_name="HE21";t.base_name="HE2";atoms.push_back(t);
	t.proton_type=37;t.name="HE22";t.cs_name="HE22";t.base_name="HE2";atoms.push_back(t);

	get_address("H")->cs_coil=8.21;
	get_address("N")->cs_coil=120.2;
	get_address("CA")->cs_coil=55.5;
	get_address("HA")->cs_coil=4.43;
	get_address("CB")->cs_coil=29.4;
	get_address("C")->cs_coil=175.7;

	get_address("H")->cs_mean=8.21;
	get_address("N")->cs_mean=119.85;
	get_address("CA")->cs_mean=56.63;
	get_address("HA")->cs_mean=4.26;
	get_address("CB")->cs_mean=29.16;
	get_address("C")->cs_mean=176.37;

	get_address("H")->cs_wang=8.20;
	get_address("N")->cs_wang=119.82;
	get_address("CA")->cs_wang=55.89;
	get_address("HA")->cs_wang=4.29;
	get_address("CB")->cs_wang=29.01;
	get_address("C")->cs_wang=175.75;

	coil_pre[0]=-0.09;
	coil_pre[1]= 0.07;
	coil_pre[2]= 0.13;
	coil_pre[3]= 0.06;
	coil_pre[4]= 0.01;
	coil_pre[5]=-0.00;

	coil_fol[0]=-0.31;
	coil_fol[1]= 0.10;
	coil_fol[2]= 0.37;
	coil_fol[3]=-0.13;
	coil_fol[4]= 0.01;
	coil_fol[5]=-0.05;
}
CGln::~CGln() {}


//GLU
void CGlu::schbond(vector<bbhbond_group> *grp)
{
	bbhbond_group t;
	t.id=residue;
	t.code=OneLetterName;
	t.npos=-1;
	t.hpos=-1;
	t.cpos=get("CD").index;
	t.opos=get("OE1").index;
	t.type=22; 

	grp->push_back(t);
	return;
}


struct noeatoms CGlu::query(string name)
{
struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QG")==0)
	{
		tt.clear();
		tt.push_back(get("HG2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HG3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}

void CGlu::ani(vector<struct ani_group> *anistropy)
{
	struct ani_group t;
	CAminoacid::ani(anistropy);


	t.type=3;
	t.id=residue;
	t.code=OneLetterName;
	t.pos[0]=get("OE1").index;
	t.pos[1]=get("CD").index;
	t.pos[2]=get("OE2").index;
	anistropy->push_back(t);
	
	return ;
}

void CGlu::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=4;
	t.x1=get("CA").index;
	t.x2=get("CB").index;
	t.x3=get("CG").index;
	t.x4=get("CD").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=5;
	t.x1=get("CB").index;
	t.x2=get("CG").index;
	t.x3=get("CD").index;
	t.x4=get("OE1").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	return;
}


CGlu::CGlu() 
{
    //CAminoacid::CAminoacid();
	OneLetterName='E';strcpy(ThreeLetterName,"GLU");
	struct Atom t;
	
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;
	t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG";t.cs_name="CG";t.base_name="CB";atoms.push_back(t);
	t.name="CD";t.cs_name="CD";t.base_name="CB";atoms.push_back(t);
	t.name="OE1";t.cs_name="OE1";t.base_name="CB";atoms.push_back(t);
	t.name="OE2";t.cs_name="OE2";t.base_name="CB";atoms.push_back(t);

	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=38;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=39;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);
	t.carbon_name="CG";
	t.proton_type=40;t.name="HG2";t.cs_name="HG2";t.base_name="HG";atoms.push_back(t);
	t.proton_type=41;t.name="HG3";t.cs_name="HG3";t.base_name="HG";atoms.push_back(t);
	
	get_address("H")->cs_coil=8.36;
	get_address("N")->cs_coil=121.4;
	get_address("CA")->cs_coil=56.3;
	get_address("HA")->cs_coil=4.39;
	get_address("CB")->cs_coil=30.3;
	get_address("C")->cs_coil=175.9;
	
	get_address("H")->cs_mean=8.33;
	get_address("N")->cs_mean=120.66;
	get_address("CA")->cs_mean=57.37;
	get_address("HA")->cs_mean=4.25;
	get_address("CB")->cs_mean=29.98;
	get_address("C")->cs_mean=176.93;


	get_address("H")->cs_wang=8.36;
	get_address("N")->cs_wang=120.62;
	get_address("CA")->cs_wang=56.66;
	get_address("HA")->cs_wang=4.28;
	get_address("CB")->cs_wang=29.87;
	get_address("C")->cs_wang=176.32;

	coil_pre[0]=-0.36;
	coil_pre[1]= 0.04;
	coil_pre[2]= 0.01;
	coil_pre[3]= 0.04;
	coil_pre[4]=-0.01;
	coil_pre[5]=-0.01;

	coil_fol[0]= 0.26;
	coil_fol[1]= 0.14;
	coil_fol[2]= 0.25;
	coil_fol[3]= 0.06;
	coil_fol[4]= 0.07;
	coil_fol[5]=-0.04;
}
CGlu::~CGlu() {}

//GLY

struct noeatoms CGly::query(string name)
{
	struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QA")==0)
	{
		tt.clear();
		tt.push_back(get("HA2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HA3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}



void CGly::dihe(vector<dihe_group> * dihe_index)
{
	return;
}

CGly::CGly() 
{
    //CAminoacid::CAminoacid();
	bexploaded=0;
	atoms.clear();
	order_parameters.clear();
	OneLetterName='G';strcpy(ThreeLetterName,"GLY");
	
	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=1;
	t.proton=0;
	t.ambig=0;
	t.proton=0;t.name="N";t.cs_name="N";t.base_name="N";atoms.push_back(t);
	t.proton=1;t.name="H";t.cs_name="H";t.base_name="H";atoms.push_back(t);
	t.proton=0;t.name="CA";t.cs_name="CA";t.base_name="CA";atoms.push_back(t);
	t.proton=0;t.name="C";t.cs_name="C";t.base_name="C";atoms.push_back(t);
	t.proton=0;t.name="O";t.cs_name="O";t.base_name="O";atoms.push_back(t);
	
	t.proton=1;
	t.carbon_name="CA";
	t.proton_type=42;t.name="HA2";t.cs_name="HA2";t.base_name="HA";atoms.push_back(t);
	t.proton_type=43;t.name="HA3";t.cs_name="HA3";t.base_name="HA";atoms.push_back(t);


	struct S2 s2;
	s2.name1="N";s2.name2="H";s2.exp=999.0;s2.pre=999.0;order_parameters.push_back(s2);
	s2.name1="N";s2.name2="CA";s2.exp=999.0;s2.pre=999.0;order_parameters.push_back(s2);
	s2.name1="CA";s2.name2="C";s2.exp=999.0;s2.pre=999.0;order_parameters.push_back(s2);
	s2.name1="C0";s2.name2="N";s2.exp=999.0;s2.pre=999.0;order_parameters.push_back(s2);

	get_address("H")->cs_coil=8.31;
	get_address("N")->cs_coil=109.8;
	get_address("CA")->cs_coil=45.2;
	get_address("HA1")->cs_coil=4.12;
	get_address("HA2")->cs_coil=4.12;
	get_address("C")->cs_coil=173.9;

	get_address("H")->cs_mean=8.33;
	get_address("N")->cs_mean=109.60;
	get_address("CA")->cs_mean=45.36;
	get_address("HA1")->cs_mean=3.97;
	get_address("HA2")->cs_mean=3.90;
	get_address("C")->cs_mean=173.38;

	get_address("H")->cs_wang=8.37;
	get_address("N")->cs_wang=109.48;
	get_address("CA")->cs_wang=45.28;
	get_address("HA1")->cs_wang=3.97;
	get_address("HA2")->cs_wang=3.97;
	get_address("C")->cs_wang=174.01;

	coil_pre[0]=-0.43;
	coil_pre[1]=-0.09;
	coil_pre[2]=-0.26;
	coil_pre[3]= 0.17;
	coil_pre[4]=-0.10;
	coil_pre[5]= 0.04;


	coil_fol[0]= 0.13;
	coil_fol[1]= 0.47;
	coil_fol[2]= 0.12;
	coil_fol[3]=-0.07;
	coil_fol[4]= 0.06;
	coil_fol[5]=-0.03;
}
CGly::~CGly() {}



//HIS
struct noeatoms CHis::query(string name)
{
	struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}

void CHis::ring(vector<ring_group> *ring)
{
	ring_group t;
	t.x1=3; //type
	t.x2=get("CG").index;
	t.x3=get("ND1").index;
	t.x4=get("CE1").index;
	t.x5=get("NE2").index;
	t.x6=get("CD2").index;
	ring->push_back(t);
	return ;
}

void CHis::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=4;
	t.x1=get("CA").index;
	t.x2=get("CB").index;
	t.x3=get("CG").index;
	t.x4=get("ND1").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	return;
}

CHis::CHis() 
{
    //CAminoacid::CAminoacid();
	OneLetterName='H';strcpy(ThreeLetterName,"HIS");

	struct Atom t;
	
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;
	t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG";t.cs_name="CG";t.base_name="CB";atoms.push_back(t);
	t.name="CD2";t.cs_name="CD2";t.base_name="CB";atoms.push_back(t);
	t.name="ND1";t.cs_name="ND1";t.base_name="CB";atoms.push_back(t);
	t.name="CE1";t.cs_name="CE1";t.base_name="CB";atoms.push_back(t);
	t.name="NE2";t.cs_name="NE2";t.base_name="CB";atoms.push_back(t);
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=44;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=45;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);
	t.carbon_name="ND1";
	t.proton_type=46;t.name="HD1";t.cs_name="HD1";t.base_name="HD1";atoms.push_back(t);
	t.carbon_name="CD2";
	t.proton_type=47;t.name="HD2";t.cs_name="HD2";t.base_name="HD2";atoms.push_back(t);
	t.carbon_name="CE1";
	t.proton_type=48;t.name="HE1";t.cs_name="HE1";t.base_name="HE1";atoms.push_back(t);
	t.carbon_name="NE2";
	t.proton_type=49;t.name="HE2";t.cs_name="HE2";t.base_name="HE2";atoms.push_back(t);
		
	get_address("H")->cs_coil=8.29;
	get_address("N")->cs_coil=119.7;
	get_address("CA")->cs_coil=55.3;
	get_address("HA")->cs_coil=4.73;
	get_address("CB")->cs_coil=30.1;
	get_address("C")->cs_coil=174.4;
	
	get_address("H")->cs_mean=8.24;
	get_address("N")->cs_mean=119.67;
	get_address("CA")->cs_mean=56.55;
	get_address("HA")->cs_mean=4.60;
	get_address("CB")->cs_mean=30.22;
	get_address("C")->cs_mean=175.28;

	get_address("H")->cs_wang=8.18;
	get_address("N")->cs_wang=118.92;
	get_address("CA")->cs_wang=55.74;
	get_address("HA")->cs_wang=4.60;
	get_address("CB")->cs_wang=29.50;
	get_address("C")->cs_wang=174.78;

	coil_pre[0]=-0.05;
	coil_pre[1]=-0.13;
	coil_pre[2]= 0.16;
	coil_pre[3]= 0.07;
	coil_pre[4]=-0.01;
	coil_pre[5]=-0.05;

	coil_fol[0]=-0.09;
	coil_fol[1]=-0.05;
	coil_fol[2]= 0.22;
	coil_fol[3]=-0.24;
	coil_fol[4]=-0.01;
	coil_fol[5]=-0.09;

}
CHis::~CHis() {}



//ILE

struct noeatoms CIle::query(string name)
{
struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QG")==0)
	{
		tt.clear();
		tt.push_back(get("HG12").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HG13").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("MG")==0 || name.compare("QG2")==0)
	{
		tt.push_back(get("HG21").index);
		tt.push_back(get("HG22").index);
		tt.push_back(get("HG23").index);
		t.atoms.push_back(tt);
		t.length=0.0;
	}
	else if(name.compare("MD")==0|| name.compare("QD1")==0)
	{
		tt.push_back(get("HD11").index);
		tt.push_back(get("HD12").index);
		tt.push_back(get("HD13").index);
		t.atoms.push_back(tt);
		t.length=0.0;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}

void CIle::proton2(vector<struct proton> *sel)
{
	struct proton t;

	t.type=9;
	t.name="HG2";
	get_proton(&t);
	sel->push_back(t);

	t.type=10;
	t.name="HD1";
	get_proton(&t);
	sel->push_back(t);

	return;
}


void CIle::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG1").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=4;
	t.x1=get("CA").index;
	t.x2=get("CB").index;
	t.x3=get("CG1").index;
	t.x4=get("CD1").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);
	
	return;
}



CIle::CIle() 
{
	//CAminoacid::CAminoacid();
	OneLetterName='I';strcpy(ThreeLetterName,"ILE");
	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;
	t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG2";t.cs_name="CG2";t.base_name="CB";atoms.push_back(t);
	t.name="CG1";t.cs_name="CG1";t.base_name="CB";atoms.push_back(t);
	t.name="CD1";t.cs_name="CD1";t.base_name="CB";atoms.push_back(t);
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=50;t.name="HB";t.cs_name="HB";t.base_name="HB";atoms.push_back(t);
	t.carbon_name="CG2";
	t.proton_type=9;t.name="HG21";t.cs_name="HG2";t.base_name="HG2";atoms.push_back(t);
	t.proton_type=9;t.name="HG22";t.cs_name="HG2";t.base_name="HG2";atoms.push_back(t);
	t.proton_type=9;t.name="HG23";t.cs_name="HG2";t.base_name="HG2";atoms.push_back(t);
	
	t.carbon_name="CG1";
	t.proton_type=51;t.name="HG12";t.cs_name="HG12";t.base_name="HG1";atoms.push_back(t);
	t.proton_type=52;t.name="HG13";t.cs_name="HG13";t.base_name="HG1";atoms.push_back(t);

	t.carbon_name="CD1";
	t.proton_type=10;t.name="HD11";t.cs_name="HD1";t.base_name="HD1";atoms.push_back(t);
	t.proton_type=10;t.name="HD12";t.cs_name="HD1";t.base_name="HD1";atoms.push_back(t);
	t.proton_type=10;t.name="HD13";t.cs_name="HD1";t.base_name="HD1";atoms.push_back(t);
		
	get_address("H")->cs_coil=8.30;
	get_address("N")->cs_coil=122.0;
	get_address("CA")->cs_coil=60.4;
	get_address("HA")->cs_coil=4.31;
	get_address("CB")->cs_coil=38.7;
	get_address("C")->cs_coil=174.9;
		
	get_address("H")->cs_mean=8.22;
	get_address("N")->cs_mean=121.79;
	get_address("CA")->cs_mean=55.70;
	get_address("HA")->cs_mean=4.30;
	get_address("CB")->cs_mean=42.27;
	get_address("C")->cs_mean=177.06;

	get_address("H")->cs_wang=7.94;
	get_address("N")->cs_wang=120.58;
	get_address("CA")->cs_wang=60.79;
	get_address("HA")->cs_wang=4.18;
	get_address("CB")->cs_wang=38.43;
	get_address("C")->cs_wang=175.52;


	coil_pre[0]= 2.92;
	coil_pre[1]= 0.11;
	coil_pre[2]=-0.15;
	coil_pre[3]= 0.26;
	coil_pre[4]= 0.12;
	coil_pre[5]= 0.04;

	coil_fol[0]=-0.20;
	coil_fol[1]=-0.09;
	coil_fol[2]= 0.03;
	coil_fol[3]= 0.28;
	coil_fol[4]=-0.01;
	coil_fol[5]= 0.03;
}
CIle::~CIle() {}




//LEU

void CLeu::methyl_ambig(int flag)
{
	int i;
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).base_name=="HD1" && atoms.at(i).ambig==2)
		{
			if(atoms.at(i).cs_exp>0.0)
				atoms.at(i).cs_exp=999.0;
		}
		if(atoms.at(i).base_name=="HD2" && atoms.at(i).ambig==2)
		{
			if(atoms.at(i).cs_exp>0.0)
				atoms.at(i).cs_exp=999.0;
		}
	}
	return;
}

struct noeatoms CLeu::query(string name)
{
struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("MD2")==0 || name.compare("QD2")==0)
	{
		tt.push_back(get("HD21").index);
		tt.push_back(get("HD22").index);
		tt.push_back(get("HD23").index);
		t.atoms.push_back(tt);
		t.length=0.0;
	}
	else if(name.compare("MD1")==0|| name.compare("QD1")==0)
	{
		tt.push_back(get("HD11").index);
		tt.push_back(get("HD12").index);
		tt.push_back(get("HD13").index);
		t.atoms.push_back(tt);
		t.length=0.0;
	}
	else if(name.compare("QD")==0)
	{
		tt.clear();
		tt.push_back(get("HD21").index);
		tt.push_back(get("HD22").index);
		tt.push_back(get("HD23").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HD11").index);
		tt.push_back(get("HD12").index);
		tt.push_back(get("HD13").index);
		t.atoms.push_back(tt);
		t.length=5.0;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}

void CLeu::proton2(vector<struct proton> *sel)
{
	struct proton t;


	t.type=7;
	t.name="HD1";
	get_proton(&t);
	sel->push_back(t);

	t.type=8;
	t.name="HD2";
	get_proton(&t);
	sel->push_back(t);

	return;
}


void CLeu::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;	
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=4;
	t.x1=get("CA").index;
	t.x2=get("CB").index;
	t.x3=get("CG").index;
	t.x4=get("CD1").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	return;
}

CLeu::CLeu() 
{
    //CAminoacid::CAminoacid();
	OneLetterName='L';strcpy(ThreeLetterName,"LEU");
	
	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;
	t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG";t.cs_name="CG";t.base_name="CB";atoms.push_back(t);
	t.name="CD1";t.cs_name="CD1";t.base_name="CB";atoms.push_back(t);
	t.name="CD2";t.cs_name="CD2";t.base_name="CB";atoms.push_back(t);
	
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=53;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=54;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);
	
	t.carbon_name="CG";
	t.proton_type=55;t.name="HG";t.cs_name="HG";t.base_name="HG";atoms.push_back(t);
	
	t.carbon_name="CD1";
	t.proton_type=7;t.name="HD11";t.cs_name="HD1";t.base_name="HD1";atoms.push_back(t);
	t.proton_type=7;t.name="HD12";t.cs_name="HD1";t.base_name="HD1";atoms.push_back(t);
	t.proton_type=7;t.name="HD13";t.cs_name="HD1";t.base_name="HD1";atoms.push_back(t);

	t.carbon_name="CD2";
	t.proton_type=8;t.name="HD21";t.cs_name="HD2";t.base_name="HD2";atoms.push_back(t);
	t.proton_type=8;t.name="HD22";t.cs_name="HD2";t.base_name="HD2";atoms.push_back(t);
	t.proton_type=8;t.name="HD23";t.cs_name="HD2";t.base_name="HD2";atoms.push_back(t);
		
	get_address("H")->cs_coil=8.18;
	get_address("N")->cs_coil=122.3;
	get_address("CA")->cs_coil=54.5;
	get_address("HA")->cs_coil=4.47;
	get_address("CB")->cs_coil=42.5;
	get_address("C")->cs_coil=176.4;

		
	get_address("H")->cs_mean=8.22;
	get_address("N")->cs_mean=121.79;
	get_address("CA")->cs_mean=55.70;
	get_address("HA")->cs_mean=4.30;
	get_address("CB")->cs_mean=42.27;
	get_address("C")->cs_mean=177.06;

	get_address("H")->cs_wang=8.06;
	get_address("N")->cs_wang=121.57;
	get_address("CA")->cs_wang=54.77;
	get_address("HA")->cs_wang=4.36;
	get_address("CB")->cs_wang=42.14;
	get_address("C")->cs_wang=176.70;


	coil_pre[0]=-0.76;
	coil_pre[1]= 0.13;
	coil_pre[2]=-0.07;
	coil_pre[3]=-0.03;
	coil_pre[4]=-0.06;
	coil_pre[5]= 0.00;

	coil_fol[0]=-0.49;
	coil_fol[1]= 0.06;
	coil_fol[2]= 0.10;
	coil_fol[3]=-0.10;
	coil_fol[4]=-0.07;
	coil_fol[5]=-0.02;
}
CLeu::~CLeu() {}




//LYS

struct noeatoms CLys::query(string name)
{
struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QG")==0)
	{
		tt.clear();
		tt.push_back(get("HG2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HG3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QD")==0)
	{
		tt.clear();
		tt.push_back(get("HD2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HD3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QE")==0)
	{
		tt.clear();
		tt.push_back(get("HE2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HE3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}

void CLys::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=4;
	t.x1=get("CA").index;
	t.x2=get("CB").index;
	t.x3=get("CG").index;
	t.x4=get("CD").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=5;
	t.x1=get("CB").index;
	t.x2=get("CG").index;
	t.x3=get("CD").index;
	t.x4=get("CE").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=6;
	t.x1=get("CG").index;
	t.x2=get("CD").index;
	t.x3=get("CE").index;
	t.x4=get("NZ").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	return;
}


CLys::CLys() 
{
    //CAminoacid::CAminoacid();
	OneLetterName='K';strcpy(ThreeLetterName,"LYS");
	
	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG";t.cs_name="CG";t.base_name="CB";atoms.push_back(t);
	t.name="CD";t.cs_name="CD";t.base_name="CB";atoms.push_back(t);
	t.name="CE";t.cs_name="CE";t.base_name="CB";atoms.push_back(t);
	t.name="NZ";t.cs_name="NZ";t.base_name="CB";atoms.push_back(t);

	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=56;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=57;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);
	t.carbon_name="CG";
	t.proton_type=58;t.name="HG2";t.cs_name="HG2";t.base_name="HG";atoms.push_back(t);
	t.proton_type=59;t.name="HG3";t.cs_name="HG3";t.base_name="HG";atoms.push_back(t);
	t.carbon_name="CD";
	t.proton_type=60;t.name="HD2";t.cs_name="HD2";t.base_name="HD";atoms.push_back(t);
	t.proton_type=61;t.name="HD3";t.cs_name="HD3";t.base_name="HD";atoms.push_back(t);
	t.carbon_name="CE";
	t.proton_type=62;t.name="HE2";t.cs_name="HE2";t.base_name="HE";atoms.push_back(t);
	t.proton_type=63;t.name="HE3";t.cs_name="HE3";t.base_name="HE";atoms.push_back(t);
	t.carbon_name="NZ";
	t.proton_type=64;t.name="HZ1";t.cs_name="HZ";t.base_name="HZ";atoms.push_back(t);
	t.proton_type=64;t.name="HZ2";t.cs_name="HZ";t.base_name="HZ";atoms.push_back(t);
	t.proton_type=64;t.name="HZ3";t.cs_name="HZ";t.base_name="HZ";atoms.push_back(t);
		
	get_address("H")->cs_coil=8.24;
	get_address("N")->cs_coil=121.8;
	get_address("CA")->cs_coil=56.2;
	get_address("HA")->cs_coil=4.36;
	get_address("CB")->cs_coil=32.8;
	get_address("C")->cs_coil=176.0;
		
	get_address("H")->cs_mean=8.18;
	get_address("N")->cs_mean=121.00;
	get_address("CA")->cs_mean=57.00;
	get_address("HA")->cs_mean=4.26;
	get_address("CB")->cs_mean=32.78;
	get_address("C")->cs_mean=176.71;

	get_address("H")->cs_wang=8.17;
	get_address("N")->cs_wang=121.1;
	get_address("CA")->cs_wang=56.29;
	get_address("HA")->cs_wang=4.28;
	get_address("CB")->cs_wang=32.53;
	get_address("C")->cs_wang=176.15;

	coil_pre[0]=-0.26;
	coil_pre[1]=-0.09;
	coil_pre[2]=-0.07;
	coil_pre[3]= 0.08;
	coil_pre[4]=-0.02;
	coil_pre[5]=-0.00;

	coil_fol[0]=-0.13;
	coil_fol[1]=-0.13;
	coil_fol[2]= 0.08;
	coil_fol[3]= 0.01;
	coil_fol[4]=-0.04;
	coil_fol[5]=-0.03;
}
CLys::~CLys() {}



//MET

struct noeatoms CMet::query(string name)
{
	struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QG")==0)
	{
		tt.clear();
		tt.push_back(get("HG2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HG3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("ME")==0 || name.compare("QE")==0)
	{
		tt.clear();
		tt.push_back(get("HE1").index);
		tt.push_back(get("HE2").index);
		tt.push_back(get("HE3").index);
		t.atoms.push_back(tt);
		t.length=0.0;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}


void CMet::proton2(vector<struct proton> *sel)
{
	struct proton t;


	t.type=3;
	t.name="HE";
	get_proton(&t);
	sel->push_back(t);

	return;
}


void CMet::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=4;
	t.x1=get("CA").index;
	t.x2=get("CB").index;
	t.x3=get("CG").index;
	t.x4=get("SD").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=5;
	t.x1=get("CB").index;
	t.x2=get("CG").index;
	t.x3=get("SD").index;
	t.x4=get("CE").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	return;
}

CMet::CMet() 
{
    //CAminoacid::CAminoacid();
	OneLetterName='M';strcpy(ThreeLetterName,"MET");

	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG";t.cs_name="CG";t.base_name="CB";atoms.push_back(t);
	t.name="SD";t.cs_name="SD";t.base_name="CB";atoms.push_back(t);
	t.name="CE";t.cs_name="CE";t.base_name="CB";atoms.push_back(t);

	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=65;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=66;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);
	t.carbon_name="CG";
	t.proton_type=67;t.name="HG2";t.cs_name="HG2";t.base_name="HG";atoms.push_back(t);
	t.proton_type=68;t.name="HG3";t.cs_name="HG3";t.base_name="HG";atoms.push_back(t);
	
	t.carbon_name="CE";
	t.proton_type=3;t.name="HE1";t.cs_name="HE";t.base_name="HE";atoms.push_back(t);
	t.proton_type=3;t.name="HE2";t.cs_name="HE";t.base_name="HE";atoms.push_back(t);
	t.proton_type=3;t.name="HE3";t.cs_name="HE";t.base_name="HE";atoms.push_back(t);
	
	get_address("H")->cs_coil=8.35;
	get_address("N")->cs_coil=121.2;
	get_address("CA")->cs_coil=55.4;
	get_address("HA")->cs_coil=4.41;
	get_address("CB")->cs_coil=33.7;
	get_address("C")->cs_coil=174.6;

		
	get_address("H")->cs_mean=8.25;
	get_address("N")->cs_mean=120.07;
	get_address("CA")->cs_mean=56.15;
	get_address("HA")->cs_mean=4.40;
	get_address("CB")->cs_mean=32.95;
	get_address("C")->cs_mean=176.24;

	get_address("H")->cs_wang=8.22;
	get_address("N")->cs_wang=120.14;
	get_address("CA")->cs_wang=55.43;
	get_address("HA")->cs_wang=4.47;
	get_address("CB")->cs_wang=32.92;
	get_address("C")->cs_wang=175.94;

	coil_pre[0]= 0.69;
	coil_pre[1]= 0.10;
	coil_pre[2]= 0.09;
	coil_pre[3]= 0.10;
	coil_pre[4]= 0.05;
	coil_pre[5]= 0.05;

	coil_fol[0]=-0.02;
	coil_fol[1]= 0.19;
	coil_fol[2]= 0.22;
	coil_fol[3]= 0.06;
	coil_fol[4]= 0.01;
	coil_fol[5]=-0.01;
}
CMet::~CMet() {}


//PHE 
//special handling for aromatic ring's HD and HE atoms.
/*void CPhe::proton(vector<struct proton> *sel)
{
	struct proton t;
	int i;
	string oldname;

	oldname="XXX";
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).bb==0 && atoms.at(i).proton==1 && atoms.at(i).cs_name!=oldname)
		{
			oldname=atoms.at(i).cs_name;
			t.name=atoms.at(i).cs_name;
			if(get_proton(&t))
				sel->push_back(t);
		}
	}
	return;
}

void CPhe::proton3(vector<struct proton> *sel)
{
	proton(sel);
	return;
}*/


struct noeatoms CPhe::query(string name)
{
struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QD")==0)
	{
		tt.clear();
		tt.push_back(get("HD1").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HD2").index);
		t.atoms.push_back(tt);
		t.length=5.0;
	}
	else if(name.compare("QE")==0)
	{
		tt.clear();
		tt.push_back(get("HE1").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HE2").index);
		t.atoms.push_back(tt);
		t.length=5.0;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}

void CPhe::ring(vector<ring_group> *ring)
{
	ring_group t;

	t.x1=1; //type
	t.x2=get("CG").index;
	t.x3=get("CD1").index;
	t.x4=get("CE1").index;
	t.x5=get("CZ").index;
	t.x6=get("CE2").index;
	t.x7=get("CD2").index;

	ring->push_back(t);
	return ;
}

void CPhe::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=4;
	t.x1=get("CA").index;
	t.x2=get("CB").index;
	t.x3=get("CG").index;
	t.x4=get("CD1").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	return;
}


CPhe::CPhe() 
{
    //CAminoacid::CAminoacid();
	OneLetterName='F';strcpy(ThreeLetterName,"PHE");
	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG";t.cs_name="CG";t.base_name="CB";atoms.push_back(t);
	t.name="CD1";t.cs_name="CD";t.base_name="CB";atoms.push_back(t);
	t.name="CD2";t.cs_name="CD";t.base_name="CB";atoms.push_back(t);
	t.name="CE1";t.cs_name="CE";t.base_name="CB";atoms.push_back(t);
	t.name="CE2";t.cs_name="CE";t.base_name="CB";atoms.push_back(t);
	t.name="CZ";t.cs_name="CZ";t.base_name="CB";atoms.push_back(t);
	
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=69;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=70;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);

	t.carbon_name="CD1";
	t.proton_type=71;t.name="HD1";t.cs_name="HD";t.base_name="HD1";atoms.push_back(t);
	t.carbon_name="CD2";
	t.proton_type=71;t.name="HD2";t.cs_name="HD";t.base_name="HD2";atoms.push_back(t);
	t.carbon_name="CE1";
	t.proton_type=72;t.name="HE1";t.cs_name="HE";t.base_name="HE1";atoms.push_back(t);
	t.carbon_name="CE2";
	t.proton_type=72;t.name="HE2";t.cs_name="HE";t.base_name="HE2";atoms.push_back(t);
	t.carbon_name="CZ";
	t.proton_type=73;t.name="HZ";t.cs_name="HZ";t.base_name="HZ";atoms.push_back(t);

	get_address("H")->cs_coil=8.27;
	get_address("N")->cs_coil=120.1;
	get_address("CA")->cs_coil=57.2;
	get_address("HA")->cs_coil=4.65;
	get_address("CB")->cs_coil=40.2;
	get_address("C")->cs_coil=175.0;
		
	get_address("H")->cs_mean=8.34;
	get_address("N")->cs_mean=120.39;
	get_address("CA")->cs_mean=58.16;
	get_address("HA")->cs_mean=4.62;
	get_address("CB")->cs_mean=39.95;
	get_address("C")->cs_mean=175.48;

	get_address("H")->cs_wang=8.09;
	get_address("N")->cs_wang=119.72;
	get_address("CA")->cs_wang=57.46;
	get_address("HA")->cs_wang=4.59;
	get_address("CB")->cs_wang=39.41;
	get_address("C")->cs_wang=175.46;

	coil_pre[0]= 0.20;
	coil_pre[1]=-0.14;
	coil_pre[2]= 0.02;
	coil_pre[3]=-0.06;
	coil_pre[4]= 0.01;
	coil_pre[5]=-0.01;

	coil_fol[0]=-0.35;
	coil_fol[1]=-0.22;
	coil_fol[2]=-0.04;
	coil_fol[3]=-0.09;
	coil_fol[4]=-0.04;
	coil_fol[5]=-0.02;
}
CPhe::~CPhe() {}


//PRO

struct noeatoms CPro::query(string name)
{
struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QG")==0)
	{
		tt.clear();
		tt.push_back(get("HG2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HG3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QD")==0)
	{
		tt.clear();
		tt.push_back(get("HD2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HD3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}



void CPro::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG").index;
	//dihe_index->push_back(t);

	t.type=3;
	t.x1=get("CA").index;
	t.x2=get("CB").index;
	t.x3=get("CG").index;
	t.x4=get("CD").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=5;
	t.x1=get("CB").index;
	t.x2=get("CG").index;
	t.x3=get("CD").index;
	t.x4=get("n").index;
	//dihe_index->push_back(t);

	return;
}

CPro::CPro() 
{
    //CAminoacid::CAminoacid();
	bexploaded=0;
	atoms.clear();order_parameters.clear();
	OneLetterName='P';strcpy(ThreeLetterName,"PRO");

	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=1;
	t.proton=0;t.ambig=0;
	t.proton=0;t.name="N";t.cs_name="N";t.base_name="N";atoms.push_back(t);
	t.proton=0;t.name="CA";t.cs_name="CA";t.base_name="CA";atoms.push_back(t);
	t.proton=1;t.name="HA";t.cs_name="HA";t.base_name="HA";atoms.push_back(t);
	t.proton=0;t.name="C";t.cs_name="C";t.base_name="C";atoms.push_back(t);
	t.proton=0;t.name="O";t.cs_name="O";t.base_name="O";atoms.push_back(t);

	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;
	t.bb=0;
	t.proton=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG";t.cs_name="CG";t.base_name="CB";atoms.push_back(t);
	t.name="CD";t.cs_name="CD";t.base_name="CB";atoms.push_back(t);
	
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=74;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=75;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);
	t.carbon_name="CG";
	t.proton_type=76;t.name="HG2";t.cs_name="HG2";t.base_name="HG";atoms.push_back(t);
	t.proton_type=77;t.name="HG3";t.cs_name="HG3";t.base_name="HG";atoms.push_back(t);
	t.carbon_name="CD";
	t.proton_type=78;t.name="HD2";t.cs_name="HD2";t.base_name="HD";atoms.push_back(t);
	t.proton_type=79;t.name="HD3";t.cs_name="HD3";t.base_name="HD";atoms.push_back(t);


	get_address("CA")->cs_coil=62.6;
	get_address("HA")->cs_coil=4.44;
	get_address("CB")->cs_coil=31.9;
	get_address("C")->cs_coil=176.1;

		
	get_address("CA")->cs_mean=63.36;
	get_address("HA")->cs_mean=4.39;
	get_address("CB")->cs_mean=31.85;
	get_address("C")->cs_mean=176.76;

	get_address("CA")->cs_wang=63.24;
	get_address("HA")->cs_wang=4.41;
	get_address("CB")->cs_wang=31.81;
	get_address("C")->cs_wang=176.62;

	coil_pre[0]=-0.94;
	coil_pre[1]= 0.21;
	coil_pre[2]= 0.07;
	coil_pre[3]=-0.16;
	coil_pre[4]= 0.14;
	coil_pre[5]=-0.04;

	coil_fol[0]= 0.92;
	coil_fol[1]=-1.19;
	coil_fol[2]=-2.04;
	coil_fol[3]=-0.20;
	coil_fol[4]=-0.17;
	coil_fol[5]= 0.21;

}
CPro::~CPro() {}


//SER
void CSer::schbond(vector<bbhbond_group> *grp)
{
	bbhbond_group t;
	t.id=residue;
	t.code=OneLetterName;
	t.cpos=-1;
	t.opos=-1;
	t.npos=get("OG").index;
	t.hpos=get("HG").index;
	t.type=12; 

	grp->push_back(t);
	return;
}

struct noeatoms CSer::query(string name)
{
	struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}


void CSer::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("OG").index;	
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	return;
}



CSer::CSer() 
{
    //CAminoacid::CAminoacid();
	OneLetterName='S';strcpy(ThreeLetterName,"SER");
	
	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="OG";t.cs_name="OG";t.base_name="CB";atoms.push_back(t);
	
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=80;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=81;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);
	t.carbon_name="OG";
	t.proton_type=82;t.name="HG";t.cs_name="HG";t.base_name="HG";atoms.push_back(t);

	get_address("H")->cs_coil=8.36;
	get_address("N")->cs_coil=116.8;
	get_address("CA")->cs_coil=58.1;
	get_address("HA")->cs_coil=4.55;
	get_address("CB")->cs_coil=64.1;
	get_address("C")->cs_coil=174.2;

		
	get_address("H")->cs_mean=8.28;
	get_address("N")->cs_mean=116.27;
	get_address("CA")->cs_mean=58.76;
	get_address("HA")->cs_mean=4.47;
	get_address("CB")->cs_mean=63.79;
	get_address("C")->cs_mean=174.65;

	get_address("H")->cs_wang=8.22;
	get_address("N")->cs_wang=116.00;
	get_address("CA")->cs_wang=58.20;
	get_address("HA")->cs_wang=4.45;
	get_address("CB")->cs_wang=63.75;
	get_address("C")->cs_wang=174.41;

	coil_pre[0]= 1.16;
	coil_pre[1]=-0.10;
	coil_pre[2]= 0.11;
	coil_pre[3]=-0.06;
	coil_pre[4]= 0.02;
	coil_pre[5]= 0.01;

	coil_fol[0]= 0.30;
	coil_fol[1]= 0.10;
	coil_fol[2]= 0.10;
	coil_fol[3]= 0.14;
	coil_fol[4]= 0.07;
	coil_fol[5]= 0.02;
}
CSer::~CSer() {}


//THR
void CThr::schbond(vector<bbhbond_group> *grp)
{
	bbhbond_group t;
	t.id=residue;
	t.code=OneLetterName;
	t.cpos=-1;
	t.opos=-1;
	t.npos=get("OG1").index;
	t.hpos=get("HG1").index;
	t.type=12; 

	grp->push_back(t);
	return;
}



struct noeatoms CThr::query(string name)
{
	struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("MG")==0|| name.compare("QG2")==0)
	{
		tt.push_back(get("HG21").index);
		tt.push_back(get("HG22").index);
		tt.push_back(get("HG23").index);
		t.atoms.push_back(tt);
		t.length=0.0;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;;
}

void CThr::proton2(vector<struct proton> *sel)
{
	struct proton t;

	t.type=2;
	t.name="HG2";
	get_proton(&t);
	sel->push_back(t);


	return;
}


void CThr::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG2").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	return;
}

CThr::CThr() 
{
    //CAminoacid::CAminoacid();
	OneLetterName='T';strcpy(ThreeLetterName,"THR");
	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="OG1";t.cs_name="OG1";t.base_name="CB";atoms.push_back(t);
	t.name="CG2";t.cs_name="CG2";t.base_name="CB";atoms.push_back(t);
	
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=83;t.name="HB";t.cs_name="HB";t.base_name="HB";atoms.push_back(t);
	t.carbon_name="OG1";
	t.proton_type=84;t.name="HG1";t.cs_name="HG1";t.base_name="HG1";atoms.push_back(t);

	t.carbon_name="CG2";
	t.proton_type=2;t.name="HG21";t.cs_name="HG2";t.base_name="HG2";atoms.push_back(t);
	t.proton_type=2;t.name="HG22";t.cs_name="HG2";t.base_name="HG2";atoms.push_back(t);
	t.proton_type=2;t.name="HG23";t.cs_name="HG2";t.base_name="HG2";atoms.push_back(t);
		
	get_address("H")->cs_coil=8.27;
	get_address("N")->cs_coil=114.6;
	get_address("CA")->cs_coil=60.9;
	get_address("HA")->cs_coil=4.55;
	get_address("CB")->cs_coil=69.7;
	get_address("C")->cs_coil=174.5;
		
	get_address("H")->cs_mean=8.24;
	get_address("N")->cs_mean=115.36;
	get_address("CA")->cs_mean=62.28;
	get_address("HA")->cs_mean=4.45;
	get_address("CB")->cs_mean=69.72;
	get_address("C")->cs_mean=174.57;


	get_address("H")->cs_wang=8.16;
	get_address("N")->cs_wang=113.88;
	get_address("CA")->cs_wang=61.30;
	get_address("HA")->cs_wang=4.44;
	get_address("CB")->cs_wang=68.92;
	get_address("C")->cs_wang=174.78;

	coil_pre[0]= 1.23;
	coil_pre[1]=-0.07;
	coil_pre[2]= 0.05;
	coil_pre[3]=-0.11;
	coil_pre[4]= 0.02;
	coil_pre[5]=-0.00;


	coil_fol[0]= 0.22;
	coil_fol[1]= 0.10;
	coil_fol[2]= 0.02;
	coil_fol[3]= 0.14;
	coil_fol[4]= 0.04;
	coil_fol[5]= 0.08;
	
}
CThr::~CThr() {}


//TRP
void CTrp::schbond(vector<bbhbond_group> *grp)
{
	bbhbond_group t;
	t.id=residue;
	t.code=OneLetterName;
	t.cpos=-1;
	t.opos=-1;
	t.npos=get("NE1").index;
	t.hpos=get("HE1").index;
	t.type=13; 

	grp->push_back(t);
	return;
}

struct noeatoms CTrp::query(string name)
{
struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}


void CTrp::ring(vector<ring_group> *ring)
{
	ring_group t;

	t.x1=4; //type
	t.x2=get("CG").index;
	t.x3=get("CD1").index;
	t.x4=get("NE1").index;
	t.x5=get("CE2").index;
	t.x6=get("CD2").index;
	ring->push_back(t);

	t.x1=5;
	t.x2=get("CD2").index;
	t.x3=get("CE2").index;
	t.x4=get("CZ2").index;
	t.x5=get("CH2").index;
	t.x6=get("CZ3").index;
	t.x7=get("CE3").index;

	ring->push_back(t);
	return ;
}


void CTrp::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	t.type=4;
	t.x1=get("CA").index;
	t.x2=get("CB").index;
	t.x3=get("CG").index;
	t.x4=get("CD1").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);
	
	return;
}



CTrp::CTrp() 
{
    //CAminoacid::CAminoacid();
	OneLetterName='W';strcpy(ThreeLetterName,"TRP");
	
	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG";t.cs_name="CG";t.base_name="CB";atoms.push_back(t);
	t.name="CD1";t.cs_name="CD1";t.base_name="CB";atoms.push_back(t);
	t.name="CD2";t.cs_name="CD2";t.base_name="CB";atoms.push_back(t);
	t.name="NE1";t.cs_name="NE1";t.base_name="CB";atoms.push_back(t);
	t.name="CE2";t.cs_name="CE2";t.base_name="CB";atoms.push_back(t);
	t.name="CE3";t.cs_name="CE3";t.base_name="CB";atoms.push_back(t);	
	t.name="CZ2";t.cs_name="CZ2";t.base_name="CB";atoms.push_back(t);
	t.name="CZ3";t.cs_name="CZ3";t.base_name="CB";atoms.push_back(t);
	t.name="CH2";t.cs_name="CH2";t.base_name="CB";atoms.push_back(t);
	
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=85;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=86;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);

	t.carbon_name="CD1";
	t.proton_type=87;t.name="HD1";t.cs_name="HD1";t.base_name="HD1";atoms.push_back(t);
	t.carbon_name="NE1";
	t.proton_type=88;t.name="HE1";t.cs_name="HE1";t.base_name="HE1";atoms.push_back(t);
	t.carbon_name="CE3";
	t.proton_type=89;t.name="HE3";t.cs_name="HE3";t.base_name="HE3";atoms.push_back(t);
	t.carbon_name="CZ2";
	t.proton_type=90;t.name="HZ2";t.cs_name="HZ2";t.base_name="HZ2";atoms.push_back(t);
	t.carbon_name="CZ3";
	t.proton_type=91;t.name="HZ3";t.cs_name="HZ3";t.base_name="HZ3";atoms.push_back(t);
	t.carbon_name="CH2";
	t.proton_type=92;t.name="HH2";t.cs_name="HH2";t.base_name="HH2";atoms.push_back(t);

	get_address("H")->cs_coil=8.19;
	get_address("N")->cs_coil=121.7;
	get_address("CA")->cs_coil=57.3;
	get_address("HA")->cs_coil=4.80;
	get_address("CB")->cs_coil=30.4;
	get_address("C")->cs_coil=175.5;

		
	get_address("H")->cs_mean=8.28;
	get_address("N")->cs_mean=121.58;
	get_address("CA")->cs_mean=57.71;
	get_address("HA")->cs_mean=4.67;
	get_address("CB")->cs_mean=29.98;
	get_address("C")->cs_mean=176.19;

	get_address("H")->cs_wang=7.97;
	get_address("N")->cs_wang=120.99;
	get_address("CA")->cs_wang=57.54;
	get_address("HA")->cs_wang=4.60;
	get_address("CB")->cs_wang=29.60;
	get_address("C")->cs_wang=175.87;

	coil_pre[0]= 0.97;
	coil_pre[1]=-0.46;
	coil_pre[2]= 0.00;
	coil_pre[3]= 0.28;
	coil_pre[4]=-0.08;
	coil_pre[5]=-0.05;


	coil_fol[0]=-0.59;
	coil_fol[1]=-0.33;
	coil_fol[2]=-0.06;
	coil_fol[3]=-0.03;
	coil_fol[4]=-0.10;
	coil_fol[5]=-0.03;

}
CTrp::~CTrp() {}



//TYR
void CTyr::schbond(vector<bbhbond_group> *grp)
{
	bbhbond_group t;
	t.id=residue;
	t.code=OneLetterName;
	t.cpos=-1;
	t.opos=-1;
	t.npos=get("OH").index;
	t.hpos=get("HH").index;
	t.type=12; 

	grp->push_back(t);
	return;
}


struct noeatoms CTyr::query(string name)
{

struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("QB")==0)
	{
		tt.clear();
		tt.push_back(get("HB2").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HB3").index);
		t.atoms.push_back(tt);
		t.length=1.8;
	}
	else if(name.compare("QD")==0)
	{
		tt.clear();
		tt.push_back(get("HD1").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HD2").index);
		t.atoms.push_back(tt);
		t.length=5.0;
	}
	else if(name.compare("QE")==0)
	{
		tt.clear();
		tt.push_back(get("HE1").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HE2").index);
		t.atoms.push_back(tt);
		t.length=5.0;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}


void CTyr::ring(vector<ring_group> *ring)
{
	ring_group t;

	t.x1=2; //type
	t.x2=get("CG").index;
	t.x3=get("CD1").index;
	t.x4=get("CE1").index;
	t.x5=get("CZ").index;
	t.x6=get("CE2").index;
	t.x7=get("CD2").index;
	ring->push_back(t);
	return ;
}

void CTyr::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);
	
	t.type=4;
	t.x1=get("CA").index;
	t.x2=get("CB").index;
	t.x3=get("CG").index;
	t.x4=get("CD1").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);
	
	return;
}


CTyr::CTyr() 
{
    //CAminoacid::CAminoacid();
	OneLetterName='Y';strcpy(ThreeLetterName,"TYR");

	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG";t.cs_name="CG";t.base_name="CB";atoms.push_back(t);
	t.name="CD1";t.cs_name="CD";t.base_name="CB";atoms.push_back(t);
	t.name="CD2";t.cs_name="CD";t.base_name="CB";atoms.push_back(t);
	t.name="CE1";t.cs_name="CE";t.base_name="CB";atoms.push_back(t);
	t.name="CE2";t.cs_name="CE";t.base_name="CB";atoms.push_back(t);
	t.name="CZ";t.cs_name="CZ";t.base_name="CB";atoms.push_back(t);
	t.name="OH";t.cs_name="OH";t.base_name="CB";atoms.push_back(t);
	
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=93;t.name="HB2";t.cs_name="HB2";t.base_name="HB";atoms.push_back(t);
	t.proton_type=94;t.name="HB3";t.cs_name="HB3";t.base_name="HB";atoms.push_back(t);

	t.carbon_name="CD";
	t.proton_type=95;t.name="HD1";t.cs_name="HD";t.base_name="HD1";atoms.push_back(t);
	t.proton_type=95;t.name="HD2";t.cs_name="HD";t.base_name="HD2";atoms.push_back(t);
	t.carbon_name="CE";
	t.proton_type=96;t.name="HE1";t.cs_name="HE";t.base_name="HE1";atoms.push_back(t);
	t.proton_type=96;t.name="HE2";t.cs_name="HE";t.base_name="HE2";atoms.push_back(t);
	
	t.carbon_name="OH";
	t.proton_type=97;t.name="HH";t.cs_name="HH";t.base_name="HH";atoms.push_back(t);

	get_address("H")->cs_coil=8.24;
	get_address("N")->cs_coil=120.0;
	get_address("CA")->cs_coil=57.6;
	get_address("HA")->cs_coil=4.73;
	get_address("CB")->cs_coil=39.4;
	get_address("C")->cs_coil=174.8;

		
	get_address("H")->cs_mean=8.30;
	get_address("N")->cs_mean=120.45;
	get_address("CA")->cs_mean=58.20;
	get_address("HA")->cs_mean=4.61;
	get_address("CB")->cs_mean=39.26;
	get_address("C")->cs_mean=175.45;

	get_address("H")->cs_wang=7.99;
	get_address("N")->cs_wang=119.37;
	get_address("CA")->cs_wang=57.64;
	get_address("HA")->cs_wang=4.56;
	get_address("CB")->cs_wang=38.78;
	get_address("C")->cs_wang=175.29;

	coil_pre[0]= 0.46;
	coil_pre[1]=-0.03;
	coil_pre[2]=-0.19;
	coil_pre[3]=-0.10;
	coil_pre[4]= 0.02;
	coil_pre[5]= 0.01;

	coil_fol[0]=-0.48;
	coil_fol[1]=-0.51;
	coil_fol[2]= 0.10;
	coil_fol[3]= 0.00;
	coil_fol[4]=-0.07;
	coil_fol[5]=-0.06;
}
CTyr::~CTyr() {}



//Val

void CVal::methyl_ambig(int flag)
{
	int i;
	for(i=0;i<(int)atoms.size();i++)
	{
		if(atoms.at(i).base_name=="HG1" && atoms.at(i).ambig==2)
		{
			if(atoms.at(i).cs_exp>0.0)
				atoms.at(i).cs_exp=999.0;
		}
		if(atoms.at(i).base_name=="HG2" && atoms.at(i).ambig==2)
		{
			if(atoms.at(i).cs_exp>0.0)
				atoms.at(i).cs_exp=999.0;
		}
	}
	return;
}

struct noeatoms CVal::query(string name)
{
struct noeatoms t;	
	vector<int> tt;

	t=CAminoacid::query(name);

	if(t.atoms.size()>0)
		;
	else if(name.compare("MG1")==0 || name.compare("QG1")==0)
	{
		tt.push_back(get("HG11").index);
		tt.push_back(get("HG12").index);
		tt.push_back(get("HG13").index);
		t.atoms.push_back(tt);
		t.length=0.0;
	}
	else if(name.compare("MG2")==0 || name.compare("QG2")==0)
	{
		tt.push_back(get("HG21").index);
		tt.push_back(get("HG22").index);
		tt.push_back(get("HG23").index);
		t.atoms.push_back(tt);
		t.length=0.0;
	}
	else if(name.compare("QG")==0 || name.compare("QQG")==0)
	{
		tt.clear();
		tt.push_back(get("HG21").index);
		tt.push_back(get("HG22").index);
		tt.push_back(get("HG23").index);
		t.atoms.push_back(tt);
		tt.clear();
		tt.push_back(get("HG11").index);
		tt.push_back(get("HG12").index);
		tt.push_back(get("HG13").index);
		t.atoms.push_back(tt);
		t.length=5.0;
	}
	else
		cout<<"In "<<residue<<" "<<ThreeLetterName<<" no NOE match for "<<name.c_str()<<endl;
	return t;
}

void CVal::proton2(vector<struct proton> *sel)
{
	struct proton t;


	t.type=5;
	t.name="HG1";
	get_proton(&t);
	sel->push_back(t);

	t.type=6;
	t.name="HG2";
	get_proton(&t);
	sel->push_back(t);

	return;
}





void CVal::dihe(vector<dihe_group> * dihe_index)
{
	dihe_group t;
	t.code=OneLetterName;
	t.id=residue;

	t.type=3;
	t.x1=get("N").index;
	t.x2=get("CA").index;
	t.x3=get("CB").index;
	t.x4=get("CG1").index;
	t.bgood=0;if(t.x1>=0 && t.x2>=0 && t.x3>=0 && t.x4>=0) t.bgood=1; dihe_index->push_back(t);

	return;
}

CVal::CVal() 
{
    //CAminoacid::CAminoacid();
	OneLetterName='V';
	strcpy(ThreeLetterName,"VAL");
	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.cs_coil=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;
	t.bb=0;
	t.proton=0;t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.name="CG1";t.cs_name="CG1";t.base_name="CB";atoms.push_back(t);
	t.name="CG2";t.cs_name="CG2";t.base_name="CB";atoms.push_back(t);
	
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=98;t.name="HB";t.cs_name="HB";t.base_name="HB";atoms.push_back(t);
	t.carbon_name="CG1";
	t.proton_type=5;t.name="HG11";t.cs_name="HG1";t.base_name="HG1";atoms.push_back(t);
	t.proton_type=5;t.name="HG12";t.cs_name="HG1";t.base_name="HG1";atoms.push_back(t);
	t.proton_type=5;t.name="HG13";t.cs_name="HG1";t.base_name="HG1";atoms.push_back(t);
	t.carbon_name="CG2";
	t.proton_type=6;t.name="HG21";t.cs_name="HG2";t.base_name="HG2";atoms.push_back(t);
	t.proton_type=6;t.name="HG22";t.cs_name="HG2";t.base_name="HG2";atoms.push_back(t);
	t.proton_type=6;t.name="HG23";t.cs_name="HG2";t.base_name="HG2";atoms.push_back(t);

	get_address("H")->cs_coil=8.32;
	get_address("N")->cs_coil=121.8;
	get_address("CA")->cs_coil=61.4;
	get_address("HA")->cs_coil=4.30;
	get_address("CB")->cs_coil=32.8;
	get_address("C")->cs_coil=175.1;

		
	get_address("H")->cs_mean=8.28;
	get_address("N")->cs_mean=121.08;
	get_address("CA")->cs_mean=62.57;
	get_address("HA")->cs_mean=4.17;
	get_address("CB")->cs_mean=32.71;
	get_address("C")->cs_mean=175.68;

	get_address("H")->cs_wang=7.98;
	get_address("N")->cs_wang=119.91;
	get_address("CA")->cs_wang=62.00;
	get_address("HA")->cs_wang=4.13;
	get_address("CB")->cs_wang=32.35;
	get_address("C")->cs_wang=175.66;

	coil_pre[0]=2.77;
	coil_pre[1]=-0.00;
	coil_pre[2]=-0.16;
	coil_pre[3]=0.03;
	coil_pre[4]=0.17;
	coil_pre[5]=0.04;

	coil_fol[0]=-0.05;
	coil_fol[1]=-0.08;
	coil_fol[2]= 0.05;
	coil_fol[3]= 0.18;
	coil_fol[4]= 0.01;
	coil_fol[5]= 0.05;

}
CVal::~CVal() {}

//Missing residue
struct noeatoms CMiss::query(string name)
{
	struct noeatoms t;t.length=0.0;vector<int> tt;
	return t;
}

void CMiss::dihe(vector<dihe_group> * dihe_index)
{
	return;
}

void CMiss::process(vector<string> block)
{
	return;
}


CMiss::CMiss() 
{
    //CAminoacid::CAminoacid();
	resname="Missing";OneLetterName='X';strcpy(ThreeLetterName,"MIS");
	atoms.clear();
	order_parameters.clear();

	for(int i=0;i<6;i++)
	{
		coil_pre[i]=coil_fol[i]=0.0;
	}
}

CMiss::~CMiss() {}

// unknown residue

struct noeatoms CUnk::query(string name)
{
	struct noeatoms t;t.length=0.0;vector<int> tt;
	return t;
}


void CUnk::dihe(vector<dihe_group> * dihe_index)
{
	return;
}



void CUnk::process(vector<string> block)
{
	int i,j;
	int index;
	char c;
	string t;
	string atomname;
	string part;
	vector<string> subblock;
	struct Atom atom;

	for(i=0;i<(int)block.size();i++)
	{
		t=block[i];
		if(i==0)
		{
			head=t.substr(0,6);
			resname=t.substr(17,3);
		}
		atomname=t.substr(11,5);  //atom name here
		while((j=atomname.find(" ")) != string::npos)
		{
			atomname.replace(j, 1, "");
		}	
		part=t.substr(6,5); //atom index
		index=atoi(part.c_str());

		c=atomname.at(0);
		if(c>'0' && c<'9')  //if name started with number, move that number to the end
		{
			atomname.erase(0,1);
			atomname.append(1,c);
		}

		c=atomname.at(0);
		if(c=='H' && atomname.size()>1)  //started with H, but it is not HN
		{
			//do nothing for protons!
		}
		else  //heavy atoms or HN atom, just store them
		{
			atom.name=atomname;
			atom.cs_name=atomname;
			atom.base_name=atomname;
			atom.index=index;
			atom.bb=1;
			atom.proton=0;
			atom.cs_exp=atom.cs_pre=999.0;
		}
	}
	return;
}


CUnk::CUnk() 
{
    //CAminoacid::CAminoacid();
	resname="None";OneLetterName='X';strcpy(ThreeLetterName,"UNK");
	order_parameters.clear();

	struct Atom t;
	t.index=-1;t.cs_exp=999.0;t.cs_pre=999.0;t.x=-999.0;t.y=-999.0;t.z=-999.0;t.cs_coil=999.0;
	t.bb=0;
	t.proton=0;t.ambig=0;
	t.name="CB";t.cs_name="CB";t.base_name="CB";atoms.push_back(t);
	t.proton=1;
	t.carbon_name="CB";
	t.proton_type=1;t.name="HB1";t.cs_name="HB";t.base_name="HB";atoms.push_back(t);
	t.proton_type=1;t.name="HB2";t.cs_name="HB";t.base_name="HB";atoms.push_back(t);
	t.proton_type=1;t.name="HB3";t.cs_name="HB";t.base_name="HB";atoms.push_back(t);

	for(int i=0;i<6;i++)
	{
		coil_pre[i]=coil_fol[i]=0.0;
	}
}

CUnk::~CUnk() {}



//water or ligand as a fake residue


CLigand::CLigand() 
{
	atomindexs.clear();
	atomnames.clear();
	id=-1;
	resname="None";
}

CLigand::~CLigand() {}

void CLigand::process(vector<string> block)
{
	int i,j;
	int index;
	string t;
	string atomname;
	string part;
	vector<string> subblock;

	t=block.at(0);
	head=t.substr(0,6);
	resname=t.substr(17,3);

	original_residue=atoi(block.at(0).substr(22,4).c_str());
	
	for(i=0;i<(int)block.size();i++)
	{
		t=block[i];
		atomname=t.substr(11,5);  //atom name here
		while((j=atomname.find(" ")) != string::npos)
		{
			atomname.replace(j, 1, "");
		}
		part=t.substr(6,5); //atom index
		index=atoi(part.c_str());
		atomindexs.push_back(index);
		atomnames.push_back(atomname);
	}
	return;
}

void CLigand::heavycoor(vector<int> *t)
{
	t->insert(t->end(),atomindexs.begin(),atomindexs.end());
}


double CAminoacid::wishart[22][12]={
										{50.86,54.86,21.72,18.27,175.3,179.58,8.59,7.99,4.87,4.03,125.57,121.65},
										{54.63,59.05,32.36,30,175.04,178.11,8.57,8.03,4.85,4,122.6,118.99},
										{52.48,55.67,40.43,38.28,174.55,176.74,8.7,8.2,5.26,4.45,122.7,117.6},
										{53.4,57.04,42.78,40.5,175.15,178.07,8.56,8.05,5.01,4.44,123.82,119.9},
										{54.33,58.61,31.92,28.33,174.5,178.35,8.51,8.11,4.97,4.03,123.14,118.59},
										{55.55,59.3,32.45,29.2,175.01,178.46,8.66,8.32,4.76,3.99,123.52,119.89},
										{45.08,47.02,999,999,173.01,176.31,8.27,8.23,4.09,3.84,110.19,107.34},
										{54.8,59.62,32.2,29.91,173.8,176.83,8.76,8.03,5.07,4.06,121.65,118.09},
										{60,64.68,40.09,37.59,174.79,177.49,8.74,8.06,4.72,3.66,124.12,120.22},
										{53.94,57.54,44.02,41.4,175.16,178.42,8.63,8.02,4.85,4,125.69,120.18},
										{55.01,59.11,34.86,32.31,174.93,177.79,8.54,8.04,4.96,3.98,123.29,119.9},
										{54.1,58.45,34.34,31.7,174.64,177.76,8.43,8.05,4.94,4.03,121.67,118.69},
										{56.33,60.74,41.64,38.91,174.15,176.42,8.8,8.21,5.1,4.11,121.95,119.12},
										{62.79,65.52,32.45,31.08,176.41,178.34,999,999,4.72,4.13,999,999},
										{57.14,60.86,65.39,62.81,173.52,176.51,8.57,8.11,5.08,4.2,117.44,114.78},
										{61.1,65.89,70.82,68.64,173.47,176.62,8.5,8.1,4.81,4.02,118.09,115.3},
										{56.28,60.03,31.78,28.74,175.1,177.81,8.83,8.24,5.24,4.35,124.04,120.48},
										{56.56,61.07,40.79,38.38,174.65,177.05,8.69,8.1,5,4.14,122.55,119.67},
										{60.72,65.96,33.81,31.41,174.66,177.75,8.73,7.99,4.66,3.5,123.27,119.53},
										{57.64,62.86,29.48,26.99,173.86,177.42,9,8.22,5.18,4.16,123.27,117.4},
										{54.19,58.57,43.79,40.02,172.73,176.84,8.68,8.58,5.21,4.53,121.81,119.51},
										{999,999,999,999,999,999,999,999,999,999,999,999}
									};


double CAminoacid::wang_rc[21][6]={
{120.58, 175.52, 60.79, 38.43, 7.94, 4.18},
{119.91, 175.66, 62.00, 32.35, 7.98, 4.13},
{120.37, 176.00, 54.00, 40.78, 8.31, 4.62},
{118.50, 174.84, 53.00, 38.43, 8.35, 4.66},
{119.72, 175.46, 57.46, 39.41, 8.09, 4.59},
{118.92, 174.78, 55.74, 29.50, 8.18, 4.60},
{120.99, 175.87, 57.54, 29.60, 7.97, 4.60},
{119.37, 175.29, 57.64, 38.78, 7.99, 4.56},
{121.10, 176.15, 56.29, 32.53, 8.17, 4.28},
{121.57, 176.70, 54.77, 42.14, 8.06, 4.36},
{120.14, 175.94, 55.43, 32.92, 8.22, 4.47},
{119.82, 175.75, 55.89, 29.01, 8.20, 4.29},
{120.75, 176.01, 56.18, 30.36, 8.21, 4.26},
{120.62, 176.32, 56.66, 29.87, 8.36, 4.28},
{113.88, 174.78, 61.30, 68.92, 8.16, 4.44},
{118.10, 175.11, 58.24, 29.54, 8.10, 4.59},
{116.00, 174.41, 58.20, 63.75, 8.22, 4.45},
{123.82, 177.28, 52.46, 18.98, 8.09, 4.31},
{109.48, 174.01, 45.28, 0, 8.37, 3.97},
{0, 176.62, 63.24, 31.81, 0, 4.41},
{999,999,999,999,999,999}
};

double CAminoacid::wang_c1[21][6]={
{-2.21, 0.14, -0.01, -0.04, -0.07, -0.01},
{1.36, -0.00, 0.44, -0.18, 0.03, -0.00},
{-0.43, 0.07, 0.20, -0.07, -0.01, -0.03},
{-0.36, 0.04, 0.01, 0.04, -0.01, -0.01},
{0.20, -0.14, 0.02, -0.06, 0.01, -0.01},
{-0.43, -0.09, -0.26, 0.17, -0.10, 0.04},
{-0.05, -0.13, 0.16, 0.07, -0.01, -0.05},
{2.92, 0.11, -0.15, 0.26, 0.12, 0.04},
{-0.26, -0.09, -0.07, 0.08, -0.02, -0.00},
{-0.76, 0.13, -0.07, -0.03, -0.06, 0.00},
{0.69, 0.10, 0.09, 0.10, 0.05, 0.05},
{-0.76, -0.19, 0.18, -0.20, 0.01, -0.03},
{-0.94, 0.21, 0.07, -0.16, 0.14, -0.04},
{-0.09, 0.07, 0.13, 0.06, 0.01, -0.00},
{-0.45, -0.07, 0.00, 0.01, -0.03, 0.01},
{1.16, -0.10, 0.11, -0.06, 0.02, 0.01},
{1.23, -0.07, 0.05, -0.11, 0.02, -0.00},
{2.77, -0.00, -0.16, 0.03, 0.17, 0.04},
{0.97, -0.46, 0.00, 0.28, -0.08, -0.05},
{0.46, -0.03, -0.19, -0.10, 0.02, 0.01},
{0,0,0,0,0,0}
};

double CAminoacid::wang_c2[21][6]={
{-0.11, 0.05, 0.07, -0.09, -0.01, -0.03},
{-1.17, 0.10, 0.17, 0.21, 0.01, 0.03},
{0.23, -0.11, 0.28, 0.11, 0.04, -0.03},
{0.26, 0.14, 0.25, 0.06, 0.07, -0.04},
{-0.35, -0.22, -0.04, -0.09, -0.04, -0.02},
{0.13, 0.47, 0.12, -0.07, 0.06, -0.03},
{-0.09, -0.05, 0.22, -0.24, -0.01, -0.09},
{-0.20, -0.09, 0.03, 0.28, -0.01, 0.03},
{-0.13, -0.13, 0.08, 0.01, -0.04, -0.03},
{-0.49, 0.06, 0.10, -0.10, -0.07, -0.02},
{-0.02, 0.19, 0.22, 0.06, 0.01, -0.01},
{-0.03, -0.23, 0.24, -0.06, 0.04, -0.04},
{0.92, -1.19, -2.04, -0.20, -0.17, 0.21},
{-0.31, 0.10, 0.37, -0.13, 0.01, -0.05},
{-0.09, 0.16, 0.19, -0.12, -0.01, -0.02},
{0.30, 0.10, 0.10, 0.14, 0.07, 0.02},
{0.22, 0.10, 0.02, 0.14, 0.04, 0.08},
{-0.05, -0.08, 0.05, 0.18, 0.01, 0.05},
{-0.59, -0.33, -0.06, -0.03, -0.10, -0.03},
{-0.48, -0.51, 0.10, 0.00, -0.07, -0.06},
{0,0,0,0,0,0}
};

########## NEXT FILE ##########
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <math.h>
#include <time.h>

using namespace std;


#include "pdb.h"

#include "debug.h"

int CDssp::loaddata(string name)
{
	char buffer[255];
	bool begin;
	struct dsspline aadssp;
	string line;

	sprintf(buffer,"dssp %s > dssp.out",name.c_str());
	system(buffer); 

	ifstream fin("dssp.out");
	if (!fin.is_open())
		return 1;

	
	begin=0;
	while(getline(fin,line))
	{
		if(line.find("RESIDUE AA")!=std::string::npos)
		{
			begin=1;
			continue;
		}
		if(begin==1)
		{
			aadssp.id=atoi(line.substr(5,5).c_str());
			aadssp.code=line[13];
			aadssp.ss=line[16];
			data.push_back(aadssp);
		}
	}
	return 0;
}

string CDssp::getseq()
{
	int i;
	string s;

	for(i=0;i<(int)data.size();i++)
		s.push_back(data.at(i).code);
	return s;
}

CDssp::CDssp()
{}
CDssp::~CDssp()
{}

//////////////////////////
// class CPdb           //
//////////////////////////

void CPdb::process_ambig(int flag)
{
	//meaning of flag:
	// 1. remove any ambig assignment
	// 2. combine all hb2, hb3 into mean value, if code is 1 or 2, otherwise remove ambig
	int i;
	if(flag==1)
	{
		for(i=0;i<(int)v.size();i++)
		{
			v.at(i)->remove_ambig(flag);
		}
	}
	
	//not really needed ??? if take mean in function get all proton
	if(flag==2)
	{
		for(i=0;i<(int)v.size();i++)
		{
			v.at(i)->methyl_ambig(flag);
			//v.at(i)->combine_hsamec(flag);
		}
	}

	if(flag==3)
	{
		//remove methyl ambig==2 case
	}
}


void CPdb::clear()
{
	unsigned int i;
	for(i=0;i<(int)v.size();i++)
	{
		delete v.at(i);
	}
	v.clear();
	for(i=0;i<(int)ligand.size();i++)
	{
		delete ligand.at(i);
	}
	ligand.clear();
	chains.clear();
	chain_block.clear();
	chain_ligand.clear();
	blocks.clear();
	pdbseq.clear();
}

void CPdb::print_print(FILE *fp,vector<int> att1, vector<int> att2,int index,int type,double a,double b,double c,double w)
{
	int i,j;

	for(i=0;i<att1.size();i++)
	for(j=0;j<att2.size();j++)
	{	
		fprintf(fp,"%10d%10d%10d%10d%10d",att1.at(i),att2.at(j),1,index,type);
		fprintf(fp,"%10.4f%10.4f%10.4f%10.4f\n",a/10,b/10,c/10,w);  //unit is nm instead of A in Gromacs!
	}
	return;
}

void CPdb::print_gromacs(string filename,vector <struct diheline> *dihecons)
{
	FILE *fp;
	struct noeline tline;
	int i,j;

	fp=fopen(filename.c_str(),"wt");
	fprintf(fp,"[dihedral_restraints]\n");
	for(i=0;i<dihecons->size();i++)
	{
		for(j=0;j<4;j++) fprintf(fp,"%d ",dihecons->at(i).index[j].atoms.at(0).at(0));
		fprintf(fp," 1 1 ");
		fprintf(fp,"%8.3f%8.3f",(float)dihecons->at(i).middle,(float)dihecons->at(i).delta);
		fprintf(fp," 1 2\n");
	}
	fclose(fp);
	return;
}



void CPdb::print_gromacs(string filename,vector <struct noeline> *nmrcons)
{
	FILE *fp;
	struct noeline tline;
	int i,j,index;
	int n1,n2;
	double length1,length2;
	vector<int> att1,att2;
	string filename2;

	vector<int> nshort;
	vector<int> nlong;
	vector< vector<int> > whos;
	vector< vector<int> > pairs;
	vector< vector<int> > used;
	vector< vector<double> > weights;

	nshort.resize(v.size());
	nlong.resize(v.size());
	whos.resize(v.size());
	pairs.resize(v.size());
	weights.resize(v.size());
	used.resize(v.size());
	for(i=0;i<v.size();i++)
		used.at(i).resize(v.size(),0);


	for(i=0;i<pairs.size();i++)
	{
		pairs.at(i).resize(v.size());
		weights.at(i).resize(v.size());
	}

	for(i=0;i<nmrcons->size();i++)
	{
		if(fabs((float)(nmrcons->at(i).resid1-nmrcons->at(i).resid2))<=4)
		{
			nshort.at(nmrcons->at(i).resid1-1)++;
			nshort.at(nmrcons->at(i).resid2-1)++;
		}
		else
		{
			nlong.at(nmrcons->at(i).resid1-1)++;
			nlong.at(nmrcons->at(i).resid2-1)++;
			whos.at(nmrcons->at(i).resid1-1).push_back(nmrcons->at(i).resid2);
			whos.at(nmrcons->at(i).resid2-1).push_back(nmrcons->at(i).resid1);
			pairs.at(nmrcons->at(i).resid1-1).at(nmrcons->at(i).resid2-1)++;
			pairs.at(nmrcons->at(i).resid2-1).at(nmrcons->at(i).resid1-1)++;
		}

	}

	fp=fopen("cons_detail.dat","wt");
	for(i=0;i<v.size();i++)
	{
		fprintf(fp,"%d %d %d\n",i+1,nshort.at(i),nlong.at(i));
	}
	fclose(fp);

	fp=fopen("cons_whos.dat","wt");
	for(i=0;i<whos.size();i++)
	{
		fprintf(fp,"%d",i+1);
		for(j=0;j<whos.at(i).size();j++)
			fprintf(fp," %d",whos.at(i).at(j));
		fprintf(fp,"\n");
	}
	fclose(fp);


	int b1,b2,s1,s2,k1,k2;
	double c;
	for(i=0;i<v.size();i++)
	{
		for(j=0;j<v.size();j++)
		{
			weights.at(i).at(j)=1;
			if(pairs.at(i).at(j)>0)
				weights.at(i).at(j)=1.0/pairs.at(i).at(j);
			c=0;
			b1=-1; if(i==0) b1=0;
			b2=-1; if(j==0) b2=0;
			s1=1; if(i==v.size()-1) s1=0;
			s2=1; if(j==v.size()-1) s2=0;
			for(k1=i+b1;k1<=i+s1;k1++)
			for(k2=j+b2;k2<=j+s2;k2++)
				c+=pairs.at(k1).at(k2);
			c-=pairs.at(i).at(j);
			if(c>0) weights.at(i).at(j)/=sqrt(c);
		}
	}


	index=-1;
	fp=fopen(filename.c_str(),"wt");
	fprintf(fp,"[distance_restraints]\n");
	fprintf(fp,"; all long range noe distance restraints\n");
	for(i=0;i<nmrcons->size();i++)
	{
		if(fabs((float)(nmrcons->at(i).resid1-nmrcons->at(i).resid2))<=4)
			continue;
		tline=nmrcons->at(i);
		length1=0;
		length2=0;

		for(n1=0;n1<(int)nmrcons->at(i).index1.atoms.size();n1++)
		{
			length1=nmrcons->at(i).index1.length;
			for(n2=0;n2<(int)nmrcons->at(i).index2.atoms.size();n2++)
			{
				index++;
				length2=nmrcons->at(i).index1.length;
				att1=nmrcons->at(i).index1.atoms.at(n1);
				att2=nmrcons->at(i).index2.atoms.at(n2);
				print_print(fp,att1,att2,index,1,0,nmrcons->at(i).a+length1+length2,nmrcons->at(i).a+2+length1+length2,weights.at(tline.resid1-1).at(tline.resid2-1));
			}
		}
	}
	fclose(fp);

	fp=fopen("cns_distance.tbl","wt");
	for(i=0;i<nmrcons->size();i++)
	{
		if(nmrcons->at(i).bvio==1)
			continue;
		if(fabs((float)(nmrcons->at(i).resid1-nmrcons->at(i).resid2))<=4)
		{
			tline=nmrcons->at(i);
			fprintf(fp,"assign (resid %d and name %s ) (resid %d and name %s ) %f %f %f\n",
				tline.oldresid1,tline.oldatomname1.c_str(),tline.oldresid2,tline.oldatomname2.c_str(),
				(float)tline.b,(float)tline.c,(float)tline.a);
		}
		else
		{
			tline=nmrcons->at(i);
			if(used.at(tline.resid1-1).at(tline.resid2-1)==0)
			{
				fprintf(fp,"assign (resid %d and name %s ) (resid %d and name %s ) %f %f %f\n",
					tline.oldresid1,tline.oldatomname1.c_str(),tline.oldresid2,tline.oldatomname2.c_str(),
					(float)tline.b,(float)tline.c,(float)tline.a);
				used.at(tline.resid1-1).at(tline.resid2-1)++;
				used.at(tline.resid2-1).at(tline.resid1-1)++;
			}
		}
	}
	fclose(fp);


	index=-1;
	filename2=filename;
	filename2.insert(filename2.find("."),"2");
	fp=fopen(filename2.c_str(),"wt");
	fprintf(fp,"[distance_restraints]\n");
	fprintf(fp,"; vilated noe distance restraints\n");
	for(i=0;i<nmrcons->size();i++)
	{
		if(nmrcons->at(i).bvio==0)
			continue;
		tline=nmrcons->at(i);
		length1=0;
		length2=0;

		for(n1=0;n1<(int)nmrcons->at(i).index1.atoms.size();n1++)
		{
			length1=nmrcons->at(i).index1.length;
			for(n2=0;n2<(int)nmrcons->at(i).index2.atoms.size();n2++)
			{
				index++;
				length2=nmrcons->at(i).index1.length;
				att1=nmrcons->at(i).index1.atoms.at(n1);
				att2=nmrcons->at(i).index2.atoms.at(n2);
				print_print(fp,att1,att2,index,1,0,nmrcons->at(i).a+length1+length2,nmrcons->at(i).a+2+length1+length2,1.0);
			}
		}
	}
	fclose(fp);


	index=-1;
	filename2=filename;
	filename2.insert(filename2.find("."),"3");
	fp=fopen(filename2.c_str(),"wt");
	fprintf(fp,"[distance_restraints]\n");
	fprintf(fp,"; fullfiled noe distance restraints\n");
	for(i=0;i<nmrcons->size();i++)
	{
		if(nmrcons->at(i).bvio==1)
			continue;
		tline=nmrcons->at(i);
		length1=0;
		length2=0;

		for(n1=0;n1<(int)nmrcons->at(i).index1.atoms.size();n1++)
		{
			length1=nmrcons->at(i).index1.length;
			for(n2=0;n2<(int)nmrcons->at(i).index2.atoms.size();n2++)
			{
				index++;
				length2=nmrcons->at(i).index1.length;
				att1=nmrcons->at(i).index1.atoms.at(n1);
				att2=nmrcons->at(i).index2.atoms.at(n2);
				print_print(fp,att1,att2,index,1,0,nmrcons->at(i).a+length1+length2,nmrcons->at(i).a+2+length1+length2,1.0);
			}
		}
	}
	fclose(fp);


	index=-1;
	filename2=filename;
	filename2.insert(filename2.find("."),"4");
	fp=fopen(filename2.c_str(),"wt");
	fprintf(fp,"[distance_restraints]\n");
	fprintf(fp,"; all noe distance restraints\n");
	for(i=0;i<nmrcons->size();i++)
	{
		tline=nmrcons->at(i);
		length1=0;
		length2=0;

		for(n1=0;n1<(int)nmrcons->at(i).index1.atoms.size();n1++)
		{
			length1=nmrcons->at(i).index1.length;
			for(n2=0;n2<(int)nmrcons->at(i).index2.atoms.size();n2++)
			{
				index++;
				length2=nmrcons->at(i).index1.length;
				att1=nmrcons->at(i).index1.atoms.at(n1);
				att2=nmrcons->at(i).index2.atoms.at(n2);
				print_print(fp,att1,att2,index,1,0,nmrcons->at(i).a+length1+length2,nmrcons->at(i).a+2+length1+length2,1.0);
			}
		}
	}
	fclose(fp);

	return;
}


int CPdb::loadnoedata(string filename,string filename2,vector <struct noeline> *nmrcons)
{
	string nmrseq;
	int adj,adj2;
	vector<int> out;
	char c1,c2;
	ifstream fin(filename.c_str());
	ifstream fin2(filename2.c_str());
	istringstream iss;
	string line,p;
	string resname1,atomname1,resname2,atomname2,resname,atomname;
	int resid1,resid2,order,resid;
	double a,b,c;
	int i;
	struct noeline tline;
	bool bfirst;
	int index,index_old;
	int norder1,norder2;

	i=0;
	bfirst=1;
	while(getline(fin,line))
	{
		i++;
		iss.clear();
		iss.str(line);
		iss>>index;
		iss>>p>>order>>p>>p;
		iss>>resid;
		iss>>resname;
		iss>>atomname;
		iss>>p>>p>>p>>p>>p>>p;

		if(bfirst)
		{
			bfirst=0;
			resid1=resid2=-1;
			index_old=index;
			norder1=norder2=0;
		}

		if(index>index_old) //we now reach a new entry
		{
			tline.id=index_old;
			tline.resid1=resid1;
			tline.resid2=resid2;
			tline.resname1=resname1;
			tline.resname2=resname2;
			tline.atomname1=atomname1;
			tline.atomname2=atomname2;
			tline.multi=0;
			if(norder1>1 || norder2>1)
				tline.multi=1;
			nmrcons->push_back(tline);

			resid1=resid2=-1;
			index_old=index;
			norder1=norder2=0;
		}

		if(order==1)
		{
			norder1++;
			resid1=resid;
			resname1=resname;
			atomname1=atomname;
		}
		else if(order==2)
		{
			norder2++;
			resid2=resid;
			resname2=resname;
			atomname2=atomname;
		}
		else
		{
			cout<<"Unsupported order "<<order<<endl;
			break;
		}
	}

	//process the final entry.
	if(resid1>0 && resid2>0)
	{
		tline.id=index_old;
		tline.resid1=resid1;
		tline.resid2=resid2;
		tline.resname1=resname1;
		tline.resname2=resname2;
		tline.atomname1=atomname1;
		tline.atomname2=atomname2;
		nmrcons->push_back(tline);
	}


	i=0;
	while(getline(fin2,line))
	{
		iss.clear();
		iss.str(line);
		iss>>index;
		if(index!=nmrcons->at(i).id)
		{
			cout<<"readin noe data error. index is NOT as expected in second part"<<endl;
			break;
		}
		iss>>p>>p>>p>>p>>p>>p;
		iss>>b>>c>>a;
		iss>>p>>p;
		nmrcons->at(i).a=a;
		nmrcons->at(i).b=b;
		nmrcons->at(i).c=c;


		c1=Sequence::name2code(nmrcons->at(i).resname1);
		c2=Sequence::name2code(nmrcons->at(i).resname2);
		nmrcons->at(i).resid1--;
		nmrcons->at(i).resid2--;
		if(nmrcons->at(i).resid1+1>nmrseq.size())
			nmrseq.resize(nmrcons->at(i).resid1+1,'U');
		nmrseq.at(nmrcons->at(i).resid1)=c1;
		if(nmrcons->at(i).resid2+1>nmrseq.size())
			nmrseq.resize(nmrcons->at(i).resid2+1,'U');
		nmrseq.at(nmrcons->at(i).resid2)=c2;

		i++;
	}

	out=Sequence::align(pdbseq,nmrseq);
	adj=0;adj2=0;
	for(i=0;i<out.size();i++)
	{
		if(out.at(i)!=0)
		{
			adj+=(out.at(i)-i);
			adj2++;
		}
	}
	adj/=adj2;


	//remove entry with multiply atoms
	for(i=nmrcons->size()-1;i>=0;i--)
	{
		nmrcons->at(i).resid1++;
		nmrcons->at(i).resid2++;
		if(nmrcons->at(i).multi==1)
		{
			cout<<"Remove noe entry with umbigirious assignment. "<<nmrcons->at(i).id<<endl;
			nmrcons->erase(nmrcons->begin()+i);
		}
	}


	for(i=0;i<nmrcons->size();i++)
	{
		nmrcons->at(i).index1.length=0.0;
		nmrcons->at(i).index2.length=0.0;
		nmrcons->at(i).resid1-=adj;
		nmrcons->at(i).resid2-=adj;

		if(nmrcons->at(i).resid1>=1 && nmrcons->at(i).resid2>=1 && nmrcons->at(i).resid1<=(int)v.size() && nmrcons->at(i).resid2<=(int)v.size() )
		{
			nmrcons->at(i).index1=v.at(nmrcons->at(i).resid1-1)->query(nmrcons->at(i).atomname1);
			nmrcons->at(i).index2=v.at(nmrcons->at(i).resid2-1)->query(nmrcons->at(i).atomname2);
		}
		else
		{
			nmrcons->erase(nmrcons->begin()+i);
			i--;
		}
	}
	return adj;

}




int CPdb::loadnoedata(string filename,vector <struct noeline> *nmrcons)
{

	ifstream fin(filename.c_str());
	string line;
	vector<string> block1, block2;
	bool bstart,inloop,begin1,begin2;

	bstart=0;
	inloop=0;
	begin1=0;
	begin2=0;

	while(getline(fin,line))
	{
		if(line.size()<4)
			continue;

		if(begin2==1 &&  line.find("stop_")!=string::npos)
			bstart=begin2=0;
		if(begin1==1 &&  line.find("stop_")!=string::npos)
			begin1=0;


		if(begin1==1)
			block1.push_back(line);
		if(begin2==1)
			block2.push_back(line);

		if(line.find("loop_")!=string::npos)
			inloop=1;
		if(line.find("stop_")!=string::npos)
			inloop=0;

		if(inloop==0 && ( line.find("save_CNS/XPLOR_distance_constraints")!=string::npos || line.find("save_DYANA/DIANA_distance_constraints")!=string::npos) )
		{
			getline(fin,line);
			getline(fin,line);
			getline(fin,line);
			getline(fin,line);
			
			if(line.find("_Distance_constraint_list.Constraint_type")!=string::npos)
			{
				if( line.find("NOE")!=string::npos )
					bstart=1;
			}
			getline(fin,line);
			getline(fin,line);
		}

		if(bstart==1 && inloop==1 && line.find("_Dist_constraint.Distance_constraint_list_ID")!=string::npos)
			begin1=1;
		if(bstart==1 && inloop==1 && line.find("_Dist_constraint_value.Distance_constraint_list_ID")!=string::npos)
			begin2=1;
	}

	return actualload(&block1,&block2,nmrcons);
}
      



 
int CPdb::actualload(vector<string> *b1, vector<string> *b2, vector <struct noeline> *nmrcons)
{
	string nmrseq;
	int adj,adj2;
	vector<int> out;
	char c1,c2;
	istringstream iss;
	string line,p;
	string resname1,atomname1,resname2,atomname2,resname,atomname;
	string oldatomname,oldatomname1,oldatomname2;
	int resid1,resid2,order,resid,oldresid,oldresid1,oldresid2;
	double a,b,c;
	int i,ii,iii;
	struct noeline tline;
	bool bfirst;
	int index,index_old;
	int norder1,norder2;


	bfirst=1;
	for(i=0;i<b1->size();i++)
	{
		
		iss.clear();
		iss.str(b1->at(i));
		iss>>index;
		iss>>p>>order>>p>>p;
		iss>>resid;
		iss>>resname;
		iss>>atomname;
		iss>>p>>oldresid>>p>>oldatomname>>p>>p;

		if(bfirst)
		{
			bfirst=0;
			resid1=resid2=-1;
			index_old=index;
			norder1=norder2=0;
		}

		if(index>index_old) //we now reach a new entry
		{
			tline.id=index_old;
			tline.resid1=resid1;
			tline.resid2=resid2;
			tline.resname1=resname1;
			tline.resname2=resname2;
			tline.atomname1=atomname1;
			tline.atomname2=atomname2;
			tline.oldresid1=oldresid1;
			tline.oldresid2=oldresid2;
			tline.oldatomname1=oldatomname1;
			tline.oldatomname2=oldatomname2;
			tline.multi=0;
			if(norder1>1 || norder2>1)
				tline.multi=1;
			nmrcons->push_back(tline);

			resid1=resid2=-1;
			index_old=index;
			norder1=norder2=0;
		}

		if(order==1)
		{
			norder1++;
			resid1=resid;
			resname1=resname;
			atomname1=atomname;
			oldresid1=oldresid;
			oldatomname1=oldatomname;
		}
		else if(order==2)
		{
			norder2++;
			resid2=resid;
			resname2=resname;
			atomname2=atomname;
			oldresid2=oldresid;
			oldatomname2=oldatomname;
		}
		else
		{
			cout<<"Unsupported order "<<order<<endl;
			break;
		}
	}

	//process the final entry.
	if(resid1>0 && resid2>0)
	{
		tline.id=index_old;
		tline.resid1=resid1;
		tline.resid2=resid2;
		tline.resname1=resname1;
		tline.resname2=resname2;
		tline.atomname1=atomname1;
		tline.atomname2=atomname2;
		nmrcons->push_back(tline);
		tline.oldresid1=oldresid1;
		tline.oldresid2=oldresid2;
		tline.oldatomname1=oldatomname1;
		tline.oldatomname2=oldatomname2;
	}


	cout<<"fillin sequence of NOE"<<endl;
	for(i=0;i<b2->size();i++)
	{
		//cout<<"i is "<<i<<" and b2's size is "<<b2->size()<<" and b1's size is "<<b1->size()<<" and nmrcons's size is "<<nmrcons->size()<<endl;
		iss.clear();
		iss.str(b2->at(i));
		iss>>index;

		iss>>p;
		iss>>p;
		iss>>p;
		iss>>p;
		iss>>p;
		iss>>p;
		iss>>p; b=atof(p.c_str());
		iss>>p; c=atof(p.c_str());
		iss>>p; a=atof(p.c_str());
		iss>>p;
		iss>>p;
		iii=-1;
		for(ii=0;ii<nmrcons->size();ii++)
		{
			if(index==nmrcons->at(ii).id)
				iii=ii;
		}

		// not found!
		if(iii<0)
			break;

		nmrcons->at(iii).a=a;
		nmrcons->at(iii).b=b;
		nmrcons->at(iii).c=c;
	}

	for(i=0;i<nmrcons->size();i++)
	{
		c1=Sequence::name2code(nmrcons->at(i).resname1);
		c2=Sequence::name2code(nmrcons->at(i).resname2);

		if(nmrcons->at(i).resid1>nmrseq.size())
		{
			nmrseq.resize(nmrcons->at(i).resid1,'U');
			//cout<<"resize nmrseq to "<<nmrcons->at(i).resid1+1<<endl;
		}
		//cout<<nmrcons->at(i).resid1<<" is filled with "<<c1<<"size of nmrseq is "<<nmrseq.size()<<endl;
		//cout.flush();
		nmrseq.at(nmrcons->at(i).resid1-1)=c1;
		//cout<<"done1"<<endl;
		if(nmrcons->at(i).resid2>nmrseq.size())
		{
			nmrseq.resize(nmrcons->at(i).resid2,'U');
			//cout<<"resize nmrseq to "<<nmrcons->at(i).resid2+1<<endl;
		}
		//cout<<nmrcons->at(i).resid2<<" is filled with "<<c2<<"size of nmrseq is "<<nmrseq.size()<<endl;
		//cout.flush();
		nmrseq.at(nmrcons->at(i).resid2-1)=c2;
		//cout<<"done2"<<endl;
	}

	//cout<<"just before alighment"<<endl;
	out=Sequence::align(pdbseq,nmrseq);
	adj=0;adj2=0;
	for(i=out.size()/10;i<out.size()-out.size()/10;i++)
	{
		if(out.at(i)!=0)
		{
			adj+=(out.at(i)-i);
			adj2++;
		}
	}
	adj/=adj2;
	//cout<<"Alignment of NOE data is "<<adj<<endl;


	//remove entry with multiply atoms
	for(i=nmrcons->size()-1;i>=0;i--)
	{
		if(nmrcons->at(i).multi==1)
		{
			cout<<"Remove noe entry with umbigirious assignment. "<<nmrcons->at(i).id<<endl;
			nmrcons->erase(nmrcons->begin()+i);
		}
	}


	for(i=0;i<nmrcons->size();i++)
	{
        nmrcons->at(i).group=1;
		nmrcons->at(i).index1.length=0.0;
		nmrcons->at(i).index2.length=0.0;
		nmrcons->at(i).resid1-=adj;
		nmrcons->at(i).resid2-=adj;

		if(nmrcons->at(i).resid1>=1 && nmrcons->at(i).resid2>=1 && nmrcons->at(i).resid1<=(int)v.size() && nmrcons->at(i).resid2<=(int)v.size() )
		{
			nmrcons->at(i).index1=v.at(nmrcons->at(i).resid1-1)->query(nmrcons->at(i).atomname1);
			nmrcons->at(i).index2=v.at(nmrcons->at(i).resid2-1)->query(nmrcons->at(i).atomname2);
		}
		else
		{
			nmrcons->erase(nmrcons->begin()+i);
			i--;
		}
	}
	return adj;

}

void CPdb::outputnoe(string filename, vector <struct noeline> * nmrcons)
{
	int i;
	ofstream fout;

	fout.open(filename.c_str());

	for(i=0;i<nmrcons->size();i++)
	{
		fout<<nmrcons->at(i).group<<" ";
		fout<<nmrcons->at(i).resid1<<" ";
		fout<<nmrcons->at(i).resname1<<" ";
		fout<<nmrcons->at(i).atomname1<<" ";
		fout<<nmrcons->at(i).resid2<<" ";
		fout<<nmrcons->at(i).resname2<<" ";
		fout<<nmrcons->at(i).atomname2<<" ";
		fout<<nmrcons->at(i).b<<" ";
		fout<<nmrcons->at(i).c<<" ";
		fout<<nmrcons->at(i).a;
		fout<<endl;
	}
	fout.close();

	return;
}

void CPdb::inputnoe(string filename, vector <struct noeline> * nmrcons)
{
	int i;
	ifstream fin;
	struct noeline noe;
	string line,p;
	vector<string> ps;

	fin.open(filename.c_str());

	istringstream iss;

	i=0;
	while(getline(fin,line))
	{
		iss.clear();
		iss.str(line);
		ps.clear();
		
		while(iss>>p)
		{
			ps.push_back(p);
		}

		if(ps.size()>10)
		{
			noe.group=atoi(ps.at(0).c_str());
			noe.id=i++;
			noe.multi=0;
			noe.resid1=atoi(ps.at(2).c_str());
			noe.resname1=ps.at(3);
			noe.atomname1=ps.at(4);
			noe.resid2=atoi(ps.at(5).c_str());
			noe.resname2=ps.at(6);
			noe.atomname2=ps.at(7);
			noe.b=atof(ps.at(8).c_str());
			noe.c=atof(ps.at(9).c_str());
			noe.a=atof(ps.at(10).c_str());
			nmrcons->push_back(noe);
		}
	}
	fin.close();


	for(i=0;i<nmrcons->size();i++)
	{
		nmrcons->at(i).index1.length=0.0;
		nmrcons->at(i).index2.length=0.0;
		if(nmrcons->at(i).resid1>=1 && nmrcons->at(i).resid2>=1 && nmrcons->at(i).resid1<=(int)v.size() && nmrcons->at(i).resid2<=(int)v.size() )
		{
			nmrcons->at(i).index1=v.at(nmrcons->at(i).resid1-1)->query(nmrcons->at(i).atomname1);
			nmrcons->at(i).index2=v.at(nmrcons->at(i).resid2-1)->query(nmrcons->at(i).atomname2);
		}
	}

	return;
}




int CPdb::load_exactnoe(string filename,vector <struct noeline> *nmrcons)
{
	ifstream fin(filename.c_str());
	string line,p;
	istringstream iss;
	struct noeline tline;
	string nmrseq;
	char c1,c2;
	int i;

	i=0;
	while(getline(fin,line))
	{
		i++;
		tline.id=i;
		iss.clear();
		iss.str(line);
		iss>>tline.resid1>>tline.resname1>>tline.atomname1;
		iss>>tline.resid2>>tline.resname2>>tline.atomname2;
		iss>>tline.a>>tline.c;
		nmrcons->push_back(tline);
	}

	for(i=0;i<nmrcons->size();i++)
	{
		c1=Sequence::name2code(nmrcons->at(i).resname1);
		c2=Sequence::name2code(nmrcons->at(i).resname2);
		if(nmrcons->at(i).resid1>=nmrseq.size())
		{
			nmrseq.resize(nmrcons->at(i).resid1+1,'U');
		}
		nmrseq.at(nmrcons->at(i).resid1)=c1;
		if(nmrcons->at(i).resid2>=nmrseq.size())
		{
			nmrseq.resize(nmrcons->at(i).resid2+1,'U');
		}
		nmrseq.at(nmrcons->at(i).resid2)=c2;
	}

	int adj,adj2;
	string out1,out2,out3;
	vector<int> out=Sequence::aligno(pdbseq,nmrseq,out1,out2,out3);
	adj=0;adj2=0;
	for(i=out.size()/10;i<out.size()-out.size()/10;i++)
	{
		if(out.at(i)!=0)
		{
			adj+=(out.at(i)-i);
			adj2++;
		}
	}
	adj/=adj2;
	cout<<out1<<endl;
	cout<<out2<<endl;
	cout<<out3<<endl;



	for(i=0;i<nmrcons->size();i++)
	{
		nmrcons->at(i).index1.length=0.0;
		nmrcons->at(i).index2.length=0.0;
		nmrcons->at(i).resid1-=adj;nmrcons->at(i).resid1++;
		nmrcons->at(i).resid2-=adj;nmrcons->at(i).resid2++;

		if(nmrcons->at(i).resid1>=1 && nmrcons->at(i).resid2>=1 && nmrcons->at(i).resid1<=(int)v.size() && nmrcons->at(i).resid2<=(int)v.size() )
		{
			nmrcons->at(i).index1=v.at(nmrcons->at(i).resid1-1)->query(nmrcons->at(i).atomname1);
			nmrcons->at(i).index2=v.at(nmrcons->at(i).resid2-1)->query(nmrcons->at(i).atomname2);
		}
		else
		{
			nmrcons->erase(nmrcons->begin()+i);
			i--;
		}
	}

	return 0;
}





int CPdb::loaddihecons(string filename,vector<struct diheline> *dihes)		
{
	ifstream fin(filename.c_str());
	string line;
	vector<string> block;
	bool bstart,inloop,begin;


	bstart=0;
	inloop=0;
	begin=0;

	block.clear();
	while(getline(fin,line))
	{
		if(line.size()<4)
			continue;

		if(begin==1 &&  line.find("stop_")!=string::npos)
		{
			bstart=begin=0;
			dihecons_actualload(&block,dihes);
			block.clear();
		}

		if(begin==1)
			block.push_back(line);


		if(line.find("loop_")!=string::npos)
			inloop=1;
		if(line.find("stop_")!=string::npos)
			inloop=0;

		if(inloop==0 && line.find("save_CNS/XPLOR_dihedral")!=string::npos)
			bstart=1;

		if(bstart==1 && inloop==1 && line.find("_Torsion_angle_constraint.Torsion_angle_constraint_list_ID")!=string::npos)
			begin=1;
	}

	if(block.size()>0) 
	{
		dihecons_actualload(&block,dihes);
		block.clear();
	}
	return 0;
}


int CPdb::dihecons_actualload(vector<string>* block,vector<struct diheline> *dihes)
{
	istringstream iss;
	string p;
	int i,j,m;
	string nmrseq;
	vector<int> out;
	char c1,c2;
	int adj,adj2;
	bool bremove;

	dihes->resize(block->size());
	for(i=0;i<block->size();i++)
	{
		iss.clear();
		iss.str(block->at(i));
		iss>>dihes->at(i).id;
		iss>>p;
		for(j=0;j<4;j++)
		{
			iss>>p>>p;
			iss>>m;dihes->at(i).resid.push_back(m);
			iss>>p;dihes->at(i).resname.push_back(p);
			iss>>p;dihes->at(i).atomname.push_back(p);
		}
		iss>>dihes->at(i).upper>>dihes->at(i).lower;
		dihes->at(i).middle=(dihes->at(i).lower+dihes->at(i).upper)/2.0;
		dihes->at(i).delta=fabs(dihes->at(i).upper-dihes->at(i).lower)/2.0;

		c1=Sequence::name2code(dihes->at(i).resname[0]);
		c2=Sequence::name2code(dihes->at(i).resname[3]);
		for(j=0;j<4;j++)	dihes->at(i).resid[j]--;
		if(dihes->at(i).resid[0]+1>nmrseq.size())
			nmrseq.resize(dihes->at(i).resid[0]+1,'U');
		nmrseq.at(dihes->at(i).resid[0])=c1;
		if(dihes->at(i).resid[3]+1>nmrseq.size())
			nmrseq.resize(dihes->at(i).resid[3]+1,'U');
		nmrseq.at(dihes->at(i).resid[3])=c2;
	}

	out=Sequence::align(pdbseq,nmrseq);
	adj=0;adj2=0;
	for(i=0;i<out.size();i++)
	{
		if(out.at(i)!=0)
		{
			adj+=(out.at(i)-i);
			adj2++;
		}
	}
	adj/=adj2;

	for(i=dihes->size()-1;i>=0;i--)
	{
		bremove=0;
		for(j=0;j<4;j++)
		{
			dihes->at(i).resid[j]++;
			dihes->at(i).resid[j]-=adj;
			if(dihes->at(i).resid[j]<1 || dihes->at(i).resid[j]>v.size())
				bremove=1;
		}
		if(bremove)
		{
			cerr<<"Remove dihes cons ID "<<dihes->at(i).id<<" because it is out-of-bound"<<endl;
			dihes->erase(dihes->begin()+i);
		}
	}




	for(i=0;i<dihes->size();i++)
	{
		dihes->at(i).index.resize(4);
		for(j=0;j<4;j++)
			dihes->at(i).index[j]=v.at(dihes->at(i).resid[j]-1)->query(dihes->at(i).atomname[j]);
	}
	return 0;
}

int CPdb::buildpdb(string seq)
{	
	string residue;
	CAminoacid *t;
	int nres;
	int i;

	for(i=0;i<seq.size();i++)
	{
		residue=Sequence::code2name(seq.at(i));
		t=NULL;
		if(residue=="ALA")	t=new CAla;
		else if(residue=="ARG")	t=new CArg;
		else if(residue=="ASN")	t=new CAsn;
		else if(residue=="ASP")	t=new CAsp;
		else if(residue=="GLN")	t=new CGln;
		else if(residue=="GLU")	t=new CGlu;
		else if(residue=="GLY")	t=new CGly;
		else if(residue=="HIS")	t=new CHis;
		else if(residue=="HID")	t=new CHis;
		else if(residue=="HIE")	t=new CHis;
		else if(residue=="ILE")	t=new CIle;
		else if(residue=="LEU") t=new CLeu;
		else if(residue=="LYS")	t=new CLys;
		else if(residue=="LYP")	t=new CLys;
		else if(residue=="MET")	t=new CMet;
		else if(residue=="PHE")	t=new CPhe;
		else if(residue=="PRO")	t=new CPro;
		else if(residue=="SER")	t=new CSer;
		else if(residue=="THR")	t=new CThr;
		else if(residue=="TYR")	t=new CTyr;
		else if(residue=="VAL")	t=new CVal;
		else if(residue=="TRP")	t=new CTrp;
		else if(residue=="CYS")	t=new CCys;
		else if(residue=="CYN")	t=new CCys;
		else if(residue=="CYX")	t=new CCyx;
		else if(residue=="UNK")	t=new CUnk;
		else t=new CUnk;

		t->setresidue(i+1);

		v.push_back(t);
	}

	nres=v.size();
	natom=0;
	natom2=0;
	chains.push_back(v.size());

	return natom;
}

void CPdb::setup(CAminoacid *t, CLigand *tt, int iligand, string residue , int index_old,vector<string> block)
{
	return;
}

int CPdb::loadpdb(string filename)
{
	string line,part;
	ifstream fin(filename.c_str());
	pdbfilename=filename;
	bool first;
	int iligand;
	int atomindex;
	int index,index_old;
	string chain,chain_old;
	string residue,residue_old;
	struct proteinblock pdbblock;
	string add;
	char buffer[10];
	

	cout<<"load in "<<pdbfilename<<endl;

	clear(); //clear all data before load in new PDB information
	iligand=0;
	atomindex=0;
	first=1;
	index_old=1;
	chain_old=" ";
	while(getline(fin,line))
	{
		part=line.substr(0,6);
		if(part=="SEQADV")
		{

		}



		part=line.substr(0,6);
		if(part=="END" || part=="ENDMDL")
		{
			break;
		}

		part=line.substr(0,3);
		if(part=="TER")
		{
			//following is ligand or water in most case
			//or another chain! need to be taken care of this situation
			iligand=1;
			continue;
		}

		//neglect all entries that are not ATOM or HETATM
		part=line.substr(0,6);
		if(part!="ATOM  " && part!="HETATM")
			continue;


		//ignore water molecules.
		part=line.substr(17,3);
		if(part=="HOH" || part=="WAT")
			continue;

		
		index=atoi(line.substr(22,4).c_str());
		chain=line.substr(21,1);
		residue=line.substr(17,3);

		//Put in real atom index, this is important for coor processing !!
		atomindex++;
		sprintf(buffer,"%5d",atomindex);
		add=buffer;
		line.replace(6,5,add);

		if(first==1)
		{
			first=0;
			index_old=index;
			chain_old=chain;
			residue_old=residue;
			pdbblock.block.push_back(line);
			pdbblock.iligand=iligand;
			pdbblock.residue=residue;
			pdbblock.index=index;
		}
		else if(index==index_old && chain==chain_old )
		{
			pdbblock.block.push_back(line);
		}
		else if(chain==chain_old && index>index_old ) // new residue
		{
			blocks.push_back(pdbblock);
			pdbblock.block.clear();
			pdbblock.block.push_back(line);  
			pdbblock.iligand=iligand;
			pdbblock.index=index;
			pdbblock.residue=residue;
			index_old=index;
			residue_old=residue;
		}
		else if(chain==chain_old && index<index_old ) //most likely a new chain
		{
			blocks.push_back(pdbblock);
			chain_block.push_back(blocks.size());
			iligand=0;
			pdbblock.block.clear();
			pdbblock.block.push_back(line);	
			pdbblock.iligand=iligand;
			pdbblock.index=index;
			pdbblock.residue=residue;
			index_old=index;
			residue_old=residue;
			chain_old=chain;
		}
		else if(chain!=chain_old)
		{
			blocks.push_back(pdbblock);
			chain_block.push_back(blocks.size());
			iligand=0;
			pdbblock.block.clear();
			pdbblock.block.push_back(line);	
			pdbblock.iligand=iligand;
			pdbblock.index=index;
			pdbblock.residue=residue;
			index_old=index;
			residue_old=residue;
			chain_old=chain;
		}
	}
	
	if(pdbblock.block.size()>0)
		blocks.push_back(pdbblock);
	chain_block.push_back(blocks.size());

	//start part 2 here
	int start,begin,stop,stop2;
	CAminoacid *t,*t2;
	CLigand *tt;
	int n;
	int i,j,ii;
	natom=natom2=0;


	for(ii=0;ii<chain_block.size();ii++)
	{
		if(ii==0)
			start=0;
		else
			start=chain_block.at(ii-1);
		stop=chain_block.at(ii);
		n=0;
		stop2=stop;


		pdbblock=blocks.at(stop-1);
		if(pdbblock.iligand==0)
		{
			//even without TER, res has only one line is mostly a ligand,if it is the last entry
			if(pdbblock.block.size()==1 )
			{
					blocks.at(stop-1).iligand=1;
					stop2=stop-1;
			}
		}

		for(i=stop-2;i>=start;i--)
		{
			pdbblock=blocks.at(i);
			if(pdbblock.iligand==0 && blocks.at(i+1).iligand==1)
			{
				//even without TER, res has only one line is mostly a ligand, if following one is also a ligand
				if(pdbblock.block.size()==1 )
				{
					blocks.at(i).iligand=1;
					stop2=i;
				}
			}
		}


		for(i=start;i<stop;i++)
		{
			
			pdbblock=blocks.at(i);
			if(pdbblock.iligand==0)
			{
				residue=pdbblock.residue;
				if(residue=="ALA")	t=new CAla;
				else if(residue=="ARG")	t=new CArg;
				else if(residue=="ASN")	t=new CAsn;
				else if(residue=="ASP")	t=new CAsp;
				else if(residue=="GLN")	t=new CGln;
				else if(residue=="GLU")	t=new CGlu;
				else if(residue=="GLY")	t=new CGly;
				else if(residue=="HIS")	t=new CHis;	
				else if(residue=="HID")	t=new CHis;
				else if(residue=="HIE")	t=new CHis;
				else if(residue=="ILE")	t=new CIle;
				else if(residue=="LEU")	t=new CLeu;
				else if(residue=="LYS")	t=new CLys;
				else if(residue=="LYP")	t=new CLys;
				else if(residue=="MET")	t=new CMet;
				else if(residue=="PHE")	t=new CPhe;
				else if(residue=="PRO")	t=new CPro;
				else if(residue=="SER")	t=new CSer;
				else if(residue=="THR")	t=new CThr;
				else if(residue=="TYR")	t=new CTyr;
				else if(residue=="VAL")	t=new CVal;
				else if(residue=="TRP") t=new CTrp;
				else if(residue=="CYS") t=new CCys;
				else if(residue=="CYN") t=new CCys;
				else if(residue=="CYX") t=new CCyx;
				else if(iligand>=2) tt=new CLigand;
				else
				{
					t=new CUnk;
					#ifndef BENCHMARK
					cout<<"Warning! unrecognized residue name "<<residue<<" for residue "<<index_old<<endl;
					printblock(pdbblock.block);
					#endif
				}

				n++;t->setresidue(n);
				if(i==start) t->setnterminal();
				if(i==stop2-1) t->setcterminal();
				else if(blocks.at(i+1).iligand==1) t->setcterminal();
				t->process(pdbblock.block);
				natom+=pdbblock.block.size();
				
				if(i>start)
				{
					for(j=blocks.at(i-1).index+1;j<pdbblock.index;j++)
					{
						t2=new CMiss;
						n++;t2->setresidue(n);
						v.push_back(t2);
						nmiss++;
					}
				}
				v.push_back(t);
			}
			else //ligand
			{
				tt=new CLigand;
				n++;tt->setresidue(n);
				tt->process(pdbblock.block);
				natom2+=pdbblock.block.size();
				ligand.push_back(tt);
			}
		}//for(i=start;i<stop;i++)

		chains.push_back(v.size());
		chain_ligand.push_back(ligand.size());
	}



	//re-index residues
	for(j=0;j<(int)chains.size();j++)
	{
		if(j==0)
			begin=0;
		else
			begin=chains.at(j-1);
		stop=chains.at(j);

		for(i=begin;i<stop;i++)
		{
			v.at(i)->setresidue(i+1);
		}
	}


	for(j=0;j<(int)chains.size();j++)
	{
		if(j==0)
			begin=0;
		else
			begin=chains.at(j-1);
		stop=chains.at(j);

		//set up chain information
		for(i=begin;i<stop;i++)
			v.at(i)->chain=j;

		for(i=begin;i<stop-1;i++)
		{	
			v.at(i)->setfollowingn(v.at(i+1)->get("N").index);
		}
		v.at(stop-1)->setfollowingn(v.at(stop-1)->get("O").index);
		
		for(i=begin+1;i<stop;i++)
		{
			v.at(i)->setpreviousc(v.at(i-1)->get("C").index);
		}
		v.at(begin)->setpreviousc(v.at(begin)->get("H1").index);

		//residue index from the PDB file may be inconsistent
	}

	for(i=0;i<(int)v.size();i++)
	{
		pdbseq.push_back(v.at(i)->OneLetterName);
	}

	return (natom+natom2);

}


		

int CPdb::loadpdb_old(string filename)
{
	bool bres;
	int i,j,n;
	int begin,stop;
	int atomindex;
	int iligand;
	vector<string> block;
	string line, part, residue,chain,chain_old,add;
	int index,index_old;
	bool first;
	char buffer[6];

	pdbfilename=filename;

	clear();
	
	ifstream fin(filename.c_str());
	CAminoacid *t;
	CLigand *tt;

	
	natom=natom2=0;
	first=1;
	atomindex=0;
	iligand=0;
	nmiss=0;


	cout<<"load in "<<pdbfilename<<endl;
	while(getline(fin,line))
	{
		part=line.substr(0,6);
		if(part=="ENDMDL")
		{
			break;
		}

		part=line.substr(0,3);
		if(part=="TER")
		{
			//following is ligand or water in most case
			//or another chain! need to be taken care of this situation
			iligand=1;
			continue;
		}

		part=line.substr(0,6);
		if(part!="ATOM  " && part!="HETATM")
			continue;

		part=line.substr(17,3);
		if(part=="HOH" || part=="WAT")
			continue;

		atomindex++;
		index=atoi(line.substr(22,4).c_str());
		chain=line.substr(21,1);


		if(first==1)
		{
			first=0;
			index_old=index;
			chain_old=chain;
			residue=line.substr(17,3);
			n=0;
		}
		bres=0;

		if(index==index_old  && chain==chain_old) //same residue
		{
			if(line.substr(17,3)==residue)
			{
				sprintf(buffer,"%5d",atomindex);
				add=buffer;
				line.replace(6,5,add);
				block.push_back(line);
			}
			else
			{
				cout<<"Warning: same residue index but different residue name!   ";
				cout<<line<<endl;
			}
		}
		else if(chain != chain_old) //new chain, so that there is also new residue
		{
			chains.push_back((int)v.size()+1);
			if(chain.compare("A")!=0 ) iligand=0;
			bres=1;
			n=0;
		}
		else if(index!=index_old)//same chain, but new residue.
		{
			bres=1;
		}
		else //must be error, so we break;
		{
			cout<<"Error in processing PDB file! Processing aborted!"<<endl;
			break;
		}


		if(bres==1)  //
		{
			t=NULL;
			tt=NULL;
		if(residue=="ALA")	t=new CAla;
		else if(residue=="ARG")	t=new CArg;
		else if(residue=="ASN")	t=new CAsn;
		else if(residue=="ASP")	t=new CAsp;
		else if(residue=="GLN")	t=new CGln;
		else if(residue=="GLU")	t=new CGlu;
		else if(residue=="GLY")	t=new CGly;
		else if(residue=="HIS")	t=new CHis;	
		else if(residue=="HID")	t=new CHis;
		else if(residue=="HIE")	t=new CHis;
		else if(residue=="ILE")	t=new CIle;
		else if(residue=="LEU")	t=new CLeu;
		else if(residue=="LYS")	t=new CLys;
		else if(residue=="LYP")	t=new CLys;
		else if(residue=="MET")	t=new CMet;
		else if(residue=="PHE")	t=new CPhe;
		else if(residue=="PRO")	t=new CPro;
		else if(residue=="SER")	t=new CSer;
		else if(residue=="THR")	t=new CThr;
		else if(residue=="TYR")	t=new CTyr;
		else if(residue=="VAL")	t=new CVal;
		else if(residue=="TRP") t=new CTrp;
		else if(residue=="CYS") t=new CCys;
		else if(residue=="CYN") t=new CCys;
		else if(residue=="CYX") t=new CCyx;
		else if(iligand>=2) tt=new CLigand;
		else
		{
			t=new CUnk;
#ifndef BENCHMARK
			cout<<"Warning! unrecognized resiude name "<<residue<<" fore residue "<<index_old<<endl;
			printblock(block);
#endif
		}

			if(t!=NULL)
			{
				n++;t->setresidue(n);
				if(n==1) t->setnterminal();
				t->process(block);
				natom+=block.size();
				v.push_back(t);
				if(iligand>0)
					iligand++;
				//cout<<natom<<endl;
			}

			if(tt!=NULL)
			{
				tt->process(block);
				natom2+=block.size();
				ligand.push_back(tt);
			}
			
			//insert missing residues if necessary
			if(iligand<2)
			{
				for(i=index_old+1;i<index;i++)
				{
					t=new CMiss;
					n++;t->setresidue(n);
					v.push_back(t);
					nmiss++;
				}
			}

			

			//prepare for new residues
			index_old=index;
			chain_old=chain;
			block.clear();
			index=atoi(line.substr(22,4).c_str());
			chain=line.substr(21,1);

			sprintf(buffer,"%5d",atomindex);
			add=buffer;
			line.replace(6,5,add);

			block.push_back(line);
			residue=line.substr(17,3);
		}

	}

	

	if(block.size()>0)
	{
		if(iligand>=1)
			iligand++;
		
		t=NULL;
		tt=NULL;
		
		if(residue=="ALA")	t=new CAla;
		else if(residue=="ARG")	t=new CArg;
		else if(residue=="ASN")	t=new CAsn;
		else if(residue=="ASP")	t=new CAsp;
		else if(residue=="GLN")	t=new CGln;
		else if(residue=="GLU")	t=new CGlu;
		else if(residue=="GLY")	t=new CGly;
		else if(residue=="HIS")	t=new CHis;	
		else if(residue=="HID")	t=new CHis;
		else if(residue=="HIE")	t=new CHis;
		else if(residue=="ILE")	t=new CIle;
		else if(residue=="LEU")	t=new CLeu;
		else if(residue=="LYS")	t=new CLys;
		else if(residue=="LYP")	t=new CLys;
		else if(residue=="MET")	t=new CMet;
		else if(residue=="PHE")	t=new CPhe;
		else if(residue=="PRO")	t=new CPro;
		else if(residue=="SER")	t=new CSer;
		else if(residue=="THR")	t=new CThr;
		else if(residue=="TYR")	t=new CTyr;
		else if(residue=="VAL")	t=new CVal;
		else if(residue=="TRP") t=new CTrp;
		else if(residue=="CYS") t=new CCys;
		else if(residue=="CYN") t=new CCys;
		else if(residue=="CYX") t=new CCyx;
		else if(iligand>=2) tt=new CLigand;
		else
		{
			t=new CUnk;
#ifndef BENCHMARK
			cout<<"Warning! unrecognized resiude name "<<residue<<" fore residue "<<index_old<<endl;
			printblock(block);
#endif
		}

		if(t!=NULL)
		{
			n++;t->setresidue(n);
			t->process(block);
			natom+=block.size();
			v.push_back(t);
		}
		if(tt!=NULL)
		{
			tt->process(block);
			ligand.push_back(tt);
			natom2+=block.size();
		}
		chains.push_back((int)v.size());
	}

	//re-index residues
	for(j=0;j<(int)chains.size();j++)
	{
		if(j==0)
			begin=0;
		else
			begin=chains.at(j-1);
		stop=chains.at(j);

		for(i=begin;i<stop;i++)
		{
			v.at(i)->setresidue(i+1-begin);
		}
	}


	for(j=0;j<(int)chains.size();j++)
	{
		if(j==0)
			begin=0;
		else
			begin=chains.at(j-1);
		stop=chains.at(j);

		for(i=begin;i<stop-1;i++)
		{	
			v.at(i)->setfollowingn(v.at(i+1)->get("N").index);
		}
		v.at(stop-1)->setfollowingn(v.at(stop-1)->get("O").index);
		
		for(i=begin+1;i<stop;i++)
		{
			v.at(i)->setpreviousc(v.at(i-1)->get("C").index);
		}
		v.at(begin)->setpreviousc(v.at(begin)->get("H1").index);

		//residue index from the PDB file may be inconsistent
	}

	for(i=0;i<(int)v.size();i++)
	{
		pdbseq.push_back(v.at(i)->OneLetterName);
	}

	return (natom+natom2);
}


bool CPdb::bisunknownmissing()
{
	int i;
	bool flag1,flag2,flag3;

	flag1=0;
	flag2=0;
	flag3=0;

	for(i=0;i<(int)v.size();i++)
	{
		if(v.at(i)->OneLetterName!='X' && flag2==0)
		{
			flag1=1;
			continue;
		}
		if(v.at(i)->OneLetterName=='X' && flag1==1)
		{
			flag1=0;
			flag2=1;
			continue;
		}
		if(v.at(i)->OneLetterName!='X' && flag2==1)
		{
			flag3=1;
			flag1=0;
			flag2=0;
			break;
		}
	}

	return flag3;
}

		



void CPdb::printpdb(char * filename, int flag)
{
	int i,n;
	FILE *fp;

	fp=fopen(filename,"wt");
	n=1;
	for(i=0;i<v.size();i++)
	{
		if(flag==0) v.at(i)->printpdb(fp,atomname,x,y,z,b,n);
		else v.at(i)->printpdb(fp,atomname,x,y,z,b2,n);
	}
	fclose(fp);
	return;
}
	



void CPdb::printblock(vector<string> block)
{
	int i;
	cout<<"*********************************************************"<<endl;
	for(i=0;i<(int)block.size();i++)
		cout<<block.at(i)<<endl;
	cout<<"*********************************************************"<<endl;
	return;
}

vector<int> CPdb::getselect(string input)
{
	int n,n1,n2;
	vector<int> res;
	vector<int> sel;
	vector<string> atoms;
	size_t found_res,found;
	string part1,part2,part3;
	string p,p1,p2;


	stringstream ss;

	try
	{
		found_res=input.find(':');
		if(found_res==string::npos)
			throw "Can't find :";
		if(found_res!=0)
			throw "First charactor is not :";
		found_res=input.find('@');
		//cout<<"input is "<<input<<" found_res is "<<found_res<<endl;
		if(found_res==string::npos)
			throw "Can't find @";
		part1=input.substr(1,found_res-1);
		part2=input.substr(found_res+1,input.length()-found_res-1);
		//cout<<part1<<endl;
		//cout<<part2<<endl;

		//extract & part to part3
		found_res=input.find('&');
		if(found_res!=string::npos)
		{
			part3=part1.substr(found_res,part1.length()-found_res);
			part1=part1.substr(0,found_res-1);
		}


		//processing part1 now
		ss.str(part1);
		while(getline(ss,p,','))
		{
			found=p.find('-');
			if(found==string::npos)
			{
				if(p=="%")
					n=v.size();
				else
					n=atoi(p.c_str());
				if(n<=0)
					throw "Residue number <=0 ??";
				res.push_back(n);
			}
			else
			{
				p1=p.substr(0,found);
				p2=p.substr(found+1,p.length()-found);
				if(p1=="%")
					n1=v.size();
				else
					n1=atoi(p1.c_str());
				if(p2=="%")
					n2=v.size();
				else
					n2=atoi(p2.c_str());
				if(n1<=0 || n2<=0)
					throw "Residue number <=0 ??";
				for(n=n1;n<=n2;n++)
					res.push_back(n);

			}
		}
		//process part3 now
		if(part3.size()>0)
		{
			for(int i=res.size()-1;i>=0;i--)
			{
				n=res.at(i)-1;
				if(n<0)
					throw "Res index is less than 1";
				if(n>=v.size())
					throw "Res index is larger than nres";
				char c=v.at(n)->getdssp();
				if(part3.find(c)==string::npos)
					res.erase(res.begin()+i);
			}
		}

		//precess part2 now
		ss.clear();
		ss.str(part2);
		while(getline(ss,p,','))
		{
			atoms.push_back(p);
		}
	


		unsigned int i,j;
		for(i=0;i<(int)res.size();i++)
		{
			n=res.at(i)-1;
			if(n<0)
				throw "Res index is less than 1";
			if(n>=v.size())
				throw "Res index is larger than nres";

			for(j=0;j<atoms.size();j++)
			{
				
				if(atoms.at(j).compare("allheavy")==0)
				{
					v.at(n)->bbheavycoor(&sel);
					v.at(n)->heavycoor(&sel);
				}
				else if(atoms.at(j).compare("all")==0)
				{
					v.at(n)->allcoor(&sel);
				}
				else if(atoms.at(j).compare("scheavy")==0)
				{
					v.at(n)->heavycoor(&sel);
				}
				else if(atoms.at(j).compare("bbheavy")==0)
				{
					v.at(n)->bbheavycoor(&sel);
				}				
				else
				{
					n1=v.at(n)->get(atoms.at(j).c_str()).index;
					if(n1>0)
						sel.push_back(n1);
					else
						cout<<"Res "<<n+1<<v.at(n)->OneLetterName<<" doesn't have "<<atoms.at(j).c_str()<<" atom"<<endl;
				}
			}
		}
	}


	catch (const char * str)
	{
		cout<<"Input selection phasing exception raised because "<<str<<". Please check."<<endl;
		cout<<"select all Ca atoms of all residues instead!"<<endl;
		sel.clear();getca(&sel);
	}
	return sel;
}


vector<int> CPdb::getselect(string input,vector<int> res)
{
	int n,n1;
	vector<int> sel;
	vector<string> atoms;
	string part1,part2;
	string p,p1,p2;


	stringstream ss;


	ss.clear();
	ss.str(input);
	while(getline(ss,p,','))
	{
		atoms.push_back(p);
	}
	

	unsigned int i,j;
	for(i=0;i<(int)res.size();i++)
	{
		n=res.at(i)-1;

		for(j=0;j<atoms.size();j++)
		{
			if(atoms.at(j).compare("allheavy")==0)
			{
				v.at(n)->bbheavycoor(&sel);
				v.at(n)->heavycoor(&sel);
			}
			else if(atoms.at(j).compare("all")==0)
			{
				v.at(n)->allcoor(&sel);
			}
			else if(atoms.at(j).compare("scheavy")==0)
			{
				v.at(n)->heavycoor(&sel);
			}
			else if(atoms.at(j).compare("bbheavy")==0)
			{
				v.at(n)->bbheavycoor(&sel);
			}					
			else
			{
				n1=v.at(n)->get(atoms.at(j).c_str()).index;
				if(n1>0)
					sel.push_back(n1);
				else
					cout<<"Res "<<n+1<<v.at(n)->OneLetterName<<" doesn't have "<<atoms.at(j).c_str()<<" atom"<<endl;
			}
		}
	}
	return sel;
}



vector<int> CPdb::getselect(vector<int> &num, string input)
{
    int n,n1;
    unsigned int j;
    vector<int> sel;
    vector<string> atoms;
    string part1,part2;
    string p,p1,p2;
    
    
    stringstream ss;
    
    
    ss.clear();
    ss.str(input);
    while(getline(ss,p,','))
    {
        atoms.push_back(p);
    }
    
    
    
    for(n=0;n<v.size();n++)
    {
        
        for(j=0;j<atoms.size();j++)
        {
            if(atoms.at(j).compare("allheavy")==0)
            {
                v.at(n)->bbheavycoor(&sel);
                v.at(n)->heavycoor(&sel);
            }
            else if(atoms.at(j).compare("all")==0)
            {
                v.at(n)->allcoor(&sel);
            }
            else if(atoms.at(j).compare("scheavy")==0)
            {
                v.at(n)->heavycoor(&sel);
            }
            else if(atoms.at(j).compare("bbheavy")==0)
            {
                v.at(n)->bbheavycoor(&sel);
            }					
            else
            {
                n1=v.at(n)->get(atoms.at(j).c_str()).index;
                if(n1>0)
                    sel.push_back(n1);
                else
                    cout<<"Res "<<n+1<<v.at(n)->OneLetterName<<" doesn't have "<<atoms.at(j).c_str()<<" atom"<<endl;
            }
        }
        num.push_back(sel.size());
    }
    return sel;
}



void CPdb::getca(vector<int> *index)
{
	unsigned int i;
	for(i=0;i<(int)v.size();i++)
	{
		//if(i>40 && i<87) continue;
		index->push_back(v.at(i)->getca());
	}

	return;
}

vector<int> CPdb::getselectca(vector<int> res)
{
	unsigned int i;
	int n;
	vector<int> index;

	for(i=0;i<(int)res.size();i++)
	{
		n=res.at(i);
		if(n>=1 && n<=v.size()) index.push_back(v.at(n-1)->getca());
	}
	return index;
}




void CPdb::getdihe(vector<dihe_group> *t, vector<int> *n)
{
	unsigned int i;

	for(i=0;i<(int)v.size();i++)
	{
		v[i]->bbdihe(t);	
		v[i]->dihe(t);
		n->push_back(t->size());
	}
}


void CPdb::getbbdihe(vector<dihe_group> *t)
{
	unsigned int i;

	for(i=0;i<(int)v.size();i++)
	{
		v[i]->bbdihe(t);	
	}
}


void CPdb::getbbdihe(vector<dihe_group> *t,int *ibb)
{
	unsigned int i;

	for(i=0;i<(int)v.size();i++)
	{
		if( i==0 || i==(int)v.size()-1)
		{
			ibb[i]=0;
		}
		else
		{
			v[i]->bbdihe(t);	
			ibb[i]=1;
		}
	}
}

void CPdb::getbbdihe_nopro(vector<dihe_group> *t,int *ibb)
{
	unsigned int i;

	for(i=0;i<(int)v.size();i++)
	{
		if(v.at(i)->OneLetterName=='P' || i==0 || i==(int)v.size()-1)
		{
			ibb[i]=0;
		}
		else
		{
			v[i]->bbdihe(t);	
			ibb[i]=1;
		}
	}
}



void CPdb::getdihe(vector<dihe_group> *t)
{
	unsigned int i;


	for(i=0;i<(int)v.size();i++)
	{
		v[i]->bbdihe(t);	
		v[i]->dihe(t);
	}
}

void CPdb::getbb(vector<bb_group> *t)
{
	int i,j;
	int begin,stop;

	for(j=0;j<chains.size();j++)
	{
		if(j==0)
			begin=0;
		else
			begin=chains.at(j-1);
		stop=chains.at(j);

		if(stop-begin<3)
			cout<<"Chain "<<j<<" only has 1 or 2 residues! I don't know how to do."<<endl;
	
		v[begin+0]->bb(t);
		v[begin+1]->follow_bb(t);

		for(i=begin+1;i<stop-1;i++)
		{
			v[i]->bb(t);
			v[i-1]->previous_bb(t);
			v[i+1]->follow_bb(t);
		}
		v[stop-1]->bb(t);
	}
	return;
}

void CPdb::getbb_assign(vector<bb_group> *t)
{
    int i,j;
    int begin,stop;
    
    for(j=0;j<chains.size();j++)
    {
        if(j==0)
            begin=0;
        else
            begin=chains.at(j-1);
        stop=chains.at(j);
        
        if(stop-begin<3)
            cout<<"Chain "<<j<<" only has 1 or 2 residues! I don't know how to do."<<endl;
        
        v[begin+0]->bb(t);
        v[begin+1]->follow_bb_assign(t);
        
        for(i=begin+1;i<stop-1;i++)
        {
            v[i]->bb(t);
            v[i-1]->previous_bb(t);
            v[i+1]->follow_bb_assign(t);
        }
        v[stop-1]->bb(t);
    }
    return;
}

void CPdb::bbhbond(vector<bbhbond_group> *t)
{	
	unsigned int i;
	for(i=0;i<(int)v.size();i++)
	{
		v[i]->bbhbond(t);
	}
	return;
}





void CPdb::schbond(vector<bbhbond_group> *t)
{
	unsigned int i;
	for(i=0;i<v.size();i++)
	{
		v[i]->schbond(t);
	}
	return;
}

void CPdb::caha(vector<index_three> *t)
{
	int i;
	for(i=0;i<(int)v.size();i++)
	{
		if(v[i]->OneLetterName != 'G')
			v[i]->caha(t);
	}
	return;
}

void CPdb::bbco(vector<co_group> *t)
{
	int i;
	for(i=0;i<(int)v.size()-1;i++)
	{
		v[i]->bbco(t);
	}
	return;
}


void CPdb::bbnh(vector<nh_group> *t)
{
	int i;
	for(i=0+1;i<(int)v.size();i++)
	{
		if(v[i]->OneLetterName != 'P')
			v[i]->bbnh(t);
	}
	return;
}


void CPdb::ired(vector<struct ired> *t)
{
	int i;
	for(i=0;i<(int)v.size();i++)
	{
		v[i]->ired(t,i);
	}
	return;
}

void CPdb::clearred(void)
{
	int i;
	for(i=0;i<v.size();i++)
		v.at(i)->clearred();
	return;
}


void CPdb::loadred(vector<struct ired> *t)
{
	int i;

	clearred();
	for(i=0;i<t->size();i++)
	{
		if(t->at(i).pos>=0 && t->at(i).pos<v.size())
			v.at(t->at(i).pos)->loadred(t->at(i));
	}

	return;
}
		
void CPdb::loadred(string filename)
{
	ifstream fin(filename.c_str());
	string p,line;
	string name1,name2;
	istringstream iss;
	vector<struct ired> red;
	struct ired t;
	int i,j,base;
	string seq1,seq2;
	vector<int> out;
	double dtotal;
	int n,total;

	clearred();

	while(getline(fin,line))
	{
		iss.clear();
		iss.str(line);
		iss>>t.id>>t.code>>t.s2.name1>>t.s2.name2>>t.s2.exp;
		red.push_back(t);
	}
	fin.close();


	if(red.size()>0) base=red.at(0).id-1;
	for(i=0;i<(int)red.size();i++)
		red.at(i).id-=base;

	base=0;
	seq2.clear();
	for(i=0;i<(int)red.size();i++)
	{
		if(red.at(i).id>base)
		{
			base=red.at(i).id;
			if(seq2.size()<base)
				seq2.resize(base,'X');
			seq2.at(base-1)=red.at(i).code;
		}
	}

	for(i=0;i<(int)v.size();i++)
	{
		seq1.push_back(v.at(i)->OneLetterName);
	}
	out=Sequence::align(seq1,seq2);

	dtotal=0.0;
	n=0;
	for(i=2;i<(int)out.size()-1;i++)
	{
		j=out.at(i);
		if(j!=0 && out.at(i)==out.at(i-1)+1 && out.at(i)==out.at(i+1)-1)
		{
			dtotal+=j-i;
			n++;
		}
	}
	dtotal/=n;
	if(dtotal>=0) total=(int)(dtotal+0.5);
	else total=(int)(dtotal-0.5);



	for(i=0;i<(int)red.size();i++)
	{
		red.at(i).pos=red.at(i).id-total-1;
	}

	loadred(&red);

};
	


void CPdb::getring(vector<ring_group> *t)
{	
	int i;

	for(i=0;i<(int)v.size();i++)
	{
		v[i]->ring(t);
	}

	for(i=t->size()-1;i>=0;i--)
	{
		if(t->at(i).x1==3 || t->at(i).x1==4)
		{
			if(t->at(i).x2<0 || t->at(i).x3<0 || t->at(i).x4<0 || t->at(i).x5<0 || t->at(i).x6<0 )
				t->erase(t->begin()+i);
		}
		else
		{
			if(t->at(i).x2<0 || t->at(i).x3<0 || t->at(i).x4<0 || t->at(i).x5<0 || t->at(i).x6<0 || t->at(i).x7<0)
				t->erase(t->begin()+i);
		}
	}

	return;
}

void CPdb::getred(int in,vector<struct ired> *t)
{
	in--;

	if(in<0 || in>v.size()-1)
		;
	else
		v.at(in)->ired(t,in);

	return;
}

char CPdb::code(int in)
{
	char c;
	in=in-1;
	if(in<0 || in >(int)v.size()-1)
		c='X';
	else
		c=v[in]->OneLetterName;

	return c;
}

int CPdb::chain(int in)
{
	int r;
	in=in-1;
	if(in<0 || in>(int)v.size()-1)
		r=-1;
	else
		r=v[in]->chain;
	return r;
}

void CPdb::name(int in,char *name)
{	in=in-1;
	if(in<0 || in >(int)v.size()-1)
		strcpy(name,"err");
	else
		strcpy(name,v[in]->ThreeLetterName);
}

void CPdb::proton(vector<struct proton> *sel, int flag)
{
	int i;
	sel->clear();
	for(i=0;i<(int)v.size();i++)
	{
		v.at(i)->proton2(sel);
	}

	if(flag==1)
	{
		for(i=0;i<sel->size();i++)
		{
			bool bmiss=0;
			for(int j=0;j<sel->at(i).nh;j++)
			{
				if(sel->at(i).hpos[j]<0)
					bmiss=1;
			}
			if(bmiss==1)
			{
#ifndef BENCHMARK
				cerr<<"Residue "<<sel->at(i).id<<" "<<sel->at(i).code<<" contain missing protons "<<sel->at(i).name<<" , removed"<<endl;
#endif
				sel->erase(sel->begin()+i);
				i--;
			}
		}
	}
}


void CPdb::proton(vector<struct proton> *sel)
{
	int i;
	vector<struct proton> tmp;
	sel->clear();
	for(i=0;i<(int)v.size();i++)
	{
		v.at(i)->proton2(&tmp);
	}
	for(i=0;i<tmp.size();i++)
	{
		bool bmiss=0;
		for(int j=0;j<tmp.at(i).nh;j++)
		{
			if(tmp.at(i).hpos[j]<0) {
				bmiss=1;
				break;
			}
		}
		if(bmiss==1) {
#ifndef BENCHMARK
			cerr<<"Residue "<<sel->at(i).id<<" "<<sel->at(i).code<<" contain missing protons "<<sel->at(i).name<<" , removed"<<endl;
#endif
			//sel->erase(sel->begin()+i);
			//i--;
		} else {
			sel->push_back(tmp.at(i));
		}
	}
}


void CPdb::allproton3(vector<struct proton> *sel)
{
	int i;
	vector<struct proton> tmp;
	sel->clear();
	for(i=0;i<(int)(int)v.size();i++)
	{
		v.at(i)->proton3(&tmp);
	}
	for(i=0;i<tmp.size();i++)
	{
		bool bmiss=0;
		for(int j=0;j<tmp.at(i).nh;j++)
		{
			if(tmp.at(i).hpos[j]<0) {
				bmiss=1;
				break;
			}
		}
		if(bmiss==1) {
#ifndef BENCHMARK
			cerr<<"Residue "<<sel->at(i).id<<" "<<sel->at(i).code<<" contain missing protons "<<sel->at(i).name<<" , removed"<<endl;
#endif
			//sel->erase(sel->begin()+i);
			//i--;
		} else {
			sel->push_back(tmp.at(i));
		}
	}
}

void CPdb::allproton(vector<struct proton> *sel)
{
	int i;
	vector<struct proton> tmp;
	sel->clear();
	for(i=0;i<(int)(int)v.size();i++)
	{
		v.at(i)->proton(&tmp);
	}
	for(i=0;i<tmp.size();i++)
	{
		bool bmiss=0;
		for(int j=0;j<tmp.at(i).nh;j++)
		{
			if(tmp.at(i).hpos[j]<0) {
				bmiss=1;
				break;
			}
		}
		if(bmiss==1) {
#ifndef BENCHMARK
			cerr<<"Residue "<<sel->at(i).id<<" "<<sel->at(i).code<<" contain missing protons "<<sel->at(i).name<<" , removed"<<endl;
#endif
			//sel->erase(sel->begin()+i);
			//i--;
		} else {
			sel->push_back(tmp.at(i));
		}
	}
}

void CPdb::ani(vector<struct ani_group> *anistropy)
{
	int i,j;
	int begin,stop;

	for(j=0;j<chains.size();j++)
	{
		if(j==0)
			begin=0;
		else
			begin=chains.at(j-1);
		stop=chains.at(j);

	
		for(i=begin;i<stop-1;i++)
		{
			v[i]->bbani(anistropy);
			v[i]->ani(anistropy);
		}
		if(stop>1) v[stop-1]->ani(anistropy);

	}


	for(i=anistropy->size()-1;i>=0;i--)
	{
		if(anistropy->at(i).pos[0]<0 || anistropy->at(i).pos[1]<0 || anistropy->at(i).pos[2]<0 )
			anistropy->erase(anistropy->begin()+i);
	}

	return;
}

void CPdb::heavycoor()
{
	int i;
	heavy.clear();
	boundary.clear();
	allcoor.clear();
	for(i=0;i<(int)v.size();i++)
	{
		v.at(i)->bbheavycoor(&heavy);
		v.at(i)->heavycoor(&heavy);
		boundary.push_back(heavy.size());
		v.at(i)->allcoor(&allcoor);
	}

	for(i=0;i<(int)ligand.size();i++)
	{
		ligand.at(i)->heavycoor(&heavy);
		boundary.push_back(heavy.size());
	}

	return;
}



void CPdb::output(string filename)
{
	int i,j;
	int begin,stop;
	FILE *fp;

	fp=fopen(filename.c_str(),"wt");

	for(i=0;i<(int)v.size();i++)
	{
		if(i==0)
			begin=0;
		else
			begin=boundary.at(i-1);
		stop=boundary.at(i);
		for(j=begin;j<stop;j++)
		{
			if(heavy.at(j)>0)
			{
				fprintf(fp,"%d %s %s",i+1,v.at(i)->ThreeLetterName,atomname.at(heavy.at(j)-1).c_str());
				//fprintf(fp," %f %f %f",x.at(heavy.at(j)-1),y.at(heavy.at(j)-1),z.at(heavy.at(j)-1));
				fprintf(fp," %f %f\n",b.at(heavy.at(j)-1),b2.at(heavy.at(j)-1));
			}
		}
	}
	fclose(fp);
	return;
}


void CPdb::caoutput(string filename)
{
	int i,j;
	FILE *fp;

	fp=fopen(filename.c_str(),"wt");

	for(i=0;i<(int)v.size();i++)
	{
		if(i==0)
			j=1;
		else
			j=boundary.at(i-1)+1;
		if(heavy.at(j)>0)
		{
			fprintf(fp,"%d %s",i+1,v.at(i)->ThreeLetterName);
			fprintf(fp," %f %f\n",b.at(heavy.at(j)-1),b2.at(heavy.at(j)-1));
		}
	}
	fclose(fp);
	return;
}



void CPdb::attach_bbprediction(int id,double pre[])
{
	v.at(id-1)->attach_bbprediction(pre);
}

void CPdb::attach_protonprediction(int id,string name,double cs)
{
	v.at(id-1)->attach_protonprediction(name,cs);
}

void CPdb::print_prediction()
{
	string test="bmrb_pre.dat";
	print_prediction(test);
}

void CPdb::print_prediction(string name)
{
	int i,j;
	FILE *fp=fopen(name.c_str(),"wt");
	char toprint0[]="loop_\n    _Residue_seq_code\n     _Residue_label\n";
	char toprint[]="      loop_\n      _Atom_shift_assign_ID\n      _Residue_seq_code\n      _Residue_label\n      _Atom_name\n      _Atom_type\n      _Chem_shift_value\n      _Chem_shift_value_error\n      _Chem_shift_ambiguity_code\n";


	fprintf(fp,toprint0);
	for(i=0;i<(int)v.size();i++)
	{
		fprintf(fp," %d %s",i+1,v.at(i)->ThreeLetterName);
		if(i%3==0) fprintf(fp,"\n");
	}
	fprintf(fp,"\n      stop_\n");
	
	
	fprintf(fp,toprint);
	j=1;
	for(i=0;i<(int)v.size();i++)
		v.at(i)->print_prediction(&j,fp);
	fprintf(fp,"      stop_\n");
	fclose(fp);

	fp=fopen("bb_predict.dat","wt");
	fprintf(fp,"%8s%8s%8s%8s%8s%8s%8s%8s%8s%8s%8s%8s%8s%8s\n","index","residue","pre_ca","exp_ca",
		"pre_cb","exp_cb","pre_c","exp_c","pre_h","exp_h","pre_n","exp_n","pre_ha","exp_ha");
	for(i=0;i<(int)v.size();i++)
		v.at(i)->print_bbprediction(fp);
	fclose(fp);

	fp=fopen("proton_predict.dat","wt");
	fprintf(fp,"%8s %8s %8s %8s %8s\n","#  index","aa type","type","cs","exp");
	for(i=0;i<(int)v.size();i++)
		v.at(i)->print_protonprediction(fp);
	fclose(fp);

}

double CPdb::test_bmbr(class CBmrb bmrb)
{
	int i;
	vector<int> index;
	string seq1,seq2;
	vector<int> out;
	int total;



	index.clear();
	seq2=bmrb.getseq(index);
	for(i=0;i<(int)v.size();i++)
	{
		seq1.push_back(v.at(i)->OneLetterName);
	}
	out=Sequence::align(seq1,seq2);

	total=0;
	for(i=1;i<out.size();i++)
	{
		if(out.at(i)>0 && seq1.at(i-1)!='X')
			total++;
	}

	return ((double)total)/seq2.length();
}


int CPdb::attach_bmrb(class CBmrb bmrb)
{
	int i,j;
	vector<int> index;
	string seq1,seq2;
	vector<int> out;
	int total,n,m;
	double dtotal;
	char c1,c2;

	for(i=0;i<v.size();i++)
		v.at(i)->clearexp();


	index.clear();
	seq2=bmrb.getseq();
	for(i=0;i<(int)v.size();i++)
	{
		seq1.push_back(v.at(i)->OneLetterName);
	}
	out=Sequence::align(seq1,seq2);

	dtotal=0.0;
	n=0;
	for(i=2;i<(int)out.size()-1;i++)
	{
		j=out.at(i);
		if(j!=0 && out.at(i)==out.at(i-1)+1 && out.at(i)==out.at(i+1)-1)
		{
			dtotal+=j-i;
			n++;
		}
	}

	dtotal/=n;


	if(dtotal>=0) total=(int)(dtotal+0.5);
	else total=(int)(dtotal-0.5);



	n=0;
	m=0;
	for(i=1;i<(int)out.size();i++)
	{
		for(j=0;j<bmrb.getsize();j++)
		{
			if(bmrb.getdata(j).res-total==i)
			{
				c1=v.at(i-1)->OneLetterName;
				c2=Sequence::name2code(bmrb.getdata(j).name);
				if(c1==c2)
				{
					v.at(i-1)->loadexp(bmrb.getdata(j));
					n++;
				}
				else
				{
					m++;
					v.at(i-1)->set_mismatch();
				}
			}
		}
	}

	return m;
}

void CPdb::clear_cs()
{
	int i;
	for(i=0;i<(int)v.size();i++)
	{
		v.at(i)->bexploaded=0;
		v.at(i)->exploaded=0;
		v.at(i)->clearexp();
	}
	return;
}



void CPdb::attach_rmsf(vector<double> t)
{
	int i;
	for(i=0;i<v.size();i++)
	{
		v.at(i)->attach_rmsf(t);
	}
	return;
}

void CPdb::print_rmsf(string filename)
{
	FILE *fp;
	int i;

	fp=fopen(filename.c_str(),"rt");
	for(i=0;i<v.size();i++)
	{
		v.at(i)->print_rmsf(fp);
	}
	fclose(fp);
	return;
}




//flag=1: bmrb rc
//flag==2: wang' rc
//flag==3: wang's rc with neighboring correction
void CPdb::attach_coil(int flag=1)
{
	int i;

	if(flag==3 && v.size()>=3 )
	{
		v.at(0)->set_coil_wc('X',v.at(1)->OneLetterName);
		for(i=0+1;i<v.size()-1;i++)
			v.at(i)->set_coil_wc(v.at(i-1)->OneLetterName,v.at(i+1)->OneLetterName);
		v.at(i)->set_coil_wc(v.at(i-1)->OneLetterName,'X');
	}
	else
	{
		for(i=0;i<(int)v.size();i++)
		{
			if(v.at(i)->bexploaded==0)
				v.at(i)->set_coil(flag);
		}
	}


	return;
}

void CPdb::attach_mean()
{
	int i;
	for(i=0;i<(int)v.size();i++)
	{
		if(v.at(i)->bexploaded==0)
			v.at(i)->set_mean();
	}
	return;
}

void CPdb::attach_dssp(string filename)
{
	int i,j;
	string seq1,seq2;
	vector<int> out;


	dssp.loaddata(filename);
	for(i=0;i<(int)v.size();i++)
	{
		seq1.push_back(v.at(i)->OneLetterName);
	}
	seq2=dssp.getseq();
	out=Sequence::align(seq1,seq2);
	for(i=1;i<(int)out.size();i++)
	{
		j=out.at(i);
		if(j!=0)
			v.at(i-1)->setdssp(dssp.data.at(j-1).ss);
	}
	return;
}


void CPdb::attach_dssp()
{
	int i,j;
	string seq1,seq2;
	vector<int> out;


	dssp.loaddata(pdbfilename);
	for(i=0;i<(int)v.size();i++)
	{
		seq1.push_back(v.at(i)->OneLetterName);
	}
	seq2=dssp.getseq();
	out=Sequence::align(seq1,seq2);
	for(i=1;i<(int)out.size();i++)
	{
		j=out.at(i);
		if(j!=0)
			v.at(i-1)->setdssp(dssp.data.at(j-1).ss);
	}
	return;
}

char CPdb::getss(int i)
{
	return v.at(i-1)->getdssp();
}

struct noeatoms CPdb::query(int resid,string name)
{
	return v.at(resid-1)->query(name);
}


CPdb::CPdb()
{nmiss=0;};

CPdb::~CPdb()
{
	clear();
};


//CPdbcut
CPdb2::CPdb2()
{};

CPdb2::~CPdb2()
{ clear(); };

void CPdb2::clear()
{
	int i;

	for(i=0;i<pdbs.size();i++)
	{
		delete pdbs.at(i);
	}

	pdbs.clear();
	return;
}

double CPdb2::loadpdb(string filename)
{
	int i,j;
	ifstream fin(filename.c_str());
	string name;
	string line;
	string part1,part2,part3,part4;
	struct modify mod;
	vector<struct modify> mods;
	char chain;
	char old_chain;
	vector<string> block;
	vector< vector<string> > blocks;
	class CPdb *pdb;
	int ixray;
	char buffer[255];
	double resolution;

	blocks.clear();
	clear();

	name=filename.substr(0,filename.find(".pdb"));


	old_chain=0;
	mods.clear();
	ixray=1;
	resolution=0.0;
	while(getline(fin,line))
	{
		//"SEQADV 1NBF GLZ C  3";
		//"76  UNP  P62988    G";
		//"LY    76 MODIFIED RE";
		//"SIDUE";

		part1=line.substr(0,6);
		if(part1.compare("EXPDTA")==0)
		{
			part2=line.substr(10,5);
			if(part2.compare("X-RAY")==0)
				ixray=1;
			if(part2.compare("SOLUT")==0)
				ixray=0;
			if(part2.compare("SOLID")==0)
				ixray=0;
		}

		part1=line.substr(0,22);
		if(part1.compare("REMARK   2 RESOLUTION.")==0)
		{
			part2=line.substr(22,8);
			resolution=atof(part2.c_str());
		}


		if(ixray==0)
		{
			cout<<"neglect nmr structure "<<filename.c_str()<<endl;
			break;
		}
		if(resolution>2.0)
		{
			cout<<"neglect low resolution ("<<resolution<<") xray structure "<<filename.c_str()<<endl;
			break;
		}

		part1=line.substr(0,6);
		part2=line.substr(49,20);
		if(part1.compare("SEQADV")==0 && part2.find("MODIFIED")!=string::npos)
		{
			mod.from=line.substr(12,3);
			mod.to=line.substr(39,3);
			mod.chain=line.at(16);
			mod.res=atoi(line.substr(18,4).c_str());
			mods.push_back(mod);
		}

		part1=line.substr(0,4);
		part2=line.substr(0,6);
		part3=line.substr(0,3);
		if(part1!="ATOM" && part2!="HETATM" && part3 !="TER")
			continue;
		
		chain=line.at(21);

		if(chain==old_chain)
		{
			block.push_back(line);
		}
		else if(chain>old_chain || (old_chain=='Z' && chain=='A'))
		{
			if(block.size()>0)
				blocks.push_back(block);
			old_chain=chain;
			block.clear();
			block.push_back(line);
		}
		else
		{
			//cout<<"old chain id is "<<old_chain<<" and new chain id is "<<chain<<endl;
			break;
		}
	}

	if(block.size()>0)
		blocks.push_back(block);

	ofstream  fout;
	for(i=0;i<blocks.size();i++)
	{
		block=blocks.at(i);
		sprintf(buffer,"%s-%d.pdb",name.c_str(),i);
		fout.open(buffer,ofstream::out);
		line=block.at(0);
		fout<<"REMART   1  PDB seperated from "<<filename.c_str()<<" chain ID is "<<line.at(21)<<endl;
		for(j=0;j<block.size();j++)
		{
			line=block.at(j);
			line.at(21)=' ';
			fout<<line<<endl;
		}
		fout.close();
		pdb=new CPdb;
		pdb->loadpdb(buffer);
		pdbs.push_back(pdb);
	}

	if(ixray==0)
	{ 
		resolution=100.0;
	}

	return resolution;
};



########## NEXT FILE ##########
#include <iostream>
#include <cstdlib>
#include <fstream>
#include <cstring>
#include <string>
#include <vector>
#include <math.h>
#include <time.h>
using namespace std;

#include "traj.h"
using namespace ldw_math;

#define USE_ACC_COMPARE
#include "debug.h"

// ///////////////////////////////////////////////////////////////////////////////////////////////////////////

void CTraj::clear()
{
	x.clear();
	y.clear();
	z.clear();
	nframe=0;
}




int CTraj::appendcoor(string filename)
{
	double xx,yy,zz;
	string line,part;

	ifstream fin(filename.c_str());
	
	while(getline(fin,line))
	{
		if(part=="ENDMDL" || part=="END")
		{
			if(x.size()%natom!=0)
				cout<<"In traj reading, suppose to read "<<natom<<" coors but actually read in "<<x.size()<<endl;
		}

		part=line.substr(0,6);
		if(part!="ATOM  " && part!="HETATM")
			continue;

		part=line.substr(30,8);
		xx=atof(part.c_str());
		x.push_back(xx);
		part=line.substr(38,8);
		yy=atof(part.c_str());
		y.push_back(yy);
		part=line.substr(46,8);
		zz=atof(part.c_str());
		z.push_back(zz);
	};


	nframe=x.size()/natom;
	return nframe;
}


int CTraj::loadcoor(string filename)
{
	double xx,yy,zz;
	string line,part;
	bool bend;

	bend=0;


	ifstream fin(filename.c_str());

	
	while(getline(fin,line))
	{
		if(part=="ENDMDL" || part=="END")
		{
			//finished read first molecule 
			bend=1;
			if(x.size()%natom!=0)
				cout<<"In traj reading, suppose to read "<<natom<<" coors but actually read in "<<x.size()<<endl;
		}

		part=line.substr(0,6);
		if(part!="ATOM  " && part!="HETATM")
			continue;

		part=line.substr(30,8);
		xx=atof(part.c_str());
		x.push_back(xx);
		part=line.substr(38,8);
		yy=atof(part.c_str());
		y.push_back(yy);
		part=line.substr(46,8);
		zz=atof(part.c_str());
		z.push_back(zz);
		if(bend==0)
		{
			part=line.substr(12,4);
			atomname.push_back(part);
		}
	};

	if(natom==0)
		nframe=0;
	else
		nframe=x.size()/natom;

#ifdef _OPENACC
#pragma acc enter data copyin(this[:1])
  double *tmp = x.data();
  int sz = x.size();
#pragma acc enter data copyin(tmp[:sz])
  tmp = y.data();
  sz = y.size();
#pragma acc enter data copyin(tmp[:sz])
  tmp = z.data();
  sz = z.size();
#pragma acc enter data copyin(tmp[:sz])
#endif

	return nframe;
}

int CTraj::set_range(int begin,int stop)
{
	if(begin<0)
	{
		begin=0;
		cout<<"Reset begin to "<<begin<<endl;
	}

	if(stop>nframe)
	{
		stop=nframe;
		cout<<"Reset stop to "<<stop<<endl;
	}

	if(stop==0)
		stop=nframe;

	nframe=stop-begin;


	if(stop<nframe)
	{
		x.erase(x.begin()+stop*natom,x.begin()+x.size());
		y.erase(y.begin()+stop*natom,y.begin()+y.size());
		z.erase(z.begin()+stop*natom,z.begin()+z.size());
	}
	if(begin>0)
	{
		x.erase(x.begin(),x.begin()+begin*natom);
		y.erase(y.begin(),y.begin()+begin*natom);
		z.erase(z.begin(),z.begin()+begin*natom);
	}

	cout<<"Using frames from "<<begin<<" to "<<stop<<endl;
	return nframe;
}



void CTraj::getschbond2(vector<struct proton> *protons, vector<struct bbhbond_group> *bb, vector< vector<ehbond> > *effect, vector< vector<eschbond> > *effect_sc)
{
	int i,j,k;
	int base;
	int n,h[3],c,o;
	int nh;
	int nid,cid;
	double u[3];
	float x2,x3,x4,x5;
	float y2,y3,y4,y5;
	float z2,z3,z4,z5;
	float phi,psi,d;

	int kk,good_kk;
	float min_d;

	effect->resize(nres);
	for(i=0;i<(int)effect->size();i++)
	{
		effect->at(i).resize(nframe);
		for(k=0;k<nframe;k++)
		{
			effect->at(i).at(k).n_length=0;
			effect->at(i).at(k).c_length=0;
			effect->at(i).at(k).n_phi=0;
			effect->at(i).at(k).c_phi=0;
			effect->at(i).at(k).n_psi=0;
			effect->at(i).at(k).c_psi=0;
		}
	}

	effect_sc->resize(protons->size());
	for(i=0;i<(int)effect_sc->size();i++)
	{
		effect_sc->at(i).resize(nframe);
		for(k=0;k<nframe;k++)
		{
			effect_sc->at(i).at(k).n_length=0;
			effect_sc->at(i).at(k).c_length=0;
			effect_sc->at(i).at(k).n_phi=0;
			effect_sc->at(i).at(k).c_phi=0;
			effect_sc->at(i).at(k).n_psi=0;
			effect_sc->at(i).at(k).c_psi=0;
		}
	}


	
	for(i=0;i<(int)protons->size();i++)
	{
		for(j=0;j<(int)bb->size();j++)
		{
			nh=protons->at(i).nh;
			for(k=0;k<nh;k++)
				h[k]=protons->at(i).hpos[k];
			n=protons->at(i).cpos;
			if(h[0]<=-1 || n<=-1 || (nh==2 && h[1]<0) || (nh==3 && h[2]<0) ) 
				continue;
			c=bb->at(j).cpos;
			o=bb->at(j).opos;
			if(o<=-1 || c<=-1)
				continue;
			n--;c--;o--;
			for(k=0;k<nh;k++)
				h[k]--;

			for(k=0;k<nframe;k++)
			{
				//cout<<"i,j,k is "<<i<<" "<<j<<" "<<k<<endl;
				min_d=100000.0;
				for(kk=0;kk<nh;kk++)
				{
					base=k*natom;
					u[0]=x[h[kk]+base]-x[o+base];
					u[1]=y[h[kk]+base]-y[o+base];
					u[2]=z[h[kk]+base]-z[o+base];
					d=veclength(u);
					if(d<min_d)
					{
						min_d=d;
						good_kk=kk;
					}
				}
				d=min_d;
				x2=x[n+base];y2=y[n+base];z2=z[n+base];
				x3=x[h[good_kk]+base];y3=y[h[good_kk]+base];z3=z[h[good_kk]+base];
				x4=x[o+base];y4=y[o+base];z4=z[o+base];
				x5=x[c+base];y5=y[c+base];z5=z[c+base];
				phi=coor_to_angle(x2,y2,z2,x3,y3,z3,x4,y4,z4);
				psi=coor_to_angle(x3,y3,z3,x4,y4,z4,x5,y5,z5);
				if(d<3 && phi>0.5 && psi>0.5)
				{
					d=1/(d-1);
					phi*=phi;
					psi*=psi;
					nid=protons->at(i).id-1;
					cid=bb->at(j).id-1; /* C start from 0*/
					
					//effect->at(nid).at(k).n_length=d;
					//effect->at(nid).at(k).n_phi=phi;
					//effect->at(nid).at(k).n_psi=psi;

					effect_sc->at(i).at(k).n_length=d;
					effect_sc->at(i).at(k).n_phi=phi;
					effect_sc->at(i).at(k).n_psi=psi;
					effect_sc->at(i).at(k).id=protons->at(i).id;
					effect_sc->at(i).at(k).type=protons->at(i).type;

					if(bb->at(j).type==1)
					{
						effect->at(cid).at(k).c_length=d;
						effect->at(cid).at(k).c_phi=phi;
						effect->at(cid).at(k).c_psi=psi;
					}
					
				}
			}//for k
		}//for j
	}//for i

	return;
}


//hbond type (1, bb) (12, sc OH) (13,sc NH) (22 or 23, sc CO)
void CTraj::gethbond(vector<bbhbond_group> *hbond,vector<ehbond> *effect)
{
	int i,j,k;
	int base;
	int nid,cid;
	int n,h,c,o;
	double u[3];
	double x2,x3,x4,x5,y2,y3,y4,y5,z2,z3,z4,z5;
	double d,phi,psi;

	bbhbond_group* hbond_arr = hbond->data();
	int hbond_size = hbond->size();
	effect->resize(nres);
	ehbond* effect_arr = effect->data();
	int effect_size = effect->size();
	double* x_arr = this->x.data();
	int x_size = this->x.size();
	double* y_arr = this->y.data();
	int y_size = this->y.size();
	double* z_arr = this->z.data();
	int z_size = this->z.size();

  int nframe = this->nframe;
  int natom  = this->natom;

#pragma acc data \
	copyin(hbond_arr[:hbond_size]) \
	copyout(effect_arr[:effect_size]) \
	present(x_arr[:x_size], y_arr[:y_size], z_arr[:z_size])
{

#pragma acc parallel loop gang
	for(i=0; i<hbond_size; i++)
	{
#pragma acc loop vector \
	private(k,n,h,c,o,base,u[:3],d,x2,x3,x4,x5,y2,y3,y4,y5,\
					z2,z3,z4,z5,phi,psi,nid,cid)
		for(j=0; j<hbond_size; j++)
		{
			//k=j-i;
			if(j-i<3 && j-i>-3)
				continue;
			n=hbond_arr[i].npos-1;
			h=hbond_arr[i].hpos-1;
			//if(h<=-1 || n<=-1) 
			//	continue;
			c=hbond_arr[j].cpos-1;
			o=hbond_arr[j].opos-1;
			//if(o<=-1 || c<=-1)
			//	continue;
			//n--;h--;c--;o--;
			if(h<0 || n<0 || o<0 || c<0)
				continue;

#pragma acc loop seq
			for(k=0;k<nframe;k++)
			{
				base=k*natom;
				u[0]=x_arr[h+base]-x_arr[o+base];
				u[1]=y_arr[h+base]-y_arr[o+base];
				u[2]=z_arr[h+base]-z_arr[o+base];
				d=veclength(u);
				x2=x_arr[n+base];y2=y_arr[n+base];z2=z_arr[n+base];
				x3=x_arr[h+base];y3=y_arr[h+base];z3=z_arr[h+base];
				x4=x_arr[o+base];y4=y_arr[o+base];z4=z_arr[o+base];
				x5=x_arr[c+base];y5=y_arr[c+base];z5=z_arr[c+base];
				phi=coor_to_angle(x2,y2,z2,x3,y3,z3,x4,y4,z4);
				psi=coor_to_angle(x3,y3,z3,x4,y4,z4,x5,y5,z5);
				if(d<3 && phi>0.5 && psi>0.5)
				{
					d=1/(d-1);
					phi*=phi;
					psi*=psi;
					nid=hbond_arr[i].id-1;
					cid=hbond_arr[j].id-1; /* C start from 0*/
					if(hbond_arr[i].type==1)
					{
#pragma acc atomic update
						effect_arr[nid].n_length+=d;
#pragma acc atomic update
						effect_arr[nid].n_phi+=phi;
#pragma acc atomic update
						effect_arr[nid].n_psi+=psi;
					}
					if(hbond_arr[j].type==1)
					{
#pragma acc atomic update
						effect_arr[cid].c_length+=d;
#pragma acc atomic update
						effect_arr[cid].c_phi+=phi;
#pragma acc atomic update
						effect_arr[cid].c_psi+=psi;
					}
				}
			}
		}
	}

#pragma acc parallel loop
	for(i=0; i<effect_size; i++)
	{
		effect_arr[i].n_length/=nframe;
		effect_arr[i].c_length/=nframe;
		effect_arr[i].n_phi/=nframe;
		effect_arr[i].c_phi/=nframe;
		effect_arr[i].n_psi/=nframe;
		effect_arr[i].c_psi/=nframe;
	}

} // end data

	return;
}


//hbond type (1, bb) (12, sc OH) (13,sc NH) (22 or 23, sc CO)
void CTraj::gethbond(vector<bbhbond_group> *hbond,vector<ehbond> *effect, double cutoff)
{

	int i,j,k;
	int base;
	int nid,cid;
	int n,h,c,o;
	double u[3];
	double x2,x3,x4,x5,y2,y3,y4,y5,z2,z3,z4,z5;
	double d,phi,psi;

	
	effect->resize(nres);
	for(i=0;i<(int)hbond->size();i++)
	{

		for(j=0;j<(int)hbond->size();j++)
		{
			k=j-i;
			if(k<3 && k>-3)
				continue;
			n=hbond->at(i).npos;
			h=hbond->at(i).hpos;
			if(h<=-1 || n<=-1) 
				continue;
			c=hbond->at(j).cpos;
			o=hbond->at(j).opos;
			if(o<=-1 || c<=-1)
				continue;
			n--;h--;c--;o--;
			if(h<0 || n<0 || o<0 || c<0)
				continue;



			for(k=0;k<nframe;k++)
			{
				//cout<<"i,j,k is "<<i<<" "<<j<<" "<<k<<endl;
				base=k*natom;
				u[0]=x[h+base]-x[o+base];
				u[1]=y[h+base]-y[o+base];
				u[2]=z[h+base]-z[o+base];
				d=veclength(u);
				x2=x[n+base];y2=y[n+base];z2=z[n+base];
				x3=x[h+base];y3=y[h+base];z3=z[h+base];
				x4=x[o+base];y4=y[o+base];z4=z[o+base];
				x5=x[c+base];y5=y[c+base];z5=z[c+base];
				phi=coor_to_angle(x2,y2,z2,x3,y3,z3,x4,y4,z4);
				psi=coor_to_angle(x3,y3,z3,x4,y4,z4,x5,y5,z5);
				if(d<3 && phi>0.5 && psi>0.5)
				{
					d=1/(d-1);
					phi*=phi;
					psi*=psi;
					nid=hbond->at(i).id-1;
					cid=hbond->at(j).id-1; /* C start from 0*/

					if(d>cutoff)
						d=cutoff;

					if(hbond->at(i).type==1)
					{
						effect->at(nid).n_length+=d;
						effect->at(nid).n_phi+=phi;
						effect->at(nid).n_psi+=psi;
					}
					if(hbond->at(j).type==1)
					{
						effect->at(cid).c_length+=d;
						effect->at(cid).c_phi+=phi;
						effect->at(cid).c_psi+=psi;
					}
				}
			}
		}
	}

	for(i=0;i<(int)effect->size();i++)
	{
		effect->at(i).n_length/=nframe;
		effect->at(i).c_length/=nframe;
		effect->at(i).n_phi/=nframe;
		effect->at(i).c_phi/=nframe;
		effect->at(i).n_psi/=nframe;
		effect->at(i).c_psi/=nframe;
	}
	return;
}



void CTraj::gethbond(vector<bbhbond_group> *hbond,vector< vector<ehbond> > *effect)
{

	int i,j,k;
	int base;
	int nid,cid;
	int n,h,c,o;
	double u[3];
	double x2,x3,x4,x5,y2,y3,y4,y5,z2,z3,z4,z5;
	double d,phi,psi;

	effect->resize(nres);
	for(i=0;i<(int)effect->size();i++)
	{
		effect->at(i).resize(nframe);
		for(k=0;k<nframe;k++)
		{
			effect->at(i).at(k).n_length=0;
			effect->at(i).at(k).c_length=0;
			effect->at(i).at(k).n_phi=0;
			effect->at(i).at(k).c_phi=0;
			effect->at(i).at(k).n_psi=0;
			effect->at(i).at(k).c_psi=0;
		}
	}

	for(i=0;i<(int)hbond->size();i++)
	{

		for(j=0;j<(int)hbond->size();j++)
		{
			k=j-i;
			if(k<3 && k>-3)
				continue;
			n=hbond->at(i).npos;
			h=hbond->at(i).hpos;
			if(h<0) 
				continue;
			c=hbond->at(j).cpos;
			o=hbond->at(j).opos;
			if(o<0)
				continue;
			n--;h--;c--;o--;


			for(k=0;k<nframe;k++)
			{
				//cout<<"i,j,k is "<<i<<" "<<j<<" "<<k<<endl;
				base=k*natom;
				u[0]=x[h+base]-x[o+base];
				u[1]=y[h+base]-y[o+base];
				u[2]=z[h+base]-z[o+base];
				d=veclength(u);
				x2=x[n+base];y2=y[n+base];z2=z[n+base];
				x3=x[h+base];y3=y[h+base];z3=z[h+base];
				x4=x[o+base];y4=y[o+base];z4=z[o+base];
				x5=x[c+base];y5=y[c+base];z5=z[c+base];
				phi=coor_to_angle(x2,y2,z2,x3,y3,z3,x4,y4,z4);
				psi=coor_to_angle(x3,y3,z3,x4,y4,z4,x5,y5,z5);
				if(d<3 && phi>0.5 && psi>0.5)
				{
					d=1/(d-1);
					phi*=phi;
					psi*=psi;
					nid=hbond->at(i).id-1;
					cid=hbond->at(j).id-1; /* C start from 0*/
					if(hbond->at(i).type==1)
					{
						effect->at(nid).at(k).n_length+=d;
						effect->at(nid).at(k).n_phi+=phi;
						effect->at(nid).at(k).n_psi+=psi;
					}
					if(hbond->at(j).type==1)
					{
						effect->at(cid).at(k).c_length+=d;
						effect->at(cid).at(k).c_phi+=phi;
						effect->at(cid).at(k).c_psi+=psi;
					}
				}
			}
		}
	}
	return;
}


void CTraj::gethbond2(vector<bbhbond_group> *hbond,vector< vector<ehbond> > *effect)
{

	int i,j,k;
	int base;
	int nid,cid;
	int n,h,c,o;
	double u[3];
	double x2,x3,x4,x5,y2,y3,y4,y5,z2,z3,z4,z5;
	double d,phi,psi;

	effect->resize(nres);
	for(i=0;i<(int)effect->size();i++)
	{
		effect->at(i).resize(nframe);
		for(k=0;k<nframe;k++)
		{
			effect->at(i).at(k).n_length=0;
			effect->at(i).at(k).c_length=0;
			effect->at(i).at(k).n_phi=0;
			effect->at(i).at(k).c_phi=0;
			effect->at(i).at(k).n_psi=0;
			effect->at(i).at(k).c_psi=0;
		}
	}

	for(i=0;i<(int)hbond->size();i++)
	{

		for(j=0;j<(int)hbond->size();j++)
		{
			k=j-i;
			if(k<=3 && k>=-3)
				continue;
			n=hbond->at(i).npos;
			h=hbond->at(i).hpos;
			if(h<0) 
				continue;
			c=hbond->at(j).cpos;
			o=hbond->at(j).opos;
			if(o<0)
				continue;
			n--;h--;c--;o--;


			for(k=0;k<nframe;k++)
			{
				//cout<<"i,j,k is "<<i<<" "<<j<<" "<<k<<endl;
				base=k*natom;
				u[0]=x[h+base]-x[o+base];
				u[1]=y[h+base]-y[o+base];
				u[2]=z[h+base]-z[o+base];
				d=veclength(u);
				x2=x[n+base];y2=y[n+base];z2=z[n+base];
				x3=x[h+base];y3=y[h+base];z3=z[h+base];
				x4=x[o+base];y4=y[o+base];z4=z[o+base];
				x5=x[c+base];y5=y[c+base];z5=z[c+base];
				phi=coor_to_angle(x2,y2,z2,x3,y3,z3,x4,y4,z4);
				psi=coor_to_angle(x3,y3,z3,x4,y4,z4,x5,y5,z5);
				if(d<3 && phi>0.5 && psi>0.5)
				{
					d=1/(d-1);
					phi*=phi;
					psi*=psi;
					nid=hbond->at(i).id-1;
					cid=hbond->at(j).id-1; /* C start from 0*/
					if(hbond->at(i).type==1)
					{
						effect->at(nid).at(k).n_length=d;
						effect->at(nid).at(k).n_phi=phi;
						effect->at(nid).at(k).n_psi=psi;
					}
					if(hbond->at(i).type==1)
					{
						effect->at(cid).at(k).c_length=d;
						effect->at(cid).at(k).c_phi=phi;
						effect->at(cid).at(k).c_psi=psi;
					}
				}
			}
		}
	}
	return;
}




void CTraj::dis_matrix(vector<int> *index,vector<double> *dis)
{
	int i,j,n1,n2;
	double d1,d2,d3,d;
	for(i=0;i<(int)index->size();i++)
	{
		n1=index->at(i)-1;
		for(j=0;j<(int)index->size();j++)
		{		
			n2=index->at(j)-1;
			d1=x.at(n1)-x.at(n2);
			d2=y.at(n1)-y.at(n2);
			d3=z.at(n1)-z.at(n2);
			d=sqrt(d1*d1+d2*d2+d3*d3);
			dis->push_back(d);
		}
	}
	return;
}


void CTraj::getangle(vector<struct dihe_group> *index, vector<double> * angle)
{
	int i,j;
	int x1,x2,x3,x4;
	int base;
	double t;


	for(i=0;i<nframe;i++)
	{
		base=i*natom-1;  // -1 because of C starts from 0 but not 1 !
		for(j=0;j<(int)index->size();j++)
		{
			x1=base+index->at(j).x1;
			x2=base+index->at(j).x2;
			x3=base+index->at(j).x3;
			x4=base+index->at(j).x4;
			t=coor_to_angle(x[x1],y[x1],z[x1],x[x2],y[x2],z[x2],x[x3],y[x3],z[x3]);
			angle->push_back(t);
			t=coor_to_angle(x[x2],y[x2],z[x2],x[x3],y[x3],z[x3],x[x4],y[x4],z[x4]);
			angle->push_back(t);
		}
	}
	return;
}




void CTraj::getdihe(vector<struct dihe_group> *index, vector<double> * dihe)
{	
	int i,j;
	int x1,x2,x3,x4;
	int base;
	double t;


	for(i=0;i<nframe;i++)
	{
		base=i*natom-1;  // -1 because of C starts from 0 but not 1 !
		for(j=0;j<(int)index->size();j++)
		{
			if(index->at(j).bgood==1)
			{
				x1=base+index->at(j).x1;
				x2=base+index->at(j).x2;
				x3=base+index->at(j).x3;
				x4=base+index->at(j).x4;
				t=coor_to_dihe(x[x1],y[x1],z[x1],x[x2],y[x2],z[x2],x[x3],y[x3],z[x3],x[x4],y[x4],z[x4]);
				dihe->push_back(t);
			}
			else
				dihe->push_back(-1000.0);
		}
	}
	return;
}


void CTraj::getring(vector<struct ring_group> *index, vector<struct nh_group>* select, vector<struct double_five> *ring_effect)
{	
	int i,j,k,ii,jj,m;
	int base;
	int t[6];
	double p1[3],t1[3],t2[3],t3[3];
	double u[6][3];
	double sum[3];
	double ori[3];
	double e;

	ring_group* index_arr = index->data();
	int index_size = index->size();
	nh_group* select_arr = select->data();
	int select_size = select->size();
	ring_effect->resize(select_size);
	double_five* effect_arr = ring_effect->data();
	int effect_size = ring_effect->size();
	double* x_arr = this->x.data();
	int x_size = this->x.size();
	double* y_arr = this->y.data();
	int y_size = this->y.size();
	double* z_arr = this->z.data();
	int z_size = this->z.size();

	int nframe = this->nframe;
	int natom = this->natom;

#pragma acc data \
	copyin(index_arr[:index_size], select_arr[:select_size], \
  	x_arr[:x_size], y_arr[:y_size], z_arr[:z_size]) \
	copyout(effect_arr[:effect_size])
{

#pragma acc parallel loop collapse(2)
	for(i=0; i<select_size; i++)
		for(j=0; j<5; j++)
			effect_arr[i].x[j]=0.0;

	for(i=0;i<nframe;i++)
	{
		base=i*natom;

#pragma acc parallel loop gang \
	private(ii,jj,m,t[:6],u[:6][:3],sum[:3],\
	ori[:3],t1[:3],t2[:3],t3[:3])
		for(j=0; j<index_size; j++)
		{
			if(index_arr[j].x1 == 1 || index_arr[j].x1 == 2 || index_arr[j].x1 == 5){
				m=6;
			} else {
				m=5;
			}

			t[0]=index_arr[j].x2;
			t[1]=index_arr[j].x3;
			t[2]=index_arr[j].x4;
			t[3]=index_arr[j].x5;
			t[4]=index_arr[j].x6;
			t[5]=index_arr[j].x7;

			u[0][0]=x_arr[t[0]+base-1]; u[0][1]=y_arr[t[0]+base-1]; u[0][2]=z_arr[t[0]+base-1];
			u[1][0]=x_arr[t[1]+base-1]; u[1][1]=y_arr[t[1]+base-1]; u[1][2]=z_arr[t[1]+base-1];
			u[2][0]=x_arr[t[2]+base-1]; u[2][1]=y_arr[t[2]+base-1]; u[2][2]=z_arr[t[2]+base-1];
			u[3][0]=x_arr[t[3]+base-1]; u[3][1]=y_arr[t[3]+base-1]; u[3][2]=z_arr[t[3]+base-1];
			u[4][0]=x_arr[t[4]+base-1]; u[4][1]=y_arr[t[4]+base-1]; u[4][2]=z_arr[t[4]+base-1];
			if(m >= 6) {
				u[5][0]=x_arr[t[5]+base-1]; u[5][1]=y_arr[t[5]+base-1]; u[5][2]=z_arr[t[5]+base-1];
			} else {
				u[5][0]=0; u[5][1]=0; u[5][2]=0;
			}

			sum[0] = (u[0][0] + u[1][0] + u[2][0] + u[3][0] + u[4][0] + u[5][0]) / m;
			sum[1] = (u[0][1] + u[1][1] + u[2][1] + u[3][1] + u[4][1] + u[5][1]) / m;
			sum[2] = (u[0][2] + u[1][2] + u[2][2] + u[3][2] + u[4][2] + u[5][2]) / m;

			u[0][0] -= sum[0]; u[0][1] -= sum[1]; u[0][2] -= sum[2];
			u[1][0] -= sum[0]; u[1][1] -= sum[1]; u[1][2] -= sum[2];
			u[2][0] -= sum[0]; u[2][1] -= sum[1]; u[2][2] -= sum[2];
			u[3][0] -= sum[0]; u[3][1] -= sum[1]; u[3][2] -= sum[2];
			u[4][0] -= sum[0]; u[4][1] -= sum[1]; u[4][2] -= sum[2];
			u[5][0] -= sum[0]; u[5][1] -= sum[1]; u[5][2] -= sum[2];

			ring(u,m,ori);

			t1[0] = u[0][0] - u[1][0];
			t1[1] = u[0][1] - u[1][1];
			t1[2] = u[0][2] - u[1][2];
			t2[0] = u[2][0] - u[1][0];
			t2[1] = u[2][1] - u[1][1];
			t2[2] = u[2][2] - u[1][2];

			cross(t3,t1,t2);
			if(dot(t3,ori)<0)
			{
				ori[0] = -ori[0];
				ori[1] = -ori[1];
				ori[2] = -ori[2];
			}

#pragma acc loop vector private(e,p1[:3])
			for(k=0; k<select_size; k++)
			{
				if(select_arr[k].hpos>=1)
				{
					e=0;
					p1[0]=x_arr[base+select_arr[k].hpos-1]-sum[0];
					p1[1]=y_arr[base+select_arr[k].hpos-1]-sum[1];
					p1[2]=z_arr[base+select_arr[k].hpos-1]-sum[2];
					e+=effect(u,m,ori,p1); 
					e=e*10;
#pragma acc atomic update
					effect_arr[k].x[index_arr[j].x1-1]+=e;
				}
			}
		}
	}

#pragma acc parallel loop collapse(2)
	for(ii=0; ii<select_size; ii++)
	{
		for(jj=0;jj<5;jj++)
		{
			effect_arr[ii].x[jj]/=nframe;
		}
	}

} // end data

	return;
}


void CTraj::getring(vector<struct ring_group> *index, vector<struct nh_group>* select, vector< vector<struct double_five> > *ring_effect)
{	
	int i,j,ii,jj,m;
	int base;
	int t[6];
	double p1[3],t1[3],t2[3],t3[3];
	double u[6][3];
	double sum[3];
	double ori[3];
	double e;
	struct double_five temp;
	
	for(i=0;i<5;i++)
		temp.x[i]=0;
	ring_effect->resize(select->size());
	for(ii=0;ii<(int)select->size();ii++)
	{
		for(jj=0;jj<nframe;jj++)
		{
			ring_effect->at(ii).push_back(temp);
		}
	}


	for(i=0;i<nframe;i++)
	{
		base=i*natom;  
		for(j=0;j<(int)index->size();j++)
		{
			switch(index->at(j).x1)
			{
				case 1:
                case 2:
                case 5:
					m=6;
					break;
				case 4:
				case 3:
					m=5;
					break;
			}
			t[0]=index->at(j).x2;
			t[1]=index->at(j).x3;
			t[2]=index->at(j).x4;
			t[3]=index->at(j).x5;
			t[4]=index->at(j).x6;
			t[5]=index->at(j).x7;

           
            for(ii=0;ii<m;ii++)
			{
				u[ii][0]=x[t[ii]+base-1];
                u[ii][1]=y[t[ii]+base-1];
                u[ii][2]=z[t[ii]+base-1];
            }
           
            for(jj=0;jj<3;jj++)
				sum[jj]=0; 
			for(ii=0;ii<m;ii++)
            {
				for(jj=0;jj<3;jj++)
				{
					sum[jj]+=u[ii][jj];
				}
			}
			for(jj=0;jj<3;jj++)
				sum[jj]/=m; 
			for(ii=0;ii<m;ii++)
			{
				for(jj=0;jj<3;jj++)
					u[ii][jj]-=sum[jj];
			}

			ring(u,m,ori);

            for(jj=0;jj<3;jj++)
            {
                   t1[jj]=u[0][jj]-u[1][jj];
                   t2[jj]=u[2][jj]-u[1][jj];
            }
            cross(t3,t1,t2);
            if(dot(t3,ori)<0)
            {
				for(jj=0;jj<3;jj++)
					ori[jj]=-ori[jj];
			}

			for(ii=0;ii<(int)select->size();ii++)
			{
				if(select->at(ii).hpos>=1)
				{
					e=0;
					p1[0]=x[base+select->at(ii).hpos-1]-sum[0];
					p1[1]=y[base+select->at(ii).hpos-1]-sum[1];
					p1[2]=z[base+select->at(ii).hpos-1]-sum[2];
					e+=effect(u,m,ori,p1); 
					e=e*10;
					ring_effect->at(ii).at(i).x[index->at(j).x1-1]+=e;
				}
			}
		}
	}

	return;
}



void CTraj::getring(vector<struct ring_group> *index, vector<struct methyl_group>* select, vector<struct double_five> *ring_effect, enum methyl c)
{	
	int i,j,ii,jj,m,k;
	int base;
	int t[6];
	double p1[3],t1[3],t2[3],t3[3];
	double u[6][3];
	double sum[3];
	double ori[3];
	double e;
	struct double_five temp;
	
	for(i=0;i<5;i++)
		temp.x[i]=0;
	for(i=0;i<(int)select->size();i++)
		ring_effect->push_back(temp);


	for(i=0;i<nframe;i++)
	{
		base=i*natom;  
		for(j=0;j<(int)index->size();j++)
		{
			switch(index->at(j).x1)
			{
				case 1:
                case 2:
                case 5:
					m=6;
					break;
				case 4:
				case 3:
					m=5;
					break;
			}
			t[0]=index->at(j).x2;
			t[1]=index->at(j).x3;
			t[2]=index->at(j).x4;
			t[3]=index->at(j).x5;
			t[4]=index->at(j).x6;
			t[5]=index->at(j).x7;

           
            for(ii=0;ii<m;ii++)
			{
				u[ii][0]=x[t[ii]+base-1];
                u[ii][1]=y[t[ii]+base-1];
                u[ii][2]=z[t[ii]+base-1];
            }
           
            for(jj=0;jj<3;jj++)
				sum[jj]=0; 
			for(ii=0;ii<m;ii++)
            {
				for(jj=0;jj<3;jj++)
				{
					sum[jj]+=u[ii][jj];
				}
			}
			for(jj=0;jj<3;jj++)
				sum[jj]/=m; 
			for(ii=0;ii<m;ii++)
			{
				for(jj=0;jj<3;jj++)
					u[ii][jj]-=sum[jj];
			}

			ring(u,m,ori);

            for(jj=0;jj<3;jj++)
            {
                   t1[jj]=u[0][jj]-u[1][jj];
                   t2[jj]=u[2][jj]-u[1][jj];
            }
            cross(t3,t1,t2);
            if(dot(t3,ori)<0)
            {
				for(jj=0;jj<3;jj++)
					ori[jj]=-ori[jj];
			}

			for(ii=0;ii<(int)select->size();ii++)
			{
				e=0;

				switch(c)
				{
				case hydrogen:
					for(k=0;k<3;k++)
					{
						p1[0]=x[base+select->at(ii).hpos[k]-1]-sum[0];
						p1[1]=y[base+select->at(ii).hpos[k]-1]-sum[1];
						p1[2]=z[base+select->at(ii).hpos[k]-1]-sum[2];
						//cout<<"Ori is "<<ori[0]<<" "<<ori[1]<<" "<<ori[2]<<endl;
						//cout<<"X is "<<p1[0]<<" "<<p1[1]<<" "<<p1[2]<<endl;
						e+=effect(u,m,ori,p1); 
					}
					break;
				case carbon:
					p1[0]=x[base+select->at(ii).cpos-1]-sum[0];
					p1[1]=y[base+select->at(ii).cpos-1]-sum[1];
					p1[2]=z[base+select->at(ii).cpos-1]-sum[2];
					e+=effect(u,m,ori,p1); 
					break;
				}

				e=e*10;
				ring_effect->at(ii).x[index->at(j).x1-1]+=e;
			}
		}
	}

	for(ii=0;ii<(int)select->size();ii++)
	{
		for(jj=0;jj<5;jj++)
		{
			ring_effect->at(ii).x[jj]/=nframe;
		}
	}
	return;
}

void CTraj::getring(vector<struct ring_group> *index, vector<struct proton>* select, vector<struct double_five> *ring_effect)
{	
	int i,j,ii,jj,m,k;
	int base;
	int t[6];
	double p1[3],t1[3],t2[3],t3[3];
	double u[6][3];
	double sum[3];
	double ori[3];
	double e;

	ring_group* index_arr = index->data();
	int index_size = index->size();
	proton* select_arr = select->data();
	int select_size = select->size();
	ring_effect->resize(select_size);
	double_five* effect_arr = ring_effect->data();
	int effect_size = ring_effect->size();
	double* x_arr = this->x.data();
	int x_size = this->x.size();
	double* y_arr = this->y.data();
	int y_size = this->y.size();
	double* z_arr = this->z.data();
	int z_size = this->z.size();

	int nframe = this->nframe;
	int natom = this->natom;

#pragma acc data \
	copyin(index_arr[:index_size], select_arr[:select_size], \
		x_arr[:x_size], y_arr[:y_size], z_arr[:z_size]) \
	copyout(effect_arr[:effect_size])
{

#pragma acc parallel loop collapse(2)
	for(i=0; i<select_size; i++)
		for(j=0; j<5; j++)
			effect_arr[i].x[j]=0.0;

	for(i=0;i<nframe;i++)
	{
		base=i*natom;  

#pragma acc parallel loop gang \
	private(m,t[:6],u[:6][:3],sum[:3],ori[:3],t1[:3],t2[:3],t3[:3])
		for(j=0; j<index_size; j++)
		{
			if(index_arr[j].x1 == 1 || index_arr[j].x1 == 2 || index_arr[j].x1 == 5){
				m=6;
			} else {
				m=5;
			}

			t[0]=index_arr[j].x2;
			t[1]=index_arr[j].x3;
			t[2]=index_arr[j].x4;
			t[3]=index_arr[j].x5;
			t[4]=index_arr[j].x6;
			t[5]=index_arr[j].x7;

			u[0][0]=x_arr[t[0]+base-1]; u[0][1]=y_arr[t[0]+base-1]; u[0][2]=z_arr[t[0]+base-1];
			u[1][0]=x_arr[t[1]+base-1]; u[1][1]=y_arr[t[1]+base-1]; u[1][2]=z_arr[t[1]+base-1];
			u[2][0]=x_arr[t[2]+base-1]; u[2][1]=y_arr[t[2]+base-1]; u[2][2]=z_arr[t[2]+base-1];
			u[3][0]=x_arr[t[3]+base-1]; u[3][1]=y_arr[t[3]+base-1]; u[3][2]=z_arr[t[3]+base-1];
			u[4][0]=x_arr[t[4]+base-1]; u[4][1]=y_arr[t[4]+base-1]; u[4][2]=z_arr[t[4]+base-1];
			if(m >= 6) {
				u[5][0]=x_arr[t[5]+base-1]; u[5][1]=y_arr[t[5]+base-1]; u[5][2]=z_arr[t[5]+base-1];
			} else {
				u[5][0]=0; u[5][1]=0; u[5][2]=0;
			}

			sum[0] = (u[0][0] + u[1][0] + u[2][0] + u[3][0] + u[4][0] + u[5][0]) / m;
			sum[1] = (u[0][1] + u[1][1] + u[2][1] + u[3][1] + u[4][1] + u[5][1]) / m;
			sum[2] = (u[0][2] + u[1][2] + u[2][2] + u[3][2] + u[4][2] + u[5][2]) / m;

			u[0][0] -= sum[0]; u[0][1] -= sum[1]; u[0][2] -= sum[2];
			u[1][0] -= sum[0]; u[1][1] -= sum[1]; u[1][2] -= sum[2];
			u[2][0] -= sum[0]; u[2][1] -= sum[1]; u[2][2] -= sum[2];
			u[3][0] -= sum[0]; u[3][1] -= sum[1]; u[3][2] -= sum[2];
			u[4][0] -= sum[0]; u[4][1] -= sum[1]; u[4][2] -= sum[2];
			u[5][0] -= sum[0]; u[5][1] -= sum[1]; u[5][2] -= sum[2];

			ring(u,m,ori);

			t1[0] = u[0][0] - u[1][0];
			t1[1] = u[0][1] - u[1][1];
			t1[2] = u[0][2] - u[1][2];
			t2[0] = u[2][0] - u[1][0];
			t2[1] = u[2][1] - u[1][1];
			t2[2] = u[2][2] - u[1][2];

			cross(t3,t1,t2);
			if(dot(t3,ori)<0)
			{
				ori[0] = -ori[0];
				ori[1] = -ori[1];
				ori[2] = -ori[2];
			}

#pragma acc loop vector private(k,e,p1[:3])
			for(ii=0; ii<select_size; ii++)
			{
				e=0;
#pragma acc loop seq
				for(k=0; k<select_arr[ii].nh; k++)
				{
					if(select_arr[ii].hpos[k] >= 0) {
						p1[0]=x_arr[base+select_arr[ii].hpos[k]-1]-sum[0];
						p1[1]=y_arr[base+select_arr[ii].hpos[k]-1]-sum[1];
						p1[2]=z_arr[base+select_arr[ii].hpos[k]-1]-sum[2];
					}
					e+=effect(u,m,ori,p1); 
				}
				e=e*10*3/select_arr[ii].nh;
#pragma acc atomic update
				effect_arr[ii].x[index_arr[j].x1-1]+=e;
			}
		}
	}

#pragma acc parallel loop collapse(2)
	for(ii=0; ii<select_size; ii++)
	{
		for(jj=0;jj<5;jj++)
		{
			effect_arr[ii].x[jj]/=nframe;
		}
	}

} // end data

	return;
}



void CTraj::getring(vector<struct ring_group> *index, vector<struct proton>* select, vector< vector<struct double_five> > *ring_effect)
{	
	int i,j,ii,jj,m,k;
	int base;
	int t[6];
	double p1[3],t1[3],t2[3],t3[3];
	double u[6][3];
	double sum[3];
	double ori[3];
	double e;
	struct double_five temp;
	
	for(i=0;i<5;i++)
		temp.x[i]=0;
	ring_effect->resize(select->size());
	for(ii=0;ii<(int)select->size();ii++)
	{
		for(jj=0;jj<nframe;jj++)
		{
			ring_effect->at(ii).push_back(temp);
		}
	}


	for(i=0;i<nframe;i++)
	{
		base=i*natom;  
		for(j=0;j<(int)index->size();j++)
		{
			switch(index->at(j).x1)
			{
				case 1:
                case 2:
                case 5:
					m=6;
					break;
				case 4:
				case 3:
					m=5;
					break;
			}
			t[0]=index->at(j).x2;
			t[1]=index->at(j).x3;
			t[2]=index->at(j).x4;
			t[3]=index->at(j).x5;
			t[4]=index->at(j).x6;
			t[5]=index->at(j).x7;

           
            for(ii=0;ii<m;ii++)
			{
				u[ii][0]=x[t[ii]+base-1];
                u[ii][1]=y[t[ii]+base-1];
                u[ii][2]=z[t[ii]+base-1];
            }
           
            for(jj=0;jj<3;jj++)
				sum[jj]=0; 
			for(ii=0;ii<m;ii++)
            {
				for(jj=0;jj<3;jj++)
				{
					sum[jj]+=u[ii][jj];
				}
			}
			for(jj=0;jj<3;jj++)
				sum[jj]/=m; 
			for(ii=0;ii<m;ii++)
			{
				for(jj=0;jj<3;jj++)
					u[ii][jj]-=sum[jj];
			}

			ring(u,m,ori);

            for(jj=0;jj<3;jj++)
            {
                   t1[jj]=u[0][jj]-u[1][jj];
                   t2[jj]=u[2][jj]-u[1][jj];
            }
            cross(t3,t1,t2);
            if(dot(t3,ori)<0)
            {
				for(jj=0;jj<3;jj++)
					ori[jj]=-ori[jj];
			}

			for(ii=0;ii<(int)select->size();ii++)
			{
				e=0;	
				for(k=0;k<(int)select->at(ii).nh;k++)
				{
					p1[0]=x[base+select->at(ii).hpos[k]-1]-sum[0];
					p1[1]=y[base+select->at(ii).hpos[k]-1]-sum[1];
					p1[2]=z[base+select->at(ii).hpos[k]-1]-sum[2];
					e+=effect(u,m,ori,p1); 
				}
				e=e*10*3/select->at(ii).nh;
				ring_effect->at(ii).at(i).x[index->at(j).x1-1]+=e;
			}
		}
	}
	return;
}


void CTraj::getring_bb(vector<struct ring_group> *index, vector<struct bb_group>* select, vector<struct double_five> *ring_effect, enum bb_carbon c)
{	
	int i,j,ii,jj,m;
	int base;
	int t[6];
	double p1[3],t1[3],t2[3],t3[3];
	double u[6][3];
	double sum[3];
	double ori[3];
	double e;
	struct double_five temp;
	
	for(i=0;i<5;i++)
		temp.x[i]=0;
	for(i=0;i<(int)select->size();i++)
		ring_effect->push_back(temp);


	for(i=0;i<nframe;i++)
	{
		base=i*natom;  
		for(j=0;j<(int)index->size();j++)
		{
			switch(index->at(j).x1)
			{
				case 1:
                case 2:
                case 5:
					m=6;
					break;
				case 4:
				case 3:
					m=5;
					break;
			}
			t[0]=index->at(j).x2;
			t[1]=index->at(j).x3;
			t[2]=index->at(j).x4;
			t[3]=index->at(j).x5;
			t[4]=index->at(j).x6;
			t[5]=index->at(j).x7;

           
            for(ii=0;ii<m;ii++)
			{
				u[ii][0]=x[t[ii]+base-1];
                u[ii][1]=y[t[ii]+base-1];
                u[ii][2]=z[t[ii]+base-1];
            }
           
            for(jj=0;jj<3;jj++)
				sum[jj]=0; 
			for(ii=0;ii<m;ii++)
            {
				for(jj=0;jj<3;jj++)
				{
					sum[jj]+=u[ii][jj];
				}
			}
			for(jj=0;jj<3;jj++)
				sum[jj]/=m; 
			for(ii=0;ii<m;ii++)
			{
				for(jj=0;jj<3;jj++)
					u[ii][jj]-=sum[jj];
			}

			ring(u,m,ori);

            for(jj=0;jj<3;jj++)
            {
                   t1[jj]=u[0][jj]-u[1][jj];
                   t2[jj]=u[2][jj]-u[1][jj];
            }
            cross(t3,t1,t2);
            if(dot(t3,ori)<0)
            {
				for(jj=0;jj<3;jj++)
					ori[jj]=-ori[jj];
			}

			for(ii=0;ii<(int)select->size();ii++)
			{
				e=0;

				if((select->at(ii).capos>=1 && c==bb_ca) || (select->at(ii).cbpos>=1 && c==bb_cb)||(select->at(ii).copos>=1 && c==bb_co))
				switch (c)
				{
				case bb_ca:
					p1[0]=x[base+select->at(ii).capos-1]-sum[0];
					p1[1]=y[base+select->at(ii).capos-1]-sum[1];
					p1[2]=z[base+select->at(ii).capos-1]-sum[2];
					break;
				case bb_cb:
					p1[0]=x[base+select->at(ii).cbpos-1]-sum[0];
					p1[1]=y[base+select->at(ii).cbpos-1]-sum[1];
					p1[2]=z[base+select->at(ii).cbpos-1]-sum[2];
					break;
				case bb_co:
					p1[0]=x[base+select->at(ii).copos-1]-sum[0];
					p1[1]=y[base+select->at(ii).copos-1]-sum[1];
					p1[2]=z[base+select->at(ii).copos-1]-sum[2];
					break;
				}
				e+=effect(u,m,ori,p1); 
				e=e*10;
				ring_effect->at(ii).x[index->at(j).x1-1]+=e;
			}
		}
	}

	for(ii=0;ii<(int)select->size();ii++)
	{
		for(jj=0;jj<5;jj++)
		{
			ring_effect->at(ii).x[jj]/=nframe;
		}
	}
	return;
}



void CTraj::getani(vector<struct ani_group> *index, vector<struct methyl_group>* select, vector<struct double_four> *ani_effect, enum methyl c)
{
	int i,j,ii,jj,k;
	int i1,i2,i3;
	int base;
	double center[3];
	double v1[3];
	double v2[3];
	double ori[3];
	double cosa;
	double length;
	double e;


	struct double_four temp;
	
	for(i=0;i<4;i++)
		temp.x[i]=0;
	for(i=0;i<(int)select->size();i++)
		ani_effect->push_back(temp);
	
	for(i=0;i<nframe;i++)
	{
		base=i*natom;
		for(j=0;j<(int)index->size();j++)
		{
			i1=index->at(j).pos[0]+base-1;
			i2=index->at(j).pos[1]+base-1;
			i3=index->at(j).pos[2]+base-1;
			center[0]=(x[i1]+x[i2]+x[i3])/3;
			center[1]=(y[i1]+y[i2]+y[i3])/3;
			center[2]=(z[i1]+z[i2]+z[i3])/3;

			v1[0]=x[i1]-x[i2];
			v1[1]=y[i1]-y[i2];
			v1[2]=z[i1]-z[i2];

			v2[0]=x[i3]-x[i2];
			v2[1]=y[i3]-y[i2];
			v2[2]=z[i3]-z[i2];

			cross(ori,v1,v2);

			for(jj=0;jj<(int)select->size();jj++)
			{
				e=0;				
				switch(c)
				{
				case hydrogen:
					for(k=0;k<3;k++)
					{
						i1=base+select->at(jj).cpos-1+k+1;
						v1[0]=center[0]-x[i1];
						v1[1]=center[1]-y[i1];
						v1[2]=center[2]-z[i1];
						length=v1[0]*v1[0]+v1[1]*v1[1]+v1[2]*v1[2];
						cosa=dot(v1,ori);
						cosa/=sqrt(ori[0]*ori[0]+ori[1]*ori[1]+ori[2]*ori[2]);
						cosa/=sqrt(length);					 
						e+=(1-3*cosa*cosa)/(length*sqrt(length));
					}
					ani_effect->at(jj).x[index->at(j).type-1]+=e/3.0*1000;
					break;

				case carbon:
					i1=base+select->at(jj).cpos-1;
					v1[0]=center[0]-x[i1];
					v1[1]=center[1]-y[i1];
					v1[2]=center[2]-z[i1];
					length=v1[0]*v1[0]+v1[1]*v1[1]+v1[2]*v1[2];
					cosa=dot(v1,ori);
					cosa/=sqrt(ori[0]*ori[0]+ori[1]*ori[1]+ori[2]*ori[2]);
					cosa/=sqrt(length);					 
					e+=(1-3*cosa*cosa)/(length*sqrt(length));
					ani_effect->at(jj).x[index->at(j).type-1]+=e*1000;
					break;
				}
			}
		}
	}

	for(ii=0;ii<(int)select->size();ii++)
	{
		for(jj=0;jj<4;jj++)
		{
			ani_effect->at(ii).x[jj]/=nframe;
		}
	}
	return;
}


void CTraj::getani(vector<struct ani_group> *index, vector<struct proton>* select, vector<struct double_four> *ani_effect)
{
	int i,j,ii,jj,k;
	int i1,i2,i3,i4;
	int base;
	double center[3];
	double v1[3];
	double v2[3];
	double v3[3];
	double ori[3];
	double cosa;
	double length;
	double e;

	ani_group* index_arr = index->data();
	int index_size = index->size();
	proton* select_arr = select->data();
	int select_size = select->size();
	ani_effect->resize(select_size);
	double_four* effect_arr = ani_effect->data();
	int effect_size = ani_effect->size();
	double* x_arr = this->x.data();
	int x_size = this->x.size();
	double* y_arr = this->y.data();
	int y_size = this->y.size();
	double* z_arr = this->z.data();
	int z_size = this->z.size();

	int nframe = this->nframe;
	int natom = this->natom;

#pragma acc data \
	copyin(index_arr[:index_size], select_arr[:select_size], \
		x_arr[:x_size], y_arr[:y_size], z_arr[:z_size]) \
	copyout(effect_arr[:effect_size])
{

#pragma acc parallel loop collapse(2)
	for(i=0;i<select_size;i++)
		for(j=0;j<4;j++)
			effect_arr[i].x[j]=0.0;
	
	for(i=0;i<nframe;i++)
	{
		base=i*natom;
#pragma acc parallel loop gang private(i1,i2,i3,center[:3], \
	v1[:3],v2[:3],ori[:3])
		for(j=0; j<index_size; j++)
		{
			i1=index_arr[j].pos[0]+base-1;
			i2=index_arr[j].pos[1]+base-1;
			i3=index_arr[j].pos[2]+base-1;
			center[0]=(x_arr[i1]+x_arr[i2]+x_arr[i3])/3;
			center[1]=(y_arr[i1]+y_arr[i2]+y_arr[i3])/3;
			center[2]=(z_arr[i1]+z_arr[i2]+z_arr[i3])/3;

			v1[0]=x_arr[i1]-x_arr[i2];
			v1[1]=y_arr[i1]-y_arr[i2];
			v1[2]=z_arr[i1]-z_arr[i2];

			v2[0]=x_arr[i3]-x_arr[i2];
			v2[1]=y_arr[i3]-y_arr[i2];
			v2[2]=z_arr[i3]-z_arr[i2];

			cross(ori,v1,v2);

#pragma acc loop vector private(k,e,i4,v3[:3],length,cosa)
			for(jj=0; jj<select_size; jj++)
			{
				e=0;		
#pragma acc loop seq		
				for(k=0; k<select_arr[jj].nh; k++)
				{
					i4=base+select_arr[jj].hpos[k]-1;
					v3[0]=center[0]-x_arr[i4];
					v3[1]=center[1]-y_arr[i4];
					v3[2]=center[2]-z_arr[i4];
					length=v3[0]*v3[0]+v3[1]*v3[1]+v3[2]*v3[2];
					cosa=dot(v3,ori);
					cosa/=sqrt(ori[0]*ori[0]+ori[1]*ori[1]+ori[2]*ori[2]);
					cosa/=sqrt(length);		 
					e+=(1-3*cosa*cosa)/(length*sqrt(length));
				}
#pragma acc atomic update
				effect_arr[jj].x[index_arr[j].type-1]+=e/select_arr[jj].nh*1000;
			}
		}
	}

#pragma acc parallel loop collapse(2)
	for(ii=0; ii<select_size; ii++)
	{
		for(jj=0; jj<4; jj++)
		{
			effect_arr[ii].x[jj]/=nframe;
		}
	}

} // end data

	return;
}


void CTraj::getani(vector<struct ani_group> *index, vector<struct proton>* select, vector< vector<struct double_four>  > *ani_effect)
{
	int i,j,ii,jj,k;
	int i1,i2,i3;
	int base;
	double center[3];
	double v1[3];
	double v2[3];
	double ori[3];
	double cosa;
	double length;
	double e;


	struct double_four temp;
	
	for(i=0;i<4;i++)
		temp.x[i]=0;
	ani_effect->resize(select->size());
	for(ii=0;ii<(int)select->size();ii++)
	{
		for(jj=0;jj<nframe;jj++)
		{
			ani_effect->at(ii).push_back(temp);
		}
	}

	
	for(i=0;i<nframe;i++)
	{
		base=i*natom;
		for(j=0;j<(int)index->size();j++)
		{
			i1=index->at(j).pos[0]+base-1;
			i2=index->at(j).pos[1]+base-1;
			i3=index->at(j).pos[2]+base-1;
			center[0]=(x[i1]+x[i2]+x[i3])/3;
			center[1]=(y[i1]+y[i2]+y[i3])/3;
			center[2]=(z[i1]+z[i2]+z[i3])/3;

			v1[0]=x[i1]-x[i2];
			v1[1]=y[i1]-y[i2];
			v1[2]=z[i1]-z[i2];

			v2[0]=x[i3]-x[i2];
			v2[1]=y[i3]-y[i2];
			v2[2]=z[i3]-z[i2];

			cross(ori,v1,v2);

			for(jj=0;jj<(int)select->size();jj++)
			{
				e=0;				
				for(k=0;k<(int)select->at(jj).nh;k++)
				{
					i1=base+select->at(jj).hpos[k]-1;
					v1[0]=center[0]-x[i1];
					v1[1]=center[1]-y[i1];
					v1[2]=center[2]-z[i1];
					length=v1[0]*v1[0]+v1[1]*v1[1]+v1[2]*v1[2];
					cosa=dot(v1,ori);
					cosa/=sqrt(ori[0]*ori[0]+ori[1]*ori[1]+ori[2]*ori[2]);
					cosa/=sqrt(length);					 
					e+=(1-3*cosa*cosa)/(length*sqrt(length));
				}
				ani_effect->at(jj).at(i).x[index->at(j).type-1]+=e/select->at(jj).nh*1000;
			}
		}
	}


	return;
}


void CTraj::getani(vector<struct ani_group> *index, vector<struct nh_group>* select, vector<struct double_four> *ani_effect)
{
	int i,j,ii,k;
	int i1,i2,i3,i4;
	int base;
	double center[3];
	double v1[3];
	double v2[3];
	double v3[3];
	double ori[3];
	double cosa;
	double length;
	double e;

	ani_group* index_arr = index->data();
	int index_size = index->size();
	nh_group* select_arr = select->data();
	int select_size = select->size();
	ani_effect->resize(select_size);
	double_four* effect_arr = ani_effect->data();
	int effect_size = ani_effect->size();
	double* x_arr = this->x.data();
	int x_size = this->x.size();
	double* y_arr = this->y.data();
	int y_size = this->y.size();
	double* z_arr = this->z.data();
	int z_size = this->z.size();

	int nframe = this->nframe;
	int natom = this->natom;

#pragma acc data \
	copyin(index_arr[:index_size], select_arr[:select_size], \
		x_arr[:x_size], y_arr[:y_size], z_arr[:z_size]) \
	copyout(effect_arr[:effect_size])
{

#pragma acc parallel loop collapse(2)
	for(i=0;i<select_size;i++)
		for(j=0;j<4;j++)
			effect_arr[i].x[j]=0.0;

	for(i=0;i<nframe;i++)
	{
		base=i*natom;
#pragma acc parallel loop gang \
	private(i1,i2,i3,center[:3],v1[:3],v2[:3],ori[:3])
		for(j=0; j<index_size; j++)
		{
			i1=index_arr[j].pos[0]+base-1;
			i2=index_arr[j].pos[1]+base-1;
			i3=index_arr[j].pos[2]+base-1;
			center[0]=(x_arr[i1]+x_arr[i2]+x_arr[i3])/3;
			center[1]=(y_arr[i1]+y_arr[i2]+y_arr[i3])/3;
			center[2]=(z_arr[i1]+z_arr[i2]+z_arr[i3])/3;

			v1[0]=x_arr[i1]-x_arr[i2];
			v1[1]=y_arr[i1]-y_arr[i2];
			v1[2]=z_arr[i1]-z_arr[i2];

			v2[0]=x_arr[i3]-x_arr[i2];
			v2[1]=y_arr[i3]-y_arr[i2];
			v2[2]=z_arr[i3]-z_arr[i2];

			cross(ori,v1,v2);

#pragma acc loop vector private(e,i4,v3[:3],length,cosa)
			for(k=0; k<select_size; k++)
			{
				if(select_arr[k].hpos>=1)
				{
					e=0;				
					i4=base+select_arr[k].hpos-1;
					v3[0]=center[0]-x_arr[i4];
					v3[1]=center[1]-y_arr[i4];
					v3[2]=center[2]-z_arr[i4];
					length=v3[0]*v3[0]+v3[1]*v3[1]+v3[2]*v3[2];
					cosa=dot(v3,ori);
					cosa/=sqrt(ori[0]*ori[0]+ori[1]*ori[1]+ori[2]*ori[2]);
					cosa/=sqrt(length);					 
					e+=(1-3*cosa*cosa)/(length*sqrt(length));
#pragma acc atomic update
					effect_arr[k].x[index_arr[j].type-1]+=e*1000;
				}
			}
		}
	}

#pragma acc parallel loop collapse(2)
	for(i=0; i<select_size; i++)
		for(j=0; j<4; j++)
			effect_arr[i].x[j]/=nframe;

} // end data

	return;
}


void CTraj::do_rmsf(void)
{
	int i,j;
	int jump;
	double meanx,meany,meanz;
	double rms;
	double t,tt;

	rmsf.clear();
	for(i=0;i<natom;i++)
	{
		meanx=meany=meanz=0.0;
		for(j=0;j<nframe;j++)
		{
			jump=j*natom+i;
			meanx+=x.at(jump);
			meany+=y.at(jump);
			meanz+=z.at(jump);
		}
		meanx/=nframe;
		meany/=nframe;
		meanz/=nframe;

		rms=0.0;
		for(j=0;j<nframe;j++)
		{
			jump=j*nframe+i;
			t=x.at(jump)-meanx;tt=t*t;
			t=y.at(jump)-meany;tt+=t*t;
			t=z.at(jump)-meanz;tt+=t*t;
			rms+=tt;
		}
		rms=sqrt(rms/nframe);
		rmsf.push_back(rms);
	}

	return;
}



void CTraj::getani(vector<struct ani_group> *index, vector<struct nh_group>* select, vector< vector<struct double_four>  > *ani_effect)
{
	int i,j,ii,jj;
	int i1,i2,i3;
	int base;
	double center[3];
	double v1[3];
	double v2[3];
	double ori[3];
	double cosa;
	double length;
	double e;


	struct double_four temp;
	
	for(i=0;i<4;i++)
		temp.x[i]=0;
	ani_effect->resize(select->size());
	for(ii=0;ii<(int)select->size();ii++)
	{
		for(jj=0;jj<nframe;jj++)
		{
			ani_effect->at(ii).push_back(temp);
		}
	}
	
	for(i=0;i<nframe;i++)
	{
		base=i*natom;
		for(j=0;j<(int)index->size();j++)
		{
			i1=index->at(j).pos[0]+base-1;
			i2=index->at(j).pos[1]+base-1;
			i3=index->at(j).pos[2]+base-1;
			center[0]=(x[i1]+x[i2]+x[i3])/3;
			center[1]=(y[i1]+y[i2]+y[i3])/3;
			center[2]=(z[i1]+z[i2]+z[i3])/3;

			v1[0]=x[i1]-x[i2];
			v1[1]=y[i1]-y[i2];
			v1[2]=z[i1]-z[i2];

			v2[0]=x[i3]-x[i2];
			v2[1]=y[i3]-y[i2];
			v2[2]=z[i3]-z[i2];

			cross(ori,v1,v2);

			for(jj=0;jj<(int)select->size();jj++)
			{
				if(select->at(jj).hpos>=1)
				{
					e=0;				
					i1=base+select->at(jj).hpos-1;
					v1[0]=center[0]-x[i1];
					v1[1]=center[1]-y[i1];
					v1[2]=center[2]-z[i1];
					length=v1[0]*v1[0]+v1[1]*v1[1]+v1[2]*v1[2];
					cosa=dot(v1,ori);
					cosa/=sqrt(ori[0]*ori[0]+ori[1]*ori[1]+ori[2]*ori[2]);
					cosa/=sqrt(length);					 
					e+=(1-3*cosa*cosa)/(length*sqrt(length));
					ani_effect->at(jj).at(i).x[index->at(j).type-1]+=e*1000;
				}
			}
		}
	}

	return;
}

double CTraj::noedistance_frame(vector<int> *att1, vector<int> *att2,int j)
{

	double x0,y0,z0;
	double r2,r6,sum,sumsum;
	int i1,j1;
	int n1,n2;
	int jump;

	sumsum=0;
	for(i1=0;i1<(int)att1->size();i1++)
	for(j1=0;j1<(int)att2->size();j1++)
	{
		n1=att1->at(i1)-1;
		n2=att2->at(j1)-1;
		
		jump=j*natom;
		x0=x.at(jump+n1)-x.at(jump+n2);
		y0=y.at(jump+n1)-y.at(jump+n2);
		z0=z.at(jump+n1)-z.at(jump+n2);
		r2=x0*x0+y0*y0+z0*z0;
		r6=r2*r2*r2;
		sum=1.0/r6;
		sumsum+=sum;
	}
	sumsum/=i1;
	sumsum/=j1;
	r2=pow(sumsum,-1/6.0);
	return r2;
}

double CTraj::noedistance(vector<int> *att1, vector<int> *att2)
{
	double x0,y0,z0;
	double r2,r6,sum,sumsum;
	int i1,j1;
	int n1,n2;
	int j;
	int jump;

	sumsum=0;
	for(i1=0;i1<(int)att1->size();i1++)
	for(j1=0;j1<(int)att2->size();j1++)
	{
		n1=att1->at(i1)-1;
		n2=att2->at(j1)-1;

		sum=0.0;
		for(j=0;j<nframe;j++)
		{
			jump=j*natom;
			x0=x.at(jump+n1)-x.at(jump+n2);
			y0=y.at(jump+n1)-y.at(jump+n2);
			z0=z.at(jump+n1)-z.at(jump+n2);
			r2=x0*x0+y0*y0+z0*z0;
			r6=r2*r2*r2;
			sum+=1.0/r6;
		}
		sum/=nframe;
		sumsum+=sum;
	}
	sumsum/=i1;
	sumsum/=j1;
	r2=pow(sumsum,-1/6.0);
	return r2;
}


void CTraj::evaluatenmrcons_frame(vector<struct noeline> *nmrcons, double cutoff)
{
	int ii,i,j;
	int pos1,pos2;
	int n1,n2;
	vector<int> att1,att2;
	double d;
	ofstream fout("noe_frame.dat");


	for(ii=0;ii<nframe;ii++)
	{
		for(i=0;i<(int)nmrcons->size();i++)
		{	

			if(fabs((float)(nmrcons->at(i).resid1-nmrcons->at(i).resid2))<=2)
				continue;

			nmrcons->at(i).obs.clear();
			nmrcons->at(i).pos1.clear();
			nmrcons->at(i).pos2.clear();
			for(n1=0;n1<(int)nmrcons->at(i).index1.atoms.size();n1++)
			for(n2=0;n2<(int)nmrcons->at(i).index2.atoms.size();n2++)
			{
				att1=nmrcons->at(i).index1.atoms.at(n1);
				att2=nmrcons->at(i).index2.atoms.at(n2);
				nmrcons->at(i).obs.push_back(noedistance_frame(&att1,&att2,ii));
				nmrcons->at(i).pos1.push_back(att1.at(0));
				nmrcons->at(i).pos2.push_back(att2.at(0));
			}

			d=100000.0;
			pos1=pos2=0;
			for(j=0;j<nmrcons->at(i).obs.size();j++)
			{
				if(nmrcons->at(i).obs.at(j)<d)
				{
					d=nmrcons->at(i).obs.at(j);
					pos1=nmrcons->at(i).pos1.at(j);
					pos2=nmrcons->at(i).pos2.at(j);
				}
			}
			nmrcons->at(i).bvio=0;
			nmrcons->at(i).d=d;
			
			if(nmrcons->at(i).a+cutoff<d)
				fout<<d<<" ";
			else
				fout<<d<<" ";
		}
		fout<<endl;

	}
	fout.close();

	ofstream fout2("noe_frame_head.dat");
	for(i=0;i<(int)nmrcons->size();i++)
	{
		if(fabs((float)(nmrcons->at(i).resid1-nmrcons->at(i).resid2))<=2)
			continue;

		fout2<<nmrcons->at(i).resid1<<" ";
		fout2<<nmrcons->at(i).resname1<<" ";
		fout2<<nmrcons->at(i).atomname1<<" ";
		fout2<<nmrcons->at(i).resid2<<" ";
		fout2<<nmrcons->at(i).resname2<<" ";
		fout2<<nmrcons->at(i).atomname2<<" ";
		fout2<<nmrcons->at(i).b<<" ";
		fout2<<nmrcons->at(i).c<<" ";
		fout2<<nmrcons->at(i).a<<endl;
	}
	fout2.close();
	return;
}

void CTraj::evulatenmrcons(vector<struct noeline> *nmrcons, double cutoff)
{
	int i,j;
	int pos1,pos2;
	int n1,n2;
	vector<int> att1,att2;
	double d;
	ofstream fout("violation.dat");
	ofstream fout2("fullfilled.dat");
	ofstream fout3("grouped.dat");
	ofstream fchimera("for_chimera.dat");
	ofstream fchimera2("for_chimera2.dat");


	
	for(i=0;i<(int)nmrcons->size();i++)
	{	
		for(n1=0;n1<(int)nmrcons->at(i).index1.atoms.size();n1++)
		for(n2=0;n2<(int)nmrcons->at(i).index2.atoms.size();n2++)
		{
			att1=nmrcons->at(i).index1.atoms.at(n1);
			att2=nmrcons->at(i).index2.atoms.at(n2);
			nmrcons->at(i).obs.push_back(noedistance(&att1,&att2));
			nmrcons->at(i).pos1.push_back(att1.at(0));
			nmrcons->at(i).pos2.push_back(att2.at(0));
		}
	}

	for(i=0;i<(int)nmrcons->size();i++)
	{
		d=100000.0;
		pos1=pos2=0;
		for(j=0;j<nmrcons->at(i).obs.size();j++)
		{
			if(nmrcons->at(i).obs.at(j)<d)
			{
				d=nmrcons->at(i).obs.at(j);
				pos1=nmrcons->at(i).pos1.at(j);
				pos2=nmrcons->at(i).pos2.at(j);
			}
		}
		nmrcons->at(i).bvio=0;
		nmrcons->at(i).d=d;

		if(nmrcons->at(i).a+cutoff<d)
		{
			nmrcons->at(i).bvio=1;
			fout<<nmrcons->at(i).group<<" ";
			fout<<i<<" "<<nmrcons->at(i).resid1<<" "<<nmrcons->at(i).resname1<<" "<<nmrcons->at(i).atomname1<<" ";
			fout<<nmrcons->at(i).resid2<<" "<<nmrcons->at(i).resname2<<" "<<nmrcons->at(i).atomname2<<" ";
			fout<<d<<" "<<nmrcons->at(i).c<<" "<<nmrcons->at(i).a<<endl;
			if(abs(nmrcons->at(i).resid1-nmrcons->at(i).resid2)>2 && d-nmrcons->at(i).a>cutoff)
			{
				fchimera<<"distance @/serialNumber="<<pos1<<" @/serialNumber="<<pos2<<endl;
				fchimera<<"display :"<<nmrcons->at(i).resid1<<endl;
				fchimera<<"display :"<<nmrcons->at(i).resid2<<endl;
				fchimera2<<"distance :"<<nmrcons->at(i).resid1<<"@CA :"<<nmrcons->at(i).resid2<<"@CA"<<endl;
			}
		}
		else
		{		
			fout2<<nmrcons->at(i).group<<" ";
			fout2<<i<<" "<<nmrcons->at(i).resid1<<" "<<nmrcons->at(i).resname1<<" "<<nmrcons->at(i).atomname1<<" ";
			fout2<<nmrcons->at(i).resid2<<" "<<nmrcons->at(i).resname2<<" "<<nmrcons->at(i).atomname2<<" ";
			fout2<<d<<" "<<nmrcons->at(i).c<<" "<<nmrcons->at(i).a<<endl;
		}
	}

	int ngroup=nmrcons->at(i-1).group;
	int i1=0;
	int i2=0;


	for(i=0;i<=ngroup;i++)
	{
		for(;i1<nmrcons->size() && nmrcons->at(i1).group<=i;i1++)
		{
			if(nmrcons->at(i1).a+cutoff<nmrcons->at(i1).d)
			{
				fout3<<nmrcons->at(i1).group<<" ";
				fout3<<i1<<" "<<nmrcons->at(i1).resid1<<" "<<nmrcons->at(i1).resname1<<" "<<nmrcons->at(i1).atomname1<<" ";
				fout3<<nmrcons->at(i1).resid2<<" "<<nmrcons->at(i1).resname2<<" "<<nmrcons->at(i1).atomname2<<" ";
				fout3<<nmrcons->at(i1).d<<" "<<nmrcons->at(i1).c<<" "<<nmrcons->at(i1).a<<" VIOLATED "<<endl;
			}
		}
		

		for(;i2<nmrcons->size() && nmrcons->at(i2).group<=i;i2++)
		{
			if(nmrcons->at(i2).a+cutoff>=nmrcons->at(i2).d)
			{
				fout3<<nmrcons->at(i2).group<<" ";
				fout3<<i2<<" "<<nmrcons->at(i2).resid1<<" "<<nmrcons->at(i2).resname1<<" "<<nmrcons->at(i2).atomname1<<" ";
				fout3<<nmrcons->at(i2).resid2<<" "<<nmrcons->at(i2).resname2<<" "<<nmrcons->at(i2).atomname2<<" ";
				fout3<<nmrcons->at(i2).d<<" "<<nmrcons->at(i2).c<<" "<<nmrcons->at(i2).a<<endl;
			}
		}
		fout3<<endl;
	}
	
	fout.close();
	fout2.close();
	fout3.close();
	fchimera.close();
	fchimera2.close();


	return;
}


void CTraj::rmsd_matrix(vector< vector<double> > *rmsd,vector<int> *ca, int skip)
{
	float *x1,*y1,*z1,*x2,*y2,*z2;
	int nca,jumpi,jumpj;
	int i,j,k;
	vector< double> t;
	class CRmsd rmsdf;

	nca=ca->size();
	
	x1=new float[nframe*nca];
	x2=new float[nframe*nca];
	y1=new float[nframe*nca];
	y2=new float[nframe*nca];
	z1=new float[nframe*nca];
	z2=new float[nframe*nca];

	for(i=0;i<nframe;i++)
	{
		if((i+1)%skip==0)
		{
			
			t.clear();
			jumpi=i*natom-1;
			for(j=0;j<i;j++)
				t.push_back(rmsd->at(j).at(i));
			t.push_back(0.0);
			for(j=i+1;j<nframe;j++)
			{
				if((j+1)%skip==0)
				{
					jumpj=j*natom-1;
					for(k=0;k<nca;k++)
					{
						x1[k]=x[jumpi+ca->at(k)];
						y1[k]=y[jumpi+ca->at(k)];
						z1[k]=z[jumpi+ca->at(k)];

						x2[k]=x[jumpj+ca->at(k)];
						y2[k]=y[jumpj+ca->at(k)];
						z2[k]=z[jumpj+ca->at(k)];
					}

					t.push_back(rmsdf.calculate_rotation_rmsd(x1,y1,z1,x2,y2,z2,nca));
				}
			}
			rmsd->push_back(t);
		}
	}
	return;
}



void CTraj::getvector(vector<struct index_three> nh,vector<double> *xx,vector<double> *yy,vector<double> *zz)
{
	int i,m,j;
	double r;
	double x1,y1,z1;
	for(i=0;i<nframe;i++)
	{	
		m=i*natom-1;		
		for(j=0;j<nh.size();j++)
		{
			x1=x.at(m+nh.at(j).x3)-x.at(m+nh.at(j).x2);
			y1=y.at(m+nh.at(j).x3)-y.at(m+nh.at(j).x2);
			z1=z.at(m+nh.at(j).x3)-z.at(m+nh.at(j).x2);
			r=sqrt(x1*x1+y1*y1+z1*z1);
			if(r>0)
			{
				x1/=r;y1/=r;z1/=r;
			}	
			else
			{
				x1=1.0;y1=z1=0.0;
			}	
			xx->push_back(x1);
			yy->push_back(y1);
			zz->push_back(z1);		
		}
	}
}


void CTraj:: getcoor(int ipos,int iframe,double *xx,double *yy,double *zz)
{
	ipos+=iframe*natom-1;
	*xx=x.at(ipos);
	*yy=y.at(ipos);
	*zz=z.at(ipos);
}


void CTraj::getcoor(vector<int> pos,int iframe,vector<double> *xx,vector<double> *yy,vector<double> *zz)
{
	int j;
	int adj;
	unsigned int i;

	adj=iframe*natom-1;
	for(i=0;i<pos.size();i++)
	{
		j=pos.at(i)+adj;
		xx->push_back(x.at(j));
		yy->push_back(y.at(j));
		zz->push_back(z.at(j));
	}
	return;
}


void CTraj::getcoor(vector<int> pos,vector<float> *xx,vector<float> *yy,vector<float> *zz)
{
	int j;
	int adj;
	unsigned int i,iframe;

	for(iframe=0;iframe<nframe;iframe++)
	{
		adj=iframe*natom-1;
		for(i=0;i<pos.size();i++)
		{
			j=pos.at(i)+adj;
			xx->push_back(x.at(j));
			yy->push_back(y.at(j));
			zz->push_back(z.at(j));
		}
	}
	return;
}

void CTraj::getcoor(vector<int> pos,int iframe,vector<float> *xx,vector<float> *yy,vector<float> *zz)
{
	int j;
	int adj;
	unsigned int i;

	adj=iframe*natom-1;
	for(i=0;i<pos.size();i++)
	{
		j=pos.at(i)+adj;
		xx->push_back(x.at(j));
		yy->push_back(y.at(j));
		zz->push_back(z.at(j));
	}
	return;
}

void CTraj::get_contact(float rc,float shift, vector<int> pos, vector<int> used, vector<float> * result)
{
	int i,j;
	int ii,jj;
	float contact;
	float x0,y0,z0;
	float rr;

	int *used_arr = used.data();
	int used_size = used.size();
	double *x_arr = x.data();
	int x_size = x.size();
	double *y_arr = y.data();
	int y_size = y.size();
	double *z_arr = z.data();
	int z_size = z.size();

#pragma acc data copyin(used_arr[:used_size], \
 x_arr[:x_size], y_arr[:y_size], z_arr[:z_size])
	for(i=0;i<(int)pos.size();i++)
	{
		contact=0.0;
		ii=pos.at(i);
		if(ii<1)
		{
			result->push_back(-1.0);
			continue;
		}
		ii--;
		x0=x.at(ii);
		y0=y.at(ii);
		z0=z.at(ii);
#pragma acc parallel loop \
 private(jj, rr) \
 reduction(+:contact)
		for(j=0;j<used_size;j++)
		{
			jj=used_arr[j]-1;
			if(jj<0)
				continue;
			rr=(x_arr[jj]-x0)*(x_arr[jj]-x0)+(y_arr[jj]-y0)*(y_arr[jj]-y0)+(z_arr[jj]-z0)*(z_arr[jj]-z0);
			rr=sqrt(rr)-shift;
			contact+=exp(-rr/rc);				
		}
		result->push_back(contact);
	}

	return;
}


void CTraj::get_contact(vector<int> pos, vector<int> used, vector<float> * result)
{
	int i,j;
	int ii,jj;
	float contact;
	float x0,y0,z0;
	float rr;

	for(i=0;i<(int)pos.size();i++)
	{
		contact=0.0;
		ii=pos.at(i);
		if(ii<0)
		{
			result->push_back(-1.0);
			continue;
		}
		ii--;
		x0=x.at(ii);
		y0=y.at(ii);
		z0=z.at(ii);
		for(j=0;j<(int)used.size();j++)
		{
			jj=used.at(j);
			if(jj<0)
				continue;
			jj--;
			rr=(x.at(jj)-x0)*(x.at(jj)-x0)+(y.at(jj)-y0)*(y.at(jj)-y0)+(z.at(jj)-z0)*(z.at(jj)-z0);
			rr=sqrt(rr);
			contact+=exp(-rr/3.0);				
		}
		result->push_back(contact);
	}

	return;
}

void CTraj::get_contacts(vector<struct bb_group> bb, vector<struct index_two> index, vector<int> c2, vector<float> *results)
{
	int i,j,p;
	int ii,jj;
	float contact;
	float x0,y0,z0;
	float rr;

	bb_group* bb_arr = bb.data();
	int bb_size = bb.size();
	index_two* index_arr = index.data();
	int index_size = index.size();
	int* c2_arr = c2.data();
	int c2_size = c2.size();
	results->resize(index_size*3);
	float* results_arr = results->data();
	int results_size = results->size();
	double* x_arr = this->x.data();
	int x_size = this->x.size();
	double* y_arr = this->y.data();
	int y_size = this->y.size();
	double* z_arr = this->z.data();
	int z_size = this->z.size();

#pragma acc data copyin(bb_arr[:bb_size], index_arr[:index_size], \
 c2_arr[:c2_size], x_arr[:x_size], y_arr[:y_size], z_arr[:z_size]) \
 copyout(results_arr[:results_size])
{

#pragma acc parallel loop gang collapse(2) private(ii,x0,y0,z0,contact)
	for(i=1; i<index_size-1; i++)
	{
  	for(p=0; p<3; p++)
		{
			if(p==0) {
					ii=bb_arr[index_arr[i].x1-1].capos;
			} else if(p==1) {
					ii=bb_arr[index_arr[i].x1-1].cbpos;
			} else {
					ii=bb_arr[index_arr[i].x1-1].copos;
			}

			if(ii < 1 || ii > x_size) {
				results_arr[i*3+p]=-1.0;
				continue;
			}

			contact=0.0;

			ii--;
			x0=x_arr[ii];
			y0=y_arr[ii];
			z0=z_arr[ii];

#pragma acc loop vector private(jj,rr) reduction(+:contact)
			for(j=0;j<c2_size;j++)
			{
				jj=c2_arr[j];
				if(jj<=1 || jj>x_size) continue;

				jj--;
				rr=(x_arr[jj]-x0)*(x_arr[jj]-x0)+(y_arr[jj]-y0)*(y_arr[jj]-y0)+(z_arr[jj]-z0)*(z_arr[jj]-z0);
				rr=sqrt(rr);
				contact+=exp(-rr/3.0);			
			}

			results_arr[i*3+p]=contact;

		}
	}

} // end data

	return;

}	



CTraj::CTraj()
{
	natom=0;
	nres=0;
	nframe=0;
};

CTraj::~CTraj()
{
  double *tmp = x.data();
#pragma acc exit data delete(tmp)
  tmp = y.data();
#pragma acc exit data delete(tmp)
  tmp = z.data();
#pragma acc exit data delete(tmp)
#pragma acc exit data delete(this)
};







void smtry::getdata(double x[3][3],double y[3])
{
	int i,j;
	for(i=0;i<3;i++)
	for(j=0;j<3;j++)
		matrix[i][j]=x[i][j];
	for(i=0;i<3;i++)
		motion[i]=y[i];
	return;
}

void smtry::trans(double x[3],double y[3])
{
	for(int i=0;i<3;i++)
		y[i]=x[0]*matrix[i][0]+x[1]*matrix[i][1]+x[2]*matrix[i][2]+motion[i];
	return;
}

void smtry::print()
{
	int j;
	for(int i=0;i<3;i++)
	{
		for(j=0;j<3;j++)
			cout<<matrix[i][j]<<" ";
		cout<<motion[i]<<endl;
	}
	return ;
}





void CTraj2::clear()
{
	x.clear();
	y.clear();
	z.clear();
	b.clear();
	crystal_sym_array.clear();
	nframe=0;
	natom=0;
	nres=0;
	memset(translation,0,sizeof(double)*9);
	memset(scale,0,sizeof(double)*9);
	btrans=0;
	bsmtry=0;
}

int CTraj2::select(vector<int> t)
{	
	int i,j;
	int nmiss=0;
	vector<double> xx,yy,zz,bb;
	for(i=0;i<(int)t.size();i++)
	{
		j=t.at(i)-1;
		if(j>=0)
		{
			xx.push_back(x.at(j));
			yy.push_back(y.at(j));
			zz.push_back(z.at(j));
			bb.push_back(b.at(j));
		}
		else
		{
			nmiss++;
		}
	}
	x=xx;
	y=yy;
	z=zz;
	b=bb;
	natom=x.size();
	return nmiss;
}


int CTraj2::loadcoor(string filename)
{
	double xx,yy,zz,bb;
	string line,part,part1,part2;
	double cx[3][3];
	double cy[3];
	class smtry crystal_sym;
	crystal_sym_array.clear();


	ifstream fin(filename.c_str());
	while(getline(fin,line))
	{
		part1.clear();
		part2.clear();

		if(line.size()>18)
		{
			part1=line.substr(0,10);
			part2=line.substr(13,5);
		}
		if(part1=="REMARK 290" && part2=="SMTRY")
		{
			bsmtry=1;
			cx[0][0]=atof(line.substr(24,9).c_str());
			cx[0][1]=atof(line.substr(34,9).c_str());
			cx[0][2]=atof(line.substr(44,9).c_str());
			cy[0]=atof(line.substr(59,9).c_str());
			getline(fin,line);
			cx[1][0]=atof(line.substr(24,9).c_str());
			cx[1][1]=atof(line.substr(34,9).c_str());
			cx[1][2]=atof(line.substr(44,9).c_str());
			cy[1]=atof(line.substr(59,9).c_str());
			getline(fin,line);
			cx[2][0]=atof(line.substr(24,9).c_str());
			cx[2][1]=atof(line.substr(34,9).c_str());
			cx[2][2]=atof(line.substr(44,9).c_str());
			cy[2]=atof(line.substr(59,9).c_str());
			
			if(!(cx[0][0]==1 && cx[1][1]==1 && cx[2][2]==1 && cx[0][1]==0 && cx[1][0]==0 && cx[0][2]==0 && cx[2][0]==0
						  && cx[1][2]==0 && cx[2][1]==0 && cy[0]==0 && cy[1]==0 && cy[2]==0))
			{
				crystal_sym.getdata(cx,cy);crystal_sym_array.push_back(crystal_sym);
			}
		}

		if(line.size()>5)
			part1=line.substr(0,5);
		else
			part1.clear();
		if(part1=="SCALE")
		{
			scale[0][0]=atof(line.substr(10,10).c_str());
			scale[0][1]=atof(line.substr(20,10).c_str());
			scale[0][2]=atof(line.substr(30,10).c_str());
			getline(fin,line);
			scale[1][0]=atof(line.substr(10,10).c_str());
			scale[1][1]=atof(line.substr(20,10).c_str());
			scale[1][2]=atof(line.substr(30,10).c_str());
			getline(fin,line);
			scale[2][0]=atof(line.substr(10,10).c_str());
			scale[2][1]=atof(line.substr(20,10).c_str());
			scale[2][2]=atof(line.substr(30,10).c_str());
			process_tran();
			btrans=1;
		}
		if(part1=="CRYST")
		{
			part1=line.substr(67,4);
			ncry=atoi(part1.c_str());
		}

		if(line.size()>6)
			part=line.substr(0,6);
		else
			part.clear();
		if(part=="ENDMDL" || part=="END")
		{
			//finished read first molecule 
			if(x.size()%natom!=0)
				cout<<"In traj reading, suppose to read "<<natom<<" coors but actually read in "<<x.size()<<endl;
		}


		part=line.substr(0,6);
		if(part!="ATOM  " && part!="HETATM")
			continue;

		part=line.substr(17,3);
		if(part=="HOH" || part=="WAT")
			continue;

		part=line.substr(30,8);
		xx=atof(part.c_str());
		x.push_back(xx);
		part=line.substr(38,8);
		yy=atof(part.c_str());
		y.push_back(yy);
		part=line.substr(46,8);
		zz=atof(part.c_str());
		z.push_back(zz);
		part=line.substr(60,6);
		bb=atof(part.c_str());
		b.push_back(bb);
		part=line.substr(12,4);
		atomname.push_back(part);
	};

	if(natom==0)
		nframe=0;
	else
		nframe=x.size()/natom;
	return nframe;
}

void CTraj2::process_tran()
{
	if(scale[1][0]!=0 || scale[2][0]!=0 || scale[2][1]!=0)
		return;
		
	translation[0][0]=1/scale[0][0];
	translation[0][1]=-scale[0][1]/(scale[1][1]*scale[0][0]);
	translation[0][2]=(scale[0][1]*scale[1][2]/scale[1][1]-scale[0][2])/(scale[0][0]*scale[2][2]);

	translation[1][0]=0;
	translation[1][1]=1/scale[1][1];
	translation[1][2]=-scale[1][2]/(scale[1][1]*scale[2][2]);

	translation[2][0]=0;
	translation[2][1]=0;
	translation[2][2]=1/scale[2][2];
	
	return;
}



int CTraj2::unitcell(void)
{
	class smtry crystal_sym;
	double xmean,ymean,zmean;
	double xscale,yscale,zscale;
	double xtran,ytran,ztran;
	double yold[3];
	double ynew[3];
	int n;
	int i,j;


	n=x.size();
	for(i=0;i<(int)crystal_sym_array.size();i++)
	{
		xmean=ymean=zmean=0;
		crystal_sym=crystal_sym_array.at(i);			
		for(j=0;j<n;j++)
		{
			yold[0]=x.at(j);
			yold[1]=y.at(j);
			yold[2]=z.at(j);
			crystal_sym.trans(yold,ynew);
			x.push_back(ynew[0]);
			y.push_back(ynew[1]);
			z.push_back(ynew[2]);
			xmean+=ynew[0];
			ymean+=ynew[1];
			zmean+=ynew[2];				
		}
		xmean/=n;
		ymean/=n;
		zmean/=n;

		xscale=scale[0][0]*xmean+scale[0][1]*ymean+scale[0][2]*zmean;
		yscale=scale[1][0]*xmean+scale[1][1]*ymean+scale[1][2]*zmean;
		zscale=scale[2][0]*xmean+scale[2][1]*ymean+scale[2][2]*zmean;
		
		xscale= xscale>=0 ? -((int)xscale) : -((int)(xscale-0.9999));
		yscale= yscale>=0 ? -((int)yscale) : -((int)(yscale-0.9999));
		zscale= zscale>=0 ? -((int)zscale) : -((int)(zscale-0.9999));	
		
		
		xtran=xscale*translation[0][0]+yscale*translation[0][1]+zscale*translation[0][2];
		ytran=yscale*translation[1][1]+zscale*translation[1][2];
		ztran=zscale*translation[2][2];
		
		for(j=0;j<natom;j++)
		{
			x.at(j+natom*(i+1))+=xtran;
			y.at(j+natom*(i+1))+=ytran;
			z.at(j+natom*(i+1))+=ztran;
		}			
	}

	return i;
}

void CTraj2::ninecells(void)
{
	int i,m,k,n;
	double xtran,ytran,ztran;
	int nnow;

	nnow=x.size();

	for(m=-1;m<=1;m++)
	for(n=-1;n<=1;n++)
	for(k=-1;k<=1;k++)
	{
		if(m==0 && n==0 && k==0)
			continue;
		xtran=m*translation[0][0]+n*translation[0][1]+k*translation[0][2];
		ytran=n*translation[1][1]+k*translation[1][2];
		ztran=k*translation[2][2];
		for(i=0;i<nnow;i++)
		{
			x.push_back(x.at(i)+xtran);
			y.push_back(y.at(i)+ytran);
			z.push_back(z.at(i)+ztran);
		}
	}
	return;
}


CTraj2::CTraj2()
{
	x.clear();
	y.clear();
	z.clear();
	b.clear();
	crystal_sym_array.clear();
	nframe=0;
	natom=0;
	nres=0;
	memset(translation,0,sizeof(double)*9);
	memset(scale,0,sizeof(double)*9);
	btrans=0;
	bsmtry=0;
};

CTraj2::~CTraj2()
{

};

########## NEXT FILE ##########
#include <iostream>
#include <cstdlib>
#include <fstream>
#include <string>
#include <cstring>
#include <vector>
#include <math.h>
#include <time.h>
#include <sstream>

using namespace std;
#include "lmmin.h"
#include "config.h"
#include "supply.h"
#include "bmrb.h"
#include  "aa.h"
#include "pdb.h"
#include "traj.h"
#include "mainbody.h"

#include "debug.h"

#ifdef BENCHMARK
#include <omp.h>
#endif

// ///////////////////////////////////////////////////////////////////////////////////////////////////////////
int main(int argc, char ** argv)
{
	int begin,stop;
	bool bh,bdetail,bnew,bann,btest,bnew_pdb,blinear,bold;
	class CMainbody mainbody;
	string pdbname;
	string spartaname;
	string gmxname;
	string bmrbname;
	int para;
	int nconf;

	cout<<"PPM: an enemble-based chemical shifts predictor"<<endl;

#ifdef BENCHMARK
	double clock = omp_get_wtime();
#endif

	bh=bdetail=bnew=btest=bnew_pdb=bann=blinear=bold=0;

	CCommandline cmdline;
	vector<string> args,args2,args3;

	args.push_back("-h");		args2.push_back("no");						args3.push_back("print help informaiton then quit");
	args.push_back("-mode");	args2.push_back("ann");						args3.push_back("prediciton algorithm: ann(default) or linear");
	args.push_back("-pdb");		args2.push_back("pdb.pdb");					args3.push_back("input pdb file name");
	args.push_back("-bmrb");	args2.push_back("bmrb.dat");				args3.push_back("input experimental chemical shifts file in NMRSTAR format");
    args.push_back("-pre");		args2.push_back("bmrb_pre.dat");			args3.push_back("output filename for predicted chemical shifts in NMRSTAR format");
	args.push_back("-begin");	args2.push_back("0");						args3.push_back("Index of first snapshot to be used (start from 0)");
	args.push_back("-stop");	args2.push_back("0");						args3.push_back("Index of last snapshot to be used (0 means last snapshot)");
	args.push_back("-para");	args2.push_back("pdb");                     args3.push_back("Parameter set: pdb(ppm_one) or old(ppm)");
    args.push_back("-detail(s)");	args2.push_back("no");					args3.push_back("calculate chemical shifts for each snapshots, only applicable to ensemble predictions");

		
	cmdline.init(args,args2,args3);
	cmdline.pharse(argc,argv);


	spartaname="sparta.pdb";
	pdbname=cmdline.query("-pdb");
	bmrbname=cmdline.query("-bmrb");
	begin=atoi(cmdline.query("-begin").c_str());
	stop=atoi(cmdline.query("-stop").c_str());
    


	if(cmdline.query("-h").compare("yes")==0)		bh=1;
	if(cmdline.query("-mode").compare("linear")==0)		{blinear=1;bann=0;}
	if(cmdline.query("-mode").compare("ann")==0)		{blinear=0;bann=1;}


	if(cmdline.query("-para").compare("pdb")==0)		para=2;
	if(cmdline.query("-para").compare("old")==0)		bold=1;
    
    if(cmdline.query("-detail").compare("yes")==0)		bdetail=1;
    if(cmdline.query("-details").compare("yes")==0)		bdetail=1;



	cmdline.print();

	if(bh==1)
	{	
		exit(0);
	}


	nconf=mainbody.loadpdb(pdbname,gmxname);
	mainbody.set_range(begin,stop);
	mainbody.load(bmrbname);




	if(bold)  //previous generation PPM
	{
		cout<<"Prediction using the old PPM parameters\n";
		cout<<"Chemical shifts root-mean-square deviations (RMSDs) between predicted and experimental values:"<<endl;
        if(bdetail)
        {
            mainbody.predict_proton2();
            mainbody.predict_bb2();
        }
        else
        {
            mainbody.predict_proton();
            mainbody.predict_bb();
        }
		mainbody.print_prediction(cmdline.query("-pre"));
	}
	else if(blinear && para==2)
	{
		cout<<"Prediction using the linear model with static parameters set\n";
		cout<<"Chemical shifts root-mean-square deviations (RMSDs) between predicted and experimental values:"<<endl;
		mainbody.predict_bb_static_new();
		mainbody.predict_proton_static_new();
		mainbody.print_prediction(cmdline.query("-pre"));
	}


	else if(bann && para==2)
	{
		cout<<"Prediction using the ANN model with static parameters set\n";
		cout<<"Chemical shifts root-mean-square deviations (RMSDs) between predicted and experimental values:"<<endl;
		mainbody.predict_bb_static_ann();
		mainbody.predict_proton_static_new();
		mainbody.print_prediction(cmdline.query("-pre"));
	}

	else
	{
		cout<<"Unrecognized command line arguments!\n";
	}

#ifdef BENCHMARK
	printf("Total runtime: %.4f\n", omp_get_wtime()-clock);
#endif

	return 0;
}










########## NEXT FILE ##########
#include <iostream>
#include <cstdlib>
#include <fstream>
#include <string>
#include <cstring>
#include <vector>
#include <math.h>
#include <time.h>
#include <sstream>

using namespace std;
#include "lmmin.h"
#include "config.h"
#include "supply.h"
#include "bmrb.h"
#include  "aa.h"
#include "pdb.h"
#include "traj.h"
#include "mainbody.h"

#include "debug.h"

#ifdef BENCHMARK
#include <omp.h>
#endif

// ///////////////////////////////////////////////////////////////////////////////////////////////////////////
int main(int argc, char ** argv)
{
	int begin,stop;
	bool bh,bdetail,bnew,bann,btest,bnew_pdb,blinear,bold;
	class CMainbody mainbody;
	string pdbname;
	string spartaname;
	string gmxname;
	string bmrbname;
	int para;
	int nconf;

	cout<<"PPM: an enemble-based chemical shifts predictor"<<endl;

#ifdef BENCHMARK
	double clock = omp_get_wtime();
#endif

	bh=bdetail=bnew=btest=bnew_pdb=bann=blinear=bold=0;

	CCommandline cmdline;
	vector<string> args,args2,args3;

	args.push_back("-h");		args2.push_back("no");						args3.push_back("print help informaiton then quit");
	args.push_back("-mode");	args2.push_back("ann");						args3.push_back("prediciton algorithm: ann(default) or linear");
	args.push_back("-pdb");		args2.push_back("pdb.pdb");					args3.push_back("input pdb file name");
	args.push_back("-bmrb");	args2.push_back("bmrb.dat");				args3.push_back("input experimental chemical shifts file in NMRSTAR format");
    args.push_back("-pre");		args2.push_back("bmrb_pre.dat");			args3.push_back("output filename for predicted chemical shifts in NMRSTAR format");
	args.push_back("-begin");	args2.push_back("0");						args3.push_back("Index of first snapshot to be used (start from 0)");
	args.push_back("-stop");	args2.push_back("0");						args3.push_back("Index of last snapshot to be used (0 means last snapshot)");
	args.push_back("-para");	args2.push_back("pdb");                     args3.push_back("Parameter set: pdb(ppm_one) or old(ppm)");
    args.push_back("-detail(s)");	args2.push_back("no");					args3.push_back("calculate chemical shifts for each snapshots, only applicable to ensemble predictions");

		
	cmdline.init(args,args2,args3);
	cmdline.pharse(argc,argv);


	spartaname="sparta.pdb";
	pdbname=cmdline.query("-pdb");
	bmrbname=cmdline.query("-bmrb");
	begin=atoi(cmdline.query("-begin").c_str());
	stop=atoi(cmdline.query("-stop").c_str());
    


	if(cmdline.query("-h").compare("yes")==0)		bh=1;
	if(cmdline.query("-mode").compare("linear")==0)		{blinear=1;bann=0;}
	if(cmdline.query("-mode").compare("ann")==0)		{blinear=0;bann=1;}


	if(cmdline.query("-para").compare("pdb")==0)		para=2;
	if(cmdline.query("-para").compare("old")==0)		bold=1;
    
    if(cmdline.query("-detail").compare("yes")==0)		bdetail=1;
    if(cmdline.query("-details").compare("yes")==0)		bdetail=1;



	cmdline.print();

	if(bh==1)
	{	
		exit(0);
	}


	nconf=mainbody.loadpdb(pdbname,gmxname);
	mainbody.set_range(begin,stop);
	mainbody.load(bmrbname);




	if(bold)  //previous generation PPM
	{
		cout<<"Prediction using the old PPM parameters\n";
		cout<<"Chemical shifts root-mean-square deviations (RMSDs) between predicted and experimental values:"<<endl;
        if(bdetail)
        {
            mainbody.predict_proton2();
            mainbody.predict_bb2();
        }
        else
        {
            mainbody.predict_proton();
            mainbody.predict_bb();
        }
		mainbody.print_prediction(cmdline.query("-pre"));
	}
	else if(blinear && para==2)
	{
		cout<<"Prediction using the linear model with static parameters set\n";
		cout<<"Chemical shifts root-mean-square deviations (RMSDs) between predicted and experimental values:"<<endl;
		mainbody.predict_bb_static_new();
		mainbody.predict_proton_static_new();
		mainbody.print_prediction(cmdline.query("-pre"));
	}


	else if(bann && para==2)
	{
		cout<<"Prediction using the ANN model with static parameters set\n";
		cout<<"Chemical shifts root-mean-square deviations (RMSDs) between predicted and experimental values:"<<endl;
		mainbody.predict_bb_static_ann();
		mainbody.predict_proton_static_new();
		mainbody.print_prediction(cmdline.query("-pre"));
	}

	else
	{
		cout<<"Unrecognized command line arguments!\n";
	}

#ifdef BENCHMARK
	printf("Total runtime: %.4f\n", omp_get_wtime()-clock);
#endif

	return 0;
}










########## NEXT FILE ##########
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <string>
#include <vector>
#include <math.h>
#include <time.h>
#include <sstream>
using namespace std;

#include "ann.h"
#include "mainbody.h"

#include "debug.h"

#ifdef BENCHMARK
#include <omp.h>
#endif



//class Dihe_process, used by ppm only

void CDihe_process::init(vector<int> innum,vector<double> *indihe)
{
	num=innum;
	dihe=indihe;
	if(num.size()>2)
	{
		ndihe=num.at(num.size()-1);
		nframe=dihe->size()/ndihe;
	}
	else
	{
		ndihe=0;
		nframe=0;
	}

	return;
}

void CDihe_process::init(vector<int> innum,vector<double> *indihe, vector<dihe_group> *indihe_index)
{
	num=innum;
	dihe=indihe;
	dihe_index=indihe_index;

	if(num.size()>2)
	{
		ndihe=num.at(num.size()-1);
		nframe=dihe->size()/ndihe;
	}
	else
	{
		ndihe=0;
		nframe=0;
	}

	return;
}

void CDihe_process::init(vector<int> innum,vector<double> *indihe, vector<double> *inangle)
{
	num=innum;
	dihe=indihe;
	angle=inangle;
	if(num.size()>2)
	{
		ndihe=num.at(num.size()-1);
		nframe=dihe->size()/ndihe;
	}
	else
	{
		ndihe=0;
		nframe=0;
	}

	return;
}


void CDihe_process::hb_expand(int type)
{
	int i;
	int begin,stop;
	vector<double> temp;

	begin=table[type]*8;
	stop=table[type]*8+8;

	if(stop==0)
	{
		out.clear();
		out.resize(18*8,0.0);
	}
	else
	{
		temp.resize(18*8,0.0);
		for(i=begin;i<stop;i++)
			temp.at(i)=out.at(i-begin);
		out=temp;
	}

	return;
}

void CDihe_process::hb_expand2(int type)
{
    int i;
    int begin,stop;
    vector< vector<double> > temp;
    vector<double> t;
    
    t.resize(nframe,0.0);
    
    begin=table[type]*8;
    stop=table[type]*8+8;
    
    if(stop==0)
    {
        out2.clear();
        out2.resize(18*8,t);
    }
    else
    {
        temp.resize(18*8,t);
        for(i=begin;i<stop;i++)
            temp.at(i)=out2.at(i-begin);
        out2=temp;
    }
    
    return;
}


vector<int> CDihe_process::pos(int in)
{
	int i;
	int base,stop;
	vector<int> out;


	if(in==1)
		base=1;
	else
		base=num.at(in-2)+1;
	
	stop=num.at(in-1);

	if(in<=0)
		base=num.at(num.size()-1)+100;
	if(in>(int)num.size())
		base=num.at(num.size()-1)+100;

	
	for(i=base;i<=stop;i++)
	{
		out.push_back(i);
		//cout<<"in is "<<in<<" "<<i<<endl;
	}

	return out;
}


vector<int> CDihe_process::pos_angle(int in)
{
	int i;
	int base,stop;
	vector<int> out;


	if(in==1)
		base=1;
	else
		base=num.at(in-2)*2+1;
	
	stop=num.at(in-1)*2;

	if(in<=0)
		base=num.at(num.size()-1)+100;
	if(in>(int)num.size())
		base=num.at(num.size()-1)+100;

	
	for(i=base;i<=stop;i++)
	{
		out.push_back(i);
		//cout<<"in is "<<in<<" "<<i<<endl;
	}

	return out;
}

void CDihe_process::allproton(int id)
{
	out.clear();
	process(id,2,2,2);
	return;
}

void CDihe_process::allproton2(int id)
{
    out2.clear();
    process2(id,2,2,2);
    return;
}

bool CDihe_process::test_good(int id,int cut)
{
	bool r;
	vector<int> index;
	int t,i;

	index=pos(id);

	if((int)index.size()>=cut)
		t=cut;
	else
		t=index.size();

	r=1;
	for(i=0;i<t;i++)
	{
		if(dihe_index->at(index.at(i)-1).bgood==0)
			r=0;
	}

	return r;
}


bool CDihe_process::test(int id, int t1, int t2)
{
	bool r;
	if(test_good(id-1,t2) && test_good(id,t1) && test_good(id+1,t2) )
		r=1;
	else
		r=0;
	return r;
}


bool CDihe_process::test_proton(int id, int type)
{
	return ((table[type]==-1) || test_good(id,2));
}


bool CDihe_process::ca_static_new(int id)
{
	out.clear();
	bool r;

	if(test_good(id-1,3) && test_good(id,4) && test_good(id+1,3) )
	{
		process_static_new(id-1,3,2,2);
		process_static_new(id  ,4,3,3);
		process_static_new(id+1,3,2,2);
		r=1;
	}
	else
		r=0;

	return r;
	
}

void CDihe_process::md_new(int id)
{
	out.clear();

	process_static_new(id-1,4,2,2);
	process_static_new(id  ,4,3,3);
	process_static_new(id+1,4,2,2);
  	return;
}

void CDihe_process::md_new_detail(int id, int n)
{
	out.clear();
    
	process_md_sep(n,id-1,4,2,2);
	process_md_sep(n,id  ,4,3,3);
	process_md_sep(n,id+1,4,2,2);
  	return;
}


void CDihe_process::ca(int id)
{
	out.clear();

	process(id-1,3,3,3);
	process(id  ,4,3,3);
	process(id+1,3,3,3);
  	return;
}



void CDihe_process::ca_ann(int id)
{
	out.clear();

	process_static_new(id-1,4,1,1);
	process_static_new(id  ,4,2,2);
	process_static_new(id+1,4,1,1);
  	return;
}

void CDihe_process::md_ann(int id,int n)
{
	out.clear();
	process_md_sep(n,id-1,4,1,1);
	process_md_sep(n,id  ,4,1,1);
	process_md_sep(n,id+1,4,1,1);
	return;
}


void CDihe_process::process_md_sep(int nn,int id,int cut, int order1, int order2)
{
	int i,ii,j,p;
	int base;
	int t;
	double phi;
	int order;
	vector<int> index;
	vector<double> temp;

	index=pos(id);
	if((int)index.size()>=cut)
		t=cut;
	else
		t=index.size();


	for(i=0;i<t;i++)
	{
		p=index.at(i);
		order=order1;
		if(i>1) order=order2;

		for(ii=1;ii<=order;ii++)
		{
			j=nn;
			base=j*ndihe;
			phi=dihe->at(base+p-1);
			out.push_back(cos(phi*ii));
			
			j=nn;
			base=j*ndihe;
			phi=dihe->at(base+p-1);
			out.push_back(sin(phi*ii));
		}
	}

	for(i=t;i<cut;i++)
	{
		for(ii=1;ii<=order2;ii++)
		{
			out.push_back(0.0);
			out.push_back(0.0);
		}
	}

	return;
}

void CDihe_process::process(int id,int cut,int order,int order2)
{
	int p,i,j,k,t,base;
	vector<int> index;
	double phi;
	double cosphi[10];
	double sinphi[10];

	

	index=pos(id);
	if((int)index.size()>=cut)
		t=cut;
	else
		t=index.size();

	for(i=0;i<2;i++)
	{
		p=index.at(i);
		for(k=1;k<=order;k++)
			cosphi[k]=sinphi[k]=0.0;
		for(j=0;j<nframe;j++)
		{
			base=j*ndihe;
			phi=dihe->at(base+p-1);
			for(k=1;k<=order;k++)
			{
				cosphi[k]+=cos(phi*k);
				sinphi[k]+=sin(phi*k);
			}
		}
		for(k=1;k<=order;k++)
		{
			out.push_back(cosphi[k]/nframe);
		}
		for(k=1;k<=order;k++)
		{
			out.push_back(sinphi[k]/nframe);
		}
	}

	for(i=2;i<t;i++)
        {
                p=index.at(i);
                for(k=1;k<=order2;k++)
                        cosphi[k]=sinphi[k]=0.0;
                for(j=0;j<nframe;j++)
                {
                        base=j*ndihe;
                        phi=dihe->at(base+p-1);
                        for(k=1;k<=order2;k++)
                        {
                                cosphi[k]+=cos(phi*k);
                                sinphi[k]+=sin(phi*k);
                        }
                }
                for(k=1;k<=order2;k++)
                {
                        out.push_back(cosphi[k]/nframe);
                }
                for(k=1;k<=order2;k++)
                {
                        out.push_back(sinphi[k]/nframe);
                }
        }

	for(i=t;i<cut;i++)
	{
		for(j=0;j<order2*2;j++)
			out.push_back(0.0);
	}
}


void CDihe_process::process_static_new(int id,int cut,int order,int order2)
{
	int p,i,j,k,t,base;
	vector<int> index;
	double phi;
	double cosphi[10];
	double sinphi[10];


	index=pos(id);
	if((int)index.size()>=cut)
		t=cut;
	else
		t=index.size();

	for(i=0;i<2;i++)
	{
		p=index.at(i);
		for(k=1;k<=order;k++)
			cosphi[k]=sinphi[k]=0.0;
		for(j=0;j<nframe;j++)
		{
			base=j*ndihe;
			phi=dihe->at(base+p-1);
			for(k=1;k<=order;k++)
			{
				cosphi[k]+=cos(phi*k);
				sinphi[k]+=sin(phi*k);
			}
		}
		for(k=1;k<=order;k++)
		{
			out.push_back(cosphi[k]/nframe);
			out.push_back(sinphi[k]/nframe);
		}
	}

	for(i=2;i<t;i++)
        {
                p=index.at(i);
                for(k=1;k<=order2;k++)
                        cosphi[k]=sinphi[k]=0.0;
                for(j=0;j<nframe;j++)
                {
                        base=j*ndihe;
                        phi=dihe->at(base+p-1);
                        for(k=1;k<=order2;k++)
                        {
                                cosphi[k]+=cos(phi*k);
                                sinphi[k]+=sin(phi*k);
                        }
                }
                for(k=1;k<=order2;k++)
                {
                        out.push_back(cosphi[k]/nframe);
						out.push_back(sinphi[k]/nframe);
                }
        }

	for(i=t;i<cut;i++)
	{
		for(j=0;j<order2*2;j++)
			out.push_back(0.0);
	}
}

void CDihe_process::proton(int id)
{
	out2.clear();
	process_fit(id,7);
  	return;
}


void CDihe_process::ca2(int id)
{
	out2.clear();

	process2(id-1,3,3,3);
	process2(id  ,4,3,3);
	process2(id+1,3,3,3);
  	return;
}

void CDihe_process::for_fit(int id)
{
	out2.clear();

	process_fit(id-1,4);
	process_fit(id,4);
	process_fit(id+1,4);
	return;
}


void CDihe_process::fit_angle(int id)
{
	int i,j,p,base;
	vector<int> index;
	vector<double> temp;
	double phi;

	index=pos_angle(id);

	out2.clear();

	int touse[5]={0,1,3,4,5};

	
	for(i=0;i<5;i++)
	{
		if(touse[i]<(int)index.size())
		{
			p=index.at(touse[i]);
			temp.clear();
			for(j=0;j<nframe;j++)
			{
				base=j*ndihe*2;
				phi=angle->at(base+p-1);
				temp.push_back(phi);
			}
			out2.push_back(temp);
		}
		else
		{
			temp.clear();
			for(j=0;j<nframe;j++)
			{
				temp.push_back(0.0);
			}
			out2.push_back(temp);
		}

	}

}


void CDihe_process::process_fit(int id,int cut)
{
	int i,j,p;
	int base;
	int t;
	double phi;
	vector<int> index;
	vector<double> temp;

	index=pos(id);
	if((int)index.size()>=cut)
		t=cut;
	else
		t=index.size();


	for(i=0;i<t;i++)
	{
		p=index.at(i);
		temp.clear();
		for(j=0;j<nframe;j++)
		{
			base=j*ndihe;
			phi=dihe->at(base+p-1);
			temp.push_back(phi);
		}
		out2.push_back(temp);
	}

	for(i=t;i<cut;i++)
	{
		temp.clear();
		for(j=0;j<nframe;j++)
		{
			temp.push_back(0.0);
		}
		out2.push_back(temp);
	}

	return;
}





void CDihe_process::process2(int id,int cut,int order,int order2)
{
	int p,i,j,k,t,base;
	vector<int> index;
	double phi;
	vector< vector<double> > t1,t2;

	

	index=pos(id);
	if((int)index.size()>=cut)
		t=cut;
	else
		t=index.size();

	for(i=0;i<2;i++)
	{
		p=index.at(i);
		t1.clear();
		t2.clear();
		t1.resize(order);
		t2.resize(order);
		for(j=0;j<nframe;j++)
		{
			base=j*ndihe;
			phi=dihe->at(base+p-1);
			for(k=1;k<=order;k++)
			{
				t1.at(k-1).push_back(cos(phi*k));
				t2.at(k-1).push_back(sin(phi*k));
			}
		}
		for(k=1;k<=order;k++)
		{
			out2.push_back(t1.at(k-1));
		}
		for(k=1;k<=order;k++)
		{
			out2.push_back(t2.at(k-1));
		}
	}

	for(i=2;i<t;i++)
    {
		p=index.at(i);
		t1.clear();
		t2.clear();
		t1.resize(order2);
		t2.resize(order2);
		for(j=0;j<nframe;j++)
        {
			base=j*ndihe;
            phi=dihe->at(base+p-1);
            for(k=1;k<=order2;k++)
            {
				t1.at(k-1).push_back(cos(phi*k));
				t2.at(k-1).push_back(sin(phi*k));
			}
		}
        for(k=1;k<=order2;k++)
		{
			out2.push_back(t1.at(k-1));
		}
        for(k=1;k<=order2;k++)
        {
			out2.push_back(t2.at(k-1));
		}
    }

	for(i=t;i<cut;i++)
	{
		t1.clear();
		t2.clear();
		t1.resize(order2);
		t2.resize(order2);
		for(j=0;j<nframe;j++)
		{
			for(k=1;k<=order2;k++)
            {
				t1.at(k-1).push_back(0.0);
				t2.at(k-1).push_back(0.0);
			}
		}
		for(k=1;k<=order2;k++)
		{
			out2.push_back(t1.at(k-1));
		}
        for(k=1;k<=order2;k++)
        {
			out2.push_back(t2.at(k-1));
		}
	}
}

vector<double> CDihe_process::output()
{
	return out;
}

vector< vector<double> > CDihe_process::output2()
{
	return out2;
}

CDihe_process::CDihe_process(void)
{
	int i;
	table=new int[98+1];
	for(i=0;i<98+1;i++)
		table[i]=-1;

	for(i=0;i<18;i++)
		table[hbs[i]]=i;

};


CDihe_process::~CDihe_process(void)
{
	delete [] table ;
};



CMainbody::CMainbody()
{
	int i;

	bnew=0;
	
	sep_table=new int[98+1];
	for(i=0;i<98+1;i++)
		sep_table[i]=-1;

	for(i=0;i<19;i++)
		sep_table[sep[i]]=i;
};

CMainbody::~CMainbody()
{
	if(bnew)
	{
		delete pdb;
		delete traj;
	}
	delete [] sep_table;
};



int CMainbody::loadpdb(CPdb *p_pdb, CTraj * p_traj)
{
	pdb=p_pdb;
	traj=p_traj;

	natom=pdb->getnatom();
	nres=pdb->getnres();
	nconf=traj->getnframe();

	return nconf;
}



int CMainbody::loadpdb(string name)
{
	pdb=new CPdb;
	traj=new CTraj;
	bnew=1;

	natom=pdb->loadpdb(name);
	nres=pdb->getnres();
	traj->setnres(nres);
	traj->setnatom(natom);
	nconf=traj->loadcoor(name);
	return nconf;
}

int CMainbody::loadpdb(string name,string name2)
{
	pdb=new CPdb;
	traj=new CTraj;
	bnew=1;

	pdb_name=name;

	natom=pdb->loadpdb(name);
	nres=pdb->getnres();
	traj->setnres(nres);
	traj->setnatom(natom);

	
	
    nconf=traj->loadcoor(name);


	return nconf;
}




void CMainbody::load(string bmrbname)
{
	bmrb.process(bmrbname.c_str());
	pdb->attach_bmrb(bmrb);
	pdb->getdihe(&dihe_index,&dihe_num);
	pdb->getring(&ring_index);
	pdb->ani(&anistropy);
	pdb->proton(&protons);
	pdb->allproton(&allprotons);
	pdb->process_ambig(2);
	pdb->allproton3(&allprotons3);
	heavy=pdb->getheavy();
	pdb->getbb(&bb);
	pdb->bbnh(&bbnh);
	pdb->bbhbond(&hbond);
	pdb->schbond(&hbond);  //This is new !
	ndihe=dihe_index.size();
	traj->getdihe(&dihe_index,&dihe);
	dihe_process.init(dihe_num,&dihe,&dihe_index);
	//process bb to remove all entry that has missing part !!
	//bbnh willn't take effect if bb is not there for particular residue
	bb=clear(bb);
	allprotons=clear(allprotons);
	allprotons3=clear(allprotons3);

	//seperate ring group to two, one for internal, one for surface, according to contact sum !
	int i;
	vector<int> ring_atom;
	vector<float> result;
	ring_atom.clear();
	result.clear();
	for(i=0;i<(int)ring_index.size();i++)
	{
		ring_atom.push_back(ring_index.at(i).x2);
	}
#ifdef BENCHMARK
	double clock = omp_get_wtime();
#endif
	traj->get_contact(1.00,0.0,ring_atom,heavy,&result);
#ifdef BENCHMARK
	printf("%.4f traj->get_contact\n", omp_get_wtime()-clock);
#endif
	ring_index_internal.clear();
	ring_index_external.clear();

	for(i=0;i<(int)ring_index.size();i++)
	{
		if(result.at(i)>2.5)
			ring_index_internal.push_back(ring_index.at(i));
		else
			ring_index_external.push_back(ring_index.at(i));
	}

	return;
}

vector<struct proton> CMainbody::clear(vector<struct proton> &protons)
{
	int i;
	int id,type;
	vector<struct proton> newprotons;
	newprotons.reserve(protons.size());

	for(i=0;i<protons.size();i++)
	{
		id=protons.at(i).id;
		type=protons.at(i).type;

		if(id<1 || id>pdb->getnres())
		{
			//protons.erase(protons.begin()+i);
			continue;
		}
		if(dihe_process.test_proton(id,type)==0) //==0 means missing dihedral angles in this calculation !!
		{
			//protons.erase(protons.begin()+i);
			continue;
		}
		newprotons.push_back(protons.at(i));
	}
	return newprotons;
}


vector<struct bb_group> CMainbody::clear(vector<struct bb_group> &bb)
{
	int i;
	int id;
	char code,code_pre,code_fol;
	vector<struct bb_group> newbb;
	newbb.reserve(bb.size());
	
	for(i=0;i<bb.size();i++)
	{
		//cout<<i<<endl;
		id=bb.at(i).id;

		//first and last residue are excluded
		if(id<=1)
		{
			//bb.erase(bb.begin()+i);
			continue;
		}
		if(id>=pdb->getnres())
		{
			//bb.erase(bb.begin()+i);
			continue;
		}

		code=pdb->code(id);
		code_pre=pdb->code(id-1);
		code_fol=pdb->code(id+1);

		//previous or following residue actually belong to another chain. 
		if(pdb->chain(id)!=pdb->chain(id-1) || pdb->chain(id)!=pdb->chain(id+1))
		{
			//bb.erase(bb.begin()+i);
			continue;
		}

		//missing or unknow residue should NOT be predicted. This is also true if either previous or following residue is missing (or unknown)
		if(code_pre=='X' || code_pre=='B' || code_fol=='X' || code_fol=='B'|| code=='X' || code=='B')
		{
			//bb.erase(bb.begin()+i);
			continue;
		}

		if(dihe_process.test(id,4,4)==0) //==0 means missing dihedral angles in this calculation !!
		{
			//bb.erase(bb.begin()+i);
			continue;
		}

		if(bb.at(i).capos<0 ||  bb.at(i).copos<0 || bb.at(i).npos<0 )
		{
			//bb.erase(bb.begin()+i);
			continue;
		}

		if(bb.at(i).cbpos<0 && bb.at(i).code!='G')
		{
			//bb.erase(bb.begin()+i);
			continue;
		}

		if(bb.at(i).hpos<0 && bb.at(i).code!='P')
		{
			//bb.erase(bb.begin()+i);
			continue;
		}

		newbb.push_back(bb.at(i));

	}

	return newbb;
}



int CMainbody::set_range(int begin,int stop)
{
	nconf=traj->set_range(begin,stop);
	return nconf;
}





void CMainbody::predict_bb()
{
	int i,j,j2,jj;
	int id;
	char code;
	vector<double> out;
	vector<double> in,in2;
	vector<struct double_five> ring_effect;
	vector<struct ehbond> hbond_effect;
	vector<struct double_four> ani_effect;
	vector<struct index_two> index;
	double pre[6];
	double temp;
	vector<double> eca,ecb,eco,eh,en;
	

	traj->gethbond(&hbond,&hbond_effect);
	traj->getani(&anistropy,&bbnh,&ani_effect);
	traj->getring(&ring_index,&bbnh,&ring_effect);

	
	/*carbon=bb_ca; exp.loadexp_bb("exp_ca.dat",&bb,carbon);
	carbon=bb_cb; exp.loadexp_bb("exp_cb.dat",&bb,carbon);
	carbon=bb_co; exp.loadexp_bb("exp_co.dat",&bb,carbon);
	exp.loadexp_bbn("exp_n.dat",&bbnh);
	exp.loadexp_bbnh("exp_hn.dat",&bbnh);*/


	index.resize(pdb->getnres());
	for(i=0;i<(int)index.size();i++)
		index.at(i).x1=index.at(i).x2=-1;
	for(i=0;i<(int)bb.size();i++)
		index.at(bb.at(i).id-1).x1=i+1;
	for(i=0;i<(int)bbnh.size();i++)
		index.at(bbnh.at(i).id-1).x2=i+1;
	

	for(i=0+1;i<(int)index.size()-1;i++)
	{
		//cout<<i<<endl;
		if(index.at(i).x1<0)
			continue;
		id=i+1;
		code=pdb->code(id);
		for(jj=0;jj<5;jj++)
			pre[jj]=0.0;
		//ca=cb=co=h=n=0.0;
 
		dihe_process.ca(id); 
		out=dihe_process.output();
		for(j=0;j<30;j++)
		{
			for(jj=0;jj<5;jj++)
				pre[jj]+=c_c[jj][j]*out.at(j);
		}

		for(j=42;j<60;j++)
		{
			for(jj=0;jj<5;jj++)
				pre[jj]+=c_c[jj][j-12]*out.at(j);
		}
			

		in.clear();
		for(j=0;j<12;j++)
		{
			in.push_back(out.at(j+30));
		}
		in2=Sequence::expand(code,&in);
		for(j=0;j<(int)in2.size();j++)
		{
			for(jj=0;jj<5;jj++)
				pre[jj]+=c_c[jj][j+48]*in2.at(j);
		}
		
		
		for(jj=0;jj<5;jj++)
		{
			for(j=-2;j<=0;j++)
			{
				j2=(j+2)*6;
				pre[jj]+=c_c[jj][288+j2]*hbond_effect.at(id+j).c_length;
				pre[jj]+=c_c[jj][289+j2]*hbond_effect.at(id+j).c_phi;
				pre[jj]+=c_c[jj][290+j2]*hbond_effect.at(id+j).c_psi;
				pre[jj]+=c_c[jj][291+j2]*hbond_effect.at(id+j).n_length;
				pre[jj]+=c_c[jj][292+j2]*hbond_effect.at(id+j).n_phi;
				pre[jj]+=c_c[jj][293+j2]*hbond_effect.at(id+j).n_psi;
			}
		}

			//sequence information
			code=pdb->code(id-1);
			Sequence::code2array(code,buffer);
			for(j=0;j<20;j++)		
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j+306]*buffer[j];
			}

			code=pdb->code(id);
			Sequence::code2array(code,buffer);
			for(j=0;j<20;j++)		
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j+326]*buffer[j];
			}

			code=pdb->code(id+1);
			Sequence::code2array(code,buffer);
			for(j=0;j<20;j++)		
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j+346]*buffer[j];
			}

			if(index.at(i).x2>0)
			{
				temp=0.0;
				for(j=0;j<5;j++)
					temp+=ring_effect.at(index.at(i).x2-1).x[j];
				temp*=c_h_add[4];
				for(j=0;j<4;j++)
					temp+=ani_effect.at(index.at(i).x2-1).x[j]*c_h_add[j];
				pre[3]+=temp;
			}
			pre[5]=999.0;
			pdb->attach_bbprediction(id,pre);
	}

	cal_error();
}





void CMainbody::predict_bb_static_ann()
{
	int i,j;
	int id;
	char code,code_pre,code_fol;
	vector<double> out;
	vector<double> in,in2;
	vector<struct double_five> ring_effect,ring_effect_ha;
	vector<struct ehbond> hbond_effect;
	vector<struct double_four> ani_effect,ani_effect_ha;
	vector<struct index_two> index;
	vector<int> c1,c2;
	vector<float> result;
	double pre[6];
	vector<double> eca,ecb,eco,eh,en;

	vector<double> oneline;
	vector<double> oneline_cb;
	vector<double> oneline_co;
	vector<double> oneline_h;
	vector<double> oneline_n;
	vector<double> oneline_ha;

#ifdef BENCHMARK
	double clock;
#endif


	class CAnn ann_ca,ann_cb,ann_co,ann_n,ann_h,ann_ha;

	//ann_ca.load("ann_ca.dat");
	ann_ca.loadp(p_ann_ca);
	ann_cb.loadp(p_ann_cb);
	ann_co.loadp(p_ann_co);
	ann_n.loadp(p_ann_n);
	ann_h.loadp(p_ann_h);
	ann_ha.loadp(p_ann_ha);

#ifdef BENCHMARK
	clock = omp_get_wtime();
#endif
	traj->gethbond(&hbond,&hbond_effect);
#ifdef BENCHMARK
	printf("%.4f gethbond\n", omp_get_wtime()-clock);
	clock = omp_get_wtime();
#endif
	traj->getani(&anistropy,&bbnh,&ani_effect);
#ifdef BENCHMARK
	printf("%.4f getani(bb)\n", omp_get_wtime()-clock);
	clock = omp_get_wtime();
#endif
	traj->getring(&ring_index,&bbnh,&ring_effect);
#ifdef BENCHMARK
	printf("%.4f getring(bb)\n", omp_get_wtime()-clock);
#endif

	
	//gather all ha protons to calculate ring and ani.
	vector<struct proton> ha_protons;
	struct proton ha;
	for(i=0;i<(int)bb.size();i++)
	{
		
		if(bb.at(i).code=='G')
		{
			ha.nh=2;
			ha.hpos[0]=max(0, bb.at(i).hapos);
			ha.hpos[1]=max(0, bb.at(i).hapos2);
			ha.exp=(bb.at(i).exp_ha+bb.at(i).exp_ha2)/2.0;
			ha.exp1=bb.at(i).exp_ha;
			ha.exp2=bb.at(i).exp_ha2;
			ha.type=90;
			ha.name="HB2";
			ha.name2="HB3";
			ha.cname="CA";
			ha.cname2="CA";
		}
		else
		{
			ha.nh=1;
			ha.hpos[0]=max(0, bb.at(i).hapos);
			ha.exp=bb.at(i).exp_ha;
			ha.type=91;
			ha.name="HA";
			ha.cname="CA";
		}
		ha.cpos=bb.at(i).capos;
		ha.exp_c=bb.at(i).exp_ca;
		ha.id=bb.at(i).id;
		ha.code=bb.at(i).code;

		ha_protons.push_back(ha);
	}
#ifdef BENCHMARK
	clock = omp_get_wtime();
#endif
	traj->getani(&anistropy,&ha_protons,&ani_effect_ha);
#ifdef BENCHMARK
	printf("%.4f getani(proton)\n", omp_get_wtime()-clock);
	clock = omp_get_wtime();
#endif
	traj->getring(&ring_index,&ha_protons,&ring_effect_ha);
#ifdef BENCHMARK
	printf("%.4f getring(proton)\n", omp_get_wtime()-clock);
#endif

	index.resize(pdb->getnres());	
	for(i=0;i<(int)index.size();i++)
		index.at(i).x1=index.at(i).x2=-1;
	for(i=0;i<(int)bb.size();i++)
		index.at(bb.at(i).id-1).x1=i+1;
	for(i=0;i<(int)bbnh.size();i++)
		index.at(bbnh.at(i).id-1).x2=i+1;

	c2 = pdb->getselect(":1-%@allheavy");
#ifdef BENCHMARK
	clock = omp_get_wtime();
#endif
	traj->get_contacts(bb,index,c2,&result);
#ifdef BENCHMARK
	printf("%.4f get_contacts\n", omp_get_wtime()-clock);
#endif

	for(i=0+1;i<(int)index.size()-1;i++)
	{
		//cout<<i<<endl;
		if(index.at(i).x1<0)
			continue;
		id=i+1;
		code=pdb->code(id);
		code_pre=pdb->code(id-1);
		code_fol=pdb->code(id+1);
		oneline.clear();

		//sequence information
		//blos62 matrix
		//total 60 terms
		Sequence::code2same(code_pre,buffer);
		for(j=0;j<20;j++)		
		{
			oneline.push_back(buffer[j]);
		}

		code=pdb->code(id);
		Sequence::code2same(code,buffer);
		for(j=0;j<20;j++)		
		{
			oneline.push_back(buffer[j]);
		}

		Sequence::code2same(code_fol,buffer);
		for(j=0;j<20;j++)		
		{
			oneline.push_back(buffer[j]);
		}


		//dihedral angle contribution!
		//total 28 terms
		dihe_process.ca_ann(id); 
		out=dihe_process.output();
		for(j=2;j<26;j++)
		{
			oneline.push_back(out.at(j));
		}
		for(j=28;j<(int)out.size();j++)
		{
			oneline.push_back(out.at(j));
		}


		//hbond effect, 12 terms
		oneline.push_back(hbond_effect.at(id-2).c_length);
		oneline.push_back((hbond_effect.at(id-2).c_phi));
		oneline.push_back((hbond_effect.at(id-2).c_psi));

		


		oneline.push_back(hbond_effect.at(id-1).c_length);
		oneline.push_back(hbond_effect.at(id-1).n_length);
		oneline.push_back((hbond_effect.at(id-1).c_phi));
		oneline.push_back((hbond_effect.at(id-1).c_psi));
		oneline.push_back((hbond_effect.at(id-1).n_phi));
		oneline.push_back((hbond_effect.at(id-1).n_psi));

		oneline.push_back(hbond_effect.at(id).n_length);
		oneline.push_back((hbond_effect.at(id).n_phi));
		oneline.push_back((hbond_effect.at(id).n_psi));


		//contact sum , one term
		//c1.clear();
		//c1.push_back(bb.at(index.at(i).x1-1).capos);
		//c1.push_back(bb.at(index.at(i).x1-1).cbpos);
		//c1.push_back(bb.at(index.at(i).x1-1).copos);
		//c2=pdb->getselect(":1-%@allheavy");
		//result.clear();
		//traj->get_contact(c1,c2,&result);

		oneline_co=oneline_cb=oneline;

		oneline.insert(oneline.begin()+60,result.at(i*3));
		oneline_cb.insert(oneline_cb.begin()+60,result.at(i*3+1));
		oneline_co.insert(oneline_co.begin()+60,result.at(i*3+2));
		oneline_n=oneline;
		
		pre[0]=ann_ca.predict_one(oneline);
		pre[1]=ann_cb.predict_one(oneline_cb);
		pre[2]=ann_co.predict_one(oneline_co);
		pre[4]=ann_n.predict_one(oneline_n);
		
		//hn
		if(index.at(i).x2>0)
		{
			oneline_h=oneline;
			for(j=0;j<5;j++)
				oneline_h.push_back(ring_effect.at(index.at(i).x2-1).x[j]);
			for(j=0;j<4;j++)
				oneline_h.push_back(ani_effect.at(index.at(i).x2-1).x[j]);	
			pre[3]=ann_h.predict_one(oneline_h);
		}
		else
			pre[3]=-999.0;
	

		//ha 
		oneline_ha=oneline;
		for(j=0;j<5;j++)
			oneline_ha.push_back(ring_effect_ha.at(index.at(i).x1-1).x[j]);
		for(j=0;j<4;j++)
			oneline_ha.push_back(ani_effect_ha.at(index.at(i).x1-1).x[j]);
		pre[5]=ann_ha.predict_one(oneline_ha);

		pdb->attach_bbprediction(id,pre);
	}

	cal_error();
};


void CMainbody::predict_bb_static_new()
{
	int i,j,jj;
	int id;
	int jump;
	char code,code_pre,code_fol;
	vector<double> out;
	vector<double> in,in2;
	vector<struct double_five> ring_effect,ring_effect_ha;
	vector<struct ehbond> hbond_effect;
	vector<struct double_four> ani_effect,ani_effect_ha;
	vector<struct index_two> index;
	vector<int> c1,c2;
	vector<float> result;
	double pre[6];
	double temp,temp1,temp2,tt1,tt2;
	vector<double> eca,ecb,eco,eh,en;
	double rc;
	double vhill;
	


	traj->gethbond(&hbond,&hbond_effect);
	traj->getani(&anistropy,&bbnh,&ani_effect);
	traj->getring(&ring_index,&bbnh,&ring_effect);



	

	vector<struct proton> ha_protons;
	struct proton ha;
	for(i=0;i<(int)bb.size();i++)
	{
		
		if(bb.at(i).code=='G')
		{
			ha.nh=2;
			ha.hpos[0]=bb.at(i).hapos;
			ha.hpos[1]=bb.at(i).hapos2;
			ha.exp=(bb.at(i).exp_ha+bb.at(i).exp_ha2)/2.0;
			ha.exp1=bb.at(i).exp_ha;
			ha.exp2=bb.at(i).exp_ha2;
			ha.type=90;
			ha.name="HB2";
			ha.name2="HB3";
			ha.cname="CA";
			ha.cname2="CA";
		}
		else
		{
			ha.nh=1;
			ha.hpos[0]=bb.at(i).hapos;
			ha.exp=bb.at(i).exp_ha;
			ha.type=91;
			ha.name="HA";
			ha.cname="CA";
		}
		ha.cpos=bb.at(i).capos;
		ha.exp_c=bb.at(i).exp_ca;
		ha.id=bb.at(i).id;
		ha.code=bb.at(i).code;

		ha_protons.push_back(ha);
	}
	traj->getani(&anistropy,&ha_protons,&ani_effect_ha);
	traj->getring(&ring_index,&ha_protons,&ring_effect_ha);




	index.resize(pdb->getnres());	
	for(i=0;i<(int)index.size();i++)
		index.at(i).x1=index.at(i).x2=-1;
	for(i=0;i<(int)bb.size();i++)
		index.at(bb.at(i).id-1).x1=i+1;
	for(i=0;i<(int)bbnh.size();i++)
		index.at(bbnh.at(i).id-1).x2=i+1;
	

	for(i=0+1;i<(int)index.size()-1;i++)
	{
		//cout<<i<<endl;
		if(index.at(i).x1<0)
			continue;
		id=i+1;
		code=pdb->code(id);
		code_pre=pdb->code(id-1);
		code_fol=pdb->code(id+1);

		for(jj=0;jj<6;jj++)
			pre[jj]=0.0;
		jump=0;

		//ca=cb=co=h=n=0.0;

		//missing or unknow residue shouldn't be predicted. This is also true if either previous or following residue is missing (or unknown)
		if(code_pre=='X' || code_pre=='B' || code_fol=='X' || code_fol=='B'|| code=='X' || code=='B')
		{
			for(jj=0;jj<6;jj++)
				pre[jj]=-999.0;
			continue;
		}

		//sequence information
		Sequence::code2array(code_pre,buffer);
		for(j=0;j<20;j++)		
		{
			for(jj=0;jj<6;jj++)
				pre[jj]+=static_c[jj][j+jump]*buffer[j];
		}
		jump+=20;
		
		code=pdb->code(id);
		Sequence::code2array(code,buffer);
		for(j=0;j<20;j++)		
		{
			for(jj=0;jj<6;jj++)
				pre[jj]+=static_c[jj][j+jump]*buffer[j];
		}
		jump+=20;

		Sequence::code2array(code_fol,buffer);
		for(j=0;j<20;j++)		
		{
			for(jj=0;jj<6;jj++)
				pre[jj]+=static_c[jj][j+jump]*buffer[j];
		}
		jump+=20;



		//dihedral angle contribution!
		if(dihe_process.ca_static_new(id)==0) //==0 means missing dihedral angles in this calculation !!
		{
			for(jj=0;jj<6;jj++)
				pre[jj]=-999.0;
			continue;
		}

		out=dihe_process.output();

		//pre dihe  12*20 terms
		in.clear();
		for(j=0;j<12;j++)
		{
			in.push_back(out.at(j));
		}
		in2=Sequence::expand(code_pre,&in);
		for(j=0;j<(int)in2.size();j++)
		{
			for(jj=0;jj<6;jj++)
				pre[jj]+=static_c[jj][j+jump]*in2.at(j);
		}
		jump+=240;


		//self dihe 24*20 terms
		in.clear();
		for(j=0;j<24;j++)
		{
			in.push_back(out.at(j+12));
		}
		in2=Sequence::expand(code,&in);
		for(j=0;j<(int)in2.size();j++)
		{
			for(jj=0;jj<6;jj++)
				pre[jj]+=static_c[jj][j+jump]*in2.at(j);
		}
		jump+=480;
		
		//follow dihe  12*20 terms
		in.clear();
		for(j=0;j<12;j++)
		{
			in.push_back(out.at(j+36));
		}
		in2=Sequence::expand(code_fol,&in);
		for(j=0;j<(int)in2.size();j++)
		{
			for(jj=0;jj<6;jj++)
				pre[jj]+=static_c[jj][j+jump]*in2.at(j);
		}
		jump+=240;
		
	
		//hbond effect, length only
		for(jj=0;jj<6;jj++)
		{	
			tt1=temp1=hbond_effect.at(id-1).c_length;
			tt2=temp2=hbond_effect.at(id-1).n_length;
			pre[jj]+=static_c[jj][jump+0]*temp1;
			pre[jj]+=static_c[jj][jump+1]*temp2;

			temp1*=temp1;temp2*=temp2;
			pre[jj]+=static_c[jj][jump+2]*temp1;
			pre[jj]+=static_c[jj][jump+3]*temp2;

			pre[jj]+=static_c[jj][jump+4]*temp1*tt1;
			pre[jj]+=static_c[jj][jump+5]*temp2*tt2;

			temp1*=temp1;temp2*=temp2;
			pre[jj]+=static_c[jj][jump+6]*temp1;
			pre[jj]+=static_c[jj][jump+7]*temp2;
		}
		jump+=8;

						
		if(index.at(i).x2>0)
		{
			temp=0.0;
			for(j=0;j<5;j++)
				temp+=ring_effect.at(index.at(i).x2-1).x[j]*static_h[0][j];
			for(j=0;j<4;j++)
				temp+=ani_effect.at(index.at(i).x2-1).x[j]*static_h[0][j+5];
			pre[3]+=temp;
		}

		temp=0.0;
		for(j=0;j<5;j++)
			temp+=ring_effect_ha.at(index.at(i).x1-1).x[j]*static_h[1][j];
		for(j=0;j<4;j++)
			temp+=ani_effect_ha.at(index.at(i).x1-1).x[j]*static_h[1][j+5];
		pre[5]+=temp;


		//get contact sum adjustment
		c1.clear();
		c1.push_back(bb.at(index.at(i).x1-1).capos);
		c1.push_back(bb.at(index.at(i).x1-1).cbpos);
		c1.push_back(bb.at(index.at(i).x1-1).copos);
		c2=pdb->getselect(":1-%@allheavy");
		result.clear();
		traj->get_contact(c1,c2,&result);
		result.push_back(result.at(0));
		result.push_back(result.at(0));
		result.push_back(result.at(0));

		for(jj=0;jj<6;jj++)
		{
			vhill=hill(result.at(jj),hill_para[jj][0],hill_para[jj][1]);
			rc=(1-vhill)/vhill;
			pre[jj]+=rc*static_c[jj][Sequence::code2pos(code)+jump];
			pre[jj]*=vhill;
		}
		
		pdb->attach_bbprediction(id,pre);
	}
	
	cal_error();

}


void CMainbody::cal_error()
{
	int j;
	vector< vector<double> > cas,cbs,cos,hs,ns,has;
	double e,t,w;


	cas.resize(2);cbs.resize(2);cos.resize(2);hs.resize(2);ns.resize(2);has.resize(2);
	bb.clear();
	pdb->getbb(&bb);
	bb=clear(bb);
	for(j=0;j<(int)bb.size();j++)
	{
		cas.at(0).push_back(bb.at(j).exp_ca);
		cbs.at(0).push_back(bb.at(j).exp_cb);
		cos.at(0).push_back(bb.at(j).exp_co);
		hs.at(0).push_back(bb.at(j).exp_h);
		ns.at(0).push_back(bb.at(j).exp_n);
		has.at(0).push_back(bb.at(j).exp_ha);
	
		cas.at(1).push_back(bb.at(j).pre_ca);
		cbs.at(1).push_back(bb.at(j).pre_cb);
		cos.at(1).push_back(bb.at(j).pre_c);
		hs.at(1).push_back(bb.at(j).pre_h);
		ns.at(1).push_back(bb.at(j).pre_n);
		has.at(1).push_back(bb.at(j).pre_ha);

	}
	compare("CA",cas);compare("CB",cbs);compare("C'",cos);compare("HN",hs);compare("N",ns);compare("HA",has);


	FILE *fp=fopen("cs_rmsd.dat","wt");

	for(j=0;j<(int)bb.size();j++)
	{
		e=0;
		w=0;
		if(fabs(bb.at(j).exp_ca)<490.0 && fabs(bb.at(j).pre_ca)<490.0)
		{
			t=bb.at(j).exp_ca-bb.at(j).pre_ca;
			e+=t*t;
			w+=1.0;
		}
		if(fabs(bb.at(j).exp_cb)<490.0 && fabs(bb.at(j).pre_cb)<490.0)
		{
			t=bb.at(j).exp_cb-bb.at(j).pre_cb;
			e+=t*t;
			w+=1.0;
		}
		if(fabs(bb.at(j).exp_co)<490.0 && fabs(bb.at(j).pre_c)<490.0)
		{
			t=bb.at(j).exp_co-bb.at(j).pre_c;
			e+=t*t;
			w+=1.0;
		}
		if(fabs(bb.at(j).exp_h)<490.0 && fabs(bb.at(j).pre_h)<490.0)
		{
			t=bb.at(j).exp_h-bb.at(j).pre_h;
			e+=t*t*4;
			w+=4.0;
		}
		if(fabs(bb.at(j).exp_n)<490.0 && fabs(bb.at(j).pre_n)<490.0)
		{
			t=bb.at(j).exp_n-bb.at(j).pre_n;
			e+=t*t*0.4;
			w+=0.4;
		}
		if(fabs(bb.at(j).exp_ha)<490.0 && fabs(bb.at(j).pre_ha)<490.0)
		{
			t=bb.at(j).exp_ha-bb.at(j).pre_ha;
			e+=t*t*4;
			w+=4;
		}
		if(w>0.0)
		{
			e=sqrt(e/w);
			fprintf(fp,"%10d%10s%10.2f\n",bb.at(j).id0,Sequence::code2name(bb.at(j).code).c_str(),e);
		}
		else
			e=0.0;

	}		
	fclose(fp);		

}


double CMainbody::hill(double contact, double v1, double v2)
{
	double hill;
	
	if(contact<v1)	
		hill=0.0;
	else if(contact>v2)
		hill=1.0;
	else
	{
		hill=(contact-v1)/(v2-v1)*6-3;
		hill=(1-exp(-2*hill))/(1+exp(-2*hill));
		hill=hill/2+0.5;
	}

	return hill;

}


void CMainbody::predict_bb2()
{
	int i,j,j2,jj,n;
	int id;
	char code;
	vector< vector<double> > out;
	vector<double> in,in2;
	vector< vector<struct double_five> > ring_effect;
	vector< vector<struct ehbond> > hbond_effect;
	vector< vector<struct double_four> > ani_effect;
	vector<struct index_two> index;
	vector<double> cs_ca,cs_cb,cs_c,cs_h,cs_n;
	double pre[6];
	double temp;
	vector<double> eca,ecb,eco,eh,en;
	char name[4];
	FILE *fp;

	fp=fopen("bb_details.dat","w");
	


	traj->gethbond(&hbond,&hbond_effect);
	traj->getani(&anistropy,&bbnh,&ani_effect);
	traj->getring(&ring_index,&bbnh,&ring_effect);

	

	index.resize(pdb->getnres());	
	for(i=0;i<(int)index.size();i++)
		index.at(i).x1=index.at(i).x2=-1;
	for(i=0;i<(int)bb.size();i++)
		index.at(bb.at(i).id-1).x1=i+1;
	for(i=0;i<(int)bbnh.size();i++)
		index.at(bbnh.at(i).id-1).x2=i+1;


	

	for(i=0+1;i<(int)index.size()-1;i++)
	{	//cout<<"i is "<<i<<endl;
		if(index.at(i).x1<0)
			continue;
		id=i+1;
		code=pdb->code(id);
		pdb->name(id,name);

		if(strcmp(name,"CYS")==0)
			continue;

		dihe_process.ca2(id); 
		out=dihe_process.output2();

		cs_ca.clear();
		cs_cb.clear();
		cs_c.clear();
		cs_h.clear();
		cs_n.clear();

		for(n=0;n<nconf;n++)
		{		
			id=i+1;
			code=pdb->code(id);

			for(jj=0;jj<5;jj++)
				pre[jj]=0.0;
	 
			for(j=0;j<30;j++)
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j]*out.at(j).at(n);
			}

			for(j=42;j<60;j++)
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j-12]*out.at(j).at(n);
			}
				

			in.clear();
			for(j=0;j<12;j++)
			{
				in.push_back(out.at(j+30).at(n));
			}
			in2=Sequence::expand(code,&in);


			for(j=0;j<(int)in2.size();j++)
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j+48]*in2.at(j);
			}
			
		
			for(jj=0;jj<5;jj++)
			{
				for(j=-2;j<=0;j++)
				{
					j2=(j+2)*6;
					pre[jj]+=c_c[jj][288+j2]*hbond_effect.at(id+j).at(n).c_length;
					pre[jj]+=c_c[jj][289+j2]*hbond_effect.at(id+j).at(n).c_phi;
					pre[jj]+=c_c[jj][290+j2]*hbond_effect.at(id+j).at(n).c_psi;
					pre[jj]+=c_c[jj][291+j2]*hbond_effect.at(id+j).at(n).n_length;
					pre[jj]+=c_c[jj][292+j2]*hbond_effect.at(id+j).at(n).n_phi;
					pre[jj]+=c_c[jj][293+j2]*hbond_effect.at(id+j).at(n).n_psi;
				}
			}

			//sequence information
			code=pdb->code(id-1);
			Sequence::code2array(code,buffer);
			for(j=0;j<20;j++)		
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j+306]*buffer[j];
			}

			code=pdb->code(id);
			Sequence::code2array(code,buffer);
			for(j=0;j<20;j++)		
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j+326]*buffer[j];
			}

			code=pdb->code(id+1);
			Sequence::code2array(code,buffer);
			for(j=0;j<20;j++)		
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j+346]*buffer[j];
			}


			if(index.at(i).x2>0)
			{
				temp=0.0;
				for(j=0;j<5;j++)
					temp+=ring_effect.at(index.at(i).x2-1).at(n).x[j];
				temp*=c_h_add[4];
				for(j=0;j<4;j++)
					temp+=ani_effect.at(index.at(i).x2-1).at(n).x[j]*c_h_add[j];
				pre[3]+=temp;
			}

			cs_ca.push_back(pre[0]);
			cs_cb.push_back(pre[1]);
			cs_c.push_back(pre[2]);
			cs_n.push_back(pre[4]);
			cs_h.push_back(pre[3]);
		}
	
		fprintf(fp,"%8d%8s",id,name);
		fprintf(fp,"   CA   ");
		fprintf(fp,"%8.3f",bb.at(index.at(i).x1-1).exp_ca);
		for(n=0;n<nconf;n++)
				fprintf(fp,"%8.3f",cs_ca.at(n));

		fprintf(fp,"\n%8d%8s",id,name);
		fprintf(fp,"   CB   ");
		fprintf(fp,"%8.3f",bb.at(index.at(i).x1-1).exp_cb);
		for(n=0;n<nconf;n++)
				fprintf(fp,"%8.3f",cs_cb.at(n));

		fprintf(fp,"\n%8d%8s",id,name);
		fprintf(fp,"   C    ");	
		fprintf(fp,"%8.3f",bb.at(index.at(i).x1-1).exp_co);
		for(n=0;n<nconf;n++)
				fprintf(fp,"%8.3f",cs_c.at(n));

		fprintf(fp,"\n%8d%8s",id,name);
		fprintf(fp,"   H    ");
		if(index.at(i).x2>1)
			fprintf(fp,"%8.3f",bbnh.at(index.at(i).x2-1).exp_h);
		else
			fprintf(fp,"%8.3f",999.0);
		for(n=0;n<nconf;n++)
				fprintf(fp,"%8.3f",cs_h.at(n));

		fprintf(fp,"\n%8d%8s",id,name);
		fprintf(fp,"   N    ");
		if(index.at(i).x2>1)
			fprintf(fp,"%8.3f",bbnh.at(index.at(i).x2-1).exp_n);
		else
			fprintf(fp,"%8.3f",999.0);
		for(n=0;n<nconf;n++)
				fprintf(fp,"%8.3f",cs_n.at(n));
		fprintf(fp,"\n");


		for(n=0;n<5;n++)
			pre[n]=0;
		for(n=0;n<nconf;n++)
		{
			pre[0]+=cs_ca.at(n);
			pre[1]+=cs_cb.at(n);
			pre[2]+=cs_c.at(n);
			pre[3]+=cs_h.at(n);
			pre[4]+=cs_n.at(n);
		}
		for(n=0;n<5;n++)
			pre[n]/=nconf;
		pre[5]=999.0;
		pdb->attach_bbprediction(id,pre);
	}
	return;
}






void CMainbody::predict_proton()
{
	int i,j;
	int id;
	char code;
	int type;

	double c_ring[5]={-0.1939,-0.1629,-0.1620,-0.1872,-0.1987};
	double c_ani[4]={0.004478932,0.000925861,0.001692256,0.00040848288};
	double c_rand[10]={1.3876,1.2671,2.0763,0.0000,1.0064,0.9611,0.9102,0.8890,0.9976,0.8584};

	
	double cs_ring,cs_ani,cs_rand,cs;


	vector< vector<double> > hs;
	hs.resize(2);


	vector<struct double_five> ring_effect;
	vector<struct double_four> ani_effect;

	traj->getani(&anistropy,&protons,&ani_effect);
	traj->getring(&ring_index,&protons,&ring_effect);
		


	for(i=0;i<(int)protons.size();i++)
	{	
		id=protons.at(i).id;
		code=protons.at(i).code;	
		type=protons.at(i).type;


		cs_ring=0;
		for(j=0;j<5;j++)
			cs_ring+=ring_effect.at(i).x[j]*c_ring[j];

		cs_ani=0;
		for(j=0;j<4;j++)
			cs_ani+=ani_effect.at(i).x[j]*c_ani[j];
		cs_rand=c_rand[type-1];
		cs=cs_ring+cs_ani+cs_rand;
		pdb->attach_protonprediction(id,protons.at(i).name,cs);

		hs.at(0).push_back(protons.at(i).exp);
		hs.at(1).push_back(cs);
	}

	compare("Methyl 1H",hs);
	return;
}

void CMainbody::predict_proton2()
{
	int i,j,ii;
	int id;
	char code;
	int type;
	double cs_rand;
	vector<double> cs_ring,cs_ani,cs;
	double ccs_ring,ccs_ani,ccs;
	FILE *fp;

	fp=fopen("proton_details.dat","w");

	double c_ring[5]={-0.1939,-0.1629,-0.1620,-0.1872,-0.1987};
	double c_ani[4]={0.004478932,0.000925861,0.001692256,0.00040848288};
	double c_rand[10]={1.3876,1.2671,2.0763,0.0000,1.0064,0.9611,0.9102,0.8890,0.9976,0.8584};

	vector< vector<struct double_five> > ring_effect;
	vector< vector<struct double_four> > ani_effect;
	traj->getani(&anistropy,&protons,&ani_effect);
	traj->getring(&ring_index,&protons,&ring_effect);

	for(i=0;i<(int)protons.size();i++)
	{	
		id=protons.at(i).id;
		code=protons.at(i).code;	
		type=protons.at(i).type;

		for(ii=0;ii<nconf;ii++)
		{
			cs_ring.push_back(0.0);
			cs_ani.push_back(0.0);
			cs.push_back(0.0);
		}
		for(ii=0;ii<nconf;ii++)
		{
			cs_ring[ii]=0;
			for(j=0;j<5;j++)
				cs_ring[ii]+=ring_effect.at(i).at(ii).x[j]*c_ring[j];
			cs_ani[ii]=0;
			for(j=0;j<4;j++)
				cs_ani[ii]+=ani_effect.at(i).at(ii).x[j]*c_ani[j];
			cs_rand=c_rand[type-1];
			cs[ii]=cs_ring[ii]+cs_ani[ii]+cs_rand;
		}
		fprintf(fp,"%8d %8s %8s",id,Sequence::code2name(code).c_str(),protons.at(i).name.c_str());
		if(fabs(protons.at(i).exp)>0.00001)
			fprintf(fp," %8.3f",protons.at(i).exp);
		else
			fprintf(fp," %8.3f",999.9);
		for(ii=0;ii<nconf;ii++)
			fprintf(fp," %8.3f",cs[ii]);
		fprintf(fp,"\n");


		ccs=ccs_ring=ccs_ani=0.0;
		for(ii=0;ii<nconf;ii++)
		{	
			ccs+=cs[ii];
			ccs_ring+=cs_ring[ii];
			ccs_ani+=cs_ani[ii];
		}
		ccs/=nconf;
		ccs_ring/=nconf;
		ccs_ani/=nconf;
		pdb->attach_protonprediction(id,protons.at(i).name,ccs);
	}
	fclose(fp);
	return;
}


void CMainbody::predict_proton_static_new(void)
{
	int i,j;
	int id;
	int type;
	vector<double> out;
	int jump;
	float pre;
	double *c;
	vector< vector<double> > hs;
	double clock;



	vector<struct double_five> ring_effect;
	vector<struct double_four> ani_effect;
	
	
	allprotons=allprotons3;
	clock = omp_get_wtime();
	traj->getani(&anistropy,&allprotons,&ani_effect);
	printf("%.4f getani(proton)\n", omp_get_wtime()-clock);
	clock = omp_get_wtime();
	traj->getring(&ring_index,&allprotons,&ring_effect);
	printf("%.4f getani(proton)\n", omp_get_wtime()-clock);

	hs.resize(2);

	
		
	for(i=0;i<(int)allprotons.size();i++)
	{		
		type=allprotons.at(i).type;
		id=allprotons.at(i).id;
		
		//too few data point and bad fitting !
		if(type==18 || type==19 || type==28 || type==49 || type==64  || type==82  || type==84  || type==97 )
			continue;
		//bad fitting !
		if(type==36 || type==48 || type==62 )
			continue;

		//use gobal or individual fitting?
		if(sep_table[type]>=0)
			c=c_sep[type-1];
		else
			c=c_all;

		jump=0;
		pre=c[type-1];
		jump+=98;

		for(j=0;j<5;j++)
			pre+=ring_effect.at(i).x[j]*c[j+jump];
		jump+=5;

		for(j=0;j<4;j++)
			pre+=ani_effect.at(i).x[j]*c[j+jump];
		jump+=4;

		dihe_process.allproton(allprotons.at(i).id); 
		dihe_process.hb_expand(type);
		out=dihe_process.output();
		for(j=0;j<8*18;j++)
			pre+=out.at(j)*c[j+jump];
		jump+=8*18;

		pdb->attach_protonprediction(id,allprotons.at(i).name,pre);
		if(allprotons.at(i).name2!="")
			pdb->attach_protonprediction(id,allprotons.at(i).name2,pre);

		hs.at(0).push_back(allprotons.at(i).exp);
		hs.at(1).push_back(pre);
	}
	compare("Side chain protons",hs);
	return;
}



void CMainbody::compare(char * buff, vector< vector<double> > t)
{
	int i,j,n;
	double e,ee;
	bool b;
	vector<bool> bs;

	for(i=0;i<(int)t.at(0).size();i++)
	{
		b=0;
		for(j=0;j<(int)t.size();j++)
		{
			if(t.at(j).at(i)<-400.0 || t.at(j).at(i)>400.0 )
				b=1;
		}
		bs.push_back(b);
		
	}

	cout<<buff<<": ";
	for(i=1;i<(int)t.size();i++)
	{
		ee=0;
		n=0;
		for(j=0;j<(int)t.at(0).size();j++)
		{
			if(bs.at(j)==0)
			{
				e=t.at(0).at(j)-t.at(i).at(j);
				ee+=e*e;
				n++;
			}
		}
		if(n>0)
		{
			ee/=n;
			ee=sqrt(ee);
			cout<<" "<<ee;
		}
		else
			cout<<" N.A.";
	}
	cout<<endl;
}

//This file include all trained parameters in PPM.
#include "data.h"

########## NEXT FILE ##########
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <string>
#include <vector>
#include <math.h>
#include <time.h>
#include <sstream>
using namespace std;

#include "ann.h"
#include "mainbody.h"

#include "debug.h"

#ifdef BENCHMARK
#include <omp.h>
#endif



//class Dihe_process, used by ppm only

void CDihe_process::init(vector<int> innum,vector<double> *indihe)
{
	num=innum;
	dihe=indihe;
	if(num.size()>2)
	{
		ndihe=num.at(num.size()-1);
		nframe=dihe->size()/ndihe;
	}
	else
	{
		ndihe=0;
		nframe=0;
	}

	return;
}

void CDihe_process::init(vector<int> innum,vector<double> *indihe, vector<dihe_group> *indihe_index)
{
	num=innum;
	dihe=indihe;
	dihe_index=indihe_index;

	if(num.size()>2)
	{
		ndihe=num.at(num.size()-1);
		nframe=dihe->size()/ndihe;
	}
	else
	{
		ndihe=0;
		nframe=0;
	}

	return;
}

void CDihe_process::init(vector<int> innum,vector<double> *indihe, vector<double> *inangle)
{
	num=innum;
	dihe=indihe;
	angle=inangle;
	if(num.size()>2)
	{
		ndihe=num.at(num.size()-1);
		nframe=dihe->size()/ndihe;
	}
	else
	{
		ndihe=0;
		nframe=0;
	}

	return;
}


void CDihe_process::hb_expand(int type)
{
	int i;
	int begin,stop;
	vector<double> temp;

	begin=table[type]*8;
	stop=table[type]*8+8;

	if(stop==0)
	{
		out.clear();
		out.resize(18*8,0.0);
	}
	else
	{
		temp.resize(18*8,0.0);
		for(i=begin;i<stop;i++)
			temp.at(i)=out.at(i-begin);
		out=temp;
	}

	return;
}

void CDihe_process::hb_expand2(int type)
{
    int i;
    int begin,stop;
    vector< vector<double> > temp;
    vector<double> t;
    
    t.resize(nframe,0.0);
    
    begin=table[type]*8;
    stop=table[type]*8+8;
    
    if(stop==0)
    {
        out2.clear();
        out2.resize(18*8,t);
    }
    else
    {
        temp.resize(18*8,t);
        for(i=begin;i<stop;i++)
            temp.at(i)=out2.at(i-begin);
        out2=temp;
    }
    
    return;
}


vector<int> CDihe_process::pos(int in)
{
	int i;
	int base,stop;
	vector<int> out;


	if(in==1)
		base=1;
	else
		base=num.at(in-2)+1;
	
	stop=num.at(in-1);

	if(in<=0)
		base=num.at(num.size()-1)+100;
	if(in>(int)num.size())
		base=num.at(num.size()-1)+100;

	
	for(i=base;i<=stop;i++)
	{
		out.push_back(i);
		//cout<<"in is "<<in<<" "<<i<<endl;
	}

	return out;
}


vector<int> CDihe_process::pos_angle(int in)
{
	int i;
	int base,stop;
	vector<int> out;


	if(in==1)
		base=1;
	else
		base=num.at(in-2)*2+1;
	
	stop=num.at(in-1)*2;

	if(in<=0)
		base=num.at(num.size()-1)+100;
	if(in>(int)num.size())
		base=num.at(num.size()-1)+100;

	
	for(i=base;i<=stop;i++)
	{
		out.push_back(i);
		//cout<<"in is "<<in<<" "<<i<<endl;
	}

	return out;
}

void CDihe_process::allproton(int id)
{
	out.clear();
	process(id,2,2,2);
	return;
}

void CDihe_process::allproton2(int id)
{
    out2.clear();
    process2(id,2,2,2);
    return;
}

bool CDihe_process::test_good(int id,int cut)
{
	bool r;
	vector<int> index;
	int t,i;

	index=pos(id);

	if((int)index.size()>=cut)
		t=cut;
	else
		t=index.size();

	r=1;
	for(i=0;i<t;i++)
	{
		if(dihe_index->at(index.at(i)-1).bgood==0)
			r=0;
	}

	return r;
}


bool CDihe_process::test(int id, int t1, int t2)
{
	bool r;
	if(test_good(id-1,t2) && test_good(id,t1) && test_good(id+1,t2) )
		r=1;
	else
		r=0;
	return r;
}


bool CDihe_process::test_proton(int id, int type)
{
	return ((table[type]==-1) || test_good(id,2));
}


bool CDihe_process::ca_static_new(int id)
{
	out.clear();
	bool r;

	if(test_good(id-1,3) && test_good(id,4) && test_good(id+1,3) )
	{
		process_static_new(id-1,3,2,2);
		process_static_new(id  ,4,3,3);
		process_static_new(id+1,3,2,2);
		r=1;
	}
	else
		r=0;

	return r;
	
}

void CDihe_process::md_new(int id)
{
	out.clear();

	process_static_new(id-1,4,2,2);
	process_static_new(id  ,4,3,3);
	process_static_new(id+1,4,2,2);
  	return;
}

void CDihe_process::md_new_detail(int id, int n)
{
	out.clear();
    
	process_md_sep(n,id-1,4,2,2);
	process_md_sep(n,id  ,4,3,3);
	process_md_sep(n,id+1,4,2,2);
  	return;
}


void CDihe_process::ca(int id)
{
	out.clear();

	process(id-1,3,3,3);
	process(id  ,4,3,3);
	process(id+1,3,3,3);
  	return;
}



void CDihe_process::ca_ann(int id)
{
	out.clear();

	process_static_new(id-1,4,1,1);
	process_static_new(id  ,4,2,2);
	process_static_new(id+1,4,1,1);
  	return;
}

void CDihe_process::md_ann(int id,int n)
{
	out.clear();
	process_md_sep(n,id-1,4,1,1);
	process_md_sep(n,id  ,4,1,1);
	process_md_sep(n,id+1,4,1,1);
	return;
}


void CDihe_process::process_md_sep(int nn,int id,int cut, int order1, int order2)
{
	int i,ii,j,p;
	int base;
	int t;
	double phi;
	int order;
	vector<int> index;
	vector<double> temp;

	index=pos(id);
	if((int)index.size()>=cut)
		t=cut;
	else
		t=index.size();


	for(i=0;i<t;i++)
	{
		p=index.at(i);
		order=order1;
		if(i>1) order=order2;

		for(ii=1;ii<=order;ii++)
		{
			j=nn;
			base=j*ndihe;
			phi=dihe->at(base+p-1);
			out.push_back(cos(phi*ii));
			
			j=nn;
			base=j*ndihe;
			phi=dihe->at(base+p-1);
			out.push_back(sin(phi*ii));
		}
	}

	for(i=t;i<cut;i++)
	{
		for(ii=1;ii<=order2;ii++)
		{
			out.push_back(0.0);
			out.push_back(0.0);
		}
	}

	return;
}

void CDihe_process::process(int id,int cut,int order,int order2)
{
	int p,i,j,k,t,base;
	vector<int> index;
	double phi;
	double cosphi[10];
	double sinphi[10];

	

	index=pos(id);
	if((int)index.size()>=cut)
		t=cut;
	else
		t=index.size();

	for(i=0;i<2;i++)
	{
		p=index.at(i);
		for(k=1;k<=order;k++)
			cosphi[k]=sinphi[k]=0.0;
		for(j=0;j<nframe;j++)
		{
			base=j*ndihe;
			phi=dihe->at(base+p-1);
			for(k=1;k<=order;k++)
			{
				cosphi[k]+=cos(phi*k);
				sinphi[k]+=sin(phi*k);
			}
		}
		for(k=1;k<=order;k++)
		{
			out.push_back(cosphi[k]/nframe);
		}
		for(k=1;k<=order;k++)
		{
			out.push_back(sinphi[k]/nframe);
		}
	}

	for(i=2;i<t;i++)
        {
                p=index.at(i);
                for(k=1;k<=order2;k++)
                        cosphi[k]=sinphi[k]=0.0;
                for(j=0;j<nframe;j++)
                {
                        base=j*ndihe;
                        phi=dihe->at(base+p-1);
                        for(k=1;k<=order2;k++)
                        {
                                cosphi[k]+=cos(phi*k);
                                sinphi[k]+=sin(phi*k);
                        }
                }
                for(k=1;k<=order2;k++)
                {
                        out.push_back(cosphi[k]/nframe);
                }
                for(k=1;k<=order2;k++)
                {
                        out.push_back(sinphi[k]/nframe);
                }
        }

	for(i=t;i<cut;i++)
	{
		for(j=0;j<order2*2;j++)
			out.push_back(0.0);
	}
}


void CDihe_process::process_static_new(int id,int cut,int order,int order2)
{
	int p,i,j,k,t,base;
	vector<int> index;
	double phi;
	double cosphi[10];
	double sinphi[10];


	index=pos(id);
	if((int)index.size()>=cut)
		t=cut;
	else
		t=index.size();

	for(i=0;i<2;i++)
	{
		p=index.at(i);
		for(k=1;k<=order;k++)
			cosphi[k]=sinphi[k]=0.0;
		for(j=0;j<nframe;j++)
		{
			base=j*ndihe;
			phi=dihe->at(base+p-1);
			for(k=1;k<=order;k++)
			{
				cosphi[k]+=cos(phi*k);
				sinphi[k]+=sin(phi*k);
			}
		}
		for(k=1;k<=order;k++)
		{
			out.push_back(cosphi[k]/nframe);
			out.push_back(sinphi[k]/nframe);
		}
	}

	for(i=2;i<t;i++)
        {
                p=index.at(i);
                for(k=1;k<=order2;k++)
                        cosphi[k]=sinphi[k]=0.0;
                for(j=0;j<nframe;j++)
                {
                        base=j*ndihe;
                        phi=dihe->at(base+p-1);
                        for(k=1;k<=order2;k++)
                        {
                                cosphi[k]+=cos(phi*k);
                                sinphi[k]+=sin(phi*k);
                        }
                }
                for(k=1;k<=order2;k++)
                {
                        out.push_back(cosphi[k]/nframe);
						out.push_back(sinphi[k]/nframe);
                }
        }

	for(i=t;i<cut;i++)
	{
		for(j=0;j<order2*2;j++)
			out.push_back(0.0);
	}
}

void CDihe_process::proton(int id)
{
	out2.clear();
	process_fit(id,7);
  	return;
}


void CDihe_process::ca2(int id)
{
	out2.clear();

	process2(id-1,3,3,3);
	process2(id  ,4,3,3);
	process2(id+1,3,3,3);
  	return;
}

void CDihe_process::for_fit(int id)
{
	out2.clear();

	process_fit(id-1,4);
	process_fit(id,4);
	process_fit(id+1,4);
	return;
}


void CDihe_process::fit_angle(int id)
{
	int i,j,p,base;
	vector<int> index;
	vector<double> temp;
	double phi;

	index=pos_angle(id);

	out2.clear();

	int touse[5]={0,1,3,4,5};

	
	for(i=0;i<5;i++)
	{
		if(touse[i]<(int)index.size())
		{
			p=index.at(touse[i]);
			temp.clear();
			for(j=0;j<nframe;j++)
			{
				base=j*ndihe*2;
				phi=angle->at(base+p-1);
				temp.push_back(phi);
			}
			out2.push_back(temp);
		}
		else
		{
			temp.clear();
			for(j=0;j<nframe;j++)
			{
				temp.push_back(0.0);
			}
			out2.push_back(temp);
		}

	}

}


void CDihe_process::process_fit(int id,int cut)
{
	int i,j,p;
	int base;
	int t;
	double phi;
	vector<int> index;
	vector<double> temp;

	index=pos(id);
	if((int)index.size()>=cut)
		t=cut;
	else
		t=index.size();


	for(i=0;i<t;i++)
	{
		p=index.at(i);
		temp.clear();
		for(j=0;j<nframe;j++)
		{
			base=j*ndihe;
			phi=dihe->at(base+p-1);
			temp.push_back(phi);
		}
		out2.push_back(temp);
	}

	for(i=t;i<cut;i++)
	{
		temp.clear();
		for(j=0;j<nframe;j++)
		{
			temp.push_back(0.0);
		}
		out2.push_back(temp);
	}

	return;
}





void CDihe_process::process2(int id,int cut,int order,int order2)
{
	int p,i,j,k,t,base;
	vector<int> index;
	double phi;
	vector< vector<double> > t1,t2;

	

	index=pos(id);
	if((int)index.size()>=cut)
		t=cut;
	else
		t=index.size();

	for(i=0;i<2;i++)
	{
		p=index.at(i);
		t1.clear();
		t2.clear();
		t1.resize(order);
		t2.resize(order);
		for(j=0;j<nframe;j++)
		{
			base=j*ndihe;
			phi=dihe->at(base+p-1);
			for(k=1;k<=order;k++)
			{
				t1.at(k-1).push_back(cos(phi*k));
				t2.at(k-1).push_back(sin(phi*k));
			}
		}
		for(k=1;k<=order;k++)
		{
			out2.push_back(t1.at(k-1));
		}
		for(k=1;k<=order;k++)
		{
			out2.push_back(t2.at(k-1));
		}
	}

	for(i=2;i<t;i++)
    {
		p=index.at(i);
		t1.clear();
		t2.clear();
		t1.resize(order2);
		t2.resize(order2);
		for(j=0;j<nframe;j++)
        {
			base=j*ndihe;
            phi=dihe->at(base+p-1);
            for(k=1;k<=order2;k++)
            {
				t1.at(k-1).push_back(cos(phi*k));
				t2.at(k-1).push_back(sin(phi*k));
			}
		}
        for(k=1;k<=order2;k++)
		{
			out2.push_back(t1.at(k-1));
		}
        for(k=1;k<=order2;k++)
        {
			out2.push_back(t2.at(k-1));
		}
    }

	for(i=t;i<cut;i++)
	{
		t1.clear();
		t2.clear();
		t1.resize(order2);
		t2.resize(order2);
		for(j=0;j<nframe;j++)
		{
			for(k=1;k<=order2;k++)
            {
				t1.at(k-1).push_back(0.0);
				t2.at(k-1).push_back(0.0);
			}
		}
		for(k=1;k<=order2;k++)
		{
			out2.push_back(t1.at(k-1));
		}
        for(k=1;k<=order2;k++)
        {
			out2.push_back(t2.at(k-1));
		}
	}
}

vector<double> CDihe_process::output()
{
	return out;
}

vector< vector<double> > CDihe_process::output2()
{
	return out2;
}

CDihe_process::CDihe_process(void)
{
	int i;
	table=new int[98+1];
	for(i=0;i<98+1;i++)
		table[i]=-1;

	for(i=0;i<18;i++)
		table[hbs[i]]=i;

};


CDihe_process::~CDihe_process(void)
{
	delete [] table ;
};



CMainbody::CMainbody()
{
	int i;

	bnew=0;
	
	sep_table=new int[98+1];
	for(i=0;i<98+1;i++)
		sep_table[i]=-1;

	for(i=0;i<19;i++)
		sep_table[sep[i]]=i;
};

CMainbody::~CMainbody()
{
	if(bnew)
	{
		delete pdb;
		delete traj;
	}
	delete [] sep_table;
};



int CMainbody::loadpdb(CPdb *p_pdb, CTraj * p_traj)
{
	pdb=p_pdb;
	traj=p_traj;

	natom=pdb->getnatom();
	nres=pdb->getnres();
	nconf=traj->getnframe();

	return nconf;
}



int CMainbody::loadpdb(string name)
{
	pdb=new CPdb;
	traj=new CTraj;
	bnew=1;

	natom=pdb->loadpdb(name);
	nres=pdb->getnres();
	traj->setnres(nres);
	traj->setnatom(natom);
	nconf=traj->loadcoor(name);
	return nconf;
}

int CMainbody::loadpdb(string name,string name2)
{
	pdb=new CPdb;
	traj=new CTraj;
	bnew=1;

	pdb_name=name;

	natom=pdb->loadpdb(name);
	nres=pdb->getnres();
	traj->setnres(nres);
	traj->setnatom(natom);

	
	
    nconf=traj->loadcoor(name);


	return nconf;
}




void CMainbody::load(string bmrbname)
{
	bmrb.process(bmrbname.c_str());
	pdb->attach_bmrb(bmrb);
	pdb->getdihe(&dihe_index,&dihe_num);
	pdb->getring(&ring_index);
	pdb->ani(&anistropy);
	pdb->proton(&protons);
	pdb->allproton(&allprotons);
	pdb->process_ambig(2);
	pdb->allproton3(&allprotons3);
	heavy=pdb->getheavy();
	pdb->getbb(&bb);
	pdb->bbnh(&bbnh);
	pdb->bbhbond(&hbond);
	pdb->schbond(&hbond);  //This is new !
	ndihe=dihe_index.size();
	traj->getdihe(&dihe_index,&dihe);
	dihe_process.init(dihe_num,&dihe,&dihe_index);
	//process bb to remove all entry that has missing part !!
	//bbnh willn't take effect if bb is not there for particular residue
	bb=clear(bb);
	allprotons=clear(allprotons);
	allprotons3=clear(allprotons3);

	//seperate ring group to two, one for internal, one for surface, according to contact sum !
	int i;
	vector<int> ring_atom;
	vector<float> result;
	ring_atom.clear();
	result.clear();
	for(i=0;i<(int)ring_index.size();i++)
	{
		ring_atom.push_back(ring_index.at(i).x2);
	}
#ifdef BENCHMARK
	double clock = omp_get_wtime();
#endif
	traj->get_contact(1.00,0.0,ring_atom,heavy,&result);
#ifdef BENCHMARK
	printf("%.4f traj->get_contact\n", omp_get_wtime()-clock);
#endif
	ring_index_internal.clear();
	ring_index_external.clear();

	for(i=0;i<(int)ring_index.size();i++)
	{
		if(result.at(i)>2.5)
			ring_index_internal.push_back(ring_index.at(i));
		else
			ring_index_external.push_back(ring_index.at(i));
	}

	return;
}

vector<struct proton> CMainbody::clear(vector<struct proton> &protons)
{
	int i;
	int id,type;
	vector<struct proton> newprotons;
	newprotons.reserve(protons.size());

	for(i=0;i<protons.size();i++)
	{
		id=protons.at(i).id;
		type=protons.at(i).type;

		if(id<1 || id>pdb->getnres())
		{
			//protons.erase(protons.begin()+i);
			continue;
		}
		if(dihe_process.test_proton(id,type)==0) //==0 means missing dihedral angles in this calculation !!
		{
			//protons.erase(protons.begin()+i);
			continue;
		}
		newprotons.push_back(protons.at(i));
	}
	return newprotons;
}


vector<struct bb_group> CMainbody::clear(vector<struct bb_group> &bb)
{
	int i;
	int id;
	char code,code_pre,code_fol;
	vector<struct bb_group> newbb;
	newbb.reserve(bb.size());
	
	for(i=0;i<bb.size();i++)
	{
		//cout<<i<<endl;
		id=bb.at(i).id;

		//first and last residue are excluded
		if(id<=1)
		{
			//bb.erase(bb.begin()+i);
			continue;
		}
		if(id>=pdb->getnres())
		{
			//bb.erase(bb.begin()+i);
			continue;
		}

		code=pdb->code(id);
		code_pre=pdb->code(id-1);
		code_fol=pdb->code(id+1);

		//previous or following residue actually belong to another chain. 
		if(pdb->chain(id)!=pdb->chain(id-1) || pdb->chain(id)!=pdb->chain(id+1))
		{
			//bb.erase(bb.begin()+i);
			continue;
		}

		//missing or unknow residue should NOT be predicted. This is also true if either previous or following residue is missing (or unknown)
		if(code_pre=='X' || code_pre=='B' || code_fol=='X' || code_fol=='B'|| code=='X' || code=='B')
		{
			//bb.erase(bb.begin()+i);
			continue;
		}

		if(dihe_process.test(id,4,4)==0) //==0 means missing dihedral angles in this calculation !!
		{
			//bb.erase(bb.begin()+i);
			continue;
		}

		if(bb.at(i).capos<0 ||  bb.at(i).copos<0 || bb.at(i).npos<0 )
		{
			//bb.erase(bb.begin()+i);
			continue;
		}

		if(bb.at(i).cbpos<0 && bb.at(i).code!='G')
		{
			//bb.erase(bb.begin()+i);
			continue;
		}

		if(bb.at(i).hpos<0 && bb.at(i).code!='P')
		{
			//bb.erase(bb.begin()+i);
			continue;
		}

		newbb.push_back(bb.at(i));

	}

	return newbb;
}



int CMainbody::set_range(int begin,int stop)
{
	nconf=traj->set_range(begin,stop);
	return nconf;
}





void CMainbody::predict_bb()
{
	int i,j,j2,jj;
	int id;
	char code;
	vector<double> out;
	vector<double> in,in2;
	vector<struct double_five> ring_effect;
	vector<struct ehbond> hbond_effect;
	vector<struct double_four> ani_effect;
	vector<struct index_two> index;
	double pre[6];
	double temp;
	vector<double> eca,ecb,eco,eh,en;
	

	traj->gethbond(&hbond,&hbond_effect);
	traj->getani(&anistropy,&bbnh,&ani_effect);
	traj->getring(&ring_index,&bbnh,&ring_effect);

	
	/*carbon=bb_ca; exp.loadexp_bb("exp_ca.dat",&bb,carbon);
	carbon=bb_cb; exp.loadexp_bb("exp_cb.dat",&bb,carbon);
	carbon=bb_co; exp.loadexp_bb("exp_co.dat",&bb,carbon);
	exp.loadexp_bbn("exp_n.dat",&bbnh);
	exp.loadexp_bbnh("exp_hn.dat",&bbnh);*/


	index.resize(pdb->getnres());
	for(i=0;i<(int)index.size();i++)
		index.at(i).x1=index.at(i).x2=-1;
	for(i=0;i<(int)bb.size();i++)
		index.at(bb.at(i).id-1).x1=i+1;
	for(i=0;i<(int)bbnh.size();i++)
		index.at(bbnh.at(i).id-1).x2=i+1;
	

	for(i=0+1;i<(int)index.size()-1;i++)
	{
		//cout<<i<<endl;
		if(index.at(i).x1<0)
			continue;
		id=i+1;
		code=pdb->code(id);
		for(jj=0;jj<5;jj++)
			pre[jj]=0.0;
		//ca=cb=co=h=n=0.0;
 
		dihe_process.ca(id); 
		out=dihe_process.output();
		for(j=0;j<30;j++)
		{
			for(jj=0;jj<5;jj++)
				pre[jj]+=c_c[jj][j]*out.at(j);
		}

		for(j=42;j<60;j++)
		{
			for(jj=0;jj<5;jj++)
				pre[jj]+=c_c[jj][j-12]*out.at(j);
		}
			

		in.clear();
		for(j=0;j<12;j++)
		{
			in.push_back(out.at(j+30));
		}
		in2=Sequence::expand(code,&in);
		for(j=0;j<(int)in2.size();j++)
		{
			for(jj=0;jj<5;jj++)
				pre[jj]+=c_c[jj][j+48]*in2.at(j);
		}
		
		
		for(jj=0;jj<5;jj++)
		{
			for(j=-2;j<=0;j++)
			{
				j2=(j+2)*6;
				pre[jj]+=c_c[jj][288+j2]*hbond_effect.at(id+j).c_length;
				pre[jj]+=c_c[jj][289+j2]*hbond_effect.at(id+j).c_phi;
				pre[jj]+=c_c[jj][290+j2]*hbond_effect.at(id+j).c_psi;
				pre[jj]+=c_c[jj][291+j2]*hbond_effect.at(id+j).n_length;
				pre[jj]+=c_c[jj][292+j2]*hbond_effect.at(id+j).n_phi;
				pre[jj]+=c_c[jj][293+j2]*hbond_effect.at(id+j).n_psi;
			}
		}

			//sequence information
			code=pdb->code(id-1);
			Sequence::code2array(code,buffer);
			for(j=0;j<20;j++)		
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j+306]*buffer[j];
			}

			code=pdb->code(id);
			Sequence::code2array(code,buffer);
			for(j=0;j<20;j++)		
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j+326]*buffer[j];
			}

			code=pdb->code(id+1);
			Sequence::code2array(code,buffer);
			for(j=0;j<20;j++)		
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j+346]*buffer[j];
			}

			if(index.at(i).x2>0)
			{
				temp=0.0;
				for(j=0;j<5;j++)
					temp+=ring_effect.at(index.at(i).x2-1).x[j];
				temp*=c_h_add[4];
				for(j=0;j<4;j++)
					temp+=ani_effect.at(index.at(i).x2-1).x[j]*c_h_add[j];
				pre[3]+=temp;
			}
			pre[5]=999.0;
			pdb->attach_bbprediction(id,pre);
	}

	cal_error();
}





void CMainbody::predict_bb_static_ann()
{
	int i,j;
	int id;
	char code,code_pre,code_fol;
	vector<double> out;
	vector<double> in,in2;
	vector<struct double_five> ring_effect,ring_effect_ha;
	vector<struct ehbond> hbond_effect;
	vector<struct double_four> ani_effect,ani_effect_ha;
	vector<struct index_two> index;
	vector<int> c1,c2;
	vector<float> result;
	double pre[6];
	vector<double> eca,ecb,eco,eh,en;

	vector<double> oneline;
	vector<double> oneline_cb;
	vector<double> oneline_co;
	vector<double> oneline_h;
	vector<double> oneline_n;
	vector<double> oneline_ha;

#ifdef BENCHMARK
	double clock;
#endif


	class CAnn ann_ca,ann_cb,ann_co,ann_n,ann_h,ann_ha;

	//ann_ca.load("ann_ca.dat");
	ann_ca.loadp(p_ann_ca);
	ann_cb.loadp(p_ann_cb);
	ann_co.loadp(p_ann_co);
	ann_n.loadp(p_ann_n);
	ann_h.loadp(p_ann_h);
	ann_ha.loadp(p_ann_ha);

#ifdef BENCHMARK
	clock = omp_get_wtime();
#endif
	traj->gethbond(&hbond,&hbond_effect);
#ifdef BENCHMARK
	printf("%.4f gethbond\n", omp_get_wtime()-clock);
	clock = omp_get_wtime();
#endif
	traj->getani(&anistropy,&bbnh,&ani_effect);
#ifdef BENCHMARK
	printf("%.4f getani(bb)\n", omp_get_wtime()-clock);
	clock = omp_get_wtime();
#endif
	traj->getring(&ring_index,&bbnh,&ring_effect);
#ifdef BENCHMARK
	printf("%.4f getring(bb)\n", omp_get_wtime()-clock);
#endif

	
	//gather all ha protons to calculate ring and ani.
	vector<struct proton> ha_protons;
	struct proton ha;
	for(i=0;i<(int)bb.size();i++)
	{
		
		if(bb.at(i).code=='G')
		{
			ha.nh=2;
			ha.hpos[0]=max(0, bb.at(i).hapos);
			ha.hpos[1]=max(0, bb.at(i).hapos2);
			ha.exp=(bb.at(i).exp_ha+bb.at(i).exp_ha2)/2.0;
			ha.exp1=bb.at(i).exp_ha;
			ha.exp2=bb.at(i).exp_ha2;
			ha.type=90;
			ha.name="HB2";
			ha.name2="HB3";
			ha.cname="CA";
			ha.cname2="CA";
		}
		else
		{
			ha.nh=1;
			ha.hpos[0]=max(0, bb.at(i).hapos);
			ha.exp=bb.at(i).exp_ha;
			ha.type=91;
			ha.name="HA";
			ha.cname="CA";
		}
		ha.cpos=bb.at(i).capos;
		ha.exp_c=bb.at(i).exp_ca;
		ha.id=bb.at(i).id;
		ha.code=bb.at(i).code;

		ha_protons.push_back(ha);
	}
#ifdef BENCHMARK
	clock = omp_get_wtime();
#endif
	traj->getani(&anistropy,&ha_protons,&ani_effect_ha);
#ifdef BENCHMARK
	printf("%.4f getani(proton)\n", omp_get_wtime()-clock);
	clock = omp_get_wtime();
#endif
	traj->getring(&ring_index,&ha_protons,&ring_effect_ha);
#ifdef BENCHMARK
	printf("%.4f getring(proton)\n", omp_get_wtime()-clock);
#endif

	index.resize(pdb->getnres());	
	for(i=0;i<(int)index.size();i++)
		index.at(i).x1=index.at(i).x2=-1;
	for(i=0;i<(int)bb.size();i++)
		index.at(bb.at(i).id-1).x1=i+1;
	for(i=0;i<(int)bbnh.size();i++)
		index.at(bbnh.at(i).id-1).x2=i+1;

	c2 = pdb->getselect(":1-%@allheavy");
#ifdef BENCHMARK
	clock = omp_get_wtime();
#endif
	traj->get_contacts(bb,index,c2,&result);
#ifdef BENCHMARK
	printf("%.4f get_contacts\n", omp_get_wtime()-clock);
#endif

	for(i=0+1;i<(int)index.size()-1;i++)
	{
		//cout<<i<<endl;
		if(index.at(i).x1<0)
			continue;
		id=i+1;
		code=pdb->code(id);
		code_pre=pdb->code(id-1);
		code_fol=pdb->code(id+1);
		oneline.clear();

		//sequence information
		//blos62 matrix
		//total 60 terms
		Sequence::code2same(code_pre,buffer);
		for(j=0;j<20;j++)		
		{
			oneline.push_back(buffer[j]);
		}

		code=pdb->code(id);
		Sequence::code2same(code,buffer);
		for(j=0;j<20;j++)		
		{
			oneline.push_back(buffer[j]);
		}

		Sequence::code2same(code_fol,buffer);
		for(j=0;j<20;j++)		
		{
			oneline.push_back(buffer[j]);
		}


		//dihedral angle contribution!
		//total 28 terms
		dihe_process.ca_ann(id); 
		out=dihe_process.output();
		for(j=2;j<26;j++)
		{
			oneline.push_back(out.at(j));
		}
		for(j=28;j<(int)out.size();j++)
		{
			oneline.push_back(out.at(j));
		}


		//hbond effect, 12 terms
		oneline.push_back(hbond_effect.at(id-2).c_length);
		oneline.push_back((hbond_effect.at(id-2).c_phi));
		oneline.push_back((hbond_effect.at(id-2).c_psi));

		


		oneline.push_back(hbond_effect.at(id-1).c_length);
		oneline.push_back(hbond_effect.at(id-1).n_length);
		oneline.push_back((hbond_effect.at(id-1).c_phi));
		oneline.push_back((hbond_effect.at(id-1).c_psi));
		oneline.push_back((hbond_effect.at(id-1).n_phi));
		oneline.push_back((hbond_effect.at(id-1).n_psi));

		oneline.push_back(hbond_effect.at(id).n_length);
		oneline.push_back((hbond_effect.at(id).n_phi));
		oneline.push_back((hbond_effect.at(id).n_psi));


		//contact sum , one term
		//c1.clear();
		//c1.push_back(bb.at(index.at(i).x1-1).capos);
		//c1.push_back(bb.at(index.at(i).x1-1).cbpos);
		//c1.push_back(bb.at(index.at(i).x1-1).copos);
		//c2=pdb->getselect(":1-%@allheavy");
		//result.clear();
		//traj->get_contact(c1,c2,&result);

		oneline_co=oneline_cb=oneline;

		oneline.insert(oneline.begin()+60,result.at(i*3));
		oneline_cb.insert(oneline_cb.begin()+60,result.at(i*3+1));
		oneline_co.insert(oneline_co.begin()+60,result.at(i*3+2));
		oneline_n=oneline;
		
		pre[0]=ann_ca.predict_one(oneline);
		pre[1]=ann_cb.predict_one(oneline_cb);
		pre[2]=ann_co.predict_one(oneline_co);
		pre[4]=ann_n.predict_one(oneline_n);
		
		//hn
		if(index.at(i).x2>0)
		{
			oneline_h=oneline;
			for(j=0;j<5;j++)
				oneline_h.push_back(ring_effect.at(index.at(i).x2-1).x[j]);
			for(j=0;j<4;j++)
				oneline_h.push_back(ani_effect.at(index.at(i).x2-1).x[j]);	
			pre[3]=ann_h.predict_one(oneline_h);
		}
		else
			pre[3]=-999.0;
	

		//ha 
		oneline_ha=oneline;
		for(j=0;j<5;j++)
			oneline_ha.push_back(ring_effect_ha.at(index.at(i).x1-1).x[j]);
		for(j=0;j<4;j++)
			oneline_ha.push_back(ani_effect_ha.at(index.at(i).x1-1).x[j]);
		pre[5]=ann_ha.predict_one(oneline_ha);

		pdb->attach_bbprediction(id,pre);
	}

	cal_error();
};


void CMainbody::predict_bb_static_new()
{
	int i,j,jj;
	int id;
	int jump;
	char code,code_pre,code_fol;
	vector<double> out;
	vector<double> in,in2;
	vector<struct double_five> ring_effect,ring_effect_ha;
	vector<struct ehbond> hbond_effect;
	vector<struct double_four> ani_effect,ani_effect_ha;
	vector<struct index_two> index;
	vector<int> c1,c2;
	vector<float> result;
	double pre[6];
	double temp,temp1,temp2,tt1,tt2;
	vector<double> eca,ecb,eco,eh,en;
	double rc;
	double vhill;
	


	traj->gethbond(&hbond,&hbond_effect);
	traj->getani(&anistropy,&bbnh,&ani_effect);
	traj->getring(&ring_index,&bbnh,&ring_effect);



	

	vector<struct proton> ha_protons;
	struct proton ha;
	for(i=0;i<(int)bb.size();i++)
	{
		
		if(bb.at(i).code=='G')
		{
			ha.nh=2;
			ha.hpos[0]=bb.at(i).hapos;
			ha.hpos[1]=bb.at(i).hapos2;
			ha.exp=(bb.at(i).exp_ha+bb.at(i).exp_ha2)/2.0;
			ha.exp1=bb.at(i).exp_ha;
			ha.exp2=bb.at(i).exp_ha2;
			ha.type=90;
			ha.name="HB2";
			ha.name2="HB3";
			ha.cname="CA";
			ha.cname2="CA";
		}
		else
		{
			ha.nh=1;
			ha.hpos[0]=bb.at(i).hapos;
			ha.exp=bb.at(i).exp_ha;
			ha.type=91;
			ha.name="HA";
			ha.cname="CA";
		}
		ha.cpos=bb.at(i).capos;
		ha.exp_c=bb.at(i).exp_ca;
		ha.id=bb.at(i).id;
		ha.code=bb.at(i).code;

		ha_protons.push_back(ha);
	}
	traj->getani(&anistropy,&ha_protons,&ani_effect_ha);
	traj->getring(&ring_index,&ha_protons,&ring_effect_ha);




	index.resize(pdb->getnres());	
	for(i=0;i<(int)index.size();i++)
		index.at(i).x1=index.at(i).x2=-1;
	for(i=0;i<(int)bb.size();i++)
		index.at(bb.at(i).id-1).x1=i+1;
	for(i=0;i<(int)bbnh.size();i++)
		index.at(bbnh.at(i).id-1).x2=i+1;
	

	for(i=0+1;i<(int)index.size()-1;i++)
	{
		//cout<<i<<endl;
		if(index.at(i).x1<0)
			continue;
		id=i+1;
		code=pdb->code(id);
		code_pre=pdb->code(id-1);
		code_fol=pdb->code(id+1);

		for(jj=0;jj<6;jj++)
			pre[jj]=0.0;
		jump=0;

		//ca=cb=co=h=n=0.0;

		//missing or unknow residue shouldn't be predicted. This is also true if either previous or following residue is missing (or unknown)
		if(code_pre=='X' || code_pre=='B' || code_fol=='X' || code_fol=='B'|| code=='X' || code=='B')
		{
			for(jj=0;jj<6;jj++)
				pre[jj]=-999.0;
			continue;
		}

		//sequence information
		Sequence::code2array(code_pre,buffer);
		for(j=0;j<20;j++)		
		{
			for(jj=0;jj<6;jj++)
				pre[jj]+=static_c[jj][j+jump]*buffer[j];
		}
		jump+=20;
		
		code=pdb->code(id);
		Sequence::code2array(code,buffer);
		for(j=0;j<20;j++)		
		{
			for(jj=0;jj<6;jj++)
				pre[jj]+=static_c[jj][j+jump]*buffer[j];
		}
		jump+=20;

		Sequence::code2array(code_fol,buffer);
		for(j=0;j<20;j++)		
		{
			for(jj=0;jj<6;jj++)
				pre[jj]+=static_c[jj][j+jump]*buffer[j];
		}
		jump+=20;



		//dihedral angle contribution!
		if(dihe_process.ca_static_new(id)==0) //==0 means missing dihedral angles in this calculation !!
		{
			for(jj=0;jj<6;jj++)
				pre[jj]=-999.0;
			continue;
		}

		out=dihe_process.output();

		//pre dihe  12*20 terms
		in.clear();
		for(j=0;j<12;j++)
		{
			in.push_back(out.at(j));
		}
		in2=Sequence::expand(code_pre,&in);
		for(j=0;j<(int)in2.size();j++)
		{
			for(jj=0;jj<6;jj++)
				pre[jj]+=static_c[jj][j+jump]*in2.at(j);
		}
		jump+=240;


		//self dihe 24*20 terms
		in.clear();
		for(j=0;j<24;j++)
		{
			in.push_back(out.at(j+12));
		}
		in2=Sequence::expand(code,&in);
		for(j=0;j<(int)in2.size();j++)
		{
			for(jj=0;jj<6;jj++)
				pre[jj]+=static_c[jj][j+jump]*in2.at(j);
		}
		jump+=480;
		
		//follow dihe  12*20 terms
		in.clear();
		for(j=0;j<12;j++)
		{
			in.push_back(out.at(j+36));
		}
		in2=Sequence::expand(code_fol,&in);
		for(j=0;j<(int)in2.size();j++)
		{
			for(jj=0;jj<6;jj++)
				pre[jj]+=static_c[jj][j+jump]*in2.at(j);
		}
		jump+=240;
		
	
		//hbond effect, length only
		for(jj=0;jj<6;jj++)
		{	
			tt1=temp1=hbond_effect.at(id-1).c_length;
			tt2=temp2=hbond_effect.at(id-1).n_length;
			pre[jj]+=static_c[jj][jump+0]*temp1;
			pre[jj]+=static_c[jj][jump+1]*temp2;

			temp1*=temp1;temp2*=temp2;
			pre[jj]+=static_c[jj][jump+2]*temp1;
			pre[jj]+=static_c[jj][jump+3]*temp2;

			pre[jj]+=static_c[jj][jump+4]*temp1*tt1;
			pre[jj]+=static_c[jj][jump+5]*temp2*tt2;

			temp1*=temp1;temp2*=temp2;
			pre[jj]+=static_c[jj][jump+6]*temp1;
			pre[jj]+=static_c[jj][jump+7]*temp2;
		}
		jump+=8;

						
		if(index.at(i).x2>0)
		{
			temp=0.0;
			for(j=0;j<5;j++)
				temp+=ring_effect.at(index.at(i).x2-1).x[j]*static_h[0][j];
			for(j=0;j<4;j++)
				temp+=ani_effect.at(index.at(i).x2-1).x[j]*static_h[0][j+5];
			pre[3]+=temp;
		}

		temp=0.0;
		for(j=0;j<5;j++)
			temp+=ring_effect_ha.at(index.at(i).x1-1).x[j]*static_h[1][j];
		for(j=0;j<4;j++)
			temp+=ani_effect_ha.at(index.at(i).x1-1).x[j]*static_h[1][j+5];
		pre[5]+=temp;


		//get contact sum adjustment
		c1.clear();
		c1.push_back(bb.at(index.at(i).x1-1).capos);
		c1.push_back(bb.at(index.at(i).x1-1).cbpos);
		c1.push_back(bb.at(index.at(i).x1-1).copos);
		c2=pdb->getselect(":1-%@allheavy");
		result.clear();
		traj->get_contact(c1,c2,&result);
		result.push_back(result.at(0));
		result.push_back(result.at(0));
		result.push_back(result.at(0));

		for(jj=0;jj<6;jj++)
		{
			vhill=hill(result.at(jj),hill_para[jj][0],hill_para[jj][1]);
			rc=(1-vhill)/vhill;
			pre[jj]+=rc*static_c[jj][Sequence::code2pos(code)+jump];
			pre[jj]*=vhill;
		}
		
		pdb->attach_bbprediction(id,pre);
	}
	
	cal_error();

}


void CMainbody::cal_error()
{
	int j;
	vector< vector<double> > cas,cbs,cos,hs,ns,has;
	double e,t,w;


	cas.resize(2);cbs.resize(2);cos.resize(2);hs.resize(2);ns.resize(2);has.resize(2);
	bb.clear();
	pdb->getbb(&bb);
	bb=clear(bb);
	for(j=0;j<(int)bb.size();j++)
	{
		cas.at(0).push_back(bb.at(j).exp_ca);
		cbs.at(0).push_back(bb.at(j).exp_cb);
		cos.at(0).push_back(bb.at(j).exp_co);
		hs.at(0).push_back(bb.at(j).exp_h);
		ns.at(0).push_back(bb.at(j).exp_n);
		has.at(0).push_back(bb.at(j).exp_ha);
	
		cas.at(1).push_back(bb.at(j).pre_ca);
		cbs.at(1).push_back(bb.at(j).pre_cb);
		cos.at(1).push_back(bb.at(j).pre_c);
		hs.at(1).push_back(bb.at(j).pre_h);
		ns.at(1).push_back(bb.at(j).pre_n);
		has.at(1).push_back(bb.at(j).pre_ha);

	}
	compare("CA",cas);compare("CB",cbs);compare("C'",cos);compare("HN",hs);compare("N",ns);compare("HA",has);


	FILE *fp=fopen("cs_rmsd.dat","wt");

	for(j=0;j<(int)bb.size();j++)
	{
		e=0;
		w=0;
		if(fabs(bb.at(j).exp_ca)<490.0 && fabs(bb.at(j).pre_ca)<490.0)
		{
			t=bb.at(j).exp_ca-bb.at(j).pre_ca;
			e+=t*t;
			w+=1.0;
		}
		if(fabs(bb.at(j).exp_cb)<490.0 && fabs(bb.at(j).pre_cb)<490.0)
		{
			t=bb.at(j).exp_cb-bb.at(j).pre_cb;
			e+=t*t;
			w+=1.0;
		}
		if(fabs(bb.at(j).exp_co)<490.0 && fabs(bb.at(j).pre_c)<490.0)
		{
			t=bb.at(j).exp_co-bb.at(j).pre_c;
			e+=t*t;
			w+=1.0;
		}
		if(fabs(bb.at(j).exp_h)<490.0 && fabs(bb.at(j).pre_h)<490.0)
		{
			t=bb.at(j).exp_h-bb.at(j).pre_h;
			e+=t*t*4;
			w+=4.0;
		}
		if(fabs(bb.at(j).exp_n)<490.0 && fabs(bb.at(j).pre_n)<490.0)
		{
			t=bb.at(j).exp_n-bb.at(j).pre_n;
			e+=t*t*0.4;
			w+=0.4;
		}
		if(fabs(bb.at(j).exp_ha)<490.0 && fabs(bb.at(j).pre_ha)<490.0)
		{
			t=bb.at(j).exp_ha-bb.at(j).pre_ha;
			e+=t*t*4;
			w+=4;
		}
		if(w>0.0)
		{
			e=sqrt(e/w);
			fprintf(fp,"%10d%10s%10.2f\n",bb.at(j).id0,Sequence::code2name(bb.at(j).code).c_str(),e);
		}
		else
			e=0.0;

	}		
	fclose(fp);		

}


double CMainbody::hill(double contact, double v1, double v2)
{
	double hill;
	
	if(contact<v1)	
		hill=0.0;
	else if(contact>v2)
		hill=1.0;
	else
	{
		hill=(contact-v1)/(v2-v1)*6-3;
		hill=(1-exp(-2*hill))/(1+exp(-2*hill));
		hill=hill/2+0.5;
	}

	return hill;

}


void CMainbody::predict_bb2()
{
	int i,j,j2,jj,n;
	int id;
	char code;
	vector< vector<double> > out;
	vector<double> in,in2;
	vector< vector<struct double_five> > ring_effect;
	vector< vector<struct ehbond> > hbond_effect;
	vector< vector<struct double_four> > ani_effect;
	vector<struct index_two> index;
	vector<double> cs_ca,cs_cb,cs_c,cs_h,cs_n;
	double pre[6];
	double temp;
	vector<double> eca,ecb,eco,eh,en;
	char name[4];
	FILE *fp;

	fp=fopen("bb_details.dat","w");
	


	traj->gethbond(&hbond,&hbond_effect);
	traj->getani(&anistropy,&bbnh,&ani_effect);
	traj->getring(&ring_index,&bbnh,&ring_effect);

	

	index.resize(pdb->getnres());	
	for(i=0;i<(int)index.size();i++)
		index.at(i).x1=index.at(i).x2=-1;
	for(i=0;i<(int)bb.size();i++)
		index.at(bb.at(i).id-1).x1=i+1;
	for(i=0;i<(int)bbnh.size();i++)
		index.at(bbnh.at(i).id-1).x2=i+1;


	

	for(i=0+1;i<(int)index.size()-1;i++)
	{	//cout<<"i is "<<i<<endl;
		if(index.at(i).x1<0)
			continue;
		id=i+1;
		code=pdb->code(id);
		pdb->name(id,name);

		if(strcmp(name,"CYS")==0)
			continue;

		dihe_process.ca2(id); 
		out=dihe_process.output2();

		cs_ca.clear();
		cs_cb.clear();
		cs_c.clear();
		cs_h.clear();
		cs_n.clear();

		for(n=0;n<nconf;n++)
		{		
			id=i+1;
			code=pdb->code(id);

			for(jj=0;jj<5;jj++)
				pre[jj]=0.0;
	 
			for(j=0;j<30;j++)
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j]*out.at(j).at(n);
			}

			for(j=42;j<60;j++)
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j-12]*out.at(j).at(n);
			}
				

			in.clear();
			for(j=0;j<12;j++)
			{
				in.push_back(out.at(j+30).at(n));
			}
			in2=Sequence::expand(code,&in);


			for(j=0;j<(int)in2.size();j++)
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j+48]*in2.at(j);
			}
			
		
			for(jj=0;jj<5;jj++)
			{
				for(j=-2;j<=0;j++)
				{
					j2=(j+2)*6;
					pre[jj]+=c_c[jj][288+j2]*hbond_effect.at(id+j).at(n).c_length;
					pre[jj]+=c_c[jj][289+j2]*hbond_effect.at(id+j).at(n).c_phi;
					pre[jj]+=c_c[jj][290+j2]*hbond_effect.at(id+j).at(n).c_psi;
					pre[jj]+=c_c[jj][291+j2]*hbond_effect.at(id+j).at(n).n_length;
					pre[jj]+=c_c[jj][292+j2]*hbond_effect.at(id+j).at(n).n_phi;
					pre[jj]+=c_c[jj][293+j2]*hbond_effect.at(id+j).at(n).n_psi;
				}
			}

			//sequence information
			code=pdb->code(id-1);
			Sequence::code2array(code,buffer);
			for(j=0;j<20;j++)		
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j+306]*buffer[j];
			}

			code=pdb->code(id);
			Sequence::code2array(code,buffer);
			for(j=0;j<20;j++)		
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j+326]*buffer[j];
			}

			code=pdb->code(id+1);
			Sequence::code2array(code,buffer);
			for(j=0;j<20;j++)		
			{
				for(jj=0;jj<5;jj++)
					pre[jj]+=c_c[jj][j+346]*buffer[j];
			}


			if(index.at(i).x2>0)
			{
				temp=0.0;
				for(j=0;j<5;j++)
					temp+=ring_effect.at(index.at(i).x2-1).at(n).x[j];
				temp*=c_h_add[4];
				for(j=0;j<4;j++)
					temp+=ani_effect.at(index.at(i).x2-1).at(n).x[j]*c_h_add[j];
				pre[3]+=temp;
			}

			cs_ca.push_back(pre[0]);
			cs_cb.push_back(pre[1]);
			cs_c.push_back(pre[2]);
			cs_n.push_back(pre[4]);
			cs_h.push_back(pre[3]);
		}
	
		fprintf(fp,"%8d%8s",id,name);
		fprintf(fp,"   CA   ");
		fprintf(fp,"%8.3f",bb.at(index.at(i).x1-1).exp_ca);
		for(n=0;n<nconf;n++)
				fprintf(fp,"%8.3f",cs_ca.at(n));

		fprintf(fp,"\n%8d%8s",id,name);
		fprintf(fp,"   CB   ");
		fprintf(fp,"%8.3f",bb.at(index.at(i).x1-1).exp_cb);
		for(n=0;n<nconf;n++)
				fprintf(fp,"%8.3f",cs_cb.at(n));

		fprintf(fp,"\n%8d%8s",id,name);
		fprintf(fp,"   C    ");	
		fprintf(fp,"%8.3f",bb.at(index.at(i).x1-1).exp_co);
		for(n=0;n<nconf;n++)
				fprintf(fp,"%8.3f",cs_c.at(n));

		fprintf(fp,"\n%8d%8s",id,name);
		fprintf(fp,"   H    ");
		if(index.at(i).x2>1)
			fprintf(fp,"%8.3f",bbnh.at(index.at(i).x2-1).exp_h);
		else
			fprintf(fp,"%8.3f",999.0);
		for(n=0;n<nconf;n++)
				fprintf(fp,"%8.3f",cs_h.at(n));

		fprintf(fp,"\n%8d%8s",id,name);
		fprintf(fp,"   N    ");
		if(index.at(i).x2>1)
			fprintf(fp,"%8.3f",bbnh.at(index.at(i).x2-1).exp_n);
		else
			fprintf(fp,"%8.3f",999.0);
		for(n=0;n<nconf;n++)
				fprintf(fp,"%8.3f",cs_n.at(n));
		fprintf(fp,"\n");


		for(n=0;n<5;n++)
			pre[n]=0;
		for(n=0;n<nconf;n++)
		{
			pre[0]+=cs_ca.at(n);
			pre[1]+=cs_cb.at(n);
			pre[2]+=cs_c.at(n);
			pre[3]+=cs_h.at(n);
			pre[4]+=cs_n.at(n);
		}
		for(n=0;n<5;n++)
			pre[n]/=nconf;
		pre[5]=999.0;
		pdb->attach_bbprediction(id,pre);
	}
	return;
}






void CMainbody::predict_proton()
{
	int i,j;
	int id;
	char code;
	int type;

	double c_ring[5]={-0.1939,-0.1629,-0.1620,-0.1872,-0.1987};
	double c_ani[4]={0.004478932,0.000925861,0.001692256,0.00040848288};
	double c_rand[10]={1.3876,1.2671,2.0763,0.0000,1.0064,0.9611,0.9102,0.8890,0.9976,0.8584};

	
	double cs_ring,cs_ani,cs_rand,cs;


	vector< vector<double> > hs;
	hs.resize(2);


	vector<struct double_five> ring_effect;
	vector<struct double_four> ani_effect;

	traj->getani(&anistropy,&protons,&ani_effect);
	traj->getring(&ring_index,&protons,&ring_effect);
		


	for(i=0;i<(int)protons.size();i++)
	{	
		id=protons.at(i).id;
		code=protons.at(i).code;	
		type=protons.at(i).type;


		cs_ring=0;
		for(j=0;j<5;j++)
			cs_ring+=ring_effect.at(i).x[j]*c_ring[j];

		cs_ani=0;
		for(j=0;j<4;j++)
			cs_ani+=ani_effect.at(i).x[j]*c_ani[j];
		cs_rand=c_rand[type-1];
		cs=cs_ring+cs_ani+cs_rand;
		pdb->attach_protonprediction(id,protons.at(i).name,cs);

		hs.at(0).push_back(protons.at(i).exp);
		hs.at(1).push_back(cs);
	}

	compare("Methyl 1H",hs);
	return;
}

void CMainbody::predict_proton2()
{
	int i,j,ii;
	int id;
	char code;
	int type;
	double cs_rand;
	vector<double> cs_ring,cs_ani,cs;
	double ccs_ring,ccs_ani,ccs;
	FILE *fp;

	fp=fopen("proton_details.dat","w");

	double c_ring[5]={-0.1939,-0.1629,-0.1620,-0.1872,-0.1987};
	double c_ani[4]={0.004478932,0.000925861,0.001692256,0.00040848288};
	double c_rand[10]={1.3876,1.2671,2.0763,0.0000,1.0064,0.9611,0.9102,0.8890,0.9976,0.8584};

	vector< vector<struct double_five> > ring_effect;
	vector< vector<struct double_four> > ani_effect;
	traj->getani(&anistropy,&protons,&ani_effect);
	traj->getring(&ring_index,&protons,&ring_effect);

	for(i=0;i<(int)protons.size();i++)
	{	
		id=protons.at(i).id;
		code=protons.at(i).code;	
		type=protons.at(i).type;

		for(ii=0;ii<nconf;ii++)
		{
			cs_ring.push_back(0.0);
			cs_ani.push_back(0.0);
			cs.push_back(0.0);
		}
		for(ii=0;ii<nconf;ii++)
		{
			cs_ring[ii]=0;
			for(j=0;j<5;j++)
				cs_ring[ii]+=ring_effect.at(i).at(ii).x[j]*c_ring[j];
			cs_ani[ii]=0;
			for(j=0;j<4;j++)
				cs_ani[ii]+=ani_effect.at(i).at(ii).x[j]*c_ani[j];
			cs_rand=c_rand[type-1];
			cs[ii]=cs_ring[ii]+cs_ani[ii]+cs_rand;
		}
		fprintf(fp,"%8d %8s %8s",id,Sequence::code2name(code).c_str(),protons.at(i).name.c_str());
		if(fabs(protons.at(i).exp)>0.00001)
			fprintf(fp," %8.3f",protons.at(i).exp);
		else
			fprintf(fp," %8.3f",999.9);
		for(ii=0;ii<nconf;ii++)
			fprintf(fp," %8.3f",cs[ii]);
		fprintf(fp,"\n");


		ccs=ccs_ring=ccs_ani=0.0;
		for(ii=0;ii<nconf;ii++)
		{	
			ccs+=cs[ii];
			ccs_ring+=cs_ring[ii];
			ccs_ani+=cs_ani[ii];
		}
		ccs/=nconf;
		ccs_ring/=nconf;
		ccs_ani/=nconf;
		pdb->attach_protonprediction(id,protons.at(i).name,ccs);
	}
	fclose(fp);
	return;
}


void CMainbody::predict_proton_static_new(void)
{
	int i,j;
	int id;
	int type;
	vector<double> out;
	int jump;
	float pre;
	double *c;
	vector< vector<double> > hs;
	double clock;



	vector<struct double_five> ring_effect;
	vector<struct double_four> ani_effect;
	
	
	allprotons=allprotons3;
	clock = omp_get_wtime();
	traj->getani(&anistropy,&allprotons,&ani_effect);
	printf("%.4f getani(proton)\n", omp_get_wtime()-clock);
	clock = omp_get_wtime();
	traj->getring(&ring_index,&allprotons,&ring_effect);
	printf("%.4f getani(proton)\n", omp_get_wtime()-clock);

	hs.resize(2);

	
		
	for(i=0;i<(int)allprotons.size();i++)
	{		
		type=allprotons.at(i).type;
		id=allprotons.at(i).id;
		
		//too few data point and bad fitting !
		if(type==18 || type==19 || type==28 || type==49 || type==64  || type==82  || type==84  || type==97 )
			continue;
		//bad fitting !
		if(type==36 || type==48 || type==62 )
			continue;

		//use gobal or individual fitting?
		if(sep_table[type]>=0)
			c=c_sep[type-1];
		else
			c=c_all;

		jump=0;
		pre=c[type-1];
		jump+=98;

		for(j=0;j<5;j++)
			pre+=ring_effect.at(i).x[j]*c[j+jump];
		jump+=5;

		for(j=0;j<4;j++)
			pre+=ani_effect.at(i).x[j]*c[j+jump];
		jump+=4;

		dihe_process.allproton(allprotons.at(i).id); 
		dihe_process.hb_expand(type);
		out=dihe_process.output();
		for(j=0;j<8*18;j++)
			pre+=out.at(j)*c[j+jump];
		jump+=8*18;

		pdb->attach_protonprediction(id,allprotons.at(i).name,pre);
		if(allprotons.at(i).name2!="")
			pdb->attach_protonprediction(id,allprotons.at(i).name2,pre);

		hs.at(0).push_back(allprotons.at(i).exp);
		hs.at(1).push_back(pre);
	}
	compare("Side chain protons",hs);
	return;
}



void CMainbody::compare(char * buff, vector< vector<double> > t)
{
	int i,j,n;
	double e,ee;
	bool b;
	vector<bool> bs;

	for(i=0;i<(int)t.at(0).size();i++)
	{
		b=0;
		for(j=0;j<(int)t.size();j++)
		{
			if(t.at(j).at(i)<-400.0 || t.at(j).at(i)>400.0 )
				b=1;
		}
		bs.push_back(b);
		
	}

	cout<<buff<<": ";
	for(i=1;i<(int)t.size();i++)
	{
		ee=0;
		n=0;
		for(j=0;j<(int)t.at(0).size();j++)
		{
			if(bs.at(j)==0)
			{
				e=t.at(0).at(j)-t.at(i).at(j);
				ee+=e*e;
				n++;
			}
		}
		if(n>0)
		{
			ee/=n;
			ee=sqrt(ee);
			cout<<" "<<ee;
		}
		else
			cout<<" N.A.";
	}
	cout<<endl;
}

//This file include all trained parameters in PPM.
#include "data.h"

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// custom user modules 

#include "./custom_modules/cancer_immune_3D.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }
	
	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// PNRG setup 
	SeedRandom(); 
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); 

	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	create_cell_types();
	setup_tissue();
	
	/* Users typically start modifying here. START USERMODS */ 

	double immune_activation_time = 
		parameters.doubles("immune_activation_time"); // 60 * 24 * 14; // activate immune response at 14 days 
	
	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );
	
	// save a simulation snapshot 

	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = cancer_immune_coloring_function;
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	display_citations(); 
	
	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}

	//set the diffusion solver to GPU
	microenvironment.diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_3D_GPU;
	bool first = true;
	
	int outs = 0;

	// main loop 
	
	try 
	{	
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			if (outs == 1){
				microenvironment.translate_array_to_vector();
				sprintf( filename , "%s/first_out" , PhysiCell_settings.folder.c_str() ); 
				save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
			}


			static bool immune_cells_introduced = false; 
			if( PhysiCell_globals.current_time > immune_activation_time - 0.01*diffusion_dt && immune_cells_introduced == false )
			{
				std::cout << "Therapy activated!" << std::endl << std::endl; 
				immune_cells_introduced = true; 
				
				PhysiCell_settings.full_save_interval = 
					parameters.doubles("save_interval_after_therapy_start"); // 3.0; 
				PhysiCell_settings.SVG_save_interval = 
					parameters.doubles("save_interval_after_therapy_start"); // 3.0; 
				
				PhysiCell_globals.next_full_save_time = PhysiCell_globals.current_time; 
				PhysiCell_globals.next_SVG_save_time = PhysiCell_globals.current_time; 
				
				introduce_immune_cells();
			} 

			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				// translate data back to vector and update host
				if (first == false){
					std::cout << "updating host" << std::endl;
					microenvironment.translate_array_to_vector();
					std::cout << "-------continuing-------" << std::endl;
				}
				first = false;
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				std::cout << "2" << std::endl;
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
			}
			
			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			// if( default_microenvironment_options.calculate_gradients )
			// { microenvironment.compute_all_gradient_vectors(); }
			
			// run PhysiCell 
			// ((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			
			// manually call the code for cell sources and sinks, 
			// since these are ordinarily automatically done as part of phenotype.secretion in the 
			// PhysiCell update that we commented out above. Remove this when we go 
			// back to main code 
/*			
			#pragma omp parallel for 
			for( int i=0; i < (*all_cells).size(); i++ )
			{
				(*all_cells)[i]->phenotype.secretion.advance( (*all_cells)[i], (*all_cells)[i]->phenotype , diffusion_dt );
			}			
*/			
			PhysiCell_globals.current_time += diffusion_dt;
			outs++;
		}
		
		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	microenvironment.translate_array_to_vector();

	std::cout << "NUM_DIRICHLET " << microenvironment.num_dirichlet << std::endl;
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );

	return 0; 
}

########## NEXT FILE ##########
/*
#############################################################################
# If you use BioFVM in your project, please cite BioFVM and the version     #
# number, such as below:                                                    #
#                                                                           #
# We solved the diffusion equations using BioFVM (Version 1.1.7) [1]        #
#                                                                           #
# [1] A. Ghaffarizadeh, S.H. Friedman, and P. Macklin, BioFVM: an efficient #
#    parallelized diffusive transport solver for 3-D biological simulations,#
#    Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730 #
#                                                                           #
#############################################################################
#                                                                           #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)   #
#                                                                           #
# Copyright (c) 2015-2017, Paul Macklin and the BioFVM Project              #
# All rights reserved.                                                      #
#                                                                           #
# Redistribution and use in source and binary forms, with or without        #
# modification, are permitted provided that the following conditions are    #
# met:                                                                      #
#                                                                           #
# 1. Redistributions of source code must retain the above copyright notice, #
# this list of conditions and the following disclaimer.                     #
#                                                                           #
# 2. Redistributions in binary form must reproduce the above copyright      #
# notice, this list of conditions and the following disclaimer in the       #
# documentation and/or other materials provided with the distribution.      #
#                                                                           #
# 3. Neither the name of the copyright holder nor the names of its          #
# contributors may be used to endorse or promote products derived from this #
# software without specific prior written permission.                       #
#                                                                           #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS       #
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED #
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A           #
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER #
# OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  #
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,       #
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR        #
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF    #
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING      #
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS        #
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.              #
#                                                                           #
#############################################################################
*/

#include "BioFVM_microenvironment.h"
#include "BioFVM_solvers.h"
#include "BioFVM_vector.h"
#include <cmath>

#include "BioFVM_basic_agent.h"
#include "openacc.h"

namespace BioFVM{

extern std::string BioFVM_version; 
extern std::string BioFVM_URL; 

Microenvironment* default_microenvironment = NULL; 

void set_default_microenvironment( Microenvironment* M )
{ default_microenvironment = M; }
Microenvironment* get_default_microenvironment( void )
{ return default_microenvironment; }

void zero_function( std::vector<double>& position, std::vector<double>& input , std::vector<double>* write_destination )
{
	for( unsigned int i=0 ; i < write_destination->size() ; i++ )
	{ (*write_destination)[i] = 0.0; }
	return; 
}

void one_function( std::vector<double>& position, std::vector<double>& input , std::vector<double>* write_destination )
{
	for( unsigned int i=0 ; i < write_destination->size() ; i++ )
	{ (*write_destination)[i] = 1.0; }
	return; 
}

void zero_function( Microenvironment* pMicroenvironment, int voxel_index, std::vector<double>* write_destination ) 
{
	for( unsigned int i=0 ; i < write_destination->size() ; i++ )
	{ (*write_destination)[i] = 0.0; }
	return; 
}

void one_function( Microenvironment* pMicroenvironment, int voxel_index, std::vector<double>* write_destination )
{
	for( unsigned int i=0 ; i < write_destination->size() ; i++ )
	{ (*write_destination)[i] = 1.0; }
	return; 
}

void empty_diffusion_solver( Microenvironment& S, double dt )
{
	static bool setup_done = false; 
	if( !setup_done )
	{
		std::cout << "Using the empty diffusion solver ... " << std::endl; 
		setup_done = true; 
	}

	return; 
}

Microenvironment::Microenvironment()
{	
	name = "unnamed"; 
	spatial_units = "none"; 
	time_units = "none";
	
	bulk_source_sink_solver_setup_done = false; 
	thomas_setup_done = false; 
	diffusion_solver_setup_done = false; 

	diffusion_decay_solver = empty_diffusion_solver;
	diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_3D; 

	mesh.resize(1,1,1); 

	openacc_data_bool = false; // GPU init
	
	one.resize( 1 , 1.0 ); 
	zero.resize( 1 , 0.0 );
	
	temporary_density_vectors1.resize( mesh.voxels.size() , zero ); 
	temporary_density_vectors2.resize( mesh.voxels.size() , zero ); 
	p_density_vectors = &temporary_density_vectors1;

	gradient_vectors.resize( mesh.voxels.size() ); 
	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		gradient_vectors[k].resize( 1 ); 
		(gradient_vectors[k])[0].resize( 3, 0.0 );
	}
	gradient_vector_computed.resize( mesh.voxels.size() , false ); 

	bulk_supply_rate_function = zero_function; 
	bulk_supply_target_densities_function = zero_function; 
	bulk_uptake_rate_function = zero_function; 

	density_names.assign( 1 , "unnamed" ); 
	density_units.assign( 1 , "none" ); 

	diffusion_coefficients.assign( number_of_densities() , 0.0 ); 
	decay_rates.assign( number_of_densities() , 0.0 ); 
	
	one_half = one; 
	one_half *= 0.5; 
	
	one_third = one; 
	one_third /= 3.0;

/*	
	dirichlet_indices.clear();
	dirichlet_value_vectors.clear();
	
	dirichlet_node_map.assign( mesh.voxels.size() , -1 ); 
*/
	dirichlet_value_vectors.assign( mesh.voxels.size(), one ); 
	dirichlet_activation_vector.assign( 1 , true ); 
	
	if(default_microenvironment==NULL)
	{ default_microenvironment=this; }

	return; 
}

Microenvironment::Microenvironment(std::string name)
{	
	Microenvironment();
	this->name=name;
	
	return; 
}

void Microenvironment::add_dirichlet_node( int voxel_index, std::vector<double>& value )
{
	mesh.voxels[voxel_index].is_Dirichlet=true;
	/*
	dirichlet_indices.push_back( voxel_index );
	dirichlet_value_vectors.push_back( value ); 
	*/
	
	dirichlet_value_vectors[voxel_index] = value; // .assign( mesh.voxels.size(), one ); 
	
	return; 
}

void Microenvironment::update_dirichlet_node( int voxel_index , std::vector<double>& new_value )
{
/*
	if( mesh.voxels[voxel_index].is_Dirichlet == false )
	{ 
		std::cout << "BioFVM Warning: No Dirichlet condition previously specified at voxel " << voxel_index << "! Creating a new one now ... " << std::endl; 
		add_dirichlet_node( voxel_index , new_value ); 
		return; 
	}
	
	int n = 0; 
	while( dirichlet_indices[n] != voxel_index && n < dirichlet_indices.size() )
	{ n++; }
		
	if( n == dirichlet_indices.size() )
	{ 
		std::cout << "BioFVM Warning: No Dirichlet condition previously specified at voxel " << voxel_index << "! Creating a new one now ... " << std::endl; 
		add_dirichlet_node( voxel_index , new_value ); 
		return; 
	}

	dirichlet_value_vectors[n] = new_value; 
	*/
	
	mesh.voxels[voxel_index].is_Dirichlet = true; 
	dirichlet_value_vectors[voxel_index] = new_value; 
	
	return; 
}

void Microenvironment::update_dirichlet_node( int voxel_index , int substrate_index , double new_value )
{
	mesh.voxels[voxel_index].is_Dirichlet = true; 
	dirichlet_value_vectors[voxel_index][substrate_index] = new_value; 
	return; 
}

void Microenvironment::remove_dirichlet_node( int voxel_index )
{
	mesh.voxels[voxel_index].is_Dirichlet = false; 
	
/*	
	if( mesh.voxels[voxel_index].is_Dirichlet == false )
	{ 
		std::cout << "BioFVM Warning: No Dirichlet condition previously specified at voxel " << voxel_index << "! Nothing to remove!" << std::endl; 
		return; 
	}	
	
	int n = 0; 
	mesh.voxels[voxel_index].is_Dirichlet=false;
	while( dirichlet_indices[n] != voxel_index && n < dirichlet_indices.size() )
	{  n++; }
	
	if( n == dirichlet_indices.size() )
	{ 
		std::cout << "BioFVM Warning: No Dirichlet condition previously specified at voxel " << voxel_index << "! Nothing to remove!" << std::endl; 
		return; 
	}
	
	// swap with the final node and then remove it 	
	dirichlet_indices[n] = dirichlet_indices[ dirichlet_indices.size()-1 ]; 
	dirichlet_value_vectors[n] = dirichlet_value_vectors[ dirichlet_value_vectors.size()-1 ]; 
	dirichlet_indices.pop_back();
	dirichlet_value_vectors.pop_back();
*/
	
	return; 
}

bool& Microenvironment::is_dirichlet_node( int voxel_index )
{
	return mesh.voxels[voxel_index].is_Dirichlet; 
}

void Microenvironment::set_substrate_dirichlet_activation( int substrate_index , bool new_value )
{
	dirichlet_activation_vector[substrate_index] = new_value; 
	return; 
}

double Microenvironment::get_substrate_dirichlet_activation( int substrate_index )
{
	return dirichlet_activation_vector[substrate_index]; 
}

void Microenvironment::apply_dirichlet_conditions( void )
{
	/*
	#pragma omp parallel for 
	for( unsigned int i=0 ; i < dirichlet_indices.size() ; i++ )
	{ density_vector( dirichlet_indices[i] ) = dirichlet_value_vectors[i]; }
	*/

	#pragma omp parallel for 
	for( unsigned int i=0 ; i < mesh.voxels.size() ;i++ )
	{
		/*
		if( mesh.voxels[i].is_Dirichlet == true )
		{ density_vector(i) = dirichlet_value_vectors[i]; }
		*/
		if( mesh.voxels[i].is_Dirichlet == true )
		{
			for( unsigned int j=0; j < dirichlet_value_vectors[i].size(); j++ )
			{
				if( dirichlet_activation_vector[j] == true )
				{
					density_vector(i)[j] = dirichlet_value_vectors[i][j]; 
				}
			}
	
		}
	}
	return; 
}

void Microenvironment::resize_voxels( int new_number_of_voxes )
{
	if( mesh.Cartesian_mesh == true )
	{
		std::cout << "Error: only use Microenvironment::" << __FUNCTION__ << " as a fall-back for non-Cartesian meshes." << std::endl
				  << "\tUse one of the Microenvironment::resize_space() functions instead. Ignoring directive." << std::endl; 
		return; 
	}
	
	mesh.voxels.resize( new_number_of_voxes ); 
	
	temporary_density_vectors1.resize( mesh.voxels.size() , zero ); 
	temporary_density_vectors2.resize( mesh.voxels.size() , zero ); 
		
	gradient_vectors.resize( mesh.voxels.size() ); 
	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		gradient_vectors[k].resize( number_of_densities() ); 
		for( unsigned int i=0 ; i < number_of_densities() ; i++ )
		{
			(gradient_vectors[k])[i].resize( 3, 0.0 );
		}
	}
	gradient_vector_computed.resize( mesh.voxels.size() , false ); 	
	
	dirichlet_value_vectors.assign( mesh.voxels.size(), one ); 
	
	return; 
}


void Microenvironment::resize_space( int x_nodes, int y_nodes, int z_nodes )
{
	mesh.resize( x_nodes, y_nodes , z_nodes ); 

	temporary_density_vectors1.assign( mesh.voxels.size() , zero ); 
	temporary_density_vectors2.assign( mesh.voxels.size() , zero ); 
		
	gradient_vectors.resize( mesh.voxels.size() ); 
	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		gradient_vectors[k].resize( number_of_densities() ); 
		for( unsigned int i=0 ; i < number_of_densities() ; i++ )
		{
			(gradient_vectors[k])[i].resize( 3, 0.0 );
		}
	}
	gradient_vector_computed.resize( mesh.voxels.size() , false ); 	
	
	dirichlet_value_vectors.assign( mesh.voxels.size(), one ); 

	return;  
}

void Microenvironment::resize_space( double x_start, double x_end, double y_start, double y_end, double z_start, double z_end , int x_nodes, int y_nodes, int z_nodes )
{
	mesh.resize( x_start, x_end, y_start, y_end, z_start, z_end, x_nodes, y_nodes , z_nodes  ); 

	temporary_density_vectors1.assign( mesh.voxels.size() , zero ); 
	temporary_density_vectors2.assign( mesh.voxels.size() , zero ); 
	
	gradient_vectors.resize( mesh.voxels.size() ); 
	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		gradient_vectors[k].resize( number_of_densities() ); 
		for( unsigned int i=0 ; i < number_of_densities() ; i++ )
		{
			(gradient_vectors[k])[i].resize( 3, 0.0 );
		}
	}
	gradient_vector_computed.resize( mesh.voxels.size() , false ); 	

	dirichlet_value_vectors.assign( mesh.voxels.size(), one ); 
	
	return;  
}

void Microenvironment::resize_space( double x_start, double x_end, double y_start, double y_end, double z_start, double z_end , double dx_new , double dy_new , double dz_new )
{
	mesh.resize( x_start, x_end, y_start, y_end, z_start, z_end,  dx_new , dy_new , dz_new ); 

	temporary_density_vectors1.assign( mesh.voxels.size() , zero ); 
	temporary_density_vectors2.assign( mesh.voxels.size() , zero ); 
	
	gradient_vectors.resize( mesh.voxels.size() ); 
	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		gradient_vectors[k].resize( number_of_densities() ); 
		for( unsigned int i=0 ; i < number_of_densities() ; i++ )
		{
			(gradient_vectors[k])[i].resize( 3, 0.0 );
		}
	}
	gradient_vector_computed.resize( mesh.voxels.size() , false ); 	
	
	dirichlet_value_vectors.assign( mesh.voxels.size(), one ); 
	
	return;  
}

void Microenvironment::resize_space_uniform( double x_start, double x_end, double y_start, double y_end, double z_start, double z_end , double dx_new )
{
 return resize_space( x_start, x_end, y_start, y_end, z_start, z_end , dx_new , dx_new, dx_new ); 
}

void Microenvironment::resize_densities( int new_size )
{
	zero.assign( new_size, 0.0 ); 
	one.assign( new_size , 1.0 );

	temporary_density_vectors1.assign( mesh.voxels.size() , zero );
	temporary_density_vectors2.assign( mesh.voxels.size() , zero );

	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		gradient_vectors[k].resize( number_of_densities() ); 
		for( unsigned int i=0 ; i < number_of_densities() ; i++ )
		{
			(gradient_vectors[k])[i].resize( 3, 0.0 );
		}
	}
	gradient_vector_computed.resize( mesh.voxels.size() , false ); 	
	
	diffusion_coefficients.assign( new_size , 0.0 ); 
	decay_rates.assign( new_size , 0.0 ); 

	density_names.assign( new_size, "unnamed" ); 
	density_units.assign( new_size , "none" ); 

	one_half = one; 
	one_half *= 0.5; 
	
	one_third = one; 
	one_third /= 3.0; 
	
	dirichlet_value_vectors.assign( mesh.voxels.size(), one ); 
	dirichlet_activation_vector.assign( new_size, true ); 

	default_microenvironment_options.Dirichlet_condition_vector.assign( new_size , 1.0 );  
	default_microenvironment_options.Dirichlet_activation_vector.assign( new_size, true ); 
	
	default_microenvironment_options.initial_condition_vector.assign( new_size , 1.0 ); 
	
	return; 
}

void Microenvironment::add_density( void )
{
	// fix in PhysiCell preview November 2017 
	// default_microenvironment_options.use_oxygen_as_first_field = false; 
	
	// update 1, 0 
	zero.push_back( 0.0 ); 
	one.push_back( 1.0 );
	
	// update units
	density_names.push_back( "unnamed" ); 
	density_units.push_back( "none" ); 

	// update coefficients 
	diffusion_coefficients.push_back( 0.0 ); 
	decay_rates.push_back( 0.0 ); 
	
	// update sources and such 
	for( unsigned int i=0; i < temporary_density_vectors1.size() ; i++ )
	{
		temporary_density_vectors1[i].push_back( 0.0 ); 
		temporary_density_vectors2[i].push_back( 0.0 ); 
	}

	// resize the gradient data structures 
	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		gradient_vectors[k].resize( number_of_densities() ); 
		for( unsigned int i=0 ; i < number_of_densities() ; i++ )
		{
			(gradient_vectors[k])[i].resize( 3, 0.0 );
		}
	}

	gradient_vector_computed.resize( mesh.voxels.size() , false ); 	
	
	one_half = one; 
	one_half *= 0.5; 
	
	one_third = one; 
	one_third /= 3.0; 
	
	dirichlet_value_vectors.assign( mesh.voxels.size(), one ); 
	dirichlet_activation_vector.assign( number_of_densities(), true ); 
	
	// Fixes in PhysiCell preview November 2017
	default_microenvironment_options.Dirichlet_condition_vector.push_back( 1.0 ); //  = one; 
	default_microenvironment_options.Dirichlet_activation_vector.push_back( true ); // assign( number_of_densities(), true ); 
	
	default_microenvironment_options.initial_condition_vector.push_back( 1.0 ); 
	
	return; 
}

void Microenvironment::add_density( std::string name , std::string units )
{
	// fix in PhysiCell preview November 2017 
	// default_microenvironment_options.use_oxygen_as_first_field = false; 
	
	// update 1, 0 
	zero.push_back( 0.0 ); 
	one.push_back( 1.0 );

	// update units
	density_names.push_back( name ); 
	density_units.push_back( units ); 

	// update coefficients 
	diffusion_coefficients.push_back( 0.0 ); 
	decay_rates.push_back( 0.0 ); 
	
	// update sources and such 
	for( unsigned int i=0; i < temporary_density_vectors1.size() ; i++ )
	{
		temporary_density_vectors1[i].push_back( 0.0 ); 
		temporary_density_vectors2[i].push_back( 0.0 ); 
	}

	// resize the gradient data structures, 
	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		gradient_vectors[k].resize( number_of_densities() ); 
		for( unsigned int i=0 ; i < number_of_densities() ; i++ )
		{
			(gradient_vectors[k])[i].resize( 3, 0.0 );
		}
	}
	gradient_vector_computed.resize( mesh.voxels.size() , false ); 	

	one_half = one; 
	one_half *= 0.5; 
	
	one_third = one; 
	one_third /= 3.0; 
	
	dirichlet_value_vectors.assign( mesh.voxels.size(), one ); 
	dirichlet_activation_vector.assign( number_of_densities(), true ); 
	
	// fix in PhysiCell preview November 2017 
	default_microenvironment_options.Dirichlet_condition_vector.push_back( 1.0 ); //  = one; 
	default_microenvironment_options.Dirichlet_activation_vector.push_back( true ); // assign( number_of_densities(), true ); 

	default_microenvironment_options.initial_condition_vector.push_back( 1.0 ); 
	
	return; 
}

void Microenvironment::add_density( std::string name , std::string units, double diffusion_constant, double decay_rate )
{
	// fix in PhysiCell preview November 2017 
	// default_microenvironment_options.use_oxygen_as_first_field = false; 
	
	// update 1, 0 
	zero.push_back( 0.0 ); 
	one.push_back( 1.0 );
	
	// update units
	density_names.push_back( name ); 
	density_units.push_back( units ); 

	// update coefficients 
	diffusion_coefficients.push_back( diffusion_constant ); 
	decay_rates.push_back( decay_rate ); 
	
	// update sources and such 
	for( unsigned int i=0; i < temporary_density_vectors1.size() ; i++ )
	{
		temporary_density_vectors1[i].push_back( 0.0 ); 
		temporary_density_vectors2[i].push_back( 0.0 ); 
	}

	// resize the gradient data structures 
	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		gradient_vectors[k].resize( number_of_densities() ); 
		for( unsigned int i=0 ; i < number_of_densities() ; i++ )
		{
			(gradient_vectors[k])[i].resize( 3, 0.0 );
		}
	}
	gradient_vector_computed.resize( mesh.voxels.size() , false ); 	

	one_half = one; 
	one_half *= 0.5; 
	
	one_third = one; 
	one_third /= 3.0; 
	
	dirichlet_value_vectors.assign( mesh.voxels.size(), one ); 
	dirichlet_activation_vector.assign( number_of_densities(), true ); 
	
	// fix in PhysiCell preview November 2017 
	default_microenvironment_options.Dirichlet_condition_vector.push_back( 1.0 ); // = one; 
	default_microenvironment_options.Dirichlet_activation_vector.push_back( true ); // assign( number_of_densities(), true ); 
	
	default_microenvironment_options.initial_condition_vector.push_back( 1.0 ); 
	
	return; 
}

int Microenvironment::find_density_index( std::string name )
{
	for( unsigned int i=0; i < density_names.size() ; i++ )
	{
		if( density_names[i] == name )
		{ return i; }
	}
	return -1; 
}

void Microenvironment::set_density( int index , std::string name , std::string units )
{
	// fix in PhysiCell preview November 2017 
	if( index == 0 )
	{ default_microenvironment_options.use_oxygen_as_first_field = false; }
	
	density_names[index] = name; 
	density_units[index] = units; 
	return; 
}

void Microenvironment::set_density( int index , std::string name , std::string units , double diffusion_constant , double decay_rate )
{
	// fix in PhysiCell preview November 2017 
	if( index == 0 )
	{ default_microenvironment_options.use_oxygen_as_first_field = false; }
	
	density_names[index] = name; 
	density_units[index] = units; 
	
	diffusion_coefficients[index] = diffusion_constant; 
	decay_rates[index] = decay_rate;	
	return; 
}

#pragma acc routine
int Microenvironment::voxel_index( int i, int j, int k )
{ return mesh.voxel_index(i,j,k) ; }

std::vector<unsigned int> Microenvironment::cartesian_indices( int n )
{ return mesh.cartesian_indices( n ); }

int Microenvironment::nearest_voxel_index( std::vector<double>& position )
{ return mesh.nearest_voxel_index( position ); }

Voxel& Microenvironment::voxels( int voxel_index )
{ return mesh.voxels[voxel_index]; }

std::vector<unsigned int> Microenvironment::nearest_cartesian_indices( std::vector<double>& position )
{ return mesh.nearest_cartesian_indices( position ); }
 
Voxel& Microenvironment::nearest_voxel( std::vector<double>& position )
{ return mesh.nearest_voxel( position ); }

std::vector<double>& Microenvironment::nearest_density_vector( std::vector<double>& position )
{ return (*p_density_vectors)[ mesh.nearest_voxel_index( position ) ]; }

std::vector<double>& Microenvironment::nearest_density_vector( int voxel_index )
{ return (*p_density_vectors)[ voxel_index ]; }

std::vector<double>& Microenvironment::operator()( int i, int j, int k )
{ return (*p_density_vectors)[ voxel_index(i,j,k) ]; }

std::vector<double>& Microenvironment::operator()( int i, int j )
{ return (*p_density_vectors)[ voxel_index(i,j,0) ]; }

std::vector<double>& Microenvironment::operator()( int n )
{ return (*p_density_vectors)[ n ]; }

std::vector<double>& Microenvironment::density_vector( int i, int j, int k )
{ return (*p_density_vectors)[ voxel_index(i,j,k) ]; }

std::vector<double>& Microenvironment::density_vector( int i, int j )
{ return (*p_density_vectors)[ voxel_index(i,j,0) ]; }

std::vector<double>& Microenvironment::density_vector( int n )
{ return (*p_density_vectors)[ n ]; }

#pragma acc routine
double& Microenvironment::density_vector_GPU( int n )
{ return (*gpu_p_density_vectors)[ n ]; }

void Microenvironment::simulate_diffusion_decay( double dt )
{
	if( diffusion_decay_solver )
	{ diffusion_decay_solver( *this, dt ); }
	else
	{
		std::cout << "Warning: diffusion-reaction-source/sink solver not set for Microenvironment object at " << this << ". Nothing happened!" << std::endl; 
		std::cout << "   Consider using Microenvironment::auto_choose_diffusion_decay_solver(void) ... " << std::endl 
		<< std::endl; 
	}
	return; 
}

void Microenvironment::auto_choose_diffusion_decay_solver( void )
{
	// set the safest choice 
	diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_explicit; 

	std::cout << "Warning: auto-selection of diffusion-decay-source/sink solver not fully implemented!" << std::endl;

 // eventual logic: if non-Cartesian, use explicit
 // if Cartesian, if non-variable, use the constant coefficient super-fast code
 // otherwise, use the variable coefficient code 

}
 
void Microenvironment::display_information( std::ostream& os )
{
	os << std::endl << "Microenvironment summary: " << name << ": " << std::endl; 
	mesh.display_information( os ); 
	os << "Densities: (" << number_of_densities() << " total)" << std::endl; 
	for( unsigned int i = 0 ; i < density_names.size() ; i++ )
	{
		os << "   " << density_names[i] << ":" << std::endl
		<< "     units: " << density_units[i] << std::endl 
		<< "     diffusion coefficient: " << diffusion_coefficients[i]  
			<< " " << spatial_units << "^2 / " << time_units << std::endl
		<< "     decay rate: " << decay_rates[i] 
			<< " " << time_units << "^-1" << std::endl 
		<< "     diffusion length scale: " << sqrt( diffusion_coefficients[i] / ( 1e-12 + decay_rates[i] ) ) 
			<< " " << spatial_units << std::endl 
		<< "     initial condition: " << default_microenvironment_options.initial_condition_vector[i] 
			<< " " << density_units[i] << std::endl 
		<< "     boundary condition: " << default_microenvironment_options.Dirichlet_condition_vector[i] 
			<< " " << density_units[i] << " (enabled: "; 
		if( dirichlet_activation_vector[i] == true )
		{ os << "true"; }
		else
		{ os << "false"; }
		os << ")" << std::endl; 
	}
	os << std::endl; 
	
	return; 
}
	
unsigned int Microenvironment::number_of_densities( void )
{ return (*p_density_vectors)[0].size(); }

unsigned int Microenvironment::number_of_voxels( void )
{ return mesh.voxels.size(); }

unsigned int Microenvironment::number_of_voxel_faces( void )
{ return mesh.voxel_faces.size(); } 

void Microenvironment::write_to_matlab( std::string filename )
{
	int number_of_data_entries = mesh.voxels.size();
	int size_of_each_datum = 3 + 1 + (*p_density_vectors)[0].size(); 

	FILE* fp = write_matlab_header( size_of_each_datum, number_of_data_entries,  filename, "multiscale_microenvironment" );  

	// storing data as cols 
	for( int i=0; i < number_of_data_entries ; i++ )
	{
		fwrite( (char*) &( mesh.voxels[i].center[0] ) , sizeof(double) , 1 , fp ); 
		fwrite( (char*) &( mesh.voxels[i].center[1] ) , sizeof(double) , 1 , fp );   
		fwrite( (char*) &( mesh.voxels[i].center[2] ) , sizeof(double) , 1 , fp ); 
		fwrite( (char*) &( mesh.voxels[i].volume ) , sizeof(double) , 1 , fp ); 

		// densities  

		for( unsigned int j=0 ; j < (*p_density_vectors)[i].size() ; j++)
		{ fwrite( (char*) &( ((*p_density_vectors)[i])[j] ) , sizeof(double) , 1 , fp ); }
	}

	fclose( fp ); 
	return;
}



void Microenvironment::simulate_bulk_sources_and_sinks( double dt )
{
	if( !bulk_source_sink_solver_setup_done )
	{
		bulk_source_sink_solver_temp1.resize( mesh.voxels.size() , zero );
		bulk_source_sink_solver_temp2.resize( mesh.voxels.size() , zero );
		bulk_source_sink_solver_temp3.resize( mesh.voxels.size() , zero );
		
		bulk_source_sink_solver_setup_done = true; 
	}
	
	#pragma omp parallel for
	for( unsigned int i=0; i < mesh.voxels.size() ; i++ )
	{
		bulk_supply_rate_function( this,i, &bulk_source_sink_solver_temp1[i] ); // temp1 = S
		bulk_supply_target_densities_function( this,i, &bulk_source_sink_solver_temp2[i]); // temp2 = T
		bulk_uptake_rate_function( this,i, &bulk_source_sink_solver_temp3[i] ); // temp3 = U

		
		bulk_source_sink_solver_temp2[i] *= bulk_source_sink_solver_temp1[i]; // temp2 = S*T
		axpy( &(*p_density_vectors)[i] , dt , bulk_source_sink_solver_temp2[i] ); // out = out + dt*temp2 = out + dt*S*T
		bulk_source_sink_solver_temp3[i] += bulk_source_sink_solver_temp1[i]; // temp3 = U+S
		bulk_source_sink_solver_temp3[i] *= dt; // temp3 = dt*(U+S)
		bulk_source_sink_solver_temp3[i] += one; // temp3 = 1 + dt*(U+S)
		
		(*p_density_vectors)[i] /= bulk_source_sink_solver_temp3[i];
	}
	
	return; 
}

void Microenvironment::simulate_cell_sources_and_sinks( std::vector<Basic_Agent*>& basic_agent_list , double dt )
{
	#pragma omp parallel for
	for( unsigned int i=0 ; i < basic_agent_list.size() ; i++ )
	{		
		basic_agent_list[i]->simulate_secretion_and_uptake( this , dt ); 
	}
	
	return; 
}

void Microenvironment::simulate_cell_sources_and_sinks( double dt )
{
	simulate_cell_sources_and_sinks(all_basic_agents, dt);
}

void Microenvironment::update_rates( void )
{
	if( supply_target_densities_times_supply_rates.size() != number_of_voxels() )
	{ supply_target_densities_times_supply_rates.assign( number_of_voxels() , zero ); }

	if( supply_rates.size() != number_of_voxels() )
	{ supply_rates.assign( number_of_voxels() , zero ); }
	
	if( uptake_rates.size() != number_of_voxels() )
	{ uptake_rates.assign( number_of_voxels() , zero ); }

	#pragma omp parallel for 
	for( unsigned int i=0 ; i < number_of_voxels() ; i++ )
	{
		bulk_uptake_rate_function( this,i, &(uptake_rates[i]) ); 		
		bulk_supply_rate_function( this,i, &(supply_rates[i]) ); 		
		bulk_supply_target_densities_function( this,i, &(supply_target_densities_times_supply_rates[i]) );
		
		supply_target_densities_times_supply_rates[i] *= supply_rates[i]; 
	}
	return; 
}

std::vector<gradient>& Microenvironment::gradient_vector(int i, int j, int k)
{
	int n = voxel_index(i,j,k);
	if( gradient_vector_computed[n] == false )
	{
		compute_gradient_vector( n );
	}
	
	return gradient_vectors[n];
}

std::vector<gradient>& Microenvironment::gradient_vector(int i, int j )
{
	int n = voxel_index(i,j,0);
	if( gradient_vector_computed[n] == false )
	{
		compute_gradient_vector( n );
	}
	
	return gradient_vectors[n];
}

std::vector<gradient>& Microenvironment::gradient_vector(int n )
{
	// if the gradient has not yet been computed, then do it!
	if( gradient_vector_computed[n] == false )
	{
		compute_gradient_vector( n );
	}
	
	
	return gradient_vectors[n];
}
	
std::vector<gradient>& Microenvironment::nearest_gradient_vector( std::vector<double>& position )
{
	int n = nearest_voxel_index( position );
	if( gradient_vector_computed[n] == false )
	{
		compute_gradient_vector( n );
	}
	
	return gradient_vectors[n];
}

void Microenvironment::compute_all_gradient_vectors( void )
{
	static double two_dx = mesh.dx; 
	static double two_dy = mesh.dy; 
	static double two_dz = mesh.dz; 
	static bool gradient_constants_defined = false; 
	if( gradient_constants_defined == false )
	{
		two_dx *= 2.0; 
		two_dy *= 2.0; 
		two_dz *= 2.0;
		gradient_constants_defined = true; 
	}
	
	#pragma omp parallel for 
	for( unsigned int k=0; k < mesh.z_coordinates.size() ; k++ )
	{
		for( unsigned int j=0; j < mesh.y_coordinates.size() ; j++ )
		{
			
			for( unsigned int i=1; i < mesh.x_coordinates.size()-1 ; i++ )
			{
				for( unsigned int q=0; q < number_of_densities() ; q++ )
				{
					int n = voxel_index(i,j,k);
					// x-derivative of qth substrate at voxel n
					gradient_vectors[n][q][0] = (*p_density_vectors)[n+thomas_i_jump][q]; 
					gradient_vectors[n][q][0] -= (*p_density_vectors)[n-thomas_i_jump][q]; 
					gradient_vectors[n][q][0] /= two_dx; 
					
					gradient_vector_computed[n] = true; 
 				}
			}
			
		}
	}
	
	#pragma omp parallel for 
	for( unsigned int k=0; k < mesh.z_coordinates.size() ; k++ )
	{
		for( unsigned int i=0; i < mesh.x_coordinates.size() ; i++ )
		{
			
			for( unsigned int j=1; j < mesh.y_coordinates.size()-1 ; j++ )
			{
				for( unsigned int q=0; q < number_of_densities() ; q++ )
				{
					int n = voxel_index(i,j,k);
					// y-derivative of qth substrate at voxel n
					gradient_vectors[n][q][1] = (*p_density_vectors)[n+thomas_j_jump][q]; 
					gradient_vectors[n][q][1] -= (*p_density_vectors)[n-thomas_j_jump][q]; 
					gradient_vectors[n][q][1] /= two_dy; 
					gradient_vector_computed[n] = true; 
				}
			}
			
		}
	}

	#pragma omp parallel for 
	for( unsigned int j=0; j < mesh.y_coordinates.size() ; j++ )
	{
		for( unsigned int i=0; i < mesh.x_coordinates.size() ; i++ )
		{
			
			for( unsigned int k=1; k < mesh.z_coordinates.size()-1 ; k++ )
			{
				for( unsigned int q=0; q < number_of_densities() ; q++ )
				{
					int n = voxel_index(i,j,k);
					// y-derivative of qth substrate at voxel n
					gradient_vectors[n][q][2] = (*p_density_vectors)[n+thomas_k_jump][q]; 
					gradient_vectors[n][q][2] -= (*p_density_vectors)[n-thomas_k_jump][q]; 
					gradient_vectors[n][q][2] /= two_dz; 
					gradient_vector_computed[n] = true; 
				}
			}
			
		}
	}

	return; 
}

void Microenvironment::compute_gradient_vector( int n )
{
	static double two_dx = mesh.dx; 
	static double two_dy = mesh.dy; 
	static double two_dz = mesh.dz; 
	static bool gradient_constants_defined = false; 
	std::vector<unsigned int> indices(3,0);
	
	if( gradient_constants_defined == false )
	{
		two_dx *= 2.0; 
		two_dy *= 2.0; 
		two_dz *= 2.0;
		gradient_constants_defined = true; 
	}	
	
	indices = cartesian_indices( n );
	
	// d/dx 
	if( indices[0] > 0 && indices[0] < mesh.x_coordinates.size()-1 )
	{
		for( unsigned int q=0; q < number_of_densities() ; q++ )
		{
			gradient_vectors[n][q][0] = (*p_density_vectors)[n+thomas_i_jump][q]; 
			gradient_vectors[n][q][0] -= (*p_density_vectors)[n-thomas_i_jump][q]; 
			gradient_vectors[n][q][0] /= two_dx; 
			gradient_vector_computed[n] = true; 
		}
	}
	
	// d/dy 
	if( indices[1] > 0 && indices[1] < mesh.y_coordinates.size()-1 )
	{
		for( unsigned int q=0; q < number_of_densities() ; q++ )
		{
			gradient_vectors[n][q][1] = (*p_density_vectors)[n+thomas_j_jump][q]; 
			gradient_vectors[n][q][1] -= (*p_density_vectors)[n-thomas_j_jump][q]; 
			gradient_vectors[n][q][1] /= two_dy; 
			gradient_vector_computed[n] = true; 
		}
	}
	
	// d/dz 
	if( indices[2] > 0 && indices[2] < mesh.z_coordinates.size()-1 )
	{
		for( unsigned int q=0; q < number_of_densities() ; q++ )
		{
			gradient_vectors[n][q][2] = (*p_density_vectors)[n+thomas_k_jump][q]; 
			gradient_vectors[n][q][2] -= (*p_density_vectors)[n-thomas_k_jump][q]; 
			gradient_vectors[n][q][2] /= two_dz; 
			gradient_vector_computed[n] = true; 
		}
	}
	
	return; 
}

void Microenvironment::reset_all_gradient_vectors( void )
{
	for( unsigned int k=0 ; k < mesh.voxels.size() ; k++ )
	{
		for( unsigned int i=0 ; i < number_of_densities() ; i++ )
		{
			(gradient_vectors[k])[i].resize( 3, 0.0 );
		}
	}
	gradient_vector_computed.assign( mesh.voxels.size() , false ); 	
}


Microenvironment microenvironment; 

Microenvironment_Options::Microenvironment_Options()
{
	use_oxygen_as_first_field = true; 
	
	if( get_default_microenvironment() != NULL )
	{
		pMicroenvironment = get_default_microenvironment(); 
	}
	else
	{
		pMicroenvironment = &microenvironment; 
		set_default_microenvironment( pMicroenvironment ); 
	}
	name = "microenvironment"; 
	
	time_units = "min"; 
	spatial_units = "micron"; 
	dx = 20; 
	dy = 20; 
	dz = 20; 
	
	outer_Dirichlet_conditions = false; 
	Dirichlet_condition_vector.assign( pMicroenvironment->number_of_densities() , 1.0 ); 
	Dirichlet_activation_vector.assign( pMicroenvironment->number_of_densities() , true ); 
	
	initial_condition_vector.resize(0); //  = Dirichlet_condition_vector; 
	
	// set a far-field value for oxygen (assumed to be in the first field)
	Dirichlet_condition_vector[0] = 38.0; 
	
	simulate_2D = false; 
	
	X_range.resize(2,500.0); 
	X_range[0] *= -1.0;
	
	Y_range.resize(2,500.0); 
	Y_range[0] *= -1.0;
	
	Z_range.resize(2,500.0); 
	Z_range[0] *= -1.0;
	
	calculate_gradients = false; 
	
	track_internalized_substrates_in_each_agent = false; 
	
	return; 
}

Microenvironment_Options default_microenvironment_options; 

void initialize_microenvironment( void )
{
	// create and name a microenvironment; 
	microenvironment.name = default_microenvironment_options.name;
	// register the diffusion solver 
	if( default_microenvironment_options.simulate_2D == true )
	{
		microenvironment.diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_2D; 
	}
	else
	{
		microenvironment.diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_3D; 
	}
	
	// set the default substrate to oxygen (with typical units of mmHg)
	if( default_microenvironment_options.use_oxygen_as_first_field == true )
	{
		microenvironment.set_density(0, "oxygen" , "mmHg" );
		microenvironment.diffusion_coefficients[0] = 1e5; 
		microenvironment.decay_rates[0] = 0.1; 
	}
	
	// resize the microenvironment  
	if( default_microenvironment_options.simulate_2D == true )
	{
		default_microenvironment_options.Z_range[0] = -default_microenvironment_options.dz/2.0; 
		default_microenvironment_options.Z_range[1] = default_microenvironment_options.dz/2.0;
	}
	microenvironment.resize_space( default_microenvironment_options.X_range[0], default_microenvironment_options.X_range[1] , 
		default_microenvironment_options.Y_range[0], default_microenvironment_options.Y_range[1], 
		default_microenvironment_options.Z_range[0], default_microenvironment_options.Z_range[1], 
		default_microenvironment_options.dx,default_microenvironment_options.dy,default_microenvironment_options.dz );
		
	// set units
	microenvironment.spatial_units = default_microenvironment_options.spatial_units;
	microenvironment.time_units = default_microenvironment_options.time_units;
	microenvironment.mesh.units = default_microenvironment_options.spatial_units;

	// set the initial densities to the values set in the initial_condition_vector
	
	// if the initial condition vector has not been set, use the Dirichlet condition vector 
	if( default_microenvironment_options.initial_condition_vector.size() != 
		microenvironment.number_of_densities() )
	{
		std::cout << "BioFVM Warning: Initial conditions not set. " << std::endl 
				  << "                Using Dirichlet condition vector to set initial substrate values!" << std::endl 
				  << "                In the future, set default_microenvironment_options.initial_condition_vector." 
				  << std::endl << std::endl;  
		default_microenvironment_options.initial_condition_vector = default_microenvironment_options.Dirichlet_condition_vector; 
	}
	
	for( unsigned int n=0; n < microenvironment.number_of_voxels() ; n++ )
	{ microenvironment.density_vector(n) = default_microenvironment_options.initial_condition_vector; }
	
	if( default_microenvironment_options.outer_Dirichlet_conditions == true ) 
	{
		
		for( unsigned int k=0 ; k < microenvironment.mesh.z_coordinates.size() ; k++ )
		{
			// set Dirichlet conditions along the 4 outer edges 
			for( unsigned int i=0 ; i < microenvironment.mesh.x_coordinates.size() ; i++ )
			{
				int J = microenvironment.mesh.y_coordinates.size()-1;
				microenvironment.add_dirichlet_node( microenvironment.voxel_index(i,0,k) , default_microenvironment_options.Dirichlet_condition_vector );
				microenvironment.add_dirichlet_node( microenvironment.voxel_index(i,J,k) , default_microenvironment_options.Dirichlet_condition_vector );
			}
			int I = microenvironment.mesh.x_coordinates.size()-1;
			for( unsigned int j=1; j < microenvironment.mesh.y_coordinates.size()-1 ; j++ )
			{
				microenvironment.add_dirichlet_node( microenvironment.voxel_index(0,j,k) , default_microenvironment_options.Dirichlet_condition_vector );
				microenvironment.add_dirichlet_node( microenvironment.voxel_index(I,j,k) , default_microenvironment_options.Dirichlet_condition_vector );
			}		
		}
		// if 3-D, also along the corresponding additional faces 
		if( default_microenvironment_options.simulate_2D == false )
		{
			int K = microenvironment.mesh.z_coordinates.size()-1; 
			for( unsigned int j=1 ; j < microenvironment.mesh.y_coordinates.size()-1 ; j++ )
			{
				for( unsigned int i=1; i < microenvironment.mesh.x_coordinates.size()-1 ; i++ )
				{
					microenvironment.add_dirichlet_node( microenvironment.voxel_index(i,j,0) , default_microenvironment_options.Dirichlet_condition_vector );
					microenvironment.add_dirichlet_node( microenvironment.voxel_index(i,j,K) , default_microenvironment_options.Dirichlet_condition_vector );
				}	
			}	
		}
		
	}
	
	// set the Dirichlet condition activation vector to match the microenvironment options 
	for( int i=0 ; i < default_microenvironment_options.Dirichlet_activation_vector.size(); i++ )
	{
		microenvironment.set_substrate_dirichlet_activation( i , default_microenvironment_options.Dirichlet_activation_vector[i] ); 
	}
	
	microenvironment.display_information( std::cout );
	return;
}

int Microenvironment::get_size_p1()
{
	return (*p_density_vectors).size();
}

int Microenvironment::get_size_p2()
{
	return (*p_density_vectors)[0].size();
}

void Microenvironment::transfer_2D()
{
	// start gpu_p_density_vectors
	const int bin_p_density_vectors = (*p_density_vectors).size();

	gpu_p_density_vectors = new double*[bin_p_density_vectors];

	sizes_p_density_vectors = new int[bin_p_density_vectors];
	#pragma acc enter data copyin(this[0:1])
	#pragma acc enter data create(this->gpu_p_density_vectors[0:bin_p_density_vectors][0:0])

	for (int i = 0; i < bin_p_density_vectors; i++){
		int sze = (*p_density_vectors)[i].size();
		sizes_p_density_vectors[i] = sze;
		gpu_p_density_vectors[i] = (*p_density_vectors)[i].data();
		#pragma acc enter data copyin(this->gpu_p_density_vectors[i:1][:sze])
	}
	#pragma acc enter data copyin(this->sizes_p_density_vectors[:bin_p_density_vectors])
	// end gpu_p_density_vectors

	// start gpu_thomas_constant1
	const int bin_thomas_constant1 = thomas_constant1.size();

	gpu_thomas_constant1 = new double [bin_thomas_constant1];

	sizes_thomas_constant1 = bin_thomas_constant1;
	#pragma acc enter data create(this->gpu_thomas_constant1[0:bin_thomas_constant1])

		//gpu_thomas_constant1[e] = thomas_constant1.at(e);
		gpu_thomas_constant1 = thomas_constant1.data();

	#pragma acc enter data copyin(this->gpu_thomas_constant1[:bin_thomas_constant1])
	#pragma acc enter data copyin(this->sizes_thomas_constant1)
	// end gpu_thomas_constant1
	
	// start gpu_thomas_denomx
	const int bin_thomas_denomx = thomas_denomx.size();

	gpu_thomas_denomx = new double * [bin_thomas_denomx];

	sizes_thomas_denomx = new int [bin_thomas_denomx];

	#pragma acc enter data create(this->gpu_thomas_denomx[0:bin_thomas_denomx][0:0])
	for (int i = 0; i < bin_thomas_denomx; i ++) {
		int sze = thomas_denomx[i].size();
		gpu_thomas_denomx[i] = thomas_denomx[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_denomx[i:1][:sze])
	}	
	// pragma acc enter data sizes
	// end gpu_thomas_denomx
	
	// start gpu_thomas_denomy
	const int bin_thomas_denomy = thomas_denomy.size();

	gpu_thomas_denomy = new double * [bin_thomas_denomy];

	sizes_thomas_denomy = new int [bin_thomas_denomy];

	#pragma acc enter data create(this->gpu_thomas_denomy[0:bin_thomas_denomy][0:0])
	for (int i = 0; i < bin_thomas_denomy; i ++) {
		int sze = thomas_denomy[i].size();
		gpu_thomas_denomy[i] = thomas_denomy[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_denomy[i:1][:sze])
	}	
	// pragma acc enter data sizes
	// end gpu_thomas_denomy
	
	// start gpu_thomas_i_jump
	gpu_thomas_i_jump = new int;

	*gpu_thomas_i_jump = thomas_i_jump;

	#pragma acc enter data copyin(this->gpu_thomas_i_jump)
	// end gpu_thomas_i_jump
	
	// start gpu_thomas_j_jump
	gpu_thomas_j_jump = new int;

	*gpu_thomas_j_jump = thomas_j_jump;

	#pragma acc enter data copyin(this->gpu_thomas_j_jump)
	// end gpu_thomas_j_jump
	
	// start gpu_thomas_cx
	const int bin_thomas_cx = thomas_cx.size();

	gpu_thomas_cx = new double * [bin_thomas_cx];

	sizes_thomas_cx = new int [bin_thomas_cx];

	#pragma acc enter data create(this->gpu_thomas_cx[0:bin_thomas_cx][0:0])
	for (int i = 0; i < bin_thomas_cx; i ++) {
		int sze = thomas_cx[i].size();
		gpu_thomas_cx[i] = thomas_cx[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_cx[i:1][:sze])
	}
	// end gpu_thomas_cx
	
	// start gpu_thomas_cy
	const int bin_thomas_cy = thomas_cy.size();

	gpu_thomas_cy = new double * [bin_thomas_cy];

	sizes_thomas_cy = new int [bin_thomas_cy];

	#pragma acc enter data create(this->gpu_thomas_cy[0:bin_thomas_cy][0:0])
	for (int i = 0; i < bin_thomas_cy; i ++) {
		int sze = thomas_cy[i].size();
		gpu_thomas_cy[i] = thomas_cy[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_cy[i:1][:sze])
	}
	// end gpu_thomas_cy
	
	// start gpu_dirichlet_value_vectors
	const int bin_dirichlet_value_vectors = dirichlet_value_vectors.size();

	gpu_dirichlet_value_vectors = new double * [bin_dirichlet_value_vectors];

	sizes_dirichlet_value_vectors = new int [bin_dirichlet_value_vectors];

	#pragma acc enter data create(this->gpu_dirichlet_value_vectors[0:bin_dirichlet_value_vectors][0:0])
	for (int i = 0; i < bin_dirichlet_value_vectors; i++) {
		int sze = dirichlet_value_vectors[i].size();
		sizes_dirichlet_value_vectors[i] = sze;
		gpu_dirichlet_value_vectors[i] = dirichlet_value_vectors[i].data();
		#pragma acc enter data copyin(this->gpu_dirichlet_value_vectors[i:1][:sze])
	}	
	#pragma acc enter data copyin(this->sizes_dirichlet_value_vectors[:bin_dirichlet_value_vectors])
	// end gpu_dirichlet_value_vectors
	
	// start gpu_dirichlet_activation_vector
	const int bin_dirichlet_activation_vector = dirichlet_activation_vector.size();

	gpu_dirichlet_activation_vector = new bool [bin_dirichlet_activation_vector];

	#pragma acc enter data create(this->gpu_dirichlet_activation_vector[0:bin_dirichlet_activation_vector])
	for (int i = 0; i < bin_dirichlet_activation_vector; i++) {
		gpu_dirichlet_activation_vector[i] = dirichlet_activation_vector.at(i);
	}
/*
 *potential error here, move copyin to inside interation?
 */
	#pragma acc enter data copyin(this->gpu_dirichlet_activation_vector[:bin_dirichlet_activation_vector])
	// end gpu_dirichlet_activation_vector
	
	// start gpu_voxel_is_dirichlet
	const int bin_mesh = mesh.voxels.size();

	gpu_voxels_is_dirichlet = new bool [bin_mesh];

	#pragma acc enter data create(this->gpu_voxels_is_dirichlet[0:bin_mesh])
	for (int i = 0; i < bin_mesh; i ++) {
		gpu_voxels_is_dirichlet[i] = mesh.voxels[i].is_Dirichlet;
	}
	#pragma acc enter data copyin(this->gpu_voxels_is_dirichlet[:bin_mesh])
	// end gpu_voxel_is_dirichlet

	std::cout << "Done transfer" << std::endl;
}

void Microenvironment::transfer_3D()
{
	// start gpu_p_density_vectors
	const int bin_p_density_vectors = (*p_density_vectors).size();

	gpu_p_density_vectors = new double*[bin_p_density_vectors];

	sizes_p_density_vectors = new int[bin_p_density_vectors];
	#pragma acc enter data copyin(this[0:1])
	#pragma acc enter data create(this->gpu_p_density_vectors[0:bin_p_density_vectors][0:0])

	for (int i = 0; i < bin_p_density_vectors; i++){
		int sze = (*p_density_vectors)[i].size();
		sizes_p_density_vectors[i] = sze;
		gpu_p_density_vectors[i] = (*p_density_vectors)[i].data();
		#pragma acc enter data copyin(this->gpu_p_density_vectors[i:1][:sze])
	}
	#pragma acc enter data copyin(this->sizes_p_density_vectors[:bin_p_density_vectors])
	// end gpu_p_density_vectors

	// start gpu_thomas_constant1
	const int bin_thomas_constant1 = thomas_constant1.size();

	gpu_thomas_constant1 = new double [bin_thomas_constant1];

	sizes_thomas_constant1 = bin_thomas_constant1;
	#pragma acc enter data create(this->gpu_thomas_constant1[0:bin_thomas_constant1])

		//gpu_thomas_constant1[e] = thomas_constant1.at(e);
		gpu_thomas_constant1 = thomas_constant1.data();

	#pragma acc enter data copyin(this->gpu_thomas_constant1[:bin_thomas_constant1])
	#pragma acc enter data copyin(this->sizes_thomas_constant1)
	// end gpu_thomas_constant1
	
	// start gpu_thomas_denomx
	const int bin_thomas_denomx = thomas_denomx.size();

	gpu_thomas_denomx = new double * [bin_thomas_denomx];

	sizes_thomas_denomx = new int [bin_thomas_denomx];

	#pragma acc enter data create(this->gpu_thomas_denomx[0:bin_thomas_denomx][0:0])
	for (int i = 0; i < bin_thomas_denomx; i ++) {
		int sze = thomas_denomx[i].size();
		gpu_thomas_denomx[i] = thomas_denomx[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_denomx[i:1][:sze])
	}	
	// pragma acc enter data sizes
	// end gpu_thomas_denomx
	
	// start gpu_thomas_denomy
	const int bin_thomas_denomy = thomas_denomy.size();

	gpu_thomas_denomy = new double * [bin_thomas_denomy];

	sizes_thomas_denomy = new int [bin_thomas_denomy];

	#pragma acc enter data create(this->gpu_thomas_denomy[0:bin_thomas_denomy][0:0])
	for (int i = 0; i < bin_thomas_denomy; i ++) {
		int sze = thomas_denomy[i].size();
		gpu_thomas_denomy[i] = thomas_denomy[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_denomy[i:1][:sze])
	}	
	// pragma acc enter data sizes
	// end gpu_thomas_denomy

	// start gpu_thomas_denomz
	const int bin_thomas_denomz = thomas_denomz.size();

	gpu_thomas_denomz = new double * [bin_thomas_denomz];

	sizes_thomas_denomz = new int [bin_thomas_denomz];

	#pragma acc enter data create(this->gpu_thomas_denomz[0:bin_thomas_denomz][0:0])
	for (int i = 0; i < bin_thomas_denomz; i ++) {
		int sze = thomas_denomz[i].size();
		gpu_thomas_denomz[i] = thomas_denomz[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_denomz[i:1][:sze])
	}	
	// pragma acc enter data sizes
	// end gpu_thomas_denomz
	
	// start gpu_thomas_i_jump
	gpu_thomas_i_jump = new int;

	*gpu_thomas_i_jump = thomas_i_jump;

	#pragma acc enter data copyin(this->gpu_thomas_i_jump)
	// end gpu_thomas_i_jump
	
	// start gpu_thomas_j_jump
	gpu_thomas_j_jump = new int;

	*gpu_thomas_j_jump = thomas_j_jump;

	#pragma acc enter data copyin(this->gpu_thomas_j_jump)
	// end gpu_thomas_j_jump
	
	// start gpu_thomas_k_jump
	gpu_thomas_k_jump = new int;

	*gpu_thomas_k_jump = thomas_k_jump;

	#pragma acc enter data copyin(this->gpu_thomas_k_jump)
	// end gpu_thomas_k_jump

	// start gpu_thomas_cx
	const int bin_thomas_cx = thomas_cx.size();

	gpu_thomas_cx = new double * [bin_thomas_cx];

	sizes_thomas_cx = new int [bin_thomas_cx];

	#pragma acc enter data create(this->gpu_thomas_cx[0:bin_thomas_cx][0:0])
	for (int i = 0; i < bin_thomas_cx; i ++) {
		int sze = thomas_cx[i].size();
		gpu_thomas_cx[i] = thomas_cx[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_cx[i:1][:sze])
	}
	// end gpu_thomas_cx
	
	// start gpu_thomas_cy
	const int bin_thomas_cy = thomas_cy.size();

	gpu_thomas_cy = new double * [bin_thomas_cy];

	sizes_thomas_cy = new int [bin_thomas_cy];

	#pragma acc enter data create(this->gpu_thomas_cy[0:bin_thomas_cy][0:0])
	for (int i = 0; i < bin_thomas_cy; i ++) {
		int sze = thomas_cy[i].size();
		gpu_thomas_cy[i] = thomas_cy[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_cy[i:1][:sze])
	}
	// end gpu_thomas_cy
	
	// start gpu_thomas_cz
	const int bin_thomas_cz = thomas_cz.size();

	gpu_thomas_cz = new double * [bin_thomas_cz];

	sizes_thomas_cz = new int [bin_thomas_cz];

	#pragma acc enter data create(this->gpu_thomas_cz[0:bin_thomas_cz][0:0])
	for (int i = 0; i < bin_thomas_cz; i ++) {
		int sze = thomas_cz[i].size();
		gpu_thomas_cz[i] = thomas_cz[i].data();
		#pragma acc enter data copyin(this->gpu_thomas_cz[i:1][:sze])
	}
	// end gpu_thomas_cz

	// start gpu_dirichlet_value_vectors
	const int bin_dirichlet_value_vectors = dirichlet_value_vectors.size();

	gpu_dirichlet_value_vectors = new double * [bin_dirichlet_value_vectors];

	sizes_dirichlet_value_vectors = new int [bin_dirichlet_value_vectors];

	#pragma acc enter data create(this->gpu_dirichlet_value_vectors[0:bin_dirichlet_value_vectors][0:0])
	for (int i = 0; i < bin_dirichlet_value_vectors; i++) {
		int sze = dirichlet_value_vectors[i].size();
		sizes_dirichlet_value_vectors[i] = sze;
		gpu_dirichlet_value_vectors[i] = dirichlet_value_vectors[i].data();
		#pragma acc enter data copyin(this->gpu_dirichlet_value_vectors[i:1][:sze])
	}	
	#pragma acc enter data copyin(this->sizes_dirichlet_value_vectors[:bin_dirichlet_value_vectors])
	// end gpu_dirichlet_value_vectors
	
	// start gpu_dirichlet_activation_vector
	const int bin_dirichlet_activation_vector = dirichlet_activation_vector.size();

	gpu_dirichlet_activation_vector = new bool [bin_dirichlet_activation_vector];

//	#pragma acc enter data create(this->gpu_dirichlet_activation_vector[0:bin_dirichlet_activation_vector])
	for (int i = 0; i < bin_dirichlet_activation_vector; i++) {
		gpu_dirichlet_activation_vector[i] = dirichlet_activation_vector.at(i);
	}
		/*
 		*potential error here, move copyin to inside interation?
 		*/
	#pragma acc enter data copyin(this->gpu_dirichlet_activation_vector[:bin_dirichlet_activation_vector])
	// end gpu_dirichlet_activation_vector
	
	// start gpu_voxel_is_dirichlet
	const int bin_mesh = mesh.voxels.size();

	gpu_voxels_is_dirichlet = new bool [bin_mesh];

//	#pragma acc enter data create(this->gpu_voxels_is_dirichlet[0:bin_mesh])
	for (int i = 0; i < bin_mesh; i ++) {
		gpu_voxels_is_dirichlet[i] = mesh.voxels[i].is_Dirichlet;
	}
	#pragma acc enter data copyin(this->gpu_voxels_is_dirichlet[:bin_mesh])
	// end gpu_voxel_is_dirichlet
	

	// Below is num_dirichlet
	num_dirichlet = 0;
	#pragma acc enter data create(this->num_dirichlet)
	// End num_dirichlet

	std::cout << "Done transfer" << std::endl;
}

#pragma acc routine
void Microenvironment::axpy_acc( double* y, double* a , double* x, int size )
{
// #pragma acc parallel loop
 for( int i=0; i < size ; i++ )
 {
  y[i] += a[i] * x[i] ; 
 }
 return; 
}

#pragma acc routine
void Microenvironment::naxpy_acc( double* y, double* a , double* x, int size )
{
// #pragma acc parallel loop
 for( int i=0; i < size ; i++ )
 {
  y[i] -= a[i] * x[i] ; 
 }
 return; 
}

void Microenvironment::apply_dirichlet_conditions_GPU( void ) {
	int mesh_size = mesh.voxels.size();

	#pragma acc parallel loop present(gpu_p_density_vectors, gpu_dirichlet_value_vectors, sizes_dirichlet_value_vectors, gpu_dirichlet_activation_vector, gpu_voxels_is_dirichlet, num_dirichlet)
	for (int i = 0; i < mesh_size; i ++){
		//if (mesh.voxels[i].is_Dirichlet == true){
		if (gpu_voxels_is_dirichlet[i] == true){
					num_dirichlet ++;
			for (int j = 0; j < sizes_dirichlet_value_vectors[i]; j++) {
					num_dirichlet ++;
				if ( gpu_dirichlet_activation_vector[j] == true) {
					gpu_p_density_vectors[i][j] = gpu_dirichlet_value_vectors[i][j];
					//density_vector_GPU(i)[j] = gpu_dirichlet_value_vectors[i][j];
					// TEST whether or not it goes this far with an int
					num_dirichlet ++;
				}
			}
		}
	}	

	return;
}

// X-Diffusion GPU for 2D
void Microenvironment::x_diffusion_GPU_2D(){

	int x_size = mesh.x_coordinates.size();
	int y_size = mesh.y_coordinates.size();

	#pragma acc parallel loop present(gpu_p_density_vectors, sizes_p_density_vectors, gpu_thomas_denomx, gpu_thomas_i_jump, gpu_thomas_cx) 
	for ( int j=0; j < y_size ; j++ ) {
		int n = voxel_index(0, j, 0);
		#pragma acc loop seq 
		for (int q = 0; q < sizes_p_density_vectors[n]; q++)
			{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomx[0][q];}
		n += *gpu_thomas_i_jump;
		#pragma acc loop seq
		for (int i=1; i < x_size ; i++) {
			axpy_acc(gpu_p_density_vectors[n], gpu_thomas_constant1, gpu_p_density_vectors[n-*gpu_thomas_i_jump], sizes_p_density_vectors[n]);
			/*
			#pragma acc loop seq
			for (int k = 0; k < 3; k++) {
				gpu_p_density_vectors[n][k] += gpu_thomas_constant1[k] * gpu_p_density_vectors[n- (*gpu_thomas_i_jump)][k];
			}
			*/
			#pragma acc loop seq
			for (int q = 0; q < sizes_p_density_vectors[n]; q++)
				{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomx[i][q]; }

			n += *gpu_thomas_i_jump;
		}

		// back substitution
		n = voxel_index(x_size-2, j, 0);
		#pragma acc loop seq
		for (int i = x_size-2 ; i >= 0 ; i--) {
			naxpy_acc(gpu_p_density_vectors[n], gpu_thomas_cx[i], gpu_p_density_vectors[n+*gpu_thomas_i_jump], sizes_p_density_vectors[n]);
			/*
			#pragma acc loop seq
			for (int k = 0; k < 3; k++) {
				gpu_p_density_vectors[n][k] -= gpu_thomas_cx[i][k] * gpu_p_density_vectors[n+ (*gpu_thomas_i_jump)][k];
			}
			*/
			n -= *gpu_thomas_i_jump;
		}
	}
//	std::cout << "Done x_diffusion_acc" << std::endl;

}
// end X-Diffusion GPU for 2D

// Y-Diffusion GPU for 2D
void Microenvironment::y_diffusion_GPU_2D(){

	int x_size = mesh.x_coordinates.size();
	int y_size = mesh.y_coordinates.size();

	#pragma acc parallel loop present(gpu_p_density_vectors, sizes_p_density_vectors, gpu_thomas_denomy, gpu_thomas_j_jump, gpu_thomas_cy) 
	for ( int i=0; i < x_size ; i++ ) {
		int n = voxel_index(i, 0, 0);
		#pragma acc loop seq 
		for (int q = 0; q < sizes_p_density_vectors[n]; q++)
			{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomy[0][q];}
		n += *gpu_thomas_j_jump;
		#pragma acc loop seq
		for (int j=1; j < y_size ; j++) {
			axpy_acc(gpu_p_density_vectors[n], gpu_thomas_constant1, gpu_p_density_vectors[n-*gpu_thomas_j_jump], sizes_p_density_vectors[n]);
			/*
			#pragma acc loop seq
			for (int k = 0; k < 3; k++) {
				gpu_p_density_vectors[n][k] += gpu_thomas_constant1[k] * gpu_p_density_vectors[n- (*gpu_thomas_i_jump)][k];
			}
			*/
			#pragma acc loop seq
			for (int q = 0; q < sizes_p_density_vectors[n]; q++)
				{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomy[j][q]; }

			n += *gpu_thomas_j_jump;
		}

		// back substitution
		n = voxel_index(i, y_size-2, 0);
		#pragma acc loop seq
		for (int j = y_size-2 ; j >= 0 ; j--) {
			naxpy_acc(gpu_p_density_vectors[n], gpu_thomas_cy[j], gpu_p_density_vectors[n+*gpu_thomas_j_jump], sizes_p_density_vectors[n]);
			/*
			#pragma acc loop seq
			for (int k = 0; k < 3; k++) {
				gpu_p_density_vectors[n][k] -= gpu_thomas_cx[i][k] * gpu_p_density_vectors[n+ (*gpu_thomas_i_jump)][k];
			}
			*/
			n -= *gpu_thomas_j_jump;
		}
	}
//	std::cout << "Done y_diffusion_acc" << std::endl;

}
// end Y-Diffusion GPU for 2D

// X-Diffusion GPU for 3D
void Microenvironment::x_diffusion_GPU_3D(){

	int x_size = mesh.x_coordinates.size();
	int y_size = mesh.y_coordinates.size();
	int z_size = mesh.z_coordinates.size();

	#pragma acc parallel present(gpu_p_density_vectors, sizes_p_density_vectors, gpu_thomas_denomx, gpu_thomas_i_jump, gpu_thomas_cx) 
	{
	#pragma acc loop independent gang
	for ( int k= 0; k < z_size; k++ )
	{
		#pragma acc loop independent vector
		for ( int j=0; j < y_size ; j++ ) 
		{
			int n = voxel_index(0, j, k);
			#pragma acc loop seq 
			for (int q = 0; q < sizes_p_density_vectors[n]; q++)
				{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomx[0][q];}

			#pragma acc loop seq
			for (int i=1; i < x_size ; i++) 
			{
				n = voxel_index(i, j, k);
				axpy_acc(gpu_p_density_vectors[n], gpu_thomas_constant1, gpu_p_density_vectors[n-*gpu_thomas_i_jump], sizes_p_density_vectors[n]);
				#pragma acc loop seq
			 	for (int q = 0; q < sizes_p_density_vectors[n]; q++)
					{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomx[i][q]; }
	
			}
	
			// back substitution
			// n = voxel_index(x_size-2, j, 0);
			#pragma acc loop seq
			for (int i = x_size-2 ; i >= 0 ; i--) 
			{
				n = voxel_index(i, j, k);
				naxpy_acc(gpu_p_density_vectors[n], gpu_thomas_cx[i], gpu_p_density_vectors[n+*gpu_thomas_i_jump], sizes_p_density_vectors[n]);
			}
		}
	}
//	std::cout << "Done x_diffusion_acc" << std::endl;

	} // end of parallel region
}
// end X-Diffusion GPU for 3D

// Y-Diffusion GPU for 3D
void Microenvironment::y_diffusion_GPU_3D(){

	int x_size = mesh.x_coordinates.size();
	int y_size = mesh.y_coordinates.size();
	int z_size = mesh.z_coordinates.size();

	#pragma acc parallel present(gpu_p_density_vectors, sizes_p_density_vectors, gpu_thomas_denomy, gpu_thomas_j_jump, gpu_thomas_cy) 
	{
	#pragma acc loop independent gang
	for ( int k= 0; k < z_size; k++ )
	{
		#pragma acc loop independent vector
		for ( int i=0; i < x_size ; i++ ) 
		{
			int n = voxel_index(i, 0, k);
			#pragma acc loop seq 
			for (int q = 0; q < sizes_p_density_vectors[n]; q++)
				{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomy[0][q];}

			#pragma acc loop seq
			for (int j=1; j < y_size ; j++) 
			{
				n = voxel_index(i, j, k);
				axpy_acc(gpu_p_density_vectors[n], gpu_thomas_constant1, gpu_p_density_vectors[n-*gpu_thomas_j_jump], sizes_p_density_vectors[n]);
				#pragma acc loop seq
				for (int q = 0; q < sizes_p_density_vectors[n]; q++)
					{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomy[j][q]; }
	
			}
	
			// back substitution
			// n = voxel_index(x_size-2, j, k);
			#pragma acc loop seq
			for (int j = y_size-2 ; j >= 0 ; j--) 
			{
				n = voxel_index(i, j, k);
				naxpy_acc(gpu_p_density_vectors[n], gpu_thomas_cy[j], gpu_p_density_vectors[n+*gpu_thomas_j_jump], sizes_p_density_vectors[n]);
			}
		}
	}
//	std::cout << "Done y_diffusion_acc" << std::endl;

	} // end of parallel region
}
// end Y-Diffusion GPU for 3D

// Z-Diffusion GPU for 3D
void Microenvironment::z_diffusion_GPU_3D(){

	int x_size = mesh.x_coordinates.size();
	int y_size = mesh.y_coordinates.size();
	int z_size = mesh.z_coordinates.size();

	#pragma acc parallel present(gpu_p_density_vectors, sizes_p_density_vectors, gpu_thomas_denomz, gpu_thomas_k_jump, gpu_thomas_cz) 
	{	
	#pragma acc loop independent gang
	for ( int j= 0; j < y_size; j++ )
	{
		#pragma acc loop independent vector
		for ( int i=0; i < x_size ; i++ ) 
		{
			int n = voxel_index(i, j, 0);
			#pragma acc loop seq 
			for (int q = 0; q < sizes_p_density_vectors[n]; q++)
				{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomz[0][q];}

			#pragma acc loop seq
			for (int k=1; k < z_size ; k++) 
			{
				n = voxel_index(i, j, k);
				axpy_acc(gpu_p_density_vectors[n], gpu_thomas_constant1, gpu_p_density_vectors[n-*gpu_thomas_k_jump], sizes_p_density_vectors[n]);
				#pragma acc loop seq
				for (int q = 0; q < sizes_p_density_vectors[n]; q++)
					{ gpu_p_density_vectors[n][q] /= gpu_thomas_denomz[k][q]; }
	
			}
	
			// back substitution
			// n = voxel_index(x_size-2, j, k);
			#pragma acc loop seq
			for (int k = z_size-2 ; k >= 0 ; k--) 
			{
				n = voxel_index(i, j, k);
				naxpy_acc(gpu_p_density_vectors[n], gpu_thomas_cz[k], gpu_p_density_vectors[n+*gpu_thomas_k_jump], sizes_p_density_vectors[n]);
			}
		}
	}
//	std::cout << "Done x_diffusion_acc" << std::endl;
	} // end of parallel region
}
// end Z-Diffusion GPU for 3D

void Microenvironment::translate_vector_to_array()
	/* translate_vector_to_array is actually an update between the two versions
	 * of p_density_vector (DEVICE = gpu_p_density_vector, HOST = p_density_vector),
	 * updating the device with the current values of the 
	 * host p_density_vector
	 */
{
	const int bin_p_density_vectors = (*p_density_vectors).size();

	for (int i = 0; i < bin_p_density_vectors; i++){
		int sze = (*p_density_vectors)[i].size();
		sizes_p_density_vectors[i] = sze;
		gpu_p_density_vectors[i] = (*p_density_vectors)[i].data();
		#pragma acc update device(this->gpu_p_density_vectors[i:1][:sze])
	}
	#pragma acc update device(this->sizes_p_density_vectors[:bin_p_density_vectors])
	
}

void Microenvironment::translate_array_to_vector()
	/* translate_array_to_vector is actually an update between the two versions
	 * of p_density_vector (DEVICE = gpu_p_density_vector, HOST = p_density_vector),
	 * updating the host with the current values of the 
	 * device gpu_p_density_vector
	 */
{
	const int bin_p_density_vectors = (*p_density_vectors).size();

	for (int i = 0; i < bin_p_density_vectors; i++){
		int sze = (*p_density_vectors)[i].size();
		#pragma acc update host(this->gpu_p_density_vectors[i:1][:sze])
	}
	#pragma acc update host(this->sizes_p_density_vectors[:bin_p_density_vectors])

	for (int i = 0; i < bin_p_density_vectors; i++) {
		for (int j = 0; j < this->sizes_p_density_vectors[i]; j++) {
			(*p_density_vectors)[i][j] = this->gpu_p_density_vectors[i][j];
		}
	}

	// Below is num_dirichlet
	#pragma acc update host(this->num_dirichlet)
	// End num_dirichlet
}

};

########## NEXT FILE ##########
/*
#############################################################################
# If you use BioFVM in your project, please cite BioFVM and the version     #
# number, such as below:                                                    #
#                                                                           #
# We solved the diffusion equations using BioFVM (Version 1.1.7) [1]        #
#                                                                           #
# [1] A. Ghaffarizadeh, S.H. Friedman, and P. Macklin, BioFVM: an efficient #
#    parallelized diffusive transport solver for 3-D biological simulations,#
#    Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730 #
#                                                                           #
#############################################################################
#                                                                           #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)   #
#                                                                           #
# Copyright (c) 2015-2017, Paul Macklin and the BioFVM Project              #
# All rights reserved.                                                      #
#                                                                           #
# Redistribution and use in source and binary forms, with or without        #
# modification, are permitted provided that the following conditions are    #
# met:                                                                      #
#                                                                           #
# 1. Redistributions of source code must retain the above copyright notice, #
# this list of conditions and the following disclaimer.                     #
#                                                                           #
# 2. Redistributions in binary form must reproduce the above copyright      #
# notice, this list of conditions and the following disclaimer in the       #
# documentation and/or other materials provided with the distribution.      #
#                                                                           #
# 3. Neither the name of the copyright holder nor the names of its          #
# contributors may be used to endorse or promote products derived from this #
# software without specific prior written permission.                       #
#                                                                           #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS       #
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED #
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A           #
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER #
# OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  #
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,       #
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR        #
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF    #
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING      #
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS        #
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.              #
#                                                                           #
#############################################################################
*/

#include "BioFVM_solvers.h" 
#include "BioFVM_vector.h" 

#include <iostream>
#include <omp.h>
#include <openacc.h>

namespace BioFVM{

// do I even need this? 
void diffusion_decay_solver__constant_coefficients_explicit( Microenvironment& M, double dt )
{
	static bool precomputations_and_constants_done = false; 
	if( !precomputations_and_constants_done )
	{
		std::cout	<< std::endl << "Using solver: " << __FUNCTION__ << std::endl 
					<< "     (constant diffusion coefficient with explicit stepping, implicit decay) ... " << std::endl << std::endl;  

		if( M.mesh.uniform_mesh == true )
		{
			std::cout << "Uniform mesh detected! Consider switching to a more efficient method, such as " << std::endl  
			<< "     diffusion_decay_solver__constant_coefficients_explicit_uniform_mesh" << std::endl  
			<< std::endl; 
		}

		precomputations_and_constants_done = true; 
	}

	return; 
}

void diffusion_decay_solver__constant_coefficients_explicit_uniform_mesh( Microenvironment& M, double dt )
{
	static bool precomputations_and_constants_done = false; 
	if( !precomputations_and_constants_done )
	{
		std::cout	<< std::endl << "Using solver: " << __FUNCTION__ << std::endl 
					<< "     (constant diffusion coefficient with explicit stepping, implicit decay, uniform mesh) ... " << std::endl << std::endl;  

		if( M.mesh.uniform_mesh == false )
		{ std::cout << "Error. This code is only supported for uniform meshes." << std::endl; }

		precomputations_and_constants_done = true; 
	}

	return; 
}

void diffusion_decay_solver__constant_coefficients_LOD_3D( Microenvironment& M, double dt )
{
	if( M.mesh.uniform_mesh == false || M.mesh.Cartesian_mesh == false )
	{
		std::cout << "Error: This algorithm is written for uniform Cartesian meshes. Try: other solvers!" << std::endl << std::endl; 
	return; 
	}

	// define constants and pre-computed quantities 
	
	if( !M.diffusion_solver_setup_done )
	{
		std::cout << std::endl << "Using method " << __FUNCTION__ << " (implicit 3-D LOD with Thomas Algorithm) ... " 
		<< std::endl << std::endl;  
		
		M.thomas_denomx.resize( M.mesh.x_coordinates.size() , M.zero );
		M.thomas_cx.resize( M.mesh.x_coordinates.size() , M.zero );

		M.thomas_denomy.resize( M.mesh.y_coordinates.size() , M.zero );
		M.thomas_cy.resize( M.mesh.y_coordinates.size() , M.zero );
		
		M.thomas_denomz.resize( M.mesh.z_coordinates.size() , M.zero );
		M.thomas_cz.resize( M.mesh.z_coordinates.size() , M.zero );

		M.thomas_i_jump = 1; 
		M.thomas_j_jump = M.mesh.x_coordinates.size(); 
		M.thomas_k_jump = M.thomas_j_jump * M.mesh.y_coordinates.size(); 

		M.thomas_constant1 =  M.diffusion_coefficients; // dt*D/dx^2 
		M.thomas_constant1a = M.zero; // -dt*D/dx^2; 
		M.thomas_constant2 =  M.decay_rates; // (1/3)* dt*lambda 
		M.thomas_constant3 = M.one; // 1 + 2*constant1 + constant2; 
		M.thomas_constant3a = M.one; // 1 + constant1 + constant2; 		
			
		M.thomas_constant1 *= dt; 
		M.thomas_constant1 /= M.mesh.dx; 
		M.thomas_constant1 /= M.mesh.dx; 

		M.thomas_constant1a = M.thomas_constant1; 
		M.thomas_constant1a *= -1.0; 

		M.thomas_constant2 *= dt; 
		M.thomas_constant2 /= 3.0; // for the LOD splitting of the source 

		M.thomas_constant3 += M.thomas_constant1; 
		M.thomas_constant3 += M.thomas_constant1; 
		M.thomas_constant3 += M.thomas_constant2; 

		M.thomas_constant3a += M.thomas_constant1; 
		M.thomas_constant3a += M.thomas_constant2; 

		// Thomas solver coefficients 

		M.thomas_cx.assign( M.mesh.x_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomx.assign( M.mesh.x_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomx[0] = M.thomas_constant3a; 
		M.thomas_denomx[ M.mesh.x_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.x_coordinates.size() == 1 )
		{ M.thomas_denomx[0] = M.one; M.thomas_denomx[0] += M.thomas_constant2; } 

		M.thomas_cx[0] /= M.thomas_denomx[0]; 
		for( unsigned int i=1 ; i <= M.mesh.x_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomx[i] , M.thomas_constant1 , M.thomas_cx[i-1] ); 
			M.thomas_cx[i] /= M.thomas_denomx[i]; // the value at  size-1 is not actually used  
		}

		M.thomas_cy.assign( M.mesh.y_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomy.assign( M.mesh.y_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomy[0] = M.thomas_constant3a; 
		M.thomas_denomy[ M.mesh.y_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.y_coordinates.size() == 1 )
		{ M.thomas_denomy[0] = M.one; M.thomas_denomy[0] += M.thomas_constant2; } 

		M.thomas_cy[0] /= M.thomas_denomy[0]; 
		for( unsigned int i=1 ; i <= M.mesh.y_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomy[i] , M.thomas_constant1 , M.thomas_cy[i-1] ); 
			M.thomas_cy[i] /= M.thomas_denomy[i]; // the value at  size-1 is not actually used  
		}

		M.thomas_cz.assign( M.mesh.z_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomz.assign( M.mesh.z_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomz[0] = M.thomas_constant3a; 
		M.thomas_denomz[ M.mesh.z_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.z_coordinates.size() == 1 )
		{ M.thomas_denomz[0] = M.one; M.thomas_denomz[0] += M.thomas_constant2; } 

		M.thomas_cz[0] /= M.thomas_denomz[0]; 
		for( unsigned int i=1 ; i <= M.mesh.z_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomz[i] , M.thomas_constant1 , M.thomas_cz[i-1] ); 
			M.thomas_cz[i] /= M.thomas_denomz[i]; // the value at  size-1 is not actually used  
		}	

		M.diffusion_solver_setup_done = true; 
	}

	// x-diffusion 
	
	M.apply_dirichlet_conditions();
	#pragma omp parallel for 
	for( unsigned int k=0; k < M.mesh.z_coordinates.size() ; k++ )
	{
		for( unsigned int j=0; j < M.mesh.y_coordinates.size() ; j++ )
		{
			// Thomas solver, x-direction

			// remaining part of forward elimination, using pre-computed quantities 
			int n = M.voxel_index(0,j,k);
			(*M.p_density_vectors)[n] /= M.thomas_denomx[0]; 

			for( unsigned int i=1; i < M.mesh.x_coordinates.size() ; i++ )
			{
				n = M.voxel_index(i,j,k); 
				axpy( &(*M.p_density_vectors)[n] , M.thomas_constant1 , (*M.p_density_vectors)[n-M.thomas_i_jump] ); 
				(*M.p_density_vectors)[n] /= M.thomas_denomx[i]; 
			}

			for( int i = M.mesh.x_coordinates.size()-2 ; i >= 0 ; i-- )
			{
				n = M.voxel_index(i,j,k); 
				naxpy( &(*M.p_density_vectors)[n] , M.thomas_cx[i] , (*M.p_density_vectors)[n+M.thomas_i_jump] ); 
			}

		}
	}

	// y-diffusion 

	M.apply_dirichlet_conditions();
	#pragma omp parallel for 
	for( unsigned int k=0; k < M.mesh.z_coordinates.size() ; k++ )
	{
		for( unsigned int i=0; i < M.mesh.x_coordinates.size() ; i++ )
		{
   // Thomas solver, y-direction

	// remaining part of forward elimination, using pre-computed quantities 

	int n = M.voxel_index(i,0,k);
	(*M.p_density_vectors)[n] /= M.thomas_denomy[0]; 

	for( unsigned int j=1; j < M.mesh.y_coordinates.size() ; j++ )
	{
		n = M.voxel_index(i,j,k); 
		axpy( &(*M.p_density_vectors)[n] , M.thomas_constant1 , (*M.p_density_vectors)[n-M.thomas_j_jump] ); 
		(*M.p_density_vectors)[n] /= M.thomas_denomy[j]; 
	}

	// back substitution 
	// n = voxel_index( mesh.x_coordinates.size()-2 ,j,k); 

	for( int j = M.mesh.y_coordinates.size()-2 ; j >= 0 ; j-- )
	{
		n = M.voxel_index(i,j,k); 
		naxpy( &(*M.p_density_vectors)[n] , M.thomas_cy[j] , (*M.p_density_vectors)[n+M.thomas_j_jump] ); 
	}

  }
 }

 // z-diffusion 

	M.apply_dirichlet_conditions();
 #pragma omp parallel for 
 for( unsigned int j=0; j < M.mesh.y_coordinates.size() ; j++ )
 {
	 
  for( unsigned int i=0; i < M.mesh.x_coordinates.size() ; i++ )
  {
   // Thomas solver, y-direction

	// remaining part of forward elimination, using pre-computed quantities 

	int n = M.voxel_index(i,j,0);
	(*M.p_density_vectors)[n] /= M.thomas_denomz[0]; 

	// should be an empty loop if mesh.z_coordinates.size() < 2  
	for( unsigned int k=1; k < M.mesh.z_coordinates.size() ; k++ )
	{
		n = M.voxel_index(i,j,k); 
		axpy( &(*M.p_density_vectors)[n] , M.thomas_constant1 , (*M.p_density_vectors)[n-M.thomas_k_jump] ); 
		(*M.p_density_vectors)[n] /= M.thomas_denomz[k]; 
	}

	// back substitution 

	// should be an empty loop if mesh.z_coordinates.size() < 2 
	for( int k = M.mesh.z_coordinates.size()-2 ; k >= 0 ; k-- )
	{
		n = M.voxel_index(i,j,k); 
		naxpy( &(*M.p_density_vectors)[n] , M.thomas_cz[k] , (*M.p_density_vectors)[n+M.thomas_k_jump] ); 
		// n -= i_jump; 
	}
  }
 }
 
	M.apply_dirichlet_conditions();
	
	// reset gradient vectors 
//	M.reset_all_gradient_vectors(); 

	return; 
}

void diffusion_decay_solver__constant_coefficients_LOD_3D_GPU( Microenvironment& M, double dt )
{

	if( M.mesh.uniform_mesh == false || M.mesh.Cartesian_mesh == false )
	{
		std::cout << "Error: This algorithm is written for uniform Cartesian meshes. Try: other solvers!" << std::endl << std::endl; 
	return; 
	}

	// define constants and pre-computed quantities 
	
	if( !M.diffusion_solver_setup_done )
	{
		std::cout << std::endl << "Using method " << __FUNCTION__ << " (implicit 3-D GPU  LOD with Thomas Algorithm) ... " 
		<< std::endl << std::endl;  
		
		M.thomas_denomx.resize( M.mesh.x_coordinates.size() , M.zero );
		M.thomas_cx.resize( M.mesh.x_coordinates.size() , M.zero );

		M.thomas_denomy.resize( M.mesh.y_coordinates.size() , M.zero );
		M.thomas_cy.resize( M.mesh.y_coordinates.size() , M.zero );
		
		M.thomas_denomz.resize( M.mesh.z_coordinates.size() , M.zero );
		M.thomas_cz.resize( M.mesh.z_coordinates.size() , M.zero );

		M.thomas_i_jump = 1; 
		M.thomas_j_jump = M.mesh.x_coordinates.size(); 
		M.thomas_k_jump = M.thomas_j_jump * M.mesh.y_coordinates.size(); 

		M.thomas_constant1 =  M.diffusion_coefficients; // dt*D/dx^2 
		M.thomas_constant1a = M.zero; // -dt*D/dx^2; 
		M.thomas_constant2 =  M.decay_rates; // (1/3)* dt*lambda 
		M.thomas_constant3 = M.one; // 1 + 2*constant1 + constant2; 
		M.thomas_constant3a = M.one; // 1 + constant1 + constant2; 		
			
		M.thomas_constant1 *= dt; 
		M.thomas_constant1 /= M.mesh.dx; 
		M.thomas_constant1 /= M.mesh.dx; 

		M.thomas_constant1a = M.thomas_constant1; 
		M.thomas_constant1a *= -1.0; 

		M.thomas_constant2 *= dt; 
		M.thomas_constant2 /= 3.0; // for the LOD splitting of the source 

		M.thomas_constant3 += M.thomas_constant1; 
		M.thomas_constant3 += M.thomas_constant1; 
		M.thomas_constant3 += M.thomas_constant2; 

		M.thomas_constant3a += M.thomas_constant1; 
		M.thomas_constant3a += M.thomas_constant2; 

		// Thomas solver coefficients 

		M.thomas_cx.assign( M.mesh.x_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomx.assign( M.mesh.x_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomx[0] = M.thomas_constant3a; 
		M.thomas_denomx[ M.mesh.x_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.x_coordinates.size() == 1 )
		{ M.thomas_denomx[0] = M.one; M.thomas_denomx[0] += M.thomas_constant2; } 

		M.thomas_cx[0] /= M.thomas_denomx[0]; 
		for( unsigned int i=1 ; i <= M.mesh.x_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomx[i] , M.thomas_constant1 , M.thomas_cx[i-1] ); 
			M.thomas_cx[i] /= M.thomas_denomx[i]; // the value at  size-1 is not actually used  
		}

		M.thomas_cy.assign( M.mesh.y_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomy.assign( M.mesh.y_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomy[0] = M.thomas_constant3a; 
		M.thomas_denomy[ M.mesh.y_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.y_coordinates.size() == 1 )
		{ M.thomas_denomy[0] = M.one; M.thomas_denomy[0] += M.thomas_constant2; } 

		M.thomas_cy[0] /= M.thomas_denomy[0]; 
		for( unsigned int i=1 ; i <= M.mesh.y_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomy[i] , M.thomas_constant1 , M.thomas_cy[i-1] ); 
			M.thomas_cy[i] /= M.thomas_denomy[i]; // the value at  size-1 is not actually used  
		}

		M.thomas_cz.assign( M.mesh.z_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomz.assign( M.mesh.z_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomz[0] = M.thomas_constant3a; 
		M.thomas_denomz[ M.mesh.z_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.z_coordinates.size() == 1 )
		{ M.thomas_denomz[0] = M.one; M.thomas_denomz[0] += M.thomas_constant2; } 

		M.thomas_cz[0] /= M.thomas_denomz[0]; 
		for( unsigned int i=1 ; i <= M.mesh.z_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomz[i] , M.thomas_constant1 , M.thomas_cz[i-1] ); 
			M.thomas_cz[i] /= M.thomas_denomz[i]; // the value at  size-1 is not actually used  
		}	

		M.diffusion_solver_setup_done = true; 
	}

	if (M.openacc_data_bool == false){
		std::cout << "transfering to device" << std::endl;
		M.transfer_3D();
		std::cout << "-continuing-" << std::endl;
		M.openacc_data_bool = true;
	}
	else {
		//M.translate_vector_to_array(); // used for updating Device if work
		// was done on Host
	}

	
	M.apply_dirichlet_conditions_GPU();

	// z-diffusion on gpu
	M.x_diffusion_GPU_3D();

	M.apply_dirichlet_conditions_GPU();

	// y-diffusion on gpu
	M.y_diffusion_GPU_3D();

	M.apply_dirichlet_conditions_GPU();

	// z-diffusion on gpu 
	M.z_diffusion_GPU_3D();

	M.apply_dirichlet_conditions_GPU();

	// reset gradient vectors 
	//M.reset_all_gradient_vectors(); 

	return; 
}

void diffusion_decay_solver__constant_coefficients_LOD_2D( Microenvironment& M, double dt )
{
	if( M.mesh.uniform_mesh == false )
	{
		std::cout << "Error: This algorithm is written for uniform Cartesian meshes. Try: something else." << std::endl << std::endl; 
		return; 
	}
	
	// constants for the linear solver (Thomas algorithm) 
	
	if( !M.diffusion_solver_setup_done )
	{
		std::cout << std::endl << "Using method " << __FUNCTION__ << " (2D LOD with Thomas Algorithm) ... " << std::endl << std::endl;  
		
		M.thomas_denomx.resize( M.mesh.x_coordinates.size() , M.zero );
		M.thomas_cx.resize( M.mesh.x_coordinates.size() , M.zero );

		M.thomas_denomy.resize( M.mesh.y_coordinates.size() , M.zero );
		M.thomas_cy.resize( M.mesh.y_coordinates.size() , M.zero );
		
		// define constants and pre-computed quantities 

		M.thomas_i_jump = 1; 
		M.thomas_j_jump = M.mesh.x_coordinates.size(); 

		M.thomas_constant1 =  M.diffusion_coefficients; //   dt*D/dx^2 
		M.thomas_constant1a = M.zero; // -dt*D/dx^2; 
		M.thomas_constant2 =  M.decay_rates; // (1/2)*dt*lambda 
		M.thomas_constant3 = M.one; // 1 + 2*constant1 + constant2; 
		M.thomas_constant3a = M.one; // 1 + constant1 + constant2; 
		
		M.thomas_constant1 *= dt; 
		M.thomas_constant1 /= M.mesh.dx; 
		M.thomas_constant1 /= M.mesh.dx; 

		M.thomas_constant1a = M.thomas_constant1; 
		M.thomas_constant1a *= -1.0; 

		M.thomas_constant2 *= dt; 
		M.thomas_constant2 *= 0.5; // for splitting via LOD

		M.thomas_constant3 += M.thomas_constant1; 
		M.thomas_constant3 += M.thomas_constant1; 
		M.thomas_constant3 += M.thomas_constant2; 

		M.thomas_constant3a += M.thomas_constant1; 
		M.thomas_constant3a += M.thomas_constant2; 
		
		// Thomas solver coefficients 

		M.thomas_cx.assign( M.mesh.x_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomx.assign( M.mesh.x_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomx[0] = M.thomas_constant3a; 
		M.thomas_denomx[ M.mesh.x_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.x_coordinates.size() == 1 )
		{ M.thomas_denomx[0] = M.one; M.thomas_denomx[0] += M.thomas_constant2; } 

		M.thomas_cx[0] /= M.thomas_denomx[0]; 
		for( unsigned int i=1 ; i <= M.mesh.x_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomx[i] , M.thomas_constant1 , M.thomas_cx[i-1] ); 
			M.thomas_cx[i] /= M.thomas_denomx[i]; // the value at  size-1 is not actually used  
		}

		M.thomas_cy.assign( M.mesh.y_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomy.assign( M.mesh.y_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomy[0] = M.thomas_constant3a; 
		M.thomas_denomy[ M.mesh.y_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.y_coordinates.size() == 1 )
		{ M.thomas_denomy[0] = M.one; M.thomas_denomy[0] += M.thomas_constant2; } 

		M.thomas_cy[0] /= M.thomas_denomy[0]; 
		for( unsigned int i=1 ; i <= M.mesh.y_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomy[i] , M.thomas_constant1 , M.thomas_cy[i-1] ); 
			M.thomas_cy[i] /= M.thomas_denomy[i]; // the value at  size-1 is not actually used  
		}

		M.diffusion_solver_setup_done = true; 
	}

	// set the pointer
	
	M.apply_dirichlet_conditions();

	// x-diffusion 
	#pragma omp parallel for 
	for( unsigned int j=0; j < M.mesh.y_coordinates.size() ; j++ )
	{
		// Thomas solver, x-direction

		// remaining part of forward elimination, using pre-computed quantities 
		unsigned int n = M.voxel_index(0,j,0);
		(*M.p_density_vectors)[n] /= M.thomas_denomx[0]; 

		n += M.thomas_i_jump; 
		for( unsigned int i=1; i < M.mesh.x_coordinates.size() ; i++ )
		{
			axpy( &(*M.p_density_vectors)[n] , M.thomas_constant1 , (*M.p_density_vectors)[n-M.thomas_i_jump] ); 
			(*M.p_density_vectors)[n] /= M.thomas_denomx[i]; 
			n += M.thomas_i_jump; 
		}

		// back substitution 
		n = M.voxel_index( M.mesh.x_coordinates.size()-2 ,j,0); 

		for( int i = M.mesh.x_coordinates.size()-2 ; i >= 0 ; i-- )
		{
			naxpy( &(*M.p_density_vectors)[n] , M.thomas_cx[i] , (*M.p_density_vectors)[n+M.thomas_i_jump] ); 
			n -= M.thomas_i_jump; 
		}
	}

	// y-diffusion 

	M.apply_dirichlet_conditions();
	#pragma omp parallel for 
	for( unsigned int i=0; i < M.mesh.x_coordinates.size() ; i++ )
	{
		// Thomas solver, y-direction

		// remaining part of forward elimination, using pre-computed quantities 

		int n = M.voxel_index(i,0,0);
		(*M.p_density_vectors)[n] /= M.thomas_denomy[0]; 

		n += M.thomas_j_jump; 
		for( unsigned int j=1; j < M.mesh.y_coordinates.size() ; j++ )
		{
			axpy( &(*M.p_density_vectors)[n] , M.thomas_constant1 , (*M.p_density_vectors)[n-M.thomas_j_jump] ); 
			(*M.p_density_vectors)[n] /= M.thomas_denomy[j]; 
			n += M.thomas_j_jump; 
		}

		// back substitution 
		n = M.voxel_index( i,M.mesh.y_coordinates.size()-2, 0); 

		for( int j = M.mesh.y_coordinates.size()-2 ; j >= 0 ; j-- )
		{
			naxpy( &(*M.p_density_vectors)[n] , M.thomas_cy[j] , (*M.p_density_vectors)[n+M.thomas_j_jump] ); 
			n -= M.thomas_j_jump; 
		}
	}

	M.apply_dirichlet_conditions();
	
	// reset gradient vectors 
//	M.reset_all_gradient_vectors(); 
	
	return; 
}

void diffusion_decay_solver__constant_coefficients_LOD_2D_GPU( Microenvironment& M, double dt )
{
	if( M.mesh.uniform_mesh == false )
	{
		std::cout << "Error: This algorithm is written for uniform Cartesian meshes. Try: something else." << std::endl << std::endl; 
		return; 
	}
	
	// constants for the linear solver (Thomas algorithm) 
	
	if( !M.diffusion_solver_setup_done )
	{
		std::cout << std::endl << "Using method " << __FUNCTION__ << " (2D LOD with Thomas Algorithm) ... " << std::endl << std::endl;  
		
		M.thomas_denomx.resize( M.mesh.x_coordinates.size() , M.zero );
		M.thomas_cx.resize( M.mesh.x_coordinates.size() , M.zero );

		M.thomas_denomy.resize( M.mesh.y_coordinates.size() , M.zero );
		M.thomas_cy.resize( M.mesh.y_coordinates.size() , M.zero );
		
		// define constants and pre-computed quantities 

		M.thomas_i_jump = 1; 
		M.thomas_j_jump = M.mesh.x_coordinates.size(); 

		M.thomas_constant1 =  M.diffusion_coefficients; //   dt*D/dx^2 
		M.thomas_constant1a = M.zero; // -dt*D/dx^2; 
		M.thomas_constant2 =  M.decay_rates; // (1/2)*dt*lambda 
		M.thomas_constant3 = M.one; // 1 + 2*constant1 + constant2; 
		M.thomas_constant3a = M.one; // 1 + constant1 + constant2; 
		
		M.thomas_constant1 *= dt; 
		M.thomas_constant1 /= M.mesh.dx; 
		M.thomas_constant1 /= M.mesh.dx; 

		M.thomas_constant1a = M.thomas_constant1; 
		M.thomas_constant1a *= -1.0; 

		M.thomas_constant2 *= dt; 
		M.thomas_constant2 *= 0.5; // for splitting via LOD

		M.thomas_constant3 += M.thomas_constant1; 
		M.thomas_constant3 += M.thomas_constant1; 
		M.thomas_constant3 += M.thomas_constant2; 

		M.thomas_constant3a += M.thomas_constant1; 
		M.thomas_constant3a += M.thomas_constant2; 
		
		// Thomas solver coefficients 

		M.thomas_cx.assign( M.mesh.x_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomx.assign( M.mesh.x_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomx[0] = M.thomas_constant3a; 
		M.thomas_denomx[ M.mesh.x_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.x_coordinates.size() == 1 )
		{ M.thomas_denomx[0] = M.one; M.thomas_denomx[0] += M.thomas_constant2; } 

		M.thomas_cx[0] /= M.thomas_denomx[0]; 
		for( unsigned int i=1 ; i <= M.mesh.x_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomx[i] , M.thomas_constant1 , M.thomas_cx[i-1] ); 
			M.thomas_cx[i] /= M.thomas_denomx[i]; // the value at  size-1 is not actually used  
		}

		M.thomas_cy.assign( M.mesh.y_coordinates.size() , M.thomas_constant1a ); 
		M.thomas_denomy.assign( M.mesh.y_coordinates.size()  , M.thomas_constant3 ); 
		M.thomas_denomy[0] = M.thomas_constant3a; 
		M.thomas_denomy[ M.mesh.y_coordinates.size()-1 ] = M.thomas_constant3a; 
		if( M.mesh.y_coordinates.size() == 1 )
		{ M.thomas_denomy[0] = M.one; M.thomas_denomy[0] += M.thomas_constant2; } 

		M.thomas_cy[0] /= M.thomas_denomy[0]; 
		for( unsigned int i=1 ; i <= M.mesh.y_coordinates.size()-1 ; i++ )
		{ 
			axpy( &M.thomas_denomy[i] , M.thomas_constant1 , M.thomas_cy[i-1] ); 
			M.thomas_cy[i] /= M.thomas_denomy[i]; // the value at  size-1 is not actually used  
		}

		M.diffusion_solver_setup_done = true; 
	}
	if (M.openacc_data_bool == false){
		M.transfer_2D();
		M.openacc_data_bool = true;
	}
	else {
		//M.translate_vector_to_array() // comment out for exclusive device
	}

	// set the pointer
	
	M.apply_dirichlet_conditions_GPU();

	// x-diffusion on gpu
	M.x_diffusion_GPU_2D();

	M.apply_dirichlet_conditions_GPU();

	// y-diffusion on gpu
	M.y_diffusion_GPU_2D();

	M.apply_dirichlet_conditions_GPU();

	// reset gradient vectors 
	//M.reset_all_gradient_vectors(); 
	
	return; 
}

void diffusion_decay_explicit_uniform_rates( Microenvironment& M, double dt )
{
	using std::vector; 
	using std::cout; 
	using std::endl; 

	// static int n_jump_i = 1; 
	// static int n_jump_j = M.mesh.x_coordinates.size(); 
	// static int n_jump_k = M.mesh.x_coordinates.size() * M.mesh.y_coordinates.size(); 

	if( !M.diffusion_solver_setup_done )
	{	
		M.thomas_i_jump = 1; 
		M.thomas_j_jump = M.mesh.x_coordinates.size(); 
		M.thomas_k_jump = M.thomas_j_jump * M.mesh.y_coordinates.size(); 
	
		M.diffusion_solver_setup_done = true; 
	}
	
	if( M.mesh.uniform_mesh == false )
	{
		cout << "Error: This algorithm is written for uniform Cartesian meshes. Try: something else" << endl << endl; 
		return; 
	}

	// double buffering to reduce memory copy / allocation overhead 

	static vector< vector<double> >* pNew = &(M.temporary_density_vectors1);
	static vector< vector<double> >* pOld = &(M.temporary_density_vectors2);

	// swap the buffers 

	vector< vector<double> >* pTemp = pNew; 
	pNew = pOld; 
	pOld = pTemp; 
	M.p_density_vectors = pNew; 

	// static bool reaction_diffusion_shortcuts_are_set = false; 

	static vector<double> constant1 = (1.0 / ( M.mesh.dx * M.mesh.dx )) * M.diffusion_coefficients; 
	static vector<double> constant2 = dt * constant1; 
	static vector<double> constant3 = M.one + dt * M.decay_rates;

	static vector<double> constant4 = M.one - dt * M.decay_rates;

	#pragma omp parallel for
	for( unsigned int i=0; i < (*(M.p_density_vectors)).size() ; i++ )
	{
		unsigned int number_of_neighbors = M.mesh.connected_voxel_indices[i].size(); 

		double d1 = -1.0 * number_of_neighbors; 

		(*pNew)[i] = (*pOld)[i];  
		(*pNew)[i] *= constant4; 

		for( unsigned int j=0; j < number_of_neighbors ; j++ )
		{
			axpy( &(*pNew)[i], constant2, (*pOld)[  M.mesh.connected_voxel_indices[i][j] ] ); 
		}
		vector<double> temp = constant2; 
		temp *= d1; 
		axpy( &(*pNew)[i] , temp , (*pOld)[i] ); 
	}
	
	// reset gradient vectors 
//	M.reset_all_gradient_vectors(); 

	return; 
}

};

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>
#include <time.h>

#include "../core/PhysiCell.h"
#include "../modules/PhysiCell_standard_modules.h"   

using namespace BioFVM;
using namespace PhysiCell;


int omp_num_threads = 8; // set number of threads for parallel computing
// set this to # of CPU cores x 2 (for hyperthreading)

double o2_conc=7.1930;  

double duct_radius= 158.75;

std::vector<std::vector<double>> create_sphere(double cell_radius, double sphere_radius)
{
	std::vector<std::vector<double>> cells;
	int xc=0,yc=0,zc=0;
	double x_spacing= cell_radius*sqrt(3);
	double y_spacing= cell_radius*2;
	double z_spacing= cell_radius*sqrt(3);
	
	std::vector<double> tempPoint(3,0.0);
	// std::vector<double> cylinder_center(3,0.0);
	
	for(double z=-sphere_radius;z<sphere_radius;z+=z_spacing, zc++)
		for(double x=-sphere_radius;x<sphere_radius;x+=x_spacing, xc++)
			for(double y=-sphere_radius;y<sphere_radius;y+=y_spacing, yc++)
			{
				tempPoint[0]=x + (zc%2) * 0.5 * cell_radius;
				tempPoint[1]=y + (xc%2) * cell_radius;
				tempPoint[2]=z;
				
				if(sqrt(norm_squared(tempPoint))< sphere_radius)
				{
					cells.push_back(tempPoint);
				}
			}
	return cells;
	
}


double distance_to_membrane_duct(Cell* pCell, Phenotype& phenotype, double dummy)
{
	double epsillon= 1e-7;
	//Note that this function assumes that duct cap center is located at <0, 0, 0>
	if(pCell->position[0]>=0) // Cell is within the cylinder part of the duct
	{
		double distance_to_x_axis= sqrt(pCell->position[1]* pCell->position[1] + pCell->position[2]*pCell->position[2]);
		distance_to_x_axis = std::max(distance_to_x_axis, epsillon);		// prevents division by zero
		pCell->displacement[0]=0; 
		pCell->displacement[1]= -pCell->position[1]/ distance_to_x_axis; 
		pCell->displacement[2]= -pCell->position[2]/ distance_to_x_axis; 
		return fabs(duct_radius- distance_to_x_axis);
	}
	
	// Cell is inside the cap of the duct
	double distance_to_origin= dist(pCell->position, {0.0,0.0,0.0});  // distance to the origin 
	distance_to_origin = std::max(distance_to_origin, epsillon);			  // prevents division by zero
	pCell->displacement[0]= -pCell->position[0]/ distance_to_origin;
	pCell->displacement[1]= -pCell->position[1]/ distance_to_origin;
	pCell->displacement[2]= -pCell->position[2]/ distance_to_origin;
	return fabs(duct_radius- distance_to_origin);
}

int main( int argc, char* argv[] )
{
	bool DEBUG=false;
	double t = 0.0; 
	double dt = 0.01; // reaction-diffusion time-step
	double mechanics_dt= 0.1;
	double cell_cycle_dt= 6;
	
	double t_output_interval = 60.0; // 1.0; 
	double t_max = 365*24*60;
	double t_next_output_time = 0; 
	int next_output_index = 0; 
	
	double dx; 
	double dy;  
	double dz; 
	
	// openmp setup
	omp_set_num_threads(omp_num_threads);
	
	// PNRG setup 	
	SeedRandom(3); 
	
	// figure out the bounding box 
	std::vector<double> bounding_box( 6, 0.0 );
	bounding_box[PhysiCell_constants::mesh_min_x_index] = -200; bounding_box[PhysiCell_constants::mesh_max_x_index] = 1000; 
	bounding_box[PhysiCell_constants::mesh_min_y_index] = -200; bounding_box[PhysiCell_constants::mesh_max_y_index] = 200; 
	bounding_box[PhysiCell_constants::mesh_min_z_index] = -200; bounding_box[PhysiCell_constants::mesh_max_z_index] = 200; 
	dx=20; dy=20; dz=20;
	
	
	// create a microenvironment
	BioFVM::Microenvironment microenvironment;
	microenvironment.name="substrate scale";
	// add a microenvironment for simulating substrates 	
	// microenvironment.create_microenvironment( "substrate scale"); 
	microenvironment.set_density(0, "oxygen" , "mmHg" );
	// microenvironment.add_density( "glucose" , "dimensionless" );
	
	std::cout << bounding_box << std::endl; 
	
	microenvironment.resize_space( bounding_box[0] , bounding_box[3] , bounding_box[1], bounding_box[4] , bounding_box[2] , bounding_box[5] ,dx,dy,dz );
	microenvironment.spatial_units = "microns";
	microenvironment.time_units = "minutes";
	microenvironment.mesh.units = "microns";
	
	// Cell_Container 
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	for( int n=0; n < microenvironment.number_of_voxels() ; n++ )
	{
		microenvironment.density_vector(n)[0] = o2_conc; 	
	}
	
	// register the diffusion solver 
	microenvironment.diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_3D; 
	
	// register substrates properties 
	microenvironment.diffusion_coefficients[0] = 1.0e5; // microns^2 / min 
	microenvironment.decay_rates[0] = 0.1;

	microenvironment.display_information( std::cout );

	
	initialize_default_cell_definition(); 	
	cell_defaults.type = 0; 
	cell_defaults.name = "tumor cell"; 
	// set default cell cycle model 
	cell_defaults.functions.cycle_model = Ki67_advanced; 	
	// set default_cell_functions; 
	cell_defaults.functions.update_phenotype = update_cell_and_death_parameters_O2_based; 
	cell_defaults.phenotype.secretion.sync_to_microenvironment( &microenvironment );
	cell_defaults.phenotype.sync_to_functions( cell_defaults.functions );
	
	int Q_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_negative );
	int oxygen_substrate_index = microenvironment.find_density_index( "oxygen" ); 
	int K1_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_positive_premitotic );
	int K2_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_positive_postmitotic );
	int apoptosis_model_index = cell_defaults.phenotype.death.find_death_model_index( "apoptosis" );
	int necrosis_model_index = cell_defaults.phenotype.death.find_death_model_index( "necrosis" );
	// cells apoptose after about 7 days 
	cell_defaults.phenotype.death.rates[apoptosis_model_index] = 1.0 / (7.0 * 24.0 * 60.0); 
	// initially no necrosis 
	cell_defaults.phenotype.death.rates[necrosis_model_index] = 0.0; 

	// make sure the cells uptake oxygen at the right rate 
	cell_defaults.phenotype.secretion.uptake_rates[oxygen_substrate_index] = 10; 

	// update transition times 
	cell_defaults.phenotype.cycle.data.transition_rate(Q_index,K1_index) = 1.0 / ( 8.5 * 60.0 ); 
	cell_defaults.phenotype.cycle.data.transition_rate(K1_index,K2_index) = 1.0 / ( 13.0 * 60.0 ); 
	cell_defaults.phenotype.cycle.data.transition_rate(K2_index,Q_index) = 1.0 / ( 2.5 * 60.0 ); 
	
	// let's make necrotic cells survive 6 hours in minimal oxygen conditions  
	cell_defaults.parameters.max_necrosis_rate = 1.0 / (6.0 * 60.0); 
	

	cell_defaults. functions.calculate_distance_to_membrane= distance_to_membrane_duct;
	double cell_radius=10;
	double sphere_radius = duct_radius - 10;;
	// std::cout << __FILE__ << " custom " << __LINE__ << std::endl; 
	std::vector<std::vector<double>> cell_positions;
	cell_positions= create_sphere(cell_radius, sphere_radius);

	//add Dirichlet node for all the voxels located outside of the duct
	std::vector<double> dirichlet_o2( 1 , o2_conc );
	
	for( int i=0; i < microenvironment.number_of_voxels() ; i++ )
	{
		if(microenvironment.voxels(i).center[0]>=0)
		{
			if(sqrt(microenvironment.voxels(i).center[1]* microenvironment.voxels(i).center[1] + microenvironment.voxels(i).center[2]*microenvironment.voxels(i).center[2])>duct_radius)
				microenvironment.add_dirichlet_node( i , dirichlet_o2 );
		}
		else
		{
			if(dist(microenvironment.voxels(i).center, {0.0,0.0,0.0})>duct_radius)
				microenvironment.add_dirichlet_node( i , dirichlet_o2 );
		}
	}
	
	Cell* pCell;

	for(int i=0;i<cell_positions.size();i++)
	// for(int i=0;i<2;i++)
	{
		if(cell_positions[i][0]>0)
			continue;
		pCell = create_cell();
		pCell->register_microenvironment(&microenvironment);
		pCell->assign_position(cell_positions[i]);
		pCell->phenotype.cycle.data.current_phase_index = Q_index; 
		if( pCell->phenotype.cycle.current_phase().entry_function )                      
			pCell->phenotype.cycle.current_phase().entry_function( pCell, pCell->phenotype, dt);
		// pCell->parameters.necrosis_type= PhysiCell_constants::deterministic_necrosis;
	}
	for(int i=0;i<all_basic_agents.size();i++){
		all_basic_agents[i]->set_internal_uptake_constants(dt); 
	}
	
	
	std::cout << (*all_cells).size() <<" agents created successfully." <<std::endl;
	
	std::vector<double> position (3, 0.0);
	position[0]=0;
	position[1]=0;
	position[2]=0;
	
	int output_index =0; 
	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	std::cout << "CLOCKS_PER_SEC = " << CLOCKS_PER_SEC << "\n";
	
/*	clock_t begin = clock();
	double sum=0;
  for(int i=0;i<1000000000;i++)
  {
	  sum+= sqrt((double)i);
  }
	std::cout<<"sum: "<<sum<<std::endl;
  clock_t end = clock();
  double elapsed_secs = double(end - begin) / CLOCKS_PER_SEC;
 */
  
	std::ofstream report_file ("report.txt");
	report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	try 
	{		
		while( t < t_max )
		{
			if(  fabs( t - t_next_output_time ) < 0.0001 )
			{
				log_output(t, output_index, microenvironment, report_file);
				t_next_output_time += t_output_interval;						
			}
			// std::cout<<__LINE__<<std::endl;			
			microenvironment.simulate_cell_sources_and_sinks( dt );
			microenvironment.simulate_diffusion_decay( dt );
			((Cell_Container *)microenvironment.agent_container)->update_all_cells(t, cell_cycle_dt, mechanics_dt, dt);		
			t += dt; 
			output_index++;
		}
		log_output(t, output_index, microenvironment, report_file);
		report_file.close();
	}
	catch( const std::exception& e ) { // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>


#include "../core/PhysiCell.h"
#include "../modules/PhysiCell_standard_modules.h"   

using namespace BioFVM;
using namespace PhysiCell;


int omp_num_threads = 8; // set number of threads for parallel computing
// set this to # of CPU cores x 2 (for hyperthreading)

double o2_conc=38.0;   //check this value to make sure it has support from literature

std::vector<std::vector<double>> create_sphere(double cell_radius, double sphere_radius)
{
	std::vector<std::vector<double>> cells;
	int xc=0,yc=0,zc=0;
	double x_spacing= cell_radius*sqrt(3);
	double y_spacing= cell_radius*2;
	double z_spacing= cell_radius*sqrt(3);
	
	std::vector<double> tempPoint(3,0.0);
	// std::vector<double> cylinder_center(3,0.0);
	
	for(double z=-sphere_radius;z<sphere_radius;z+=z_spacing, zc++)
		for(double x=-sphere_radius;x<sphere_radius;x+=x_spacing, xc++)
			for(double y=-sphere_radius;y<sphere_radius;y+=y_spacing, yc++)
			{
				tempPoint[0]=x + (zc%2) * 0.5 * cell_radius;
				tempPoint[1]=y + (xc%2) * cell_radius;
				tempPoint[2]=z;
				
				if(sqrt(norm_squared(tempPoint))< sphere_radius)
				{
					cells.push_back(tempPoint);
				}
			}
	return cells;
	
}

int main( int argc, char* argv[] )
{
	bool DEBUG=false;
	double t = 0.0; 
	double dt = 0.01; // reaction-diffusion time-step
	double mechanics_dt= 0.1;
	double cell_cycle_dt= 6;
	
	double t_output_interval = 600.0; // 1.0; 
	double t_max = 365*24*60;
	double t_next_output_time = 0; 
	int next_output_index = 0; 
	
	double dx; 
	double dy;  
	double dz; 
	
	// openmp setup
	omp_set_num_threads(omp_num_threads);
	
	// PNRG setup 	
	SeedRandom(3); 
	
	// figure out the bounding box 
	std::vector<double> bounding_box( 6, 0.0 );
	bounding_box[PhysiCell_constants::mesh_min_x_index] = -1000; bounding_box[PhysiCell_constants::mesh_max_x_index] = 1000; 
	bounding_box[PhysiCell_constants::mesh_min_y_index] = -1000; bounding_box[PhysiCell_constants::mesh_max_y_index] = 1000; 
	bounding_box[PhysiCell_constants::mesh_min_z_index] = -1000; bounding_box[PhysiCell_constants::mesh_max_z_index] = 1000; 
	dx=20; dy=20; dz=20;
	

	// create a microenvironment
	BioFVM::Microenvironment microenvironment;
	microenvironment.name="substrate scale";
	// add a microenvironment for simulating substrates 	
	// microenvironment.create_microenvironment( "substrate scale"); 
	microenvironment.set_density(0, "oxygen" , "mmHg" );
	// microenvironment.add_density( "glucose" , "dimensionless" );
	
	std::cout << bounding_box << std::endl; 
	
	microenvironment.resize_space( bounding_box[0] , bounding_box[3] , bounding_box[1], bounding_box[4] , bounding_box[2] , bounding_box[5] ,dx,dy,dz );
	microenvironment.spatial_units = "microns";
	microenvironment.time_units = "minutes";
	microenvironment.mesh.units = "microns";
	
	// Cell_Container 
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	for( int n=0; n < microenvironment.number_of_voxels() ; n++ )
	{
		microenvironment.density_vector(n)[0] = o2_conc; 	
	}
	
	// register the diffusion solver 
	microenvironment.diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_3D; 
	
	// register substrates properties 
	microenvironment.diffusion_coefficients[0] = 1.0e5; // microns^2 / min 
	microenvironment.decay_rates[0] = 0.1;

	microenvironment.display_information( std::cout );

	
	initialize_default_cell_definition(); 	
	cell_defaults.type = 0; 
	cell_defaults.name = "tumor cell"; 
	// set default cell cycle model 
	cell_defaults.functions.cycle_model = Ki67_advanced; 	
	// set default_cell_functions; 
	cell_defaults.functions.update_phenotype = update_cell_and_death_parameters_O2_based; 
	cell_defaults.phenotype.secretion.sync_to_microenvironment( &microenvironment );
	cell_defaults.phenotype.sync_to_functions( cell_defaults.functions );
	
	int Q_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_negative );
	int oxygen_substrate_index = microenvironment.find_density_index( "oxygen" ); 
	int K1_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_positive_premitotic );
	int K2_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_positive_postmitotic );
	int apoptosis_model_index = cell_defaults.phenotype.death.find_death_model_index( "apoptosis" );
	int necrosis_model_index = cell_defaults.phenotype.death.find_death_model_index( "necrosis" );
	// cells apoptose after about 7 days 
	cell_defaults.phenotype.death.rates[apoptosis_model_index] = 1.0 / (7.0 * 24.0 * 60.0); 
	// initially no necrosis 
	cell_defaults.phenotype.death.rates[necrosis_model_index] = 0.0; 

	// make sure the cells uptake oxygen at the right rate 
	cell_defaults.phenotype.secretion.uptake_rates[oxygen_substrate_index] = 10; 

	// update transition times 
	cell_defaults.phenotype.cycle.data.transition_rate(Q_index,K1_index) = 1.0 / ( 8.5 * 60.0 ); 
	cell_defaults.phenotype.cycle.data.transition_rate(K1_index,K2_index) = 1.0 / ( 13.0 * 60.0 ); 
	cell_defaults.phenotype.cycle.data.transition_rate(K2_index,Q_index) = 1.0 / ( 2.5 * 60.0 ); 
	
	// let's make necrotic cells survive 6 hours in minimal oxygen conditions  
	cell_defaults.parameters.max_necrosis_rate = 1.0 / (6.0 * 60.0); 
	
	double cell_radius=10;
	double sphere_radius = 150;
	// std::cout << __FILE__ << " custom " << __LINE__ << std::endl; 
	std::vector<std::vector<double>> cell_positions;
	cell_positions= create_sphere(cell_radius, sphere_radius);

	//add Dirichlet node for all the voxels located outside of the duct
	std::vector<double> dirichlet_o2( 1 , o2_conc );
	
	double min_x=microenvironment.mesh.bounding_box[0];
	double max_x=microenvironment.mesh.bounding_box[3];
	double min_y=microenvironment.mesh.bounding_box[1];
	double max_y=microenvironment.mesh.bounding_box[4];
	double min_z=microenvironment.mesh.bounding_box[2];
	double max_z=microenvironment.mesh.bounding_box[5];
	double strip_width=40;	

	for( int i=0; i < microenvironment.number_of_voxels() ; i++ )
	{
		if( abs(max_x-microenvironment.voxels(i).center[0]) < strip_width || abs(microenvironment.voxels(i).center[0]- min_x)< strip_width  
			|| abs(max_y-microenvironment.voxels(i).center[1]) < strip_width || abs(microenvironment.voxels(i).center[1]- min_y)< strip_width  
				|| abs(max_z-microenvironment.voxels(i).center[2]) < strip_width || abs(microenvironment.voxels(i).center[2]- min_z)< strip_width )
				{
					microenvironment.add_dirichlet_node( i , dirichlet_o2 );
				}		
	}

	
	Cell* pCell;

for(int i=0;i<cell_positions.size();i++)
	// for(int i=0;i<2;i++)
	{
		if(cell_positions[i][0]>0)
			continue;
		pCell = create_cell();
		pCell->register_microenvironment(&microenvironment);
		pCell->assign_position(cell_positions[i]);
		pCell->phenotype.cycle.data.current_phase_index = Q_index; 
		if( pCell->phenotype.cycle.current_phase().entry_function )                      
			pCell->phenotype.cycle.current_phase().entry_function( pCell, pCell->phenotype, dt);
		// pCell->parameters.necrosis_type= PhysiCell_constants::deterministic_necrosis;
	}

	for(int i=0;i<all_basic_agents.size();i++){
		all_basic_agents[i]->set_internal_uptake_constants(dt); 
	}
	
	std::cout << (*all_cells).size() <<" agents created successfully." <<std::endl;
	
	std::vector<double> position (3, 0.0);
	position[0]=0;
	position[1]=0;
	position[2]=0;
	
	int output_index =0; 
	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file ("report_spheroid.txt");
	report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	try 
	{		
		while( t < t_max )
		{
			if(  fabs( t - t_next_output_time ) < 0.0001 )
			{
				log_output(t, output_index, microenvironment, report_file);
				t_next_output_time += t_output_interval;						
			}
			microenvironment.simulate_cell_sources_and_sinks( dt );
			microenvironment.simulate_diffusion_decay( dt );
			((Cell_Container *)microenvironment.agent_container)->update_all_cells(t, cell_cycle_dt, mechanics_dt, dt);		
			t += dt; 
			output_index++;
		}
		log_output(t, output_index, microenvironment, report_file);
		report_file.close();
	}
	catch( const std::exception& e ) { // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "../core/PhysiCell.h"
#include "../modules/PhysiCell_standard_modules.h" 

using namespace BioFVM;
using namespace PhysiCell;


int omp_num_threads = 8; // set number of threads for parallel computing
// set this to # of CPU cores x 2 (for hyperthreading)
double pi=3.1415926535897932384626433832795;

double o2_conc=6.06;
double min_voxel_size=30;

int write_test_report(std::vector<Cell*> all_cells, double timepoint)
{
    std::string filename; 
    filename.resize( 1024 ); 
    sprintf( (char*) filename.c_str() , "test_cycle\\cells_%08i.txt" , (int)round(timepoint) ); 
    std::ofstream outputFile (filename.c_str(), std::ofstream::out);
    //outputFile<<"\tID\tx\ty\tz\tradius\tphenotype\telapsed_time\n";
    int phenotype_code;
    for(int i=0;i<all_cells.size();i++)
    {
        phenotype_code=all_cells[i]->phenotype.cycle.current_phase().code;
        outputFile<<i<<"\t"<<all_cells[i]->ID<<"\t"<<all_cells[i]->position[0]<<"\t" << all_cells[i]->position[1] <<"\t"<< all_cells[i]->position[2]<<"\t";
        outputFile<<all_cells[i]->phenotype.geometry.radius<<"\t"<<phenotype_code<< "\t"<< all_cells[i]->
        phenotype.cycle.data.elapsed_time_in_phase <<std::endl;
         
        // std::cout<<"Cell ID #"<<all_cells[i]->ID<<" position: "<< all_cells[i]->position<<std::endl;
    }
    outputFile.close();
    return 0;
}

int main( int argc, char* argv[] )
{
	if(argc<=1)
	{
		std::cout<<"you need to provide dt as an argument"<<std::endl;
		return 0;
	}
	double t = 0.0; 
	double dt = strtod(argv[1], NULL);
	std::cout<<dt<<std::endl;
	
	double t_output_interval = std::max(60.0,dt); // 1.0; 
	double t_max = 60*24*6;
	double t_next_output_time = 0; 
	int next_output_index = 0; 
	
	double dx; 
	double dy;  
	double dz; 
	
	// openmp setup
	omp_set_num_threads(omp_num_threads);
	
	// PNRG setup 	
	SeedRandom(); 
	
	// figure out the bounding box 
	double side_length= 2000;
	std::vector<double> bounding_box( 6, 0.0 );
	bounding_box[PhysiCell_constants::mesh_min_x_index] = 0; bounding_box[PhysiCell_constants::mesh_max_x_index] = side_length; 
	bounding_box[PhysiCell_constants::mesh_min_y_index] = 0; bounding_box[PhysiCell_constants::mesh_max_y_index] = side_length; 
	bounding_box[PhysiCell_constants::mesh_min_z_index] = 0; bounding_box[PhysiCell_constants::mesh_max_z_index] = side_length; 
	dx=20; dy=20; dz=20;
		
	// create a microenvironment; 
	BioFVM::Microenvironment microenvironment;
	microenvironment.name="substrate scale";
	// add a microenvironment for simulating substrates 	
	microenvironment.set_density(0, "oxygen" , "mmHg" );
	
	std::cout << bounding_box << std::endl; 
	
	microenvironment.resize_space( bounding_box[0] , bounding_box[3] , bounding_box[1], bounding_box[4] , bounding_box[2] , bounding_box[5] ,dx,dy,dz );
	microenvironment.spatial_units = "microns";
	microenvironment.time_units = "minutes";
	microenvironment.mesh.units = "microns";
	// Cell_Container 
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	for( int n=0; n < microenvironment.number_of_voxels() ; n++ )
	{
		microenvironment.density_vector(n)[0] = o2_conc; 	
	}
	
	// register the diffusion solver 
	microenvironment.diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_3D; 
	
	initialize_default_cell_definition(); 	
	cell_defaults.type = 0; 
	cell_defaults.name = "tumor cell"; 
	// set default cell cycle model 
	cell_defaults.functions.cycle_model = Ki67_advanced; 	
	// set default_cell_functions; 
	cell_defaults.functions.update_phenotype = update_cell_and_death_parameters_O2_based; 
	
	// disable cell's movement
	cell_defaults.functions.update_velocity=empty_function;
	cell_defaults.phenotype.secretion.sync_to_microenvironment( &microenvironment );
	cell_defaults.phenotype.sync_to_functions( cell_defaults.functions ); 
	// first find index for a few key variables. 
	int apoptosis_model_index = cell_defaults.phenotype.death.find_death_model_index( "Apoptosis" );
	int necrosis_model_index = cell_defaults.phenotype.death.find_death_model_index( "Necrosis" );
	int oxygen_substrate_index = microenvironment.find_density_index( "oxygen" ); 

	int K1_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_positive_premitotic );
	int K2_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_positive_postmitotic );
	int Q_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_negative );
	int A_index = Ki67_advanced.find_phase_index( PhysiCell_constants::apoptotic );
	int N_index = Ki67_advanced.find_phase_index( PhysiCell_constants::necrotic_swelling );
	
		// cells apoptose after about 7 days 
	cell_defaults.phenotype.death.rates[apoptosis_model_index] = 1.0 / (7.0 * 24.0 * 60.0); 
	// initially no necrosis 
	cell_defaults.phenotype.death.rates[necrosis_model_index] = 0.0; 

	// make sure the cells uptake oxygen at the right rate 
	cell_defaults.phenotype.secretion.uptake_rates[oxygen_substrate_index] = 0; 

	// cells leave the Q phase and enter the K1 phase after 5 hours 
	cell_defaults.phenotype.cycle.data.transition_rate(Q_index,K1_index) = 1.0 / ( 5.0 * 60.0 ); 
	
	// let's make necrotic cells survive 6 hours in minimal oxygen conditions  
	cell_defaults.parameters.max_necrosis_rate = 1.0 / (6.0 * 60.0); 
	

	microenvironment.display_information( std::cout );

	std::vector<double> temp_position(3);
	
	int num_ki67_positive_pre= 0;
	int num_ki67_positive_post= 0;
	int num_ki67_q=1000;//;
	int num_apoptotic= 0;
	int total= num_ki67_positive_pre + num_ki67_positive_post + num_ki67_q + num_apoptotic;
	double T1= 13 * 60;
	double T2= 2.5 * 60;
	double TQ= 74.35 * 60;
	double TA= 8.6 * 60;
	double T;
	int phase_index;
	for(int i=0;i<total;i++)
	{
		
		for(int j=0;j<3;j++)
			temp_position[j]= uniform_random()*1000+500;
		Cell* pCell = create_cell();
		pCell->register_microenvironment(&microenvironment);
		pCell->assign_position(temp_position);
		//pCell->advance_cell_current_phase=ki67_advanced_cycle_model_stochastic;
		if(i<num_ki67_positive_pre)
		{
			phase_index=K1_index;
			T = T1;
		}
		else if(i< num_ki67_positive_pre+ num_ki67_positive_post)
		{
			phase_index = K2_index;	
			T = T2;			
		}
		else if(i< num_ki67_positive_pre+ num_ki67_positive_post+ num_apoptotic)
		{
			phase_index = A_index;	
			T = TA;	
			pCell->phenotype.death.trigger_death( apoptosis_model_index );
			pCell->phenotype.cycle.sync_to_cycle_model( pCell->phenotype.death.current_model() );
		}
		else
		{
			phase_index = Q_index;	
			T = TQ;			
		}
		pCell->phenotype.cycle.data.current_phase_index = phase_index; 
		if( pCell->phenotype.cycle.current_phase().entry_function )                      
			pCell->phenotype.cycle.current_phase().entry_function( pCell, pCell->phenotype, dt);
		// std::cout<<__FILE__<<","<<__LINE__<<std::endl;

	}
	for(int i=0;i<all_basic_agents.size();i++){
		all_basic_agents[i]->set_internal_uptake_constants(dt); 
	}
		
	std::cout << (*all_cells).size() <<" agents created successfully." <<std::endl;
	
	int output_index =0; 
	// std::ofstream report_file ("report.txt");
	// report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();

	try 
	{		
		while( t < t_max )
		{
			if(  fabs( t - t_next_output_time ) < 0.0001 )
			{
				write_test_report(*all_cells,t);
				t_next_output_time += t_output_interval;	
				std::cout << "t: "<<t<<", cell count: "<<(*all_cells).size()<<std::endl;
			}
	
			((Cell_Container *)microenvironment.agent_container)->update_all_cells(t, dt, dt, dt);
			t += dt; 
			output_index++;
		}
		write_test_report(*all_cells,t);
		// report_file.close();
	}
	catch( const std::exception& e ) { // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "../core/PhysiCell.h"
#include "../modules/PhysiCell_standard_modules.h" 
using namespace BioFVM;
using namespace PhysiCell;

int omp_num_threads = 8; // set number of threads for parallel computing
// set this to # of CPU cores x 2 (for hyperthreading)


void do_nothing(Cell* pCell, Phenotype& phenotype, double dt){}

int main( int argc, char* argv[] )
{
	if(argc<=1)
	{
		std::cout<<"you need to provide dt as an argument"<<std::endl;
		return 0;
	}

	double t = 0.0; 
	double dt = strtod(argv[1],NULL);
	double t_output_interval = 1; // 1.0; 
	double t_max = 60;
	double t_next_output_time = 0; 
	int next_output_index = 0; 
	
	double dx; 
	double dy;  
	double dz; 
	
	// openmp setup
	omp_set_num_threads(omp_num_threads);
	
	// PNRG setup 	
	SeedRandom(3); 
	
	// figure out the bounding box 
	std::vector<double> bounding_box( 6, 0.0 );
	bounding_box[PhysiCell_constants::mesh_min_x_index] = 0; bounding_box[PhysiCell_constants::mesh_max_x_index] = 2000; 
	bounding_box[PhysiCell_constants::mesh_min_y_index] = 0; bounding_box[PhysiCell_constants::mesh_max_y_index] = 2000; 
	bounding_box[PhysiCell_constants::mesh_min_z_index] = 0; bounding_box[PhysiCell_constants::mesh_max_z_index] = 2000; 
	dx=20; dy=20; dz=20;
	
	// create a microenvironment;
	BioFVM::Microenvironment microenvironment;
	microenvironment.name="substrate scale";
	// add a microenvironment for simulating substrates 	
	microenvironment.set_density(0, "oxygen" , "mmHg" );
	microenvironment.resize_space( bounding_box[0] , bounding_box[3] , bounding_box[1], bounding_box[4] , bounding_box[2] , bounding_box[5] ,dx,dy,dz );
	microenvironment.spatial_units = "microns";
	microenvironment.time_units = "minutes";
	microenvironment.mesh.units = "microns";
	// Since this is just a test for mechanics, the following density initialization are not needed
	/* for( int n=0; n < microenvironment.number_of_voxels() ; n++ )
	{
		microenvironment.density_vector(n)[0] = o2_conc; 	
	}*/
	
	// Cell_Container
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	//microenvironment.agent_container= (Agent_Container *) cell_container; // cell_container;
	
	initialize_default_cell_definition(); 	
	cell_defaults.type = 0; 
	cell_defaults.name = "tumor cell"; 
	cell_defaults.functions.cycle_model = Ki67_advanced; 
	cell_defaults.functions.update_phenotype = empty_function;
	cell_defaults.functions.volume_update_function = empty_function;
	
	
	int Q_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_negative );
	// register the diffusion solver 
	microenvironment.diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_3D; 
		
	microenvironment.display_information( std::cout );

	
	// std::cout << __FILE__ << " custom " << __LINE__ << std::endl; 
	std::vector<double> point1(3), point2(3);

	double num1, num2;
	num1=100;
	num2= 105.73;
	double volume=4188.790204786391;
	point1[0]= num1; point1[1]= num1; point1[2]= num1; 
	point2[0]= num2; point2[1]= num2; point2[2]= num2; 
	
	Cell* pCell1 = create_cell();
	pCell1->register_microenvironment(&microenvironment);
	pCell1->assign_position(point1);
	pCell1->phenotype.cycle.data.current_phase_index = Q_index; 
	/* NOTE: for this experiment, you need to disable volume update function 
	 to make sure that volume change are not affecting the distance we measure for the cells.*/
	//pCell1->functions.volume_update_function=do_nothing;
	pCell1->set_total_volume(volume);
	
	Cell* pCell2 = create_cell();
	 pCell2->register_microenvironment(&microenvironment);
	pCell2->assign_position(point2);
	pCell2->phenotype.cycle.data.current_phase_index = Q_index; 
	//pCell2->functions.volume_update_function=do_nothing;
	pCell2->set_total_volume(volume);
	
	std::cout << pCell1->phenotype.geometry.radius<<std::endl;
	
	std::cout << (*all_cells).size() <<" agents created successfully." <<std::endl;
	
	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::string filename; 
	filename.resize( 1024 ); 
	sprintf( (char*) filename.c_str() , "mechanics_test1_result_dt=%f.txt" , dt ); 
	std::ofstream report_file (filename.c_str(), std::ofstream::out);
	
	pCell1->functions.update_velocity(pCell1,pCell1->phenotype, dt);
	pCell2->functions.update_velocity(pCell2,pCell2->phenotype, dt);
	
	pCell1->set_previous_velocity(pCell1->velocity[0],pCell1->velocity[1],pCell1->velocity[2]);
	pCell2->set_previous_velocity(pCell2->velocity[0],pCell2->velocity[1],pCell2->velocity[2]);
		
	for(int i=0;i<10;i++)
	{
		pCell1->position += (dt/10.0)*pCell1->velocity; 
		pCell2->position += (dt/10.0)*pCell2->velocity;
		t+=dt/10.0;
	}
	std::cout<<"time: "<< t<<std::endl;
	t_next_output_time=t_output_interval;
	std::cout<<pCell1->get_total_volume()<<std::endl;
	try 
	{		
		while( t < t_max )
		{
			
			if(  fabs( t - t_next_output_time ) < dt/10.0 )
			{
				report_file<<t<<"\t"<<dist(pCell1->position,pCell2->position)<<"\n";
				t_next_output_time += t_output_interval; 
			}
			
			((Cell_Container *)microenvironment.agent_container)->update_all_cells(t, dt, dt, dt);
			t += dt; 
		}
		report_file.close();
		std::cout<<pCell1->position<<"  "<< pCell2->position<< ", distance: " <<dist(pCell1->position,pCell2->position)<<  std::endl;
		
		std::cout<<pCell1->get_total_volume()<<std::endl;
		std::cout << "total number of agents: " << (*all_cells).size()<<std::endl << std::endl;
		BioFVM::RUNTIME_TOC();
		BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() );
	}
	catch( const std::exception& e ) { // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "../core/PhysiCell.h"
#include "../modules/PhysiCell_standard_modules.h" 

using namespace BioFVM;
using namespace PhysiCell;

int omp_num_threads = 8; // set number of threads for parallel computing
// set this to # of CPU cores x 2 (for hyperthreading)
double pi=3.1415926535897932384626433832795;

double min_voxel_size=30;

void do_nothing(Cell* pCell, Phenotype& phenotype, double dt){}

std::vector<std::vector<double>> create_sphere(double cell_radius, double sphere_radius)
{
	std::vector<std::vector<double>> cells;
	int xc=0,yc=0,zc=0;
	double x_spacing= cell_radius*sqrt(3);
	double y_spacing= cell_radius*2;
	double z_spacing= cell_radius*sqrt(3);
	
	std::vector<double> tempPoint(3,0.0);
	// std::vector<double> cylinder_center(3,0.0);
	
	for(double z=-sphere_radius;z<sphere_radius;z+=z_spacing, zc++)
		for(double x=-sphere_radius;x<sphere_radius;x+=x_spacing, xc++)
			for(double y=-sphere_radius;y<sphere_radius;y+=y_spacing, yc++)
			{
				tempPoint[0]=x + (zc%2) * 0.5 * cell_radius;
				tempPoint[1]=y + (xc%2) * cell_radius;
				tempPoint[2]=z;
				
				if(sqrt(norm_squared(tempPoint))< sphere_radius)
				{
					cells.push_back(tempPoint);
				}
			}
	return cells;
	
}

int main( int argc, char* argv[] )
{
	if(argc<=1)
	{
		std::cout<<"you need to provide dt as an argument"<<std::endl;
		return 0;
	}

	double t = 0.0; 
	double dt = strtod(argv[1],NULL);
	double t_output_interval = 5.0; // 1.0; 
	double t_max = 60;
	double t_next_output_time = 0; 
	int next_output_index = 0; 
	
	double dx; 
	double dy;  
	double dz; 
	
	// openmp setup
	omp_set_num_threads(omp_num_threads);
	
	// PNRG setup 	
	SeedRandom(3); 
	
	// figure out the bounding box 
	std::vector<double> bounding_box( 6, 0.0 );
	bounding_box[PhysiCell_constants::mesh_min_x_index] = 0; bounding_box[PhysiCell_constants::mesh_max_x_index] = 2000; 
	bounding_box[PhysiCell_constants::mesh_min_y_index] = 0; bounding_box[PhysiCell_constants::mesh_max_y_index] = 2000; 
	bounding_box[PhysiCell_constants::mesh_min_z_index] = 0; bounding_box[PhysiCell_constants::mesh_max_z_index] = 2000; 
	dx=20; dy=20; dz=20;
	
	
	// create a microenvironment
	BioFVM::Microenvironment microenvironment;
	microenvironment.name="substrate scale";
	// add a microenvironment for simulating substrates 	
	microenvironment.set_density(0, "oxygen" , "mmHg" );
	
	std::cout << bounding_box << std::endl; 
	
	microenvironment.resize_space( bounding_box[0] , bounding_box[3] , bounding_box[1], bounding_box[4] , bounding_box[2] , bounding_box[5] ,dx,dy,dz );
	microenvironment.spatial_units = "microns";
	microenvironment.time_units = "minutes";
	microenvironment.mesh.units = "microns";
	// Cell_Container * 
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	microenvironment.display_information( std::cout );

	initialize_default_cell_definition(); 	
	cell_defaults.type = 0; 
	cell_defaults.name = "tumor cell"; 
	cell_defaults.functions.cycle_model = Ki67_advanced; 
	cell_defaults.functions.update_phenotype = empty_function;
	cell_defaults.functions.volume_update_function = empty_function;
	
	int Q_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_negative );
	

	double sample_cell_radius=10;
	double volume=2.4943e+03;
	double sphere_radius = 80;
	// std::cout << __FILE__ << " custom " << __LINE__ << std::endl; 
	std::vector<std::vector<double>> cell_positions;
	cell_positions= create_sphere(sample_cell_radius/5, sphere_radius);
	
	std::vector<double> tumor_center(3);
		tumor_center[0]=1000;
		tumor_center[1]=1000;
		tumor_center[2]=1000;
	
	for(int i=0;i<cell_positions.size();i++)
	{
		Cell* pCell = create_cell();
		pCell->register_microenvironment(&microenvironment);
		pCell->assign_position(tumor_center+ cell_positions[i]);
		// pCell->functions.volume_update_function=empty_function;
		// pCell->functions.update_phenotype=do_nothing;
		pCell->phenotype.cycle.data.current_phase_index = Q_index; 
		pCell->set_total_volume(volume);	
	}
	
	std::cout << (*all_cells)[0]->phenotype.geometry.radius<<std::endl;	
	std::cout << (*all_cells).size() <<" agents created successfully." <<std::endl;
	
	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	try 
	{		
		while( t < t_max )
		{
			// std::cout<<"time: "<<t<<" diff:"<<fabs( t - t_next_output_time )<<" next output time:"<<t_next_output_time<<std::endl;
			if(  fabs( t - t_next_output_time ) < 0.001 )
			{
				std::cout<<"time: "<<t<<std::endl;
				writeCellReport(*all_cells, t);
				t_next_output_time += t_output_interval;
			}
				
			((Cell_Container *)microenvironment.agent_container)->update_all_cells(t, dt, dt, dt);
			t += dt; 
		}
		double scale=1000;
		writeCellReport(*all_cells, t_max);
		std::cout << "total number of agents: " << (*all_cells).size()<<std::endl << std::endl;
		BioFVM::RUNTIME_TOC();
		BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() );
	}
	catch( const std::exception& e ) { // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "../core/PhysiCell.h"
#include "../modules/PhysiCell_standard_modules.h" 

using namespace BioFVM;
using namespace PhysiCell;

int omp_num_threads = 1; // set number of threads for parallel computing
// set this to # of CPU cores x 2 (for hyperthreading)

double o2_conc=5.01;

int main( int argc, char* argv[] )
{
	double t = 0.0; 
	double dt;
	char test_type[3];
	// -A or -a for apoptotic, -N of -n for necrotic, and -c for live cells; the command should be like "program_name dt -x" where x is from (c,n,a)
	if(argc>=2)
	{
		dt = strtod(argv[1], NULL);
		if(argc==3)
			strcpy(test_type, argv[2]);
		else
			strcpy(test_type, "-c");
	}
	else
	{
		dt=0.1;
		strcpy(test_type, "-c");
	}
	std::cout<<test_type<<", "<<dt<<std::endl;
	double t_output_interval = 60.0;
	
	// set t_max to a larger value if you want to check volume change in necrotic phase
	double t_max = 1201;
	double t_next_output_time = 0; 
	int next_output_index = 0; 
	
	double dx; 
	double dy;  
	double dz; 
	
	// openmp setup
	omp_set_num_threads(omp_num_threads);
	
	// PNRG setup 	
	SeedRandom(-35); 
	
	// figure out the bounding box 
	std::vector<double> bounding_box( 6, 0.0 );
	bounding_box[PhysiCell_constants::mesh_min_x_index] = 0; bounding_box[PhysiCell_constants::mesh_max_x_index] = 2000; 
	bounding_box[PhysiCell_constants::mesh_min_y_index] = 0; bounding_box[PhysiCell_constants::mesh_max_y_index] = 2000; 
	bounding_box[PhysiCell_constants::mesh_min_z_index] = 0; bounding_box[PhysiCell_constants::mesh_max_z_index] = 2000; 
	dx=20; dy=20; dz=20;
	
	// create a microenvironment
	BioFVM::Microenvironment microenvironment;
	microenvironment.name="substrate scale";
	// add a microenvironment for simulating substrates 	
	microenvironment.set_density(0, "oxygen" , "mmHg" );
	
	std::cout << bounding_box << std::endl; 
	
	microenvironment.resize_space( bounding_box[0] , bounding_box[3] , bounding_box[1], bounding_box[4] , bounding_box[2] , bounding_box[5] ,dx,dy,dz );
	microenvironment.spatial_units = "microns";
	microenvironment.time_units = "minutes";
	microenvironment.mesh.units = "microns";
	// Cell_Container * 
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	for( int n=0; n < microenvironment.number_of_voxels() ; n++ )
	{
		microenvironment.density_vector(n)[0] = o2_conc; 	
	}

	// register the diffusion solver 
	microenvironment.diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_3D; 
	
	initialize_default_cell_definition(); 	
	cell_defaults.type = 0; 
	cell_defaults.name = "tumor cell"; 
	// set default cell cycle model 
	cell_defaults.functions.cycle_model = Ki67_advanced; 	
	// set default_cell_functions; 
	cell_defaults.functions.update_phenotype = update_cell_and_death_parameters_O2_based; 
	//cell_defaults.functions.volume_update_function = standard_volume_update_function;
	cell_defaults.phenotype.secretion.sync_to_microenvironment( &microenvironment );
	cell_defaults.phenotype.sync_to_functions( cell_defaults.functions ); 
	// first find index for a few key variables. 
	int apoptosis_model_index = cell_defaults.phenotype.death.find_death_model_index( "Apoptosis" );
	int necrosis_model_index = cell_defaults.phenotype.death.find_death_model_index( "Necrosis" );
	int oxygen_substrate_index = microenvironment.find_density_index( "oxygen" ); 

	int K1_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_positive_premitotic );
	int K2_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_positive_postmitotic );
	int Q_index = Ki67_advanced.find_phase_index( PhysiCell_constants::Ki67_negative );
	int A_index = Ki67_advanced.find_phase_index( PhysiCell_constants::apoptotic );
	int N_index = Ki67_advanced.find_phase_index( PhysiCell_constants::necrotic_swelling );
	
	microenvironment.display_information( std::cout );
	std::vector<double> point1(3);
	
	double a1=500;
	point1[0]= a1; point1[1]= a1; point1[2]= a1; 
	
	Cell* pCell1 = create_cell();
	pCell1->register_microenvironment(&microenvironment);
	pCell1->assign_position(point1);
	if(test_type[1]=='A' || test_type[1]=='a')
	{
		pCell1->phenotype.cycle.data.current_phase_index = A_index; 
		pCell1->phenotype.death.trigger_death( apoptosis_model_index );
		pCell1->phenotype.cycle.sync_to_cycle_model( pCell1->phenotype.death.current_model() );
	}
	else if(test_type[1]=='N' || test_type[1]=='n')
	{
		pCell1->phenotype.cycle.data.current_phase_index = N_index; 
		pCell1->phenotype.death.trigger_death( necrosis_model_index );
		pCell1->phenotype.cycle.sync_to_cycle_model( pCell1->phenotype.death.current_model() );
	}
	else if(test_type[1]=='C' || test_type[1]=='c')
	{
		pCell1->phenotype.cycle.data.current_phase_index = K1_index; 
		// disable apoptosis
		cell_defaults.phenotype.death.rates[apoptosis_model_index] =0;
		// set Q duration to a large value
		cell_defaults.phenotype.cycle.data.transition_rate(Q_index,K1_index) = 1e9;
		
	}

	pCell1->phenotype.cycle.current_phase().entry_function( pCell1, pCell1->phenotype, dt);

	
	
	
	for(int i=0;i<all_basic_agents.size();i++){
		all_basic_agents[i]->set_internal_uptake_constants(dt); 
	}
		
	std::cout << (*all_cells).size() <<" agent(s) created successfully." <<std::endl;
	
	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	std::ofstream vol_report ("vol_report.txt", std::ofstream::out);
	try 
	{		
		while( t < t_max )
		{
			if(  fabs( t - t_next_output_time ) < 0.001 )
			{
				vol_report<<t<<"\t"<<pCell1->get_total_volume()<<"\t"<<pCell1->phenotype.volume.fluid<<"\t"<<pCell1->phenotype.volume.nuclear_solid<<"\t"<<pCell1->phenotype.volume.cytoplasmic_solid<<"\n";
				t_next_output_time += t_output_interval;
			}
			if((*all_cells).size()>1)
			{
				delete_cell((Cell*)all_basic_agents[1]);
				std::cout << "cell deleted " << std::endl;
			}
			((Cell_Container *)microenvironment.agent_container)->update_all_cells(t, dt, dt, dt);
			t += dt; 
		}

		std::cout << "total number of agents: " << (*all_cells).size()<<std::endl << std::endl;
		BioFVM::RUNTIME_TOC();
		BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() );
		vol_report.close();
		std::cout<<"\nTotal volume: " << pCell1->get_total_volume()<<std::endl;
	}
	
	catch( const std::exception& e ) { // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>
#include <string> 

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// custom user modules 

#include "./custom_modules/heterogeneity.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }

	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// PNRG setup 
	SeedRandom(); 
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); 

	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	create_cell_types();
	setup_tissue();
	
	/* Users typically start modifying here. START USERMODS */ 
	
	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );
	
	// save a simulation snapshot 
	
	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = heterogeneity_coloring_function;
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	display_citations(); 
	
	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}
	
	// main loop 
	
	try 
	{	
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
			}
			
			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			
			// run PhysiCell 
			((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			PhysiCell_globals.current_time += diffusion_dt;
		}
		
		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	// timer 
	
	std::cout << std::endl << "Total simulation runtime: " << std::endl; 
	BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() ); 

	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// custom user modules 

#include "./custom_modules/biorobots.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }
	
	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// PNRG setup 
	SeedRandom(); 
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); 

	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	create_cell_types();
	setup_tissue();
	
	/* Users typically start modifying here. START USERMODS */ 
	
	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );
	
	// save a simulation snapshot 

	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = robot_coloring_function;
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	display_citations(); 
	
	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}
	
	// main loop 
	
	try 
	{	
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
			}
			
			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			
			// run PhysiCell 
			((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			PhysiCell_globals.current_time += diffusion_dt;
		}
		
		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	// timer 
	
	std::cout << std::endl << "Total simulation runtime: " << std::endl; 
	BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() ); 

	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// custom user modules 

#include "./custom_modules/cancer_biorobots.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }
	
	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// PNRG setup 
	SeedRandom(); 
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); 

	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	create_cell_types();
	setup_tissue();
	
	/* Users typically start modifying here. START USERMODS */ 

	double therapy_activation_time = parameters.doubles("therapy_activation_time"); // 60 * 24 * 7; // inject therapy at 7 days 

	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );
	
	// save a simulation snapshot 

	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = cancer_biorobots_coloring_function;
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	display_citations(); 
	
	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}	
	
	// main loop 
	
	try 
	{	
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			static bool therapy_introduced = false; 
			if( PhysiCell_globals.current_time > therapy_activation_time - 0.01*diffusion_dt && therapy_introduced == false )
			{
				std::cout << "Therapy started!" << std::endl; 
				therapy_introduced = true; 
				PhysiCell_settings.full_save_interval = parameters.doubles("save_interval_after_therapy_start"); // 3.0; 
				PhysiCell_settings.SVG_save_interval = parameters.doubles("save_interval_after_therapy_start"); // 3.0; 
				
				PhysiCell_globals.next_full_save_time = PhysiCell_globals.current_time; 
				PhysiCell_globals.next_SVG_save_time = PhysiCell_globals.current_time; 
				
				introduce_biorobots();
			} 	

			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
			}

			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			
			// run PhysiCell 
			((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			PhysiCell_globals.current_time += diffusion_dt;
		}
		
		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	// timer 
	
	std::cout << std::endl << "Total simulation runtime: " << std::endl; 
	BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() ); 

	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// custom user modules 

#include "./custom_modules/cancer_immune_3D.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }
	
	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// PNRG setup 
	SeedRandom(); 
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); 

	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	create_cell_types();
	setup_tissue();
	
	/* Users typically start modifying here. START USERMODS */ 

	double immune_activation_time = 
		parameters.doubles("immune_activation_time"); // 60 * 24 * 14; // activate immune response at 14 days 
	
	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );
	
	// save a simulation snapshot 

	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = cancer_immune_coloring_function;
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	display_citations(); 
	
	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}

	//set the diffusion solver to GPU
	microenvironment.diffusion_decay_solver = diffusion_decay_solver__constant_coefficients_LOD_3D_GPU;
	
	// main loop 
	
	try 
	{	
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			static bool immune_cells_introduced = false; 
			if( PhysiCell_globals.current_time > immune_activation_time - 0.01*diffusion_dt && immune_cells_introduced == false )
			{
				std::cout << "Therapy activated!" << std::endl << std::endl; 
				immune_cells_introduced = true; 
				
				PhysiCell_settings.full_save_interval = 
					parameters.doubles("save_interval_after_therapy_start"); // 3.0; 
				PhysiCell_settings.SVG_save_interval = 
					parameters.doubles("save_interval_after_therapy_start"); // 3.0; 
				
				PhysiCell_globals.next_full_save_time = PhysiCell_globals.current_time; 
				PhysiCell_globals.next_SVG_save_time = PhysiCell_globals.current_time; 
				
				introduce_immune_cells();
			} 

			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				std::cout << "1" << std::endl;
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				std::cout << "2" << std::endl;
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
			}
			
			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			// if( default_microenvironment_options.calculate_gradients )
			// { microenvironment.compute_all_gradient_vectors(); }
			
			// run PhysiCell 
			// ((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			
			// manually call the code for cell sources and sinks, 
			// since these are ordinarily automatically done as part of phenotype.secretion in the 
			// PhysiCell update that we commented out above. Remove this when we go 
			// back to main code 

			#pragma omp parallel for 
			for( int i=0; i < (*all_cells).size(); i++ )
			{
				(*all_cells)[i]->phenotype.secretion.advance( (*all_cells)[i], (*all_cells)[i]->phenotype , diffusion_dt );
			}			
			
			PhysiCell_globals.current_time += diffusion_dt;
		}
		
		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );

	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>
#include <string> 

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// custom user modules 

#include "./custom_modules/heterogeneity.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }

	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// PNRG setup 
	SeedRandom(); 
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); 

	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	create_cell_types();
	setup_tissue();
	
	/* Users typically start modifying here. START USERMODS */ 
	
	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );
	
	// save a simulation snapshot 
	
	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = heterogeneity_coloring_function;
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	display_citations(); 
	
	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}
	
	// main loop 
	
	try 
	{	
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
			}
			
			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			
			// run PhysiCell 
			((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			PhysiCell_globals.current_time += diffusion_dt;
		}
		
		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	// timer 
	
	std::cout << std::endl << "Total simulation runtime: " << std::endl; 
	BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() ); 

	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// put custom code modules here! 

#include "./custom_modules/custom.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }
	
	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); // modify this in the custom code 
	
	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	/* Users typically start modifying here. START USERMODS */ 
	
	create_cell_types();
	
	setup_tissue();

	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );
	
	// save a simulation snapshot 
	
	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = my_coloring_function; 
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	display_citations(); 
	
	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}
	
	// main loop 
	
	try 
	{		
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
			}

			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			
			// run PhysiCell 
			((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			/*
			  Custom add-ons could potentially go here. 
			*/
			
			PhysiCell_globals.current_time += diffusion_dt;
		}
		
		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	// timer 
	
	std::cout << std::endl << "Total simulation runtime: " << std::endl; 
	BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() ); 

	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// put custom code modules here! 

#include "./custom_modules/custom.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }
	
	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// PNRG setup 
	SeedRandom(); 
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); // modify this in the custom code 
	
	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	/* Users typically start modifying here. START USERMODS */ 
	
	create_cell_types();
	
	setup_tissue();

	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );
	
	// save a simulation snapshot 
	
	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = my_coloring_function;
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	display_citations(); 
	
	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}
	
	// main loop 
	
	try 
	{		
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
			}

			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			
			// run PhysiCell 
			((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			/*
			  Custom add-ons could potentially go here. 
			*/			
			
			PhysiCell_globals.current_time += diffusion_dt;
		}

		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );

	
	// timer 
	
	std::cout << std::endl << "Total simulation runtime: " << std::endl; 
	BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() ); 

	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// put custom code modules here! 

#include "./custom_modules/custom.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }

	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); // modify this in the custom code 

	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );

	/* Users typically start modifying here. START USERMODS */ 
	
	create_cell_types();

	setup_tissue();

	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );

	// save a simulation snapshot 
	
	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = viral_coloring_function; 
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );

	display_citations(); 

	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}
	
	// main loop 
	
	try 
	{		
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
				
				std::cout << "Total substrates " << integrate_total_substrates() << std::endl; 
			}

			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			
			// run PhysiCell 
			((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			/*
			  Custom add-ons could potentially go here. 
			*/
			
			PhysiCell_globals.current_time += diffusion_dt;
		}
		
		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	// timer 
	
	std::cout << std::endl << "Total simulation runtime: " << std::endl; 
	BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() ); 

	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

#include "./core/PhysiCell.h"
#include "./modules/PhysiCell_standard_modules.h" 

// put custom code modules here! 

#include "./custom_modules/custom.h" 
	
using namespace BioFVM;
using namespace PhysiCell;

int main( int argc, char* argv[] )
{
	// load and parse settings file(s)
	
	bool XML_status = false; 
	if( argc > 1 )
	{ XML_status = load_PhysiCell_config_file( argv[1] ); }
	else
	{ XML_status = load_PhysiCell_config_file( "./config/PhysiCell_settings.xml" ); }
	if( !XML_status )
	{ exit(-1); }
	
	// OpenMP setup
	omp_set_num_threads(PhysiCell_settings.omp_num_threads);
	
	// time setup 
	std::string time_units = "min"; 

	/* Microenvironment setup */ 
	
	setup_microenvironment(); // modify this in the custom code 
	
	/* PhysiCell setup */ 
 	
	// set mechanics voxel size, and match the data structure to BioFVM
	double mechanics_voxel_size = 30; 
	Cell_Container* cell_container = create_cell_container_for_microenvironment( microenvironment, mechanics_voxel_size );
	
	/* Users typically start modifying here. START USERMODS */ 
	
	create_cell_types();
	
	setup_tissue();

	/* Users typically stop modifying here. END USERMODS */ 
	
	// set MultiCellDS save options 

	set_save_biofvm_mesh_as_matlab( true ); 
	set_save_biofvm_data_as_matlab( true ); 
	set_save_biofvm_cell_data( true ); 
	set_save_biofvm_cell_data_as_custom_matlab( true );
	
	// save a simulation snapshot 
	
	char filename[1024];
	sprintf( filename , "%s/initial" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	// save a quick SVG cross section through z = 0, after setting its 
	// length bar to 200 microns 

	PhysiCell_SVG_options.length_bar = 200; 

	// for simplicity, set a pathology coloring function 
	
	std::vector<std::string> (*cell_coloring_function)(Cell*) = my_coloring_function; 
	
	sprintf( filename , "%s/initial.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	display_citations(); 
	
	// set the performance timers 

	BioFVM::RUNTIME_TIC();
	BioFVM::TIC();
	
	std::ofstream report_file;
	if( PhysiCell_settings.enable_legacy_saves == true )
	{	
		sprintf( filename , "%s/simulation_report.txt" , PhysiCell_settings.folder.c_str() ); 
		
		report_file.open(filename); 	// create the data log file 
		report_file<<"simulated time\tnum cells\tnum division\tnum death\twall time"<<std::endl;
	}
	
	// main loop 
	
	std::cout << "Unit test: conservation with individual agent substrate internalization " << std::endl 
		<< "If this works, the total amount of each substrate should stay fixed at each output " << std::endl << std::endl ; 
	
	try 
	{		
		while( PhysiCell_globals.current_time < PhysiCell_settings.max_time + 0.1*diffusion_dt )
		{
			// save data if it's time. 
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_full_save_time ) < 0.01 * diffusion_dt )
			{
				display_simulation_status( std::cout ); 
				if( PhysiCell_settings.enable_legacy_saves == true )
				{	
					log_output( PhysiCell_globals.current_time , PhysiCell_globals.full_output_index, microenvironment, report_file);
				}
				
				if( PhysiCell_settings.enable_full_saves == true )
				{	
					sprintf( filename , "%s/output%08u" , PhysiCell_settings.folder.c_str(),  PhysiCell_globals.full_output_index ); 
					
					save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
				}
				
				PhysiCell_globals.full_output_index++; 
				PhysiCell_globals.next_full_save_time += PhysiCell_settings.full_save_interval;
			}
			
			// save SVG plot if it's time
			if( fabs( PhysiCell_globals.current_time - PhysiCell_globals.next_SVG_save_time  ) < 0.01 * diffusion_dt )
			{
				if( PhysiCell_settings.enable_SVG_saves == true )
				{	
					sprintf( filename , "%s/snapshot%08u.svg" , PhysiCell_settings.folder.c_str() , PhysiCell_globals.SVG_output_index ); 
					SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
					
					PhysiCell_globals.SVG_output_index++; 
					PhysiCell_globals.next_SVG_save_time  += PhysiCell_settings.SVG_save_interval;
				}
				
				std::cout << "Total substrates " << integrate_total_substrates() << std::endl; 
			}

			// update the microenvironment
			microenvironment.simulate_diffusion_decay( diffusion_dt );
			
			// run PhysiCell 
			((Cell_Container *)microenvironment.agent_container)->update_all_cells( PhysiCell_globals.current_time );
			
			/*
			  Custom add-ons could potentially go here. 
			*/
			
			PhysiCell_globals.current_time += diffusion_dt;
		}
		
		if( PhysiCell_settings.enable_legacy_saves == true )
		{			
			log_output(PhysiCell_globals.current_time, PhysiCell_globals.full_output_index, microenvironment, report_file);
			report_file.close();
		}
	}
	catch( const std::exception& e )
	{ // reference to the base of a polymorphic object
		std::cout << e.what(); // information from length_error printed
	}
	
	// save a final simulation snapshot 
	
	sprintf( filename , "%s/final" , PhysiCell_settings.folder.c_str() ); 
	save_PhysiCell_to_MultiCellDS_xml_pugi( filename , microenvironment , PhysiCell_globals.current_time ); 
	
	sprintf( filename , "%s/final.svg" , PhysiCell_settings.folder.c_str() ); 
	SVG_plot( filename , microenvironment, 0.0 , PhysiCell_globals.current_time, cell_coloring_function );
	
	// timer 
	
	std::cout << std::endl << "Total simulation runtime: " << std::endl; 
	BioFVM::display_stopwatch_value( std::cout , BioFVM::runtime_stopwatch_value() ); 

	return 0; 
}

########## NEXT FILE ##########
/*
###############################################################################
# If you use PhysiCell in your project, please cite PhysiCell and the version #
# number, such as below:                                                      #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# See VERSION.txt or call get_PhysiCell_version() to get the current version  #
#     x.y.z. Call display_citations() to get detailed information on all cite-#
#     able software used in your PhysiCell application.                       #
#                                                                             #
# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #
#     as below:                                                               #
#                                                                             #
# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #
# with BioFVM [2] to solve the transport equations.                           #
#                                                                             #
# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #
#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #
#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #
#     DOI: 10.1371/journal.pcbi.1005991                                       #
#                                                                             #
# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #
#     llelized diffusive transport solver for 3-D biological simulations,     #
#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #
#                                                                             #
###############################################################################
#                                                                             #
# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #
#                                                                             #
# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #
# All rights reserved.                                                        #
#                                                                             #
# Redistribution and use in source and binary forms, with or without          #
# modification, are permitted provided that the following conditions are met: #
#                                                                             #
# 1. Redistributions of source code must retain the above copyright notice,   #
# this list of conditions and the following disclaimer.                       #
#                                                                             #
# 2. Redistributions in binary form must reproduce the above copyright        #
# notice, this list of conditions and the following disclaimer in the         #
# documentation and/or other materials provided with the distribution.        #
#                                                                             #
# 3. Neither the name of the copyright holder nor the names of its            #
# contributors may be used to endorse or promote products derived from this   #
# software without specific prior written permission.                         #
#                                                                             #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
# POSSIBILITY OF SUCH DAMAGE.                                                 #
#                                                                             #
###############################################################################
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <cmath>
#include <omp.h>
#include <fstream>

// set number of threads for OpenMP (parallel computing)
int omp_num_threads = 8; // set this to # of CPU cores x 2 (for hyperthreading)

int main( int argc, char* argv[] )
{
	// OpenMP setup
	omp_set_num_threads(omp_num_threads);

	#pragma omp parallel for 
	for( int i= atoi( argv[1] ) ; i <= atoi( argv[2] ); i++ )
	{
		char str [1024]; 
		sprintf( str , "CI_vis %i", i ); 
		system( str ); 
		
		std::cout << i << " " << str << std::endl; 
		
		
	}
	

	
	return 0; 
}
########## NEXT FILE ##########
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB BT code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//OpenACC version author: Rengan Xu(renganxu@gmail.com)				   //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS BT code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

//---------------------------------------------------------------------
// program BT
//---------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>

#include "header.h"
#include "timers.h"
#include "print_results.h"
#include<openacc.h>

/* common /global/ */
double elapsed_time;
int grid_points[3];
logical timeron;

/* common /constants/ */
double tx1, tx2, tx3, ty1, ty2, ty3, tz1, tz2, tz3, 
       dx1, dx2, dx3, dx4, dx5, dy1, dy2, dy3, dy4, 
       dy5, dz1, dz2, dz3, dz4, dz5, dssp, dt, 
       ce[5][13], dxmax, dymax, dzmax, xxcon1, xxcon2, 
       xxcon3, xxcon4, xxcon5, dx1tx1, dx2tx1, dx3tx1,
       dx4tx1, dx5tx1, yycon1, yycon2, yycon3, yycon4,
       yycon5, dy1ty1, dy2ty1, dy3ty1, dy4ty1, dy5ty1,
       zzcon1, zzcon2, zzcon3, zzcon4, zzcon5, dz1tz1, 
       dz2tz1, dz3tz1, dz4tz1, dz5tz1, dnxm1, dnym1, 
       dnzm1, c1c2, c1c5, c3c4, c1345, conz1, c1, c2, 
       c3, c4, c5, c4dssp, c5dssp, dtdssp, dttx1,
       dttx2, dtty1, dtty2, dttz1, dttz2, c2dttx1, 
       c2dtty1, c2dttz1, comz1, comz4, comz5, comz6, 
       c3c4tx3, c3c4ty3, c3c4tz3, c2iv, con43, con16;

// to improve cache performance, grid dimensions padded by 1 
// for even number sizes only.
/* common /fields/ */
double us     [KMAX][JMAXP+1][IMAXP+1];
double vs     [KMAX][JMAXP+1][IMAXP+1];
double ws     [KMAX][JMAXP+1][IMAXP+1];
double qs     [KMAX][JMAXP+1][IMAXP+1];
double rho_i  [KMAX][JMAXP+1][IMAXP+1];
double square [KMAX][JMAXP+1][IMAXP+1];
double forcing[5][KMAX][JMAXP+1][IMAXP+1];
double u[5][KMAX][JMAXP+1][IMAXP+1];
double rhs[5][KMAX][JMAXP+1][IMAXP+1];

/* common /work_1d/ */
double cuf[PROBLEM_SIZE+1];
double q  [PROBLEM_SIZE+1];
double ue [PROBLEM_SIZE+1][5];
double buf[PROBLEM_SIZE+1][5];

/* common /work_lhs/ */
double fjac[PROBLEM_SIZE+1][5][5];
double njac[PROBLEM_SIZE+1][5][5];
double lhs [PROBLEM_SIZE+1][3][5][5];
double tmp1, tmp2, tmp3;
/*  
double fjacX[5][5][PROBLEM_SIZE+1][JMAXP-1][KMAX-1];
double njacX[5][5][PROBLEM_SIZE+1][JMAXP-1][KMAX-1];
double lhsX[5][5][3][PROBLEM_SIZE][JMAXP-1][KMAX-1];
  
double fjacY[5][5][PROBLEM_SIZE+1][IMAXP-1][KMAX-1];
double njacY[5][5][PROBLEM_SIZE+1][IMAXP-1][KMAX-1];
double lhsY[5][5][3][PROBLEM_SIZE][IMAXP-1][KMAX-1];

double fjacZ[5][5][PROBLEM_SIZE+1][IMAXP-1][JMAXP-1];
double njacZ[5][5][PROBLEM_SIZE+1][IMAXP-1][JMAXP-1];
double lhsZ[5][5][3][PROBLEM_SIZE][IMAXP-1][JMAXP-1];
*/
int main(int argc, char *argv[])
{
  int i, niter, step;
  double navg, mflops, n3;

  double tmax, t, trecs[t_last+1];
  logical verified;
  char Class;
  char *t_names[t_last+1];

  //---------------------------------------------------------------------
  // Root node reads input file (if it exists) else takes
  // defaults from parameters
  //---------------------------------------------------------------------
  FILE *fp;
  if ((fp = fopen("timer.flag", "r")) != NULL) {
    timeron = true;
    t_names[t_total] = "total";
    t_names[t_rhsx] = "rhsx";
    t_names[t_rhsy] = "rhsy";
    t_names[t_rhsz] = "rhsz";
    t_names[t_rhs] = "rhs";
    t_names[t_xsolve] = "xsolve";
    t_names[t_ysolve] = "ysolve";
    t_names[t_zsolve] = "zsolve";
    t_names[t_rdis1] = "redist1";
    t_names[t_rdis2] = "redist2";
    t_names[t_add] = "add";
    fclose(fp);
  } else {
    timeron = false;
  }

  printf("\n\n NAS Parallel Benchmarks (NPB3.3-ACC-C) - BT Benchmark\n\n");

  if ((fp = fopen("inputbt.data", "r")) != NULL) {
    int result;
    printf(" Reading from input file inputbt.data\n");
    result = fscanf(fp, "%d", &niter);
    while (fgetc(fp) != '\n');
    result = fscanf(fp, "%lf", &dt);
    while (fgetc(fp) != '\n');
    result = fscanf(fp, "%d%d%d\n", 
        &grid_points[0], &grid_points[1], &grid_points[2]);
    fclose(fp);
  } else {
    printf(" No input file inputbt.data. Using compiled defaults\n");
    niter = NITER_DEFAULT;
    dt    = DT_DEFAULT;
    grid_points[0] = PROBLEM_SIZE;
    grid_points[1] = PROBLEM_SIZE;
    grid_points[2] = PROBLEM_SIZE;
  }

  printf(" Size: %4dx%4dx%4d\n",
      grid_points[0], grid_points[1], grid_points[2]);
  printf(" Iterations: %4d    dt: %10.6f\n", niter, dt);
  printf("\n");
  
  //PROBLEM_SIZE=grid_points[0];

  if ( (grid_points[0] > IMAX) ||
       (grid_points[1] > JMAX) ||
       (grid_points[2] > KMAX) ) {
    printf(" %d, %d, %d\n", grid_points[0], grid_points[1], grid_points[2]);
    printf(" Problem size too big for compiled array sizes\n");
    return 0;
  }
  
//printf("PROBLEM_SIZE: %d, IMAX: %d, JMAX: %d, KMAX: %d, IMAXP: %d, JMAXP: %d\n",
//  		  PROBLEM_SIZE, IMAX, JMAX, KMAX, IMAXP, JMAXP);

    acc_init(acc_device_default);
  set_constants();

  for (i = 1; i <= t_last; i++) {
    timer_clear(i);
  }

#pragma acc data create(forcing,rho_i,u,us,vs,ws,square,qs,rhs) //fjacX,njacX,lhsX,fjacY,njacY,lhsY,fjacZ,njacZ,lhsZ)
{
  initialize();

  exact_rhs();

  //---------------------------------------------------------------------
  // do one time step to touch all code, and reinitialize
  //---------------------------------------------------------------------
  adi();
  initialize();
  
  for (i = 1; i <= t_last; i++) {
    timer_clear(i);
  }
  timer_start(1);

  for (step = 1; step <= niter; step++) {
    if ((step % 20) == 0 || step == 1) {
      printf(" Time step %4d\n", step);
    }

    adi();
  }

  timer_stop(1);
  tmax = timer_read(1);

  #pragma acc update host(u)
  verify(niter, &Class, &verified);

  n3 = 1.0*grid_points[0]*grid_points[1]*grid_points[2];
  navg = (grid_points[0]+grid_points[1]+grid_points[2])/3.0;
  if(tmax != 0.0) {
    mflops = 1.0e-6 * (double)niter *
      (3478.8 * n3 - 17655.7 * (navg*navg) + 28023.7 * navg)
      / tmax;
  } else {
    mflops = 0.0;
  }

}/*end acc data*/
  print_results("BT", Class, grid_points[0], 
                grid_points[1], grid_points[2], niter,
                tmax, mflops, "          floating point", 
                verified, NPBVERSION,COMPILETIME, CS1, CS2, CS3, CS4, CS5, 
                CS6, "(none)");

    acc_shutdown(acc_device_default);
  return 0;
}


########## NEXT FILE ##########
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB CG code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS CG code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

//---------------------------------------------------------------------
// NPB CG OpenACC version      
//---------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include "globals.h"
#include "randdp.h"
#include "timers.h"
#include "print_results.h"
#include <openacc.h>
//---------------------------------------------------------------------
unsigned int  nz =  (NA*(NONZER+1)*(NONZER+1));
unsigned int  naz = (NA*(NONZER+1));
unsigned int  na = NA;
/* common / main_int_mem / */
static int colidx[NZ];
static int rowstr[NA+1];
static int iv[NA];
static int arow[NA];
static int acol[NAZ];

/* common / main_flt_mem / */
static double aelt[NAZ];
static double a[NZ];
static double x[NA+2];
static double z[NA+2];
static double p[NA+2];
static double q[NA+2];
static double r[NA+2];

/* common / partit_size / */
static int naa;
static int nzz;
static int firstrow;
static int lastrow;
static int firstcol;
static int lastcol;

/* common /urando/ */
static double amult;
static double tran;

/* common /timers/ */
static logical timeron;
//---------------------------------------------------------------------


//---------------------------------------------------------------------
static void conj_grad(int colidx[],
                      int rowstr[],
                      double x[],
                      double z[],
                      double a[],
                      double p[],
                      double q[],
                      double r[],
                      double *rnorm);
static void makea(int n,
                  int nz,
                  double a[],
                  int colidx[],
                  int rowstr[],
                  int firstrow,
                  int lastrow,
                  int firstcol,
                  int lastcol,
                  int arow[],
                  int acol[][NONZER+1],
                  double aelt[][NONZER+1],
                  int iv[]);
static void sparse(double a[],
                   int colidx[],
                   int rowstr[],
                   int n,
                   int nz,
                   int nozer,
                   int arow[],
                   int acol[][NONZER+1],
                   double aelt[][NONZER+1],
                   int firstrow,
                   int lastrow,
                   int nzloc[],
                   double rcond,
                   double shift);
static void sprnvc(int n, int nz, int nn1, double v[], int iv[]);
static int icnvrt(double x, int ipwr2);
static void vecset(int n, double v[], int iv[], int *nzv, int i, double val);
static int conj_calls = 0;
static int loop_iter = 0;
//---------------------------------------------------------------------


int main(int argc, char *argv[])
{
  int i, j, k, it;
  int end;

  double zeta;
  double rnorm;
  double norm_temp1, norm_temp2;

  double t, mflops, tmax;
  char Class;
  int verified;
  double zeta_verify_value, epsilon, err;

  char *t_names[T_last];
  acc_init(acc_device_default);

  for (i = 0; i < T_last; i++) {
    timer_clear(i);
  }
  
  FILE *fp;
  if ((fp = fopen("timer.flag", "r")) != NULL) {
    timeron = true;
    t_names[T_init] = "init";
    t_names[T_bench] = "benchmk";
    t_names[T_conj_grad] = "conjgd";
    fclose(fp);
  } else {
    timeron = false;
  }

  timer_start(T_init);

  firstrow = 0;
  lastrow  = NA-1;
  firstcol = 0;
  lastcol  = NA-1;

  if (NA == 1400 && NONZER == 7 && NITER == 15 && SHIFT == 10) {
    Class = 'S';
    zeta_verify_value = 8.5971775078648;
  } else if (NA == 7000 && NONZER == 8 && NITER == 15 && SHIFT == 12) {
    Class = 'W';
    zeta_verify_value = 10.362595087124;
  } else if (NA == 14000 && NONZER == 11 && NITER == 15 && SHIFT == 20) {
    Class = 'A';
    zeta_verify_value = 17.130235054029;
  } else if (NA == 75000 && NONZER == 13 && NITER == 75 && SHIFT == 60) {
    Class = 'B';
    zeta_verify_value = 22.712745482631;
  } else if (NA == 150000 && NONZER == 15 && NITER == 75 && SHIFT == 110) {
    Class = 'C';
    zeta_verify_value = 28.973605592845;
  } else if (NA == 1500000 && NONZER == 21 && NITER == 100 && SHIFT == 500) {
    Class = 'D';
    zeta_verify_value = 52.514532105794;
  } else if (NA == 9000000 && NONZER == 26 && NITER == 100 && SHIFT == 1500) {
    Class = 'E';
    zeta_verify_value = 77.522164599383;
  } else {
    Class = 'U';
  }

  printf("\n\n NAS Parallel Benchmarks (NPB3.3-ACC-C) - CG Benchmark\n\n");
  printf(" Size: %11d\n", NA);
  printf(" Iterations: %5d\n", NITER);
  printf("\n");

  naa = NA;
  nzz = NZ;

  //---------------------------------------------------------------------
  // Inialize random number generator
  //---------------------------------------------------------------------
  tran    = 314159265.0;
  amult   = 1220703125.0;
  zeta    = randlc(&tran, amult);

  //---------------------------------------------------------------------
  //  
  //---------------------------------------------------------------------
  makea(naa, nzz, a, colidx, rowstr, 
        firstrow, lastrow, firstcol, lastcol, 
        arow, 
        (int (*)[NONZER+1])(void*)acol, 
        (double (*)[NONZER+1])(void*)aelt,
        iv);

  //---------------------------------------------------------------------
  // Note: as a result of the above call to makea:
  //      values of j used in indexing rowstr go from 0 --> lastrow-firstrow
  //      values of colidx which are col indexes go from firstcol --> lastcol
  //      So:
  //      Shift the col index vals from actual (firstcol --> lastcol ) 
  //      to local, i.e., (0 --> lastcol-firstcol)
  //---------------------------------------------------------------------
  for (j = 0; j < lastrow - firstrow + 1; j++) {
    for (k = rowstr[j]; k < rowstr[j+1]; k++) {
      colidx[k] = colidx[k] - firstcol;
    }
  }

#pragma acc data copyin(colidx[0:nz],a[0:nz], \
						rowstr[0:na+1]) \
				 create(x[0:na+2],z[0:na+2], \
						p[0:na+2],q[0:na+2], \
						r[0:na+2])
{
  //---------------------------------------------------------------------
  // set starting vector to (1, 1, .... 1)
  //---------------------------------------------------------------------
  int na_gangs = NA+1;
  #pragma acc kernels loop gang((na_gangs+127)/128) vector(128) 
  for (i = 0; i < NA+1; i++) {
    x[i] = 1.0;
  }

  end = lastcol - firstcol + 1;
  #pragma acc kernels loop gang((end+127)/128) vector(128) 
  for (j = 0; j < end; j++) {
    q[j] = 0.0;
    z[j] = 0.0;
    r[j] = 0.0;
    p[j] = 0.0;
  }

  zeta = 0.0;

  //---------------------------------------------------------------------
  //---->
  // Do one iteration untimed to init all code and data page tables
  //---->                    (then reinit, start timing, to niter its)
  //---------------------------------------------------------------------
  for (it = 1; it <= 1; it++) {
    //---------------------------------------------------------------------
    // The call to the conjugate gradient routine:
    //---------------------------------------------------------------------
    conj_grad(colidx, rowstr, x, z, a, p, q, r, &rnorm);

    //---------------------------------------------------------------------
    // zeta = shift + 1/(x.z)
    // So, first: (x.z)
    // Also, find norm of z
    // So, first: (z.z)
    //---------------------------------------------------------------------
    norm_temp1 = 0.0;
    norm_temp2 = 0.0;
	#pragma acc parallel loop num_gangs((end+127)/128) num_workers(4) \
                         vector_length(32) reduction(+:norm_temp2)
    for (j = 0; j < end; j++) {
      //norm_temp1 = norm_temp1 + x[j] * z[j];
      norm_temp2 = norm_temp2 + z[j] * z[j];
    }

    norm_temp2 = 1.0 / sqrt(norm_temp2);

    //---------------------------------------------------------------------
    // Normalize z to obtain x
    //---------------------------------------------------------------------
	#pragma acc kernels loop gang((end+127)/128) vector(128) 
    for (j = 0; j < end; j++) {     
      x[j] = norm_temp2 * z[j];
    }
  } // end of do one iteration untimed


  //---------------------------------------------------------------------
  // set starting vector to (1, 1, .... 1)
  //---------------------------------------------------------------------
  na_gangs = NA+1;
  #pragma acc kernels loop gang((na_gangs+127)/128) vector(128)
  for (i = 0; i < NA+1; i++) {
    x[i] = 1.0;
  }

  zeta = 0.0;

  timer_stop(T_init);

  printf(" Initialization time = %15.3f seconds\n", timer_read(T_init));

  timer_start(T_bench);

  //---------------------------------------------------------------------
  //---->
  // Main Iteration for inverse power method
  //---->
  //---------------------------------------------------------------------
  for (it = 1; it <= NITER; it++) {
    //---------------------------------------------------------------------
    // The call to the conjugate gradient routine:
    //---------------------------------------------------------------------
    conj_grad(colidx, rowstr, x, z, a, p, q, r, &rnorm);

    //---------------------------------------------------------------------
    // zeta = shift + 1/(x.z)
    // So, first: (x.z)
    // Also, find norm of z
    // So, first: (z.z)
    //---------------------------------------------------------------------
    norm_temp1 = 0.0;
    norm_temp2 = 0.0;
	#pragma acc parallel loop gang worker vector num_gangs((end+127)/128) num_workers(4) \
                              vector_length(32) reduction(+:norm_temp1,norm_temp2)
    for (j = 0; j < end; j++) {
      norm_temp1 = norm_temp1 + x[j]*z[j];
      norm_temp2 = norm_temp2 + z[j]*z[j];
    }

    norm_temp2 = 1.0 / sqrt(norm_temp2);

    zeta = SHIFT + 1.0 / norm_temp1;
    if (it == 1) 
      printf("\n   iteration           ||r||                 zeta\n");
    printf("    %5d       %20.14E%20.13f\n", it, rnorm, zeta);

    //---------------------------------------------------------------------
    // Normalize z to obtain x
    //---------------------------------------------------------------------
	#pragma acc kernels loop gang((end+127)/128) vector(128)
    for (j = 0; j < end; j++) {
      x[j] = norm_temp2 * z[j];
    }
  } // end of main iter inv pow meth

  timer_stop(T_bench);
}/*end acc data*/
  //---------------------------------------------------------------------
  // End of timed section
  //---------------------------------------------------------------------

  t = timer_read(T_bench);

  printf(" Benchmark completed\n");

  epsilon = 1.0e-10;
  if (Class != 'U') {
    err = fabs(zeta - zeta_verify_value) / zeta_verify_value;
    if (err <= epsilon) {
      verified = true;
      printf(" VERIFICATION SUCCESSFUL\n");
      printf(" Zeta is    %20.13E\n", zeta);
      printf(" Error is   %20.13E\n", err);
    } else {
      verified = false;
      printf(" VERIFICATION FAILED\n");
      printf(" Zeta                %20.13E\n", zeta);
      printf(" The correct zeta is %20.13E\n", zeta_verify_value);
    }
  } else {
    verified = false;
    printf(" Problem size unknown\n");
    printf(" NO VERIFICATION PERFORMED\n");
  }

  if (t != 0.0) {
    mflops = (double)(2*NITER*NA)
                   * (3.0+(double)(NONZER*(NONZER+1))
                     + 25.0*(5.0+(double)(NONZER*(NONZER+1)))
                     + 3.0) / t / 1000000.0;
  } else {
    mflops = 0.0;
  }

  print_results("CG", Class, NA, 0, 0,
                NITER, t,
                mflops, "          floating point", 
                verified, NPBVERSION, COMPILETIME,
                CS1, CS2, CS3, CS4, CS5, CS6, CS7);

  //---------------------------------------------------------------------
  // More timers
  //---------------------------------------------------------------------
  if (timeron) {
    tmax = timer_read(T_bench);
    if (tmax == 0.0) tmax = 1.0;
    printf("  SECTION   Time (secs)\n");
    for (i = 0; i < T_last; i++) {
      t = timer_read(i);
      if (i == T_init) {
        printf("  %8s:%9.3f\n", t_names[i], t);
      } else {
        printf("  %8s:%9.3f  (%6.2f%%)\n", t_names[i], t, t*100.0/tmax);
        if (i == T_conj_grad) {
          t = tmax - t;
          printf("    --> %8s:%9.3f  (%6.2f%%)\n", "rest", t, t*100.0/tmax);
        }
      }
    }
  }
  acc_shutdown(acc_device_default);
  printf("conj calls=%d, loop iter = %d. \n", conj_calls, loop_iter);
  return 0;
}


//---------------------------------------------------------------------
// Floaging point arrays here are named as in NPB1 spec discussion of 
// CG algorithm
//---------------------------------------------------------------------
static void conj_grad(int colidx[],
                      int rowstr[],
                      double x[],
                      double z[],
                      double a[],
                      double p[],
                      double q[],
                      double r[],
                      double *rnorm)
{
  int j, k,tmp1,tmp2,tmp3;
  int end;
  int cgit, cgitmax = 25;
  double d, sum, rho, rho0, alpha, beta;
  double sum_array[NA+2];
  conj_calls ++;
  rho = 0.0;
  unsigned int num_gangs = 0;
 #pragma acc data present(colidx[0:nz], \
						 rowstr[0:na+1], \
						 x[0:na+2],z[0:na+2], \
						 a[0:nz],p[0:na+2], \
						 q[0:na+2],r[0:na+2])
{
  //---------------------------------------------------------------------
  // Initialize the CG algorithm:
  //---------------------------------------------------------------------
  #pragma acc kernels loop gang((naa+127)/128) vector(128) independent
  for (j = 0; j < naa; j++) {
    q[j] = 0.0;
    z[j] = 0.0;
    r[j] = x[j];
    p[j] = r[j];
  }

  //---------------------------------------------------------------------
  // rho = r.r
  // Now, obtain the norm of r: First, sum squares of r elements locally...
  //---------------------------------------------------------------------
  //num_gangs = (lastcol - firstcol + 1)/128;
  #pragma acc parallel loop gang worker vector num_gangs((lastcol-firstcol+1+127)/128) \
                            num_workers(4) vector_length(32) reduction(+:rho) 
  for (j = 0; j < lastcol - firstcol + 1; j++) {
    rho = rho + r[j]*r[j];
  }
  
  //---------------------------------------------------------------------
  //---->
  // The conj grad iteration loop
  //---->
  //---------------------------------------------------------------------
//#pragma acc kernels loop private(cgit,j,k)
  for (cgit = 1; cgit <= cgitmax; cgit++) {
  //#pragma acc update host(p[0:NA+2])
    //---------------------------------------------------------------------
    // q = A.p
    // The partition submatrix-vector multiply: use workspace w
    //---------------------------------------------------------------------
    //
    // NOTE: this version of the multiply is actually (slightly: maybe %5) 
    //       faster on the sp2 on 16 nodes than is the unrolled-by-2 version 
    //       below.   On the Cray t3d, the reverse is true, i.e., the 
    //       unrolled-by-two version is some 10% faster.  
    //       The unrolled-by-8 version below is significantly faster
    //       on the Cray t3d - overall speed of code is 1.5 times faster.
	/*
    for (j = 0; j < lastrow - firstrow + 1; j++) {
        sum_array[j]=0.0; 
    }     
    for (j = 0; j < lastrow - firstrow + 1; j++) {
      tmp1=rowstr[j];
      tmp2=rowstr[j+1];
      for (k = tmp1; k < tmp2; k++) {
        tmp3=colidx[k];
        sum_array[j] = sum_array[j] + a[k]*p[tmp3];
      }
      q[j] = sum_array[j];
    }
	*/
    loop_iter ++;
    //num_gangs = (lastrow - firstrow + 1)/128;
    end = lastrow - firstrow + 1;

	#pragma acc parallel num_gangs(end) num_workers(4) vector_length(32)
	{
		#pragma acc loop gang 	
		for (j = 0; j < end; j++) {
		  tmp1 = rowstr[j];
		  tmp2 = rowstr[j+1];
		  sum = 0.0;
		  #pragma acc loop worker vector reduction(+:sum)
		  for (k = tmp1; k < tmp2; k++) {
			tmp3 = colidx[k];
		    sum = sum + a[k]*p[tmp3];
		  }
		  q[j] = sum;
		}
    }
    //---------------------------------------------------------------------
    // Obtain p.q
    //---------------------------------------------------------------------
    d = 0.0;
	end = lastcol - firstcol + 1;
	#pragma acc parallel num_gangs((end+127)/128) num_workers(4) vector_length(32)
	{
		#pragma acc loop gang worker vector reduction(+:d) 
		for (j = 0; j < end; j++) {
		  d = d + p[j]*q[j];
		}
    }

    //---------------------------------------------------------------------
    // Obtain alpha = rho / (p.q)
    //---------------------------------------------------------------------
    alpha = rho / d;

    //---------------------------------------------------------------------
    // Save a temporary of rho
    //---------------------------------------------------------------------
    rho0 = rho;

    //---------------------------------------------------------------------
    // Obtain z = z + alpha*p
    // and    r = r - alpha*q
    //---------------------------------------------------------------------
    rho = 0.0;
	#pragma acc kernels loop gang((end+1023)/1024) vector(1024) independent
    for (j = 0; j < end; j++) {
      z[j] = z[j] + alpha*p[j];
      r[j] = r[j] - alpha*q[j];
    }
              
    //---------------------------------------------------------------------
    // rho = r.r
    // Now, obtain the norm of r: First, sum squares of r elements locally...
    //---------------------------------------------------------------------
	#pragma acc parallel num_gangs((end+127)/128) num_workers(4) vector_length(32)
	{
		#pragma acc loop gang worker vector reduction(+:rho)
		for (j = 0; j < end; j++) 
		{
		  rho = rho + r[j]*r[j];
		}
    }

    //---------------------------------------------------------------------
    // Obtain beta:
    //---------------------------------------------------------------------
    beta = rho / rho0;

    //---------------------------------------------------------------------
    // p = r + beta*p
    //---------------------------------------------------------------------
	#pragma acc kernels loop gang((end+127)/128) vector(128) independent
    for (j = 0; j < end; j++) {
      p[j] = r[j] + beta*p[j];
    } 
  } // end of do cgit=1,cgitmax

  //---------------------------------------------------------------------
  // Compute residual norm explicitly:  ||r|| = ||x - A.z||
  // First, form A.z
  // The partition submatrix-vector multiply
  //---------------------------------------------------------------------

  end = lastrow - firstrow + 1;
  //num_gangs = end/128;
  #pragma acc parallel loop gang num_gangs(end) \
                       num_workers(4) vector_length(32)
  for (j = 0; j < end; j++) {
    tmp1=rowstr[j];
    tmp2=rowstr[j+1];
    d = 0.0;
	#pragma acc loop worker vector reduction(+:d)
    for (k = tmp1; k < tmp2; k++) {
        tmp3=colidx[k];
        d = d + a[k]*z[tmp3];
    }
    r[j] = d;
  }
   
  //---------------------------------------------------------------------
  // At this point, r contains A.z 
  //---------------------------------------------------------------------
  sum = 0.0;
  //num_gangs = (lastcol-firstcol+1)/128;
  #pragma acc parallel loop gang worker vector \
                       num_gangs((lastcol-firstcol+1+127)/128) \
                       num_workers(4) vector_length(32) \
                       reduction(+:sum)
  for (j = 0; j < lastcol-firstcol+1; j++) {
    d   = x[j] - r[j];
    sum = sum + d*d;
  }

}/*end acc data*/
  *rnorm = sqrt(sum);
}


//---------------------------------------------------------------------
// generate the test problem for benchmark 6
// makea generates a sparse matrix with a
// prescribed sparsity distribution
//
// parameter    type        usage
//
// input
//
// n            i           number of cols/rows of matrix
// nz           i           nonzeros as declared array size
// rcond        r*8         condition number
// shift        r*8         main diagonal shift
//
// output
//
// a            r*8         array for nonzeros
// colidx       i           col indices
// rowstr       i           row pointers
//
// workspace
//
// iv, arow, acol i
// aelt           r*8
//---------------------------------------------------------------------
static void makea(int n,
                  int nz,
                  double a[],
                  int colidx[],
                  int rowstr[],
                  int firstrow,
                  int lastrow,
                  int firstcol,
                  int lastcol,
                  int arow[],
                  int acol[][NONZER+1],
                  double aelt[][NONZER+1],
                  int iv[])
{
  int iouter, ivelt, nzv, nn1;
  int ivc[NONZER+1];
  double vc[NONZER+1];

  //---------------------------------------------------------------------
  // nonzer is approximately  (int(sqrt(nnza /n)));
  //---------------------------------------------------------------------

  //---------------------------------------------------------------------
  // nn1 is the smallest power of two not less than n
  //---------------------------------------------------------------------
  nn1 = 1;
  do {
    nn1 = 2 * nn1;
  } while (nn1 < n);

  //---------------------------------------------------------------------
  // Generate nonzero positions and save for the use in sparse.
  //---------------------------------------------------------------------
  for (iouter = 0; iouter < n; iouter++) {
    nzv = NONZER;
    sprnvc(n, nzv, nn1, vc, ivc);
    vecset(n, vc, ivc, &nzv, iouter+1, 0.5);
    arow[iouter] = nzv;
    
    for (ivelt = 0; ivelt < nzv; ivelt++) {
      acol[iouter][ivelt] = ivc[ivelt] - 1;
      aelt[iouter][ivelt] = vc[ivelt];
    }
  }

  //---------------------------------------------------------------------
  // ... make the sparse matrix from list of elements with duplicates
  //     (iv is used as  workspace)
  //---------------------------------------------------------------------
  sparse(a, colidx, rowstr, n, nz, NONZER, arow, acol, 
         aelt, firstrow, lastrow,
         iv, RCOND, SHIFT);
}


//---------------------------------------------------------------------
// rows range from firstrow to lastrow
// the rowstr pointers are defined for nrows = lastrow-firstrow+1 values
//---------------------------------------------------------------------
static void sparse(double a[],
                   int colidx[],
                   int rowstr[],
                   int n,
                   int nz,
                   int nozer,
                   int arow[],
                   int acol[][NONZER+1],
                   double aelt[][NONZER+1],
                   int firstrow,
                   int lastrow,
                   int nzloc[],
                   double rcond,
                   double shift)
{
  int nrows;

  //---------------------------------------------------
  // generate a sparse matrix from a list of
  // [col, row, element] tri
  //---------------------------------------------------
  int i, j, j1, j2, nza, k, kk, nzrow, jcol;
  double size, scale, ratio, va;
  logical cont40;

  //---------------------------------------------------------------------
  // how many rows of result
  //---------------------------------------------------------------------
  nrows = lastrow - firstrow + 1;

  //---------------------------------------------------------------------
  // ...count the number of triples in each row
  //---------------------------------------------------------------------
  for (j = 0; j < nrows+1; j++) {
    rowstr[j] = 0;
  }

  for (i = 0; i < n; i++) {
    for (nza = 0; nza < arow[i]; nza++) {
      j = acol[i][nza] + 1;
      rowstr[j] = rowstr[j] + arow[i];
    }
  }

  rowstr[0] = 0;
  for (j = 1; j < nrows+1; j++) {
    rowstr[j] = rowstr[j] + rowstr[j-1];
  }
  nza = rowstr[nrows] - 1;

  //---------------------------------------------------------------------
  // ... rowstr(j) now is the location of the first nonzero
  //     of row j of a
  //---------------------------------------------------------------------
  if (nza > nz) {
    printf("Space for matrix elements exceeded in sparse\n");
    printf("nza, nzmax = %d, %d\n", nza, nz);
    exit(EXIT_FAILURE);
  }

  //---------------------------------------------------------------------
  // ... preload data pages
  //---------------------------------------------------------------------
  for (j = 0; j < nrows; j++) {
    for (k = rowstr[j]; k < rowstr[j+1]; k++) {
      a[k] = 0.0;
      colidx[k] = -1;
    }
    nzloc[j] = 0;
  }

  //---------------------------------------------------------------------
  // ... generate actual values by summing duplicates
  //---------------------------------------------------------------------
  size = 1.0;
  ratio = pow(rcond, (1.0 / (double)(n)));

  for (i = 0; i < n; i++) {
    for (nza = 0; nza < arow[i]; nza++) {
      j = acol[i][nza];

      scale = size * aelt[i][nza];
      for (nzrow = 0; nzrow < arow[i]; nzrow++) {
        jcol = acol[i][nzrow];
        va = aelt[i][nzrow] * scale;

        //--------------------------------------------------------------------
        // ... add the identity * rcond to the generated matrix to bound
        //     the smallest eigenvalue from below by rcond
        //--------------------------------------------------------------------
        if (jcol == j && j == i) {
          va = va + rcond - shift;
        }

        cont40 = false;
        for (k = rowstr[j]; k < rowstr[j+1]; k++) {
          if (colidx[k] > jcol) {
            //----------------------------------------------------------------
            // ... insert colidx here orderly
            //----------------------------------------------------------------
            for (kk = rowstr[j+1]-2; kk >= k; kk--) {
              if (colidx[kk] > -1) {
                a[kk+1]  = a[kk];
                colidx[kk+1] = colidx[kk];
              }
            }
            colidx[k] = jcol;
            a[k]  = 0.0;
            cont40 = true;
            break;
          } else if (colidx[k] == -1) {
            colidx[k] = jcol;
            cont40 = true;
            break;
          } else if (colidx[k] == jcol) {
            //--------------------------------------------------------------
            // ... mark the duplicated entry
            //--------------------------------------------------------------
            nzloc[j] = nzloc[j] + 1;
            cont40 = true;
            break;
          }
        }
        if (cont40 == false) {
          printf("internal error in sparse: i=%d\n", i);
          exit(EXIT_FAILURE);
        }
        a[k] = a[k] + va;
      }
    }
    size = size * ratio;
  }

  //---------------------------------------------------------------------
  // ... remove empty entries and generate final results
  //---------------------------------------------------------------------
  for (j = 1; j < nrows; j++) {
    nzloc[j] = nzloc[j] + nzloc[j-1];
  }

  for (j = 0; j < nrows; j++) {
    if (j > 0) {
      j1 = rowstr[j] - nzloc[j-1];
    } else {
      j1 = 0;
    }
    j2 = rowstr[j+1] - nzloc[j];
    nza = rowstr[j];
    for (k = j1; k < j2; k++) {
      a[k] = a[nza];
      colidx[k] = colidx[nza];
      nza = nza + 1;
    }
  }
  for (j = 1; j < nrows+1; j++) {
    rowstr[j] = rowstr[j] - nzloc[j-1];
  }
  nza = rowstr[nrows] - 1;
}


//---------------------------------------------------------------------
// generate a sparse n-vector (v, iv)
// having nzv nonzeros
//
// mark(i) is set to 1 if position i is nonzero.
// mark is all zero on entry and is reset to all zero before exit
// this corrects a performance bug found by John G. Lewis, caused by
// reinitialization of mark on every one of the n calls to sprnvc
//---------------------------------------------------------------------
static void sprnvc(int n, int nz, int nn1, double v[], int iv[])
{
  int nzv, ii, i;
  double vecelt, vecloc;

  nzv = 0;

  while (nzv < nz) {
    vecelt = randlc(&tran, amult);

    //---------------------------------------------------------------------
    // generate an integer between 1 and n in a portable manner
    //---------------------------------------------------------------------
    vecloc = randlc(&tran, amult);
    i = icnvrt(vecloc, nn1) + 1;
    if (i > n) continue;

    //---------------------------------------------------------------------
    // was this integer generated already?
    //---------------------------------------------------------------------
    logical was_gen = false;
    for (ii = 0; ii < nzv; ii++) {
      if (iv[ii] == i) {
        was_gen = true;
        break;
      }
    }
    if (was_gen) continue;
    v[nzv] = vecelt;
    iv[nzv] = i;
    nzv = nzv + 1;
  }
}


//---------------------------------------------------------------------
// scale a double precision number x in (0,1) by a power of 2 and chop it
//---------------------------------------------------------------------
static int icnvrt(double x, int ipwr2)
{
  return (int)(ipwr2 * x);
}


//---------------------------------------------------------------------
// set ith element of sparse vector (v, iv) with
// nzv nonzeros to val
//---------------------------------------------------------------------
static void vecset(int n, double v[], int iv[], int *nzv, int i, double val)
{
  int k;
  logical set;

  set = false;
  for (k = 0; k < *nzv; k++) {
    if (iv[k] == i) {
      v[k] = val;
      set  = true;
    }
  }
  if (set == false) {
    v[*nzv]  = val;
    iv[*nzv] = i;
    *nzv     = *nzv + 1;
  }
}


########## NEXT FILE ##########
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB EP code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS EP code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

//--------------------------------------------------------------------
//      program EMBAR
//--------------------------------------------------------------------
//  This is the OpenACC version of the APP Benchmark 1,
//  the "embarassingly parallel" benchmark.
//
//
//  M is the Log_2 of the number of complex pairs of uniform (0, 1) random
//  numbers.  MK is the Log_2 of the size of each batch of uniform random
//  numbers.  MK can be set for convenience on a given system, since it does
//  not affect the results.
//--------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include "type.h"
#include "npbparams.h"
#include "timers.h"
#include "print_results.h"
#include <openacc.h>

#define MAX(X,Y)  (((X) > (Y)) ? (X) : (Y))

int MK;
int MM;
int NN;
double EPSILON;
double A;
double S;
int NK;
int NQ;

int BLKSIZE;

double r23;
double r46;
double t23;
double t46;

inline double randlc_ep( double *x, double a )
{
  //--------------------------------------------------------------------
  //
  //  This routine returns a uniform pseudorandom double precision number in the
  //  range (0, 1) by using the linear congruential generator
  //
  //  x_{k+1} = a x_k  (mod 2^46)
  //
  //  where 0 < x_k < 2^46 and 0 < a < 2^46.  This scheme generates 2^44 numbers
  //  before repeating.  The argument A is the same as 'a' in the above formula,
  //  and X is the same as x_0.  A and X must be odd double precision integers
  //  in the range (1, 2^46).  The returned value randlc_ep is normalized to be
  //  between 0 and 1, i.e. randlc_ep = 2^(-46) * x_1.  X is updated to contain
  //  the new seed x_1, so that subsequent calls to randlc_ep using the same
  //  arguments will generate a continuous sequence.
  //
  //  This routine should produce the same results on any computer with at least
  //  48 mantissa bits in double precision floating point data.  On 64 bit
  //  systems, double precision should be disabled.
  //
  //  David H. Bailey     October 26, 1990
  //
  //--------------------------------------------------------------------

  // r23 = pow(0.5, 23.0);
  ////  pow(0.5, 23.0) = 1.1920928955078125e-07
  // r46 = r23 * r23;
  // t23 = pow(2.0, 23.0);
  ////  pow(2.0, 23.0) = 8.388608e+06
  // t46 = t23 * t23;
/*
  const double r23 = 1.1920928955078125e-07;
  const double r46 = r23 * r23;
  const double t23 = 8.388608e+06;
  const double t46 = t23 * t23;
*/
  double t1, t2, t3, t4, a1, a2, x1, x2, z;
  double r;

  //--------------------------------------------------------------------
  //  Break A into two parts such that A = 2^23 * A1 + A2.
  //--------------------------------------------------------------------
  t1 = r23 * a;
  a1 = (int) t1;
  a2 = a - t23 * a1;

  //--------------------------------------------------------------------
  //  Break X into two parts such that X = 2^23 * X1 + X2, compute
  //  Z = A1 * X2 + A2 * X1  (mod 2^23), and then
  //  X = 2^23 * Z + A2 * X2  (mod 2^46).
  //--------------------------------------------------------------------
  t1 = r23 * (*x);
  x1 = (int) t1;
  x2 = *x - t23 * x1;
  t1 = a1 * x2 + a2 * x1;
  t2 = (int) (r23 * t1);
  z = t1 - t23 * t2;
  t3 = t23 * z + a2 * x2;
  t4 = (int) (r46 * t3);
  *x = t3 - t46 * t4;
  r = r46 * (*x);

  return r;
}

int main() 
{
  double Mops, t1, t2, t3, t4, x1, x2;
  double sx, sy, tm, an, tt, gc;
  double sx_verify_value, sy_verify_value, sx_err, sy_err;
  int    np;
  int    i, ik, kk, l, k, nit;
  int    k_offset, j;
  int verified, timers_enabled;
  double q0, q1, q2, q3, q4, q5, q6, q7, q8, q9;
    
    MK =  16;
    MM =  (M - MK);
    NN =       (1 << MM);
    EPSILON =  1.0e-8;
    A =        1220703125.0;
    S =        271828183.0;
    NK = 1 << MK;
    NQ = 10;

  //  BLKSIZE = 1792;
    BLKSIZE = 2048;

    r23 = 1.1920928955078125e-07;
    r46 = r23 * r23;
    t23 = 8.388608e+06;
    t46 = t23 * t23;

  double x[2*(1<<16)];
  double q[10]; 
  double *xx, *qq;
  
  /*variables for inlining vranlc()*/
  double in_t1, in_t2, in_t3, in_t4;
  double in_a1, in_a2, in_x1, in_x2, in_z;

  double tmp_sx, tmp_sy;
  double dum[3] = {1.0, 1.0, 1.0};
  char   size[16];
    

  int blksize = BLKSIZE;
  int blk, koff, numblks;

  FILE *fp;

  acc_init(acc_device_default);

  if ((fp = fopen("timer.flag", "r")) == NULL) {
    timers_enabled = 0;
  } else {
    timers_enabled = 1;
    fclose(fp);
  }

  if (NN < blksize) {
     blksize = NN;
  }
  numblks = ceil( (double)NN / (double) blksize);

  xx = (double*)malloc(blksize*2*NK*sizeof(double));
  qq = (double*)malloc(blksize*NQ*sizeof(double));

  //--------------------------------------------------------------------
  //  Because the size of the problem is too large to store in a 32-bit
  //  integer for some classes, we put it into a string (for printing).
  //  Have to strip off the decimal point put in there by the floating
  //  point print statement (internal file)
  //--------------------------------------------------------------------

  sprintf(size, "%15.0lf", pow(2.0, M+1));
  j = 14;
  if (size[j] == '.') j--;
  size[j+1] = '\0';
  printf("\n\n NAS Parallel Benchmarks (NPB3.3-ACC-C) - EP Benchmark\n");
  printf("\n Number of random numbers generated: %15s\n", size);

  verified = 0;

  //--------------------------------------------------------------------
  //  Compute the number of "batches" of random number pairs generated 
  //  per processor. Adjust if the number of processors does not evenly 
  //  divide the total number
  //--------------------------------------------------------------------

  np = NN; 
printf("NK=%d NN=%d NQ=%d BLKS=%d NBLKS=%d\n",NK,NN,NQ,blksize,numblks);
  //--------------------------------------------------------------------
  //  Call the random number generator functions and initialize
  //  the x-array to reduce the effects of paging on the timings.
  //  Also, call all mathematical functions that are used. Make
  //  sure these initializations cannot be eliminated as dead code.
  //--------------------------------------------------------------------
#pragma acc data create(xx[0:blksize*2*NK],qq[0:blksize*NQ]) copyout(q[0:NQ])
{
  vranlc(0, &dum[0], dum[1], &dum[2]);
  dum[0] = randlc_ep(&dum[1], dum[2]);

#pragma acc parallel num_gangs((NQ+127)/128) vector_length(128) present(q[0:NQ])
{
  #pragma acc loop gang vector
  for (i = 0; i < NQ; i++) {
    q[i] = 0.0;
  }
}
  Mops = log(sqrt(fabs(MAX(1.0, 1.0))));   

  timer_clear(0);
  timer_clear(1);
  timer_clear(2);
  timer_start(0);

  /*this function actullay does nothing, so comment it*/
  //vranlc(0, &t1, A, x);

  //#pragma acc update device(x[0:2*NK])
  //--------------------------------------------------------------------
  //  Compute AN = A ^ (2 * NK) (mod 2^46).
  //--------------------------------------------------------------------

  t1 = A;

  for (i = 0; i < MK + 1; i++) {
    t2 = randlc_ep(&t1, t1);
  }

  an = t1;
  tt = S;
  gc = 0.0;
  sx = 0.0;
  sy = 0.0;
  k_offset = -1;

for (blk=0; blk < numblks; ++blk) {

 koff = blk*blksize;

 if (koff + blksize > np) {
     blksize = np - (blk*blksize);
 }
 
#pragma acc parallel num_gangs(blksize) vector_length(128) present(qq[0:blksize*NQ])
{
 #pragma acc loop gang
 for(k=0; k<blksize; k++)
  {
    #pragma acc loop vector
  	for(i=0; i<NQ; i++)
		qq[k*NQ + i] = 0.0;
  }
}

/*
#pragma acc parallel num_gangs(blksize) vector_length(128) present(xx[0:blksize*2*NK])
{
 #pragma acc loop gang
 for(k=0; k<blksize; k++)
  {
	#pragma acc loop vector
	for(i=0; i<2*NK; i++)
		xx[k*2*NK + i] = -1.0e99;
  }
 }
*/
  //--------------------------------------------------------------------
  //  Each instance of this loop may be performed independently. We compute
  //  the k offsets separately to take into account the fact that some nodes
  //  have more numbers to generate than others
  //--------------------------------------------------------------------


#pragma acc parallel num_gangs((blksize+255)/256) num_workers(1) vector_length(256) \
                     present(xx[0:blksize*2*NK],qq[0:blksize*NQ]) 
{ 
  #pragma acc loop gang worker vector reduction(+:sx,sy)
  for (k = 1; k <= blksize; k++) {
    kk = k_offset + k + koff; 
    t1 = S;
    t2 = an;

    // Find starting seed t1 for this kk.

    for (i = 1; i <= 100; i++) {
      ik = kk / 2;
      if ((2 * ik) != kk)
      {
        in_t1 = r23 * t2;
        in_a1 = (int)in_t1;
        in_a2 = t2 - t23 * in_a1;
        
        in_t1 = r23 * t1;
        in_x1 = (int)in_t1;
        in_x2 = t1 - t23 * in_x1;
        in_t1 = in_a1 * in_x2 + in_a2 * in_x1;
        in_t2 = (int)(r23 * in_t1);
        in_z = in_t1 - t23 * in_t2;
        in_t3 = t23 * in_z + in_a2 * in_x2;
        in_t4 = (int)(r46 * in_t3);
        t1 = in_t3 - t46 * in_t4;
        t3 = r46 * t1;
      }
      if (ik == 0) break;
        in_t1 = r23 * t2;
        in_a1 = (int)in_t1;
        in_a2 = t2 - t23 * in_a1;
        
        in_t1 = r23 * t2;
        in_x1 = (int)in_t1;
        in_x2 = t2 - t23 * in_x1;
        in_t1 = in_a1 * in_x2 + in_a2 * in_x1;
        in_t2 = (int)(r23 * in_t1);
        in_z = in_t1 - t23 * in_t2;
        in_t3 = t23 * in_z + in_a2 * in_x2;
        in_t4 = (int)(r46 * in_t3);
        t2 = in_t3 - t46 * in_t4;
        t3 = r46 * t2;
      kk = ik;
    }

    //--------------------------------------------------------------------
    //  Compute uniform pseudorandom numbers.
    //--------------------------------------------------------------------
    //vranlc(2 * NK, &t1, A, x);
	/*inline vranlc function*/
    in_t1 = r23 * A;
    in_a1 = (int)in_t1;
    in_a2 = A - t23 * in_a1;

    for(i=0; i<2*NK; i++)
    {
		in_t1 = r23 * t1;
		in_x1 = (int)in_t1;
		in_x2 = t1 - t23 * in_x1;
		in_t1 = in_a1 * in_x2 + in_a2 * in_x1;
		in_t2 = (int)(r23 * in_t1);
		in_z = in_t1 - t23 * in_t2;
		in_t3 = t23*in_z + in_a2 *in_x2;
		in_t4 = (int)(r46 * in_t3);
		t1 = in_t3 - t46 * in_t4;
        xx[i*blksize + (k-1)] = r46 * t1;
    }

    //--------------------------------------------------------------------
    //  Compute Gaussian deviates by acceptance-rejection method and 
    //  tally counts in concentri//square annuli.  This loop is not 
    //  vectorizable. 
    //--------------------------------------------------------------------
    //if (timers_enabled) timer_start(1);

	tmp_sx = 0.0;
	tmp_sy = 0.0;

    for (i = 0; i < NK; i++) {
      x1 = 2.0 * xx[2*i*blksize + (k-1)] - 1.0;
      x2 = 2.0 * xx[(2*i+1)*blksize + (k-1)] - 1.0;
      t1 = x1 * x1 + x2 * x2;
      if (t1 <= 1.0) {
        t2   = sqrt(-2.0 * log(t1) / t1);
        t3   = (x1 * t2); 
        t4   = (x2 * t2); 
        l    = MAX(fabs(t3), fabs(t4));
        qq[l*blksize + (k-1)] += 1.0;
        tmp_sx   = tmp_sx + t3;  
        tmp_sy   = tmp_sy + t4;  
      }
    }

    sx += tmp_sx;
    sy += tmp_sy;

  }
}/*end acc parallel*/

  //  printf("sx=%f,sy=%f\n", sx, sy);
  #pragma acc parallel num_gangs(NQ) num_workers(4) vector_length(32) \
                       present(q[0:NQ],qq[0:blksize*NQ])
  {
	#pragma acc loop gang reduction(+:gc) 
	for(i=0; i<NQ; i++)
	{
		double sum_qi = 0.0;
		#pragma acc loop worker vector reduction(+:sum_qi)
		for(k=0; k<blksize; k++)
			sum_qi = sum_qi + qq[i*blksize + k];
		/*sum of each column of qq/q[i] */
		q[i] += sum_qi;
		/*final sum of q*/
		gc += sum_qi;
	}
   }
 }
 
}/*end acc data*/

  timer_stop(0);
  tm = timer_read(0);

  nit = 0;
  verified = 1;
  if (M == 24) {
    sx_verify_value = -3.247834652034740e+3;
    sy_verify_value = -6.958407078382297e+3;
  } else if (M == 25) {
    sx_verify_value = -2.863319731645753e+3;
    sy_verify_value = -6.320053679109499e+3;
  } else if (M == 28) {
    sx_verify_value = -4.295875165629892e+3;
    sy_verify_value = -1.580732573678431e+4;
  } else if (M == 30) {
    sx_verify_value =  4.033815542441498e+4;
    sy_verify_value = -2.660669192809235e+4;
  } else if (M == 32) {
    sx_verify_value =  4.764367927995374e+4;
    sy_verify_value = -8.084072988043731e+4;
  } else if (M == 36) {
    sx_verify_value =  1.982481200946593e+5;
    sy_verify_value = -1.020596636361769e+5;
  } else if (M == 40) {
    sx_verify_value = -5.319717441530e+05;
    sy_verify_value = -3.688834557731e+05;
  } else {
    verified = 0;
  }

  if (verified) {
    sx_err = fabs((sx - sx_verify_value) / sx_verify_value);
    sy_err = fabs((sy - sy_verify_value) / sy_verify_value);
    verified = ((sx_err <= EPSILON) && (sy_err <= EPSILON));
  }

  Mops = pow(2.0, M+1) / tm / 1000000.0;

  printf("\nEP Benchmark Results:\n\n");
  printf("CPU Time =%10.4lf\n", tm);
  printf("N = 2^%5d\n", M);
  printf("No. Gaussian Pairs = %15.0lf\n", gc);
  printf("Sums = %25.15lE %25.15lE\n", sx, sy);
  printf("Counts: \n");
  for (i = 0; i < NQ; i++) {
    printf("%3d%15.0lf\n", i, q[i]);
  }

  print_results("EP", CLASS, M+1, 0, 0, nit,
      tm, Mops, 
      "Random numbers generated",
      verified, NPBVERSION, COMPILETIME, CS1,
      CS2, CS3, CS4, CS5, CS6, CS7);

  if (timers_enabled) {
    if (tm <= 0.0) tm = 1.0;
    tt = timer_read(0);
    printf("\nTotal time:     %9.3lf (%6.2lf)\n", tt, tt*100.0/tm);
    tt = timer_read(1);
    printf("Gaussian pairs: %9.3lf (%6.2lf)\n", tt, tt*100.0/tm);
    tt = timer_read(2);
    printf("Random numbers: %9.3lf (%6.2lf)\n", tt, tt*100.0/tm);
  }

	free(xx);
	free(qq);

  return 0;
}

########## NEXT FILE ##########
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is an OpenMP C version of the NPB FT code. This OpenMP  //
//  C version is developed by the Center for Manycore Programming at Seoul //
//  National University and derived from the OpenMP Fortran versions in    //
//  "NPB3.3-OMP" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this OpenMP C version to              //
//  cmp@aces.snu.ac.kr                                                     //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS FT code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

//---------------------------------------------------------------------
// FT benchmark
//---------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "npbparams.h"
#include <openacc.h>

#include "randdp.h"
#include "timers.h"
#include "print_results.h"

//#define FFTBLOCKPAD_DEFAULT   33
//#define FFTBLOCK_DEFAULT      32
#define FFTBLOCKPAD   33
#define FFTBLOCK      32

typedef enum { false, true } logical;
typedef struct { 
  double real;
  double imag;
} dcomplex;

/* common /blockinfo/ */
static int fftblock, fftblockpad;

static int dims[3];

#define T_total       1
#define T_setup       2
#define T_fft         3
#define T_evolve      4
#define T_checksum    5 
#define T_fftx        6
#define T_ffty        7
#define T_fftz        8
#define T_max         8

static logical timers_enabled;
static logical debug;


#define SEED          314159265.0
#define A             1220703125.0
#define PI            3.141592653589793238
#define ALPHA         1.0e-6

//static dcomplex u[NXP];
static double u_real[NXP];
static double u_imag[NXP];
static dcomplex sums[NITER_DEFAULT+1];
static int niter;

#define dcmplx(r,i)       (dcomplex){r, i}
#define dcmplx_add(a,b)   (dcomplex){(a).real+(b).real, (a).imag+(b).imag}
#define dcmplx_sub(a,b)   (dcomplex){(a).real-(b).real, (a).imag-(b).imag}
#define dcmplx_mul(a,b)   (dcomplex){((a).real*(b).real)-((a).imag*(b).imag),\
                                     ((a).real*(b).imag)+((a).imag*(b).real)}
#define dcmplx_mul2(a,b)  (dcomplex){(a).real*(b), (a).imag*(b)}
static inline dcomplex dcmplx_div(dcomplex z1, dcomplex z2) {
  double a = z1.real;
  double b = z1.imag;
  double c = z2.real;
  double d = z2.imag;

  double divisor = c*c + d*d;
  double real = (a*c + b*d) / divisor;
  double imag = (b*c - a*d) / divisor;
  dcomplex result = (dcomplex){real, imag};
  return result;
}
#define dcmplx_div2(a,b)  (dcomplex){(a).real/(b), (a).imag/(b)}
#define dcmplx_abs(x)     sqrt(((x).real*(x).real) + ((x).imag*(x).imag))

#define dconjg(x)         (dcomplex){(x).real, -1.0*(x).imag}

//---------------------------------------------------------------------------
//static  dcomplex gty1[MAXDIM][MAXDIM][MAXDIM];
//static  dcomplex gty2[MAXDIM][MAXDIM][MAXDIM];
static  double gty1_real[MAXDIM][MAXDIM][MAXDIM];
static  double gty1_imag[MAXDIM][MAXDIM][MAXDIM];
static  double gty2_real[MAXDIM][MAXDIM][MAXDIM];
static  double gty2_imag[MAXDIM][MAXDIM][MAXDIM];

//---------------------------------------------------------------------
// u0, u1, u2 are the main arrays in the problem. 
// Depending on the decomposition, these arrays will have different 
// dimensions. To accomodate all possibilities, we allocate them as 
// one-dimensional arrays and pass them to subroutines for different 
// views
//  - u0 contains the initial (transformed) initial condition
//  - u1 and u2 are working arrays
//  - twiddle contains exponents for the time evolution operator. 
//---------------------------------------------------------------------
//---------------------------------------------------------------------
// Large arrays are in common so that they are allocated on the
// heap rather than the stack. This common block is not
// referenced directly anywhere else. Padding is to avoid accidental 
// cache problems, since all array sizes are powers of two.
//---------------------------------------------------------------------
/* common /bigarrays/ */
//dcomplex u0[NTOTALP];
//dcomplex pad1[3];
//dcomplex u1[NTOTALP];
//dcomplex pad2[3];
double u0_real[NTOTALP];
double u0_imag[NTOTALP];
double u1_real[NTOTALP];
double u1_imag[NTOTALP];
double twiddle[NTOTALP];
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
static void init_ui(int d1, int d2, int d3);
static void evolve(int d1, int d2, int d3);
static void compute_initial_conditions(int d1, int d2, int d3);
static double ipow46(double a, int exponent);
static void setup();
static void compute_indexmap(int d1, int d2, int d3);
static void print_timers();
static void fft(int dir);
static void cffts1_pos(int is, int d1, int d2, int d3);
static void cffts1_neg(int is, int d1, int d2, int d3);
static void cffts2_pos(int is, int d1, int d2, int d3);
static void cffts2_neg(int is, int d1, int d2, int d3);
static void cffts3_pos(int is, int d1, int d2, int d3);
static void cffts3_neg(int is, int d1, int d2, int d3);
static void fft_init(int n);
static int ilog2(int n);
static void checksum(int i, int d1, int d2, int d3);
static void verify(int d1, int d2, int d3, int nt, 
                   logical *verified, char *Class);
//---------------------------------------------------------------------------


int main(int argc, char *argv[])
{
  int i;
  int iter;
  double total_time, mflops;
  logical verified;
  char Class;

  acc_init(acc_device_default);
  //---------------------------------------------------------------------
  // Run the entire problem once to make sure all data is touched. 
  // This reduces variable startup costs, which is important for such a 
  // short benchmark. The other NPB 2 implementations are similar. 
  //---------------------------------------------------------------------
  for (i = 1; i <= T_max; i++) {
    timer_clear(i);
  }
  setup();
#pragma acc data create(u0_real,u0_imag,u1_real,u1_imag,u_real,u_imag,\
                        twiddle,gty1_real,gty1_imag, gty2_real, gty2_imag)
{
  init_ui(dims[0], dims[1], dims[2]);
  compute_indexmap(dims[0], dims[1], dims[2]);
  compute_initial_conditions(dims[0], dims[1], dims[2]);
  fft_init(dims[0]);
  fft(1);

  //---------------------------------------------------------------------
  // Start over from the beginning. Note that all operations must
  // be timed, in contrast to other benchmarks. 
  //---------------------------------------------------------------------
  for (i = 1; i <= T_max; i++) {
    timer_clear(i);
  }

  timer_start(T_total);
  if (timers_enabled) timer_start(T_setup);

  compute_indexmap(dims[0], dims[1], dims[2]);

  compute_initial_conditions(dims[0], dims[1], dims[2]);

  fft_init(dims[0]);

  fft(1);

  for (iter = 1; iter <= niter; iter++) {
    evolve(dims[0], dims[1], dims[2]);
    fft(-1);
    checksum(iter, dims[0], dims[1], dims[2]);
  }

  verify(NX, NY, NZ, niter, &verified, &Class);
  timer_stop(T_total);
  total_time = timer_read(T_total);
}

  if (total_time != 0.0) {
    mflops = 1.0e-6 * (double)NTOTAL *
            (14.8157 + 7.19641 * log((double)NTOTAL)
            + (5.23518 + 7.21113 * log((double)NTOTAL)) * niter)
            / total_time;
  } else {
    mflops = 0.0;
  }
  print_results("FT", Class, NX, NY, NZ, niter,
                total_time, mflops, "          floating point", verified, 
                NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, CS7);
  if (timers_enabled) print_timers();

  return 0;
}


//---------------------------------------------------------------------
// touch all the big data
//---------------------------------------------------------------------
static void init_ui(int d1, int d2, int d3)
{
  int i, j, k;

 #pragma acc parallel num_gangs(d3) num_workers(8) vector_length(128) \
                      present(u0_real,u0_imag,u1_real,u1_imag,twiddle)
 {
  #pragma acc loop gang
  for (k = 0; k < d3; k++) {
    #pragma acc loop worker 
    for (j = 0; j < d2; j++) {
      #pragma acc loop vector
      for (i = 0; i < d1; i++) {
        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = 0.0;
        u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = 0.0;
        u1_real[k*d2*(d1+1) + j*(d1+1) + i] = 0.0;
        u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = 0.0;
        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = 0.0;
      }
    }
  }
 }
}


//---------------------------------------------------------------------
// evolve u0 -> u1 (t time steps) in fourier space
//---------------------------------------------------------------------
static void evolve(int d1, int d2, int d3)
{
  int i, j, k;

  #pragma acc parallel num_gangs(d3) num_workers(8) vector_length(128) \
                      present(u0_real,u0_imag,u1_real,u1_imag,twiddle)
  {
  #pragma acc loop gang
  for (k = 0; k < d3; k++) {
    #pragma acc loop worker 
    for (j = 0; j < d2; j++) {
      #pragma acc loop vector
      for (i = 0; i < d1; i++) {
        u0_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i]
											   *twiddle[k*d2*(d1+1) + j*(d1+1) + i];
		u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i]
												*twiddle[k*d2*(d1+1) + j*(d1+1) + i];
		
		u1_real[k*d2*(d1+1) + j*(d1+1) + i] = u0_real[k*d2*(d1+1) + j*(d1+1) + i];
		u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = u0_imag[k*d2*(d1+1) + j*(d1+1) + i];
      }
    }
  }
 }
}


//---------------------------------------------------------------------
// Fill in array u0 with initial conditions from 
// random number generator 
//---------------------------------------------------------------------
static void compute_initial_conditions(int d1, int d2, int d3)
{
  int k, j;
  int NZ_var;
  NZ_var = NZ;
  double x0, start, an, dummy, starts[NZ];

  start = SEED;
  //---------------------------------------------------------------------
  // Jump to the starting element for our first plane.
  //---------------------------------------------------------------------
  an = ipow46(A, 0);
  dummy = randlc(&start, an);
  an = ipow46(A, 2*NX*NY);

  starts[0] = start;
  for (k = 1; k < d3; k++) {
    dummy = randlc(&start, an);
    starts[k] = start;
  }

//#pragma acc update host(u1_real,u1_imag)
  //---------------------------------------------------------------------
  // Go through by z planes filling in one square at a time.
  //---------------------------------------------------------------------
//#pragma acc parallel num_gangs(d3/128) vector_length(128) present(u1_real,u1_imag) copyin(starts[0:d3])
{
  //#pragma acc loop gang vector
  for (k = 0; k < d3; k++) {
    x0 = starts[k];
    for (j = 0; j < d2; j++) {
  //    vranlc(2*NX, &x0, A, (double *)&u1[k*d2*(d1+1) + j*(d1+1) + 0]);
        const double r23 = 1.1920928955078125e-07;
        const double r46 = r23 * r23;
        const double t23 = 8.388608e+06;
        const double t46 = t23 * t23;

        double t1, t2, t3, t4, a1, a2, x1, x2, z;

        int i;
       
        t1 = r23*A;
        a1 = (int)t1;
        a2 = A - t23*a1;
        
        for(i=0; i<2*NX; i++){
            t1 = r23 * x0;
            x1 = (int)t1;
            x2 = x0 - t23*x1;
            t1 = a1 * x2 + a2 * x1;
            t2 = (int) (r23 * t1);
            z = t1 - t23 * t2;
            t3 = t23 * z + a2 * x2;
            t4 = (int) (r46 * t3) ;
            x0 = t3 - t46 * t4;
            //y[i] = r46 * x0;
            if(i%2 == 0)
                u1_real[k*d2*(d1+1) + j*(d1+1) + i/2] = r46*x0;
            else
                u1_imag[k*d2*(d1+1) + j*(d1+1) + i/2] = r46*x0;
        }  
    }
  }
}
#pragma acc update device(u1_real,u1_imag)
}


//---------------------------------------------------------------------
// compute a^exponent mod 2^46
//---------------------------------------------------------------------
static double ipow46(double a, int exponent)
{
  double result, dummy, q, r;
  int n, n2;

  //---------------------------------------------------------------------
  // Use
  //   a^n = a^(n/2)*a^(n/2) if n even else
  //   a^n = a*a^(n-1)       if n odd
  //---------------------------------------------------------------------
  result = 1;
  if (exponent == 0) return result;
  q = a;
  r = 1;
  n = exponent;

  while (n > 1) {
    n2 = n / 2;
    if (n2 * 2 == n) {
      dummy = randlc(&q, q);
      n = n2;
    } else {
      dummy = randlc(&r, q);
      n = n-1;
    }
  }
  dummy = randlc(&r, q);
  result = r;
  return result;
}


static void setup()
{
  FILE *fp;
  debug = false;

  if ((fp = fopen("timer.flag", "r")) != NULL) {
    timers_enabled = true;
    fclose(fp);
  } else {
    timers_enabled = false;
  }

  niter = NITER_DEFAULT;

  printf("\n\n NAS Parallel Benchmarks (NPB3.3-ACC-C) - FT Benchmark\n\n");
  printf(" Size                : %4dx%4dx%4d\n", NX, NY, NZ);
  printf(" Iterations                  :%7d\n", niter);
  printf("\n");

  dims[0] = NX;
  dims[1] = NY;
  dims[2] = NZ;

  //---------------------------------------------------------------------
  // Set up info for blocking of ffts and transposes.  This improves
  // performance on cache-based systems. Blocking involves
  // working on a chunk of the problem at a time, taking chunks
  // along the first, second, or third dimension. 
  //
  // - In cffts1 blocking is on 2nd dimension (with fft on 1st dim)
  // - In cffts2/3 blocking is on 1st dimension (with fft on 2nd and 3rd dims)

  // Since 1st dim is always in processor, we'll assume it's long enough 
  // (default blocking factor is 16 so min size for 1st dim is 16)
  // The only case we have to worry about is cffts1 in a 2d decomposition. 
  // so the blocking factor should not be larger than the 2nd dimension. 
  //---------------------------------------------------------------------
}


//---------------------------------------------------------------------
// compute function from local (i,j,k) to ibar^2+jbar^2+kbar^2 
// for time evolution exponent. 
//---------------------------------------------------------------------
static void compute_indexmap(int d1, int d2, int d3)
{
  int i, j, k, kk, kk2, jj, kj2, ii;
  double ap;

  //---------------------------------------------------------------------
  // basically we want to convert the fortran indices 
  //   1 2 3 4 5 6 7 8 
  // to 
  //   0 1 2 3 -4 -3 -2 -1
  // The following magic formula does the trick:
  // mod(i-1+n/2, n) - n/2
  //---------------------------------------------------------------------

  ap = -4.0 * ALPHA * PI * PI;

#pragma acc parallel num_gangs(d3) num_workers(8) vector_length(128) present(twiddle)
{
  #pragma acc loop gang
  for (k = 0; k < d3; k++) {
    #pragma acc loop worker 
    for (j = 0; j < d2; j++) {
      #pragma acc loop vector
      for (i = 0; i < d1; i++) {
    	kk = ((k + NZ/2) % NZ) - NZ/2;
    	kk2 = kk*kk;
      	jj = ((j + NY/2) % NY) - NY/2;
      	kj2 = jj*jj + kk2;
        ii = ((i + NX/2) % NX) - NX/2;
        //twiddle[k][j][i] = exp(ap * (double)(ii*ii+kj2));
        twiddle[k*d2*(d1+1) + j*(d1+1) + i] = exp(ap * (double)(ii*ii+kj2));
      }
    }
  }
 }
}


static void print_timers()
{
  int i;
  double t, t_m;
  char *tstrings[T_max+1];
  tstrings[1] = "          total "; 
  tstrings[2] = "          setup "; 
  tstrings[3] = "            fft "; 
  tstrings[4] = "         evolve "; 
  tstrings[5] = "       checksum "; 
  tstrings[6] = "           fftx "; 
  tstrings[7] = "           ffty "; 
  tstrings[8] = "           fftz ";

  t_m = timer_read(T_total);
  if (t_m <= 0.0) t_m = 1.00;
  for (i = 1; i <= T_max; i++) {
    t = timer_read(i);
    printf(" timer %2d(%16s) :%9.4f (%6.2f%%)\n", 
        i, tstrings[i], t, t*100.0/t_m);
  }
}

//---------------------------------------------------------------------
// compute the roots-of-unity array that will be used for subsequent FFTs. 
//---------------------------------------------------------------------
static void fft_init(int n)
{
  int m, nu, ku, i, j, ln;
  double t, ti;

  //---------------------------------------------------------------------
  // Initialize the U array with sines and cosines in a manner that permits
  // stride one access at each FFT iteration.
  //---------------------------------------------------------------------
  nu = n;
  m = ilog2(n);
  //u[0] = dcmplx(m, 0.0);

#pragma acc parallel num_gangs(1) num_workers(1) vector_length(1) present(u_real,u_imag)
{
  u_real[0] = m;
  u_imag[0] = 0.0;
}
  ku = 2;
  ln = 1;

  for (j = 1; j <= m; j++) {
    t = PI / ln;

 #pragma acc parallel num_gangs((ln+127)/128) vector_length(128) present(u_real,u_imag)
 {
    #pragma acc loop gang vector
    for (i = 0; i <= ln - 1; i++) {
      ti = i * t;
      //u[i+ku-1] = dcmplx(cos(ti), sin(ti));
      u_real[i+ku-1] = (double)cos(ti);
      u_imag[i+ku-1] = (double)sin(ti);
    }
  }

    ku = ku + ln;
    ln = 2 * ln;
 }
}

//---------------------------------------------------------------------
// note: args x1, x2 must be different arrays
// note: args for cfftsx are (direction, layout, xin, xout, scratch)
//       xin/xout may be the same and it can be somewhat faster
//       if they are
//---------------------------------------------------------------------
static void fft(int dir)
{
  if (dir == 1) {
    cffts1_pos(1, dims[0], dims[1], dims[2]);
    cffts2_pos(1, dims[0], dims[1], dims[2]);
    cffts3_pos(1, dims[0], dims[1], dims[2]);
  } else {
    cffts3_neg(-1, dims[0], dims[1], dims[2]);
    cffts2_neg(-1, dims[0], dims[1], dims[2]);
    cffts1_neg(-1, dims[0], dims[1], dims[2]);
  }
}

static void cffts1_pos(int is, int d1, int d2, int d3)
{
  int logd1;
  int i, j, k, jj;
  int l, j1, i1, k1;
  int n1, li, lj, lk, ku, i11, i12, i21, i22;
  double uu1_real, x11_real, x21_real;
  double uu1_imag, x11_imag, x21_imag;
  double uu2_real, x12_real, x22_real;
  double uu2_imag, x12_imag, x22_imag;
  double temp_real, temp2_real;
  double temp_imag, temp2_imag;

  logd1 = ilog2(d1);

 #pragma acc parallel num_gangs(d3) vector_length(128) \
                      present(gty1_real,gty1_imag,gty2_real,gty2_imag,\
                              u1_real,u1_imag,u_real,u_imag) 
 {
  #pragma acc loop gang
  for (k = 0; k < d3; k++) {
   #pragma acc loop vector
    for (j = 0; j < d2; j++) {
        for (i = 0; i < d1; i++) {
          gty1_real[k][i][j] = u1_real[k*d2*(d1+1) + j*(d1+1) + i];
          gty1_imag[k][i][j] = u1_imag[k*d2*(d1+1) + j*(d1+1) + i];
        }

	  for(l = 1; l <= logd1; l += 2){
  		n1 = d1 / 2;
  		lk = 1 << (l - 1);
  		li = 1 << (logd1 - l);
  		lj = 2 * lk;
  		ku = li;
 		for (i1 = 0; i1 <= li - 1; i1++) {
    		for (k1 = 0; k1 <= lk - 1; k1++) {
    				i11 = i1 * lk;
    				i12 = i11 + n1;
    				i21 = i1 * lj;
   				 	i22 = i21 + lk;
	
					uu1_real = u_real[ku+i1];
					uu1_imag = u_imag[ku+i1];

        			x11_real = gty1_real[k][i11+k1][j];
        			x11_imag = gty1_imag[k][i11+k1][j];
		
        			x21_real = gty1_real[k][i12+k1][j];
        			x21_imag = gty1_imag[k][i12+k1][j];

					gty2_real[k][i21+k1][j] = x11_real + x21_real;
	   				gty2_imag[k][i21+k1][j] = x11_imag + x21_imag;
		
					temp_real = x11_real - x21_real;
					temp_imag = x11_imag - x21_imag;
					gty2_real[k][i22+k1][j] = (uu1_real)*(temp_real) - (uu1_imag)*(temp_imag);
					gty2_imag[k][i22+k1][j] = (uu1_real)*(temp_imag) + (uu1_imag)*(temp_real);

    		}
  		}
	  	if(l == logd1){
      		for (j1 = 0; j1 < d1; j1++) {
          			gty1_real[k][j1][j] = gty2_real[k][j1][j];
          			gty1_imag[k][j1][j] = gty2_imag[k][j1][j];
      		}
		 }else{
  			n1 = d1 / 2;
  			lk = 1 << (l+1 - 1);
		    li = 1 << (logd1 - (l+1));
			lj = 2 * lk;
		    ku = li;
			
  			for (i1 = 0; i1 <= li - 1; i1++) {
   				for (k1 = 0; k1 <= lk - 1; k1++) {
    					i11 = i1 * lk;
    					i12 = i11 + n1;
    					i21 = i1 * lj;
    					i22 = i21 + lk;
	
						uu2_real = u_real[ku+i1];
						uu2_imag = u_imag[ku+i1];
        
						x12_real = gty2_real[k][i11+k1][j];
        				x12_imag = gty2_imag[k][i11+k1][j];
		
        				x22_real = gty2_real[k][i12+k1][j];
        				x22_imag = gty2_imag[k][i12+k1][j];

						gty1_real[k][i21+k1][j] = x12_real + x22_real;
	    				gty1_imag[k][i21+k1][j] = x12_imag + x22_imag;
		
						temp2_real = x12_real - x22_real;
						temp2_imag = x12_imag - x22_imag;
						gty1_real[k][i22+k1][j] = (uu2_real)*(temp2_real) - (uu2_imag)*(temp2_imag);
						gty1_imag[k][i22+k1][j] = (uu2_real)*(temp2_imag) + (uu2_imag)*(temp2_real);
    			}
  			  }
		   }/*end else*/
	 	}/*end l*/
	
        for (i = 0; i < d1; i++) {
          u1_real[k*d2*(d1+1) + j*(d1+1) + i] = gty1_real[k][i][j];
          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = gty1_imag[k][i][j];
        }
    }
  }
 }/*end acc parallel*/
}

static void cffts1_neg(int is, int d1, int d2, int d3)
{
  int logd1;
  int i, j, k, jj;
  int l, j1, i1, k1;
  int n1, li, lj, lk, ku, i11, i12, i21, i22;
  double uu1_real, x11_real, x21_real;
  double uu1_imag, x11_imag, x21_imag;
  double uu2_real, x12_real, x22_real;
  double uu2_imag, x12_imag, x22_imag;
  double temp_real, temp2_real;
  double temp_imag, temp2_imag;
  
  logd1 = ilog2(d1);
  
  #pragma acc parallel num_gangs(d3) vector_length(128) \
                       present(gty1_real,gty1_imag,gty2_real,gty2_imag,\
                               u1_real,u1_imag,u_real,u_imag) 
 {
  #pragma acc loop gang
  for (k = 0; k < d3; k++) {
   #pragma acc loop vector
    for (j = 0; j < d2; j++ ){
        for (i = 0; i < d1; i++) {
          gty1_real[k][i][j] = u1_real[k*d2*(d1+1) + j*(d1+1) + i];
          gty1_imag[k][i][j] = u1_imag[k*d2*(d1+1) + j*(d1+1) + i];
        }

	  for(l = 1; l <= logd1; l += 2){
  		n1 = d1 / 2;
  		lk = 1 << (l - 1);
  		li = 1 << (logd1 - l);
  		lj = 2 * lk;
  		ku = li;
 		for (i1 = 0; i1 <= li - 1; i1++) {
    		for (k1 = 0; k1 <= lk - 1; k1++) {
    				i11 = i1 * lk;
    				i12 = i11 + n1;
    				i21 = i1 * lj;
   				 	i22 = i21 + lk;
	
					uu1_real = u_real[ku+i1];
					uu1_imag = -1.0*u_imag[ku+i1];

        			x11_real = gty1_real[k][i11+k1][j];
        			x11_imag = gty1_imag[k][i11+k1][j];
		
        			x21_real = gty1_real[k][i12+k1][j];
        			x21_imag = gty1_imag[k][i12+k1][j];

					gty2_real[k][i21+k1][j] = x11_real + x21_real;
	   				gty2_imag[k][i21+k1][j] = x11_imag + x21_imag;
		
					temp_real = x11_real - x21_real;
					temp_imag = x11_imag - x21_imag;
					gty2_real[k][i22+k1][j] = (uu1_real)*(temp_real) - (uu1_imag)*(temp_imag);
					gty2_imag[k][i22+k1][j] = (uu1_real)*(temp_imag) + (uu1_imag)*(temp_real);

    		}
  		}
	  	if(l == logd1){
      		for (j1 = 0; j1 < d1; j1++) {
          			gty1_real[k][j1][j] = gty2_real[k][j1][j];
          			gty1_imag[k][j1][j] = gty2_imag[k][j1][j];
      		}
		 }else{
  			n1 = d1 / 2;
  			lk = 1 << (l+1 - 1);
		    li = 1 << (logd1 - (l+1));
			lj = 2 * lk;
		    ku = li;
			
  			for (i1 = 0; i1 <= li - 1; i1++) {
   				for (k1 = 0; k1 <= lk - 1; k1++) {
    					i11 = i1 * lk;
    					i12 = i11 + n1;
    					i21 = i1 * lj;
    					i22 = i21 + lk;
	
						uu2_real = u_real[ku+i1];
						uu2_imag = -1.0*u_imag[ku+i1];
        
						x12_real = gty2_real[k][i11+k1][j];
        				x12_imag = gty2_imag[k][i11+k1][j];
		
        				x22_real = gty2_real[k][i12+k1][j];
        				x22_imag = gty2_imag[k][i12+k1][j];

						gty1_real[k][i21+k1][j] = x12_real + x22_real;
	    				gty1_imag[k][i21+k1][j] = x12_imag + x22_imag;
		
						temp2_real = x12_real - x22_real;
						temp2_imag = x12_imag - x22_imag;
						gty1_real[k][i22+k1][j] = (uu2_real)*(temp2_real) - (uu2_imag)*(temp2_imag);
						gty1_imag[k][i22+k1][j] = (uu2_real)*(temp2_imag) + (uu2_imag)*(temp2_real);
    			}
  			  }
		   }/*end else*/
	 	}/*end l*/
	
        for (i = 0; i < d1; i++) {
          u1_real[k*d2*(d1+1) + j*(d1+1) + i] = gty1_real[k][i][j];
          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = gty1_imag[k][i][j];
        }
    }
  }
 }/*end acc parallel*/
}


static void cffts2_pos(int is, int d1, int d2, int d3)
{
  int logd2;
  int i, j, k, ii;
  int l, j1, i1, k1;
  int n1, li, lj, lk, ku, i11, i12, i21, i22;
  double uu1_real, x11_real, x21_real;
  double uu1_imag, x11_imag, x21_imag;
  double uu2_real, x12_real, x22_real;
  double uu2_imag, x12_imag, x22_imag;
  double temp_real, temp2_real;
  double temp_imag, temp2_imag;

  logd2 = ilog2(d2);
  
  #pragma acc parallel num_gangs(d3) vector_length(128) \
                       present(gty1_real,gty1_imag,gty2_real,gty2_imag,\
                               u1_real,u1_imag,u_real,u_imag) 
  {
  #pragma acc loop gang
  for (k = 0; k < d3; k++) {
    #pragma acc loop vector
    for (i = 0; i < d1; i++) {
      for (j = 0; j < d2; j++) {
          gty1_real[k][j][i] = u1_real[k*d2*(d1+1) + j*(d1+1) + i];
          gty1_imag[k][j][i] = u1_imag[k*d2*(d1+1) + j*(d1+1) + i];
      }

	  for(l = 1; l <= logd2; l += 2){
  		n1 = d2 / 2;
  		lk = 1 << (l - 1);
  		li = 1 << (logd2 - l);
  		lj = 2 * lk;
  		ku = li;
 		for (i1 = 0; i1 <= li - 1; i1++) {
    		for (k1 = 0; k1 <= lk - 1; k1++) {
    				i11 = i1 * lk;
    				i12 = i11 + n1;
    				i21 = i1 * lj;
   				 	i22 = i21 + lk;
	
					uu1_real = u_real[ku+i1];
					uu1_imag = u_imag[ku+i1];

        			x11_real = gty1_real[k][i11+k1][i];
        			x11_imag = gty1_imag[k][i11+k1][i];
		
        			x21_real = gty1_real[k][i12+k1][i];
        			x21_imag = gty1_imag[k][i12+k1][i];

					gty2_real[k][i21+k1][i] = x11_real + x21_real;
	   				gty2_imag[k][i21+k1][i] = x11_imag + x21_imag;
		
					temp_real = x11_real - x21_real;
					temp_imag = x11_imag - x21_imag;
					gty2_real[k][i22+k1][i] = (uu1_real)*(temp_real) - (uu1_imag)*(temp_imag);
					gty2_imag[k][i22+k1][i] = (uu1_real)*(temp_imag) + (uu1_imag)*(temp_real);

    		}
  		}
	  	if(l == logd2){
      		for (j1 = 0; j1 < d1; j1++) {
          			//ty1[j][i] = ty2[j][i];
          			gty1_real[k][j1][i] = gty2_real[k][j1][i];
          			gty1_imag[k][j1][i] = gty2_imag[k][j1][i];
      		}
		 }else{
  			n1 = d2 / 2;
  			lk = 1 << (l+1 - 1);
		    li = 1 << (logd2 - (l+1));
			lj = 2 * lk;
		    ku = li;
			
  			for (i1 = 0; i1 <= li - 1; i1++) {
   				for (k1 = 0; k1 <= lk - 1; k1++) {
    					i11 = i1 * lk;
    					i12 = i11 + n1;
    					i21 = i1 * lj;
    					i22 = i21 + lk;
	
						uu2_real = u_real[ku+i1];
						uu2_imag = u_imag[ku+i1];
        
						x12_real = gty2_real[k][i11+k1][i];
        				x12_imag = gty2_imag[k][i11+k1][i];
		
        				x22_real = gty2_real[k][i12+k1][i];
        				x22_imag = gty2_imag[k][i12+k1][i];

						gty1_real[k][i21+k1][i] = x12_real + x22_real;
	    				gty1_imag[k][i21+k1][i] = x12_imag + x22_imag;
		
						temp2_real = x12_real - x22_real;
						temp2_imag = x12_imag - x22_imag;
						gty1_real[k][i22+k1][i] = (uu2_real)*(temp2_real) - (uu2_imag)*(temp2_imag);
						gty1_imag[k][i22+k1][i] = (uu2_real)*(temp2_imag) + (uu2_imag)*(temp2_real);
    			}
  			  }
		   }/*end else*/
	 	}/*end l*/

	for (j = 0; j < d2; j++) {
          u1_real[k*d2*(d1+1) + j*(d1+1) + i] = gty1_real[k][j][i];
          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = gty1_imag[k][j][i];
      }
    }
  }
 }/*end acc parallel*/
}

static void cffts2_neg(int is, int d1, int d2, int d3)
{
  int logd2;
  int i, j, k, ii;
  int l, j1, i1, k1;
  int n1, li, lj, lk, ku, i11, i12, i21, i22;
  double uu1_real, x11_real, x21_real;
  double uu1_imag, x11_imag, x21_imag;
  double uu2_real, x12_real, x22_real;
  double uu2_imag, x12_imag, x22_imag;
  double temp_real, temp2_real;
  double temp_imag, temp2_imag;

  logd2 = ilog2(d2);
  
 #pragma acc parallel num_gangs(d3) vector_length(128) \
                      present(gty1_real,gty1_imag,gty2_real,gty2_imag,\
                              u1_real,u1_imag,u_real,u_imag) 
 {
  #pragma acc loop gang
  for (k = 0; k < d3; k++) {
    #pragma acc loop vector
    for (i = 0; i < d1; i ++) {
      for (j = 0; j < d2; j++) {
          gty1_real[k][j][i] = u1_real[k*d2*(d1+1) + j*(d1+1) + i];
          gty1_imag[k][j][i] = u1_imag[k*d2*(d1+1) + j*(d1+1) + i];
      }

	  for(l = 1; l <= logd2; l += 2){
  		n1 = d2 / 2;
  		lk = 1 << (l - 1);
  		li = 1 << (logd2 - l);
  		lj = 2 * lk;
  		ku = li;
 		for (i1 = 0; i1 <= li - 1; i1++) {
    		for (k1 = 0; k1 <= lk - 1; k1++) {
    				i11 = i1 * lk;
    				i12 = i11 + n1;
    				i21 = i1 * lj;
   				 	i22 = i21 + lk;
	
					uu1_real = u_real[ku+i1];
					uu1_imag = -1.0*u_imag[ku+i1];

        			x11_real = gty1_real[k][i11+k1][i];
        			x11_imag = gty1_imag[k][i11+k1][i];
		
        			x21_real = gty1_real[k][i12+k1][i];
        			x21_imag = gty1_imag[k][i12+k1][i];

					gty2_real[k][i21+k1][i] = x11_real + x21_real;
	   				gty2_imag[k][i21+k1][i] = x11_imag + x21_imag;
		
					temp_real = x11_real - x21_real;
					temp_imag = x11_imag - x21_imag;
					gty2_real[k][i22+k1][i] = (uu1_real)*(temp_real) - (uu1_imag)*(temp_imag);
					gty2_imag[k][i22+k1][i] = (uu1_real)*(temp_imag) + (uu1_imag)*(temp_real);

    		}
  		}
	  	if(l == logd2){
      		for (j1 = 0; j1 < d1; j1++) {
          			gty1_real[k][j1][i] = gty2_real[k][j1][i];
          			gty1_imag[k][j1][i] = gty2_imag[k][j1][i];
      		}
		 }else{
  			n1 = d2 / 2;
  			lk = 1 << (l+1 - 1);
		    li = 1 << (logd2 - (l+1));
			lj = 2 * lk;
		    ku = li;
			
  			for (i1 = 0; i1 <= li - 1; i1++) {
   				for (k1 = 0; k1 <= lk - 1; k1++) {
    					i11 = i1 * lk;
    					i12 = i11 + n1;
    					i21 = i1 * lj;
    					i22 = i21 + lk;
	
						uu2_real = u_real[ku+i1];
						uu2_imag = -1.0*u_imag[ku+i1];
        
						x12_real = gty2_real[k][i11+k1][i];
        				x12_imag = gty2_imag[k][i11+k1][i];
		
        				x22_real = gty2_real[k][i12+k1][i];
        				x22_imag = gty2_imag[k][i12+k1][i];

						gty1_real[k][i21+k1][i] = x12_real + x22_real;
	    				gty1_imag[k][i21+k1][i] = x12_imag + x22_imag;
		
						temp2_real = x12_real - x22_real;
						temp2_imag = x12_imag - x22_imag;
						gty1_real[k][i22+k1][i] = (uu2_real)*(temp2_real) - (uu2_imag)*(temp2_imag);
						gty1_imag[k][i22+k1][i] = (uu2_real)*(temp2_imag) + (uu2_imag)*(temp2_real);
    			}
  			  }
		   }/*end else*/
	 	}/*end l*/

	for (j = 0; j < d2; j++) {
          u1_real[k*d2*(d1+1) + j*(d1+1) + i] = gty1_real[k][j][i];
          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = gty1_imag[k][j][i];
      }
    }
  }
 }/*end acc parallel*/
}

/*is == 1*/
static void cffts3_pos(int is, int d1, int d2, int d3)
{
  int logd3;
  int i, j, k, ii;
  int l, j1, i1, k1;
  int n1, li, lj, lk, ku, i11, i12, i21, i22;
  double uu1_real, x11_real, x21_real;
  double uu1_imag, x11_imag, x21_imag;
  double uu2_real, x12_real, x22_real;
  double uu2_imag, x12_imag, x22_imag;
  double temp_real, temp2_real;
  double temp_imag, temp2_imag;
  
  logd3 = ilog2(d3);

  #pragma acc parallel num_gangs(d2) vector_length(128) \
                       present(gty1_real,gty1_imag,gty2_real,gty2_imag,\
                               u0_real,u0_imag,u1_real,u1_imag,u_real,u_imag) 
 {
  #pragma acc loop gang
  for (j = 0; j < d2; j++) {
    #pragma acc loop vector
    for (i = 0; i < d1; i ++) {
      for (k = 0; k < d3; k++) {
          gty1_real[j][k][i] = u1_real[k*d2*(d1+1) + j*(d1+1) + i];
          gty1_imag[j][k][i] = u1_imag[k*d2*(d1+1) + j*(d1+1) + i];
      }

	  for(l = 1; l <= logd3; l += 2){
  		n1 = d3 / 2;
  		lk = 1 << (l - 1);
  		li = 1 << (logd3 - l);
  		lj = 2 * lk;
  		ku = li;
 		for (i1 = 0; i1 <= li - 1; i1++) {
    		for (k1 = 0; k1 <= lk - 1; k1++) {
    				i11 = i1 * lk;
    				i12 = i11 + n1;
    				i21 = i1 * lj;
   				 	i22 = i21 + lk;
	
					uu1_real = u_real[ku+i1];
					uu1_imag = u_imag[ku+i1];

        			x11_real = gty1_real[j][i11+k1][i];
        			x11_imag = gty1_imag[j][i11+k1][i];
		
        			x21_real = gty1_real[j][i12+k1][i];
        			x21_imag = gty1_imag[j][i12+k1][i];

					gty2_real[j][i21+k1][i] = x11_real + x21_real;
	   				gty2_imag[j][i21+k1][i] = x11_imag + x21_imag;
		
					temp_real = x11_real - x21_real;
					temp_imag = x11_imag - x21_imag;
					gty2_real[j][i22+k1][i] = (uu1_real)*(temp_real) - (uu1_imag)*(temp_imag);
					gty2_imag[j][i22+k1][i] = (uu1_real)*(temp_imag) + (uu1_imag)*(temp_real);

    		}
  		}
	  	if(l == logd3){
      		for (j1 = 0; j1 < d1; j1++) {
          			gty1_real[j][j1][i] = gty2_real[j][j1][i];
          			gty1_imag[j][j1][i] = gty2_imag[j][j1][i];
      		}
		 }else{
  			n1 = d3 / 2;
  			lk = 1 << (l+1 - 1);
		    li = 1 << (logd3 - (l+1));
			lj = 2 * lk;
		    ku = li;
			
  			for (i1 = 0; i1 <= li - 1; i1++) {
   				for (k1 = 0; k1 <= lk - 1; k1++) {
    					i11 = i1 * lk;
    					i12 = i11 + n1;
    					i21 = i1 * lj;
    					i22 = i21 + lk;
	
						uu2_real = u_real[ku+i1];
						uu2_imag = u_imag[ku+i1];
        
						x12_real = gty2_real[j][i11+k1][i];
        				x12_imag = gty2_imag[j][i11+k1][i];
		
        				x22_real = gty2_real[j][i12+k1][i];
        				x22_imag = gty2_imag[j][i12+k1][i];

						gty1_real[j][i21+k1][i] = x12_real + x22_real;
	    				gty1_imag[j][i21+k1][i] = x12_imag + x22_imag;
		
						temp2_real = x12_real - x22_real;
						temp2_imag = x12_imag - x22_imag;
						gty1_real[j][i22+k1][i] = (uu2_real)*(temp2_real) - (uu2_imag)*(temp2_imag);
						gty1_imag[j][i22+k1][i] = (uu2_real)*(temp2_imag) + (uu2_imag)*(temp2_real);
    			}
  			  }
		   }/*end else*/
	 	}/*end l*/

      for (k = 0; k < d3; k++) {
          u0_real[k*d2*(d1+1) + j*(d1+1) + i] = gty1_real[j][k][i];
          u0_imag[k*d2*(d1+1) + j*(d1+1) + i] = gty1_imag[j][k][i];
      }
    }
  }
 }/* end acc parlalel */
}



/*is==-1*/
static void cffts3_neg(int is, int d1, int d2, int d3)
{
  int logd3;
  int i, j, k, ii;
  int l, j1, i1, k1;
  int n1, li, lj, lk, ku, i11, i12, i21, i22;
  double uu1_real, x11_real, x21_real;
  double uu1_imag, x11_imag, x21_imag;
  double uu2_real, x12_real, x22_real;
  double uu2_imag, x12_imag, x22_imag;
  double temp_real, temp2_real;
  double temp_imag, temp2_imag;

  logd3 = ilog2(d3);
  
  #pragma acc parallel num_gangs(d2) vector_length(128) \
                       present(gty1_real,gty1_imag,gty2_real,gty2_imag,\
                               u1_real,u1_imag,u_real,u_imag) 
  {
  #pragma acc loop gang
  for (j = 0; j < d2; j++) {
    #pragma acc loop vector
    for (i = 0; i < d1; i++) {
      for (k = 0; k < d3; k++) {
          gty1_real[j][k][i] = u1_real[k*d2*(d1+1) + j*(d1+1) + i];
          gty1_imag[j][k][i] = u1_imag[k*d2*(d1+1) + j*(d1+1) + i];
      }

	  for(l = 1; l <= logd3; l += 2){
  		n1 = d3 / 2;
  		lk = 1 << (l - 1);
  		li = 1 << (logd3 - l);
  		lj = 2 * lk;
  		ku = li;
 		for (i1 = 0; i1 <= li - 1; i1++) {
    		for (k1 = 0; k1 <= lk - 1; k1++) {
    				i11 = i1 * lk;
    				i12 = i11 + n1;
    				i21 = i1 * lj;
   				 	i22 = i21 + lk;
	
					uu1_real = u_real[ku+i1];
					uu1_imag = -1.0*u_imag[ku+i1];

        			x11_real = gty1_real[j][i11+k1][i];
        			x11_imag = gty1_imag[j][i11+k1][i];
		
        			x21_real = gty1_real[j][i12+k1][i];
        			x21_imag = gty1_imag[j][i12+k1][i];

					gty2_real[j][i21+k1][i] = x11_real + x21_real;
	   				gty2_imag[j][i21+k1][i] = x11_imag + x21_imag;
		
					temp_real = x11_real - x21_real;
					temp_imag = x11_imag - x21_imag;
					gty2_real[j][i22+k1][i] = (uu1_real)*(temp_real) - (uu1_imag)*(temp_imag);
					gty2_imag[j][i22+k1][i] = (uu1_real)*(temp_imag) + (uu1_imag)*(temp_real);

    		}
  		}
	  	if(l == logd3){
      		for (j1 = 0; j1 < d1; j1++) {
          			gty1_real[j][j1][i] = gty2_real[j][j1][i];
          			gty1_imag[j][j1][i] = gty2_imag[j][j1][i];
      		}
		 }else{
  			n1 = d3 / 2;
  			lk = 1 << (l+1 - 1);
		    li = 1 << (logd3 - (l+1));
			lj = 2 * lk;
		    ku = li;
			
  			for (i1 = 0; i1 <= li - 1; i1++) {
   				for (k1 = 0; k1 <= lk - 1; k1++) {
    					i11 = i1 * lk;
    					i12 = i11 + n1;
    					i21 = i1 * lj;
    					i22 = i21 + lk;
	
						uu2_real = u_real[ku+i1];
						uu2_imag = -1.0*u_imag[ku+i1];
        
						x12_real = gty2_real[j][i11+k1][i];
        				x12_imag = gty2_imag[j][i11+k1][i];
		
        				x22_real = gty2_real[j][i12+k1][i];
        				x22_imag = gty2_imag[j][i12+k1][i];

						gty1_real[j][i21+k1][i] = x12_real + x22_real;
	    				gty1_imag[j][i21+k1][i] = x12_imag + x22_imag;
		
						temp2_real = x12_real - x22_real;
						temp2_imag = x12_imag - x22_imag;
						gty1_real[j][i22+k1][i] = (uu2_real)*(temp2_real) - (uu2_imag)*(temp2_imag);
						gty1_imag[j][i22+k1][i] = (uu2_real)*(temp2_imag) + (uu2_imag)*(temp2_real);
    			}
  			  }
		   }/*end else*/
	 	}/*end l*/

      for (k = 0; k < d3; k++) {
          u1_real[k*d2*(d1+1) + j*(d1+1) + i] = gty1_real[j][k][i];
          u1_imag[k*d2*(d1+1) + j*(d1+1) + i] = gty1_imag[j][k][i];
      }
    }
  }
 }/*end acc parallel*/
}


static int ilog2(int n)
{
  int nn, lg;
  if (n == 1) return 0;
  lg = 1;
  nn = 2;
  while (nn < n) {
    nn = nn*2;
    lg = lg+1;
  }
  return lg;
}


static void checksum(int i, int d1, int d2, int d3)
{

  int j, q, r, s;
  double temp1,temp2;
  // dcomplex chk = dcmplx(0.0, 0.0);
  dcomplex chk;
  chk.real = 0.0;
  chk.imag = 0.0;

  temp1 = 0.0;
  temp2 = 0.0;

//#pragma acc update host(u1_real,u1_imag)
#pragma acc parallel num_gangs(1) num_workers(1) \
                     vector_length(1024) present(u1_real,u1_imag)
{
	#pragma acc loop gang worker vector reduction(+:temp1,temp2)
    for (j = 1; j <= 1024; j++) {
      q = j % NX;
      r = 3*j % NY;
      s = 5*j % NZ;
	 temp1 = temp1 + u1_real[s*d2*(d1+1) + r*(d1+1) + q];
	 temp2 = temp2 + u1_imag[s*d2*(d1+1) + r*(d1+1) + q];
    }
}
	 chk.real = temp1;
	 chk.imag = temp2;

  chk = dcmplx_div2(chk, (double)(NTOTAL));

  printf(" T =%5d     Checksum =%22.12E%22.12E\n", i, chk.real, chk.imag);
  sums[i] = chk;
}


static void verify(int d1, int d2, int d3, int nt, 
                   logical *verified, char *Class)
{
  int i;
  double err, epsilon;

  //---------------------------------------------------------------------
  // Reference checksums
  //---------------------------------------------------------------------
  dcomplex csum_ref[25+1];

  *Class = 'U';

  epsilon = 1.0e-12;
  *verified = false;

  if (d1 == 64 && d2 == 64 && d3 == 64 && nt == 6) {
    //---------------------------------------------------------------------
    //   Sample size reference checksums
    //---------------------------------------------------------------------
    *Class = 'S';
    csum_ref[1] = dcmplx(5.546087004964E+02, 4.845363331978E+02);
    csum_ref[2] = dcmplx(5.546385409189E+02, 4.865304269511E+02);
    csum_ref[3] = dcmplx(5.546148406171E+02, 4.883910722336E+02);
    csum_ref[4] = dcmplx(5.545423607415E+02, 4.901273169046E+02);
    csum_ref[5] = dcmplx(5.544255039624E+02, 4.917475857993E+02);
    csum_ref[6] = dcmplx(5.542683411902E+02, 4.932597244941E+02);

  } else if (d1 == 128 && d2 == 128 && d3 == 32 && nt == 6) {
    //---------------------------------------------------------------------
    //   Class W size reference checksums
    //---------------------------------------------------------------------
    *Class = 'W';
    csum_ref[1] = dcmplx(5.673612178944E+02, 5.293246849175E+02);
    csum_ref[2] = dcmplx(5.631436885271E+02, 5.282149986629E+02);
    csum_ref[3] = dcmplx(5.594024089970E+02, 5.270996558037E+02);
    csum_ref[4] = dcmplx(5.560698047020E+02, 5.260027904925E+02);
    csum_ref[5] = dcmplx(5.530898991250E+02, 5.249400845633E+02);
    csum_ref[6] = dcmplx(5.504159734538E+02, 5.239212247086E+02);

  } else if (d1 == 256 && d2 == 256 && d3 == 128 && nt == 6) {
    //---------------------------------------------------------------------
    //   Class A size reference checksums
    //---------------------------------------------------------------------
    *Class = 'A';
    csum_ref[1] = dcmplx(5.046735008193E+02, 5.114047905510E+02);
    csum_ref[2] = dcmplx(5.059412319734E+02, 5.098809666433E+02);
    csum_ref[3] = dcmplx(5.069376896287E+02, 5.098144042213E+02);
    csum_ref[4] = dcmplx(5.077892868474E+02, 5.101336130759E+02);
    csum_ref[5] = dcmplx(5.085233095391E+02, 5.104914655194E+02);
    csum_ref[6] = dcmplx(5.091487099959E+02, 5.107917842803E+02);

  } else if (d1 == 512 && d2 == 256 && d3 == 256 && nt == 20) {
    //---------------------------------------------------------------------
    //   Class B size reference checksums
    //---------------------------------------------------------------------
    *Class = 'B';
    csum_ref[1]  = dcmplx(5.177643571579E+02, 5.077803458597E+02);
    csum_ref[2]  = dcmplx(5.154521291263E+02, 5.088249431599E+02);
    csum_ref[3]  = dcmplx(5.146409228649E+02, 5.096208912659E+02);
    csum_ref[4]  = dcmplx(5.142378756213E+02, 5.101023387619E+02);
    csum_ref[5]  = dcmplx(5.139626667737E+02, 5.103976610617E+02);
    csum_ref[6]  = dcmplx(5.137423460082E+02, 5.105948019802E+02);
    csum_ref[7]  = dcmplx(5.135547056878E+02, 5.107404165783E+02);
    csum_ref[8]  = dcmplx(5.133910925466E+02, 5.108576573661E+02);
    csum_ref[9]  = dcmplx(5.132470705390E+02, 5.109577278523E+02);
    csum_ref[10] = dcmplx(5.131197729984E+02, 5.110460304483E+02);
    csum_ref[11] = dcmplx(5.130070319283E+02, 5.111252433800E+02);
    csum_ref[12] = dcmplx(5.129070537032E+02, 5.111968077718E+02);
    csum_ref[13] = dcmplx(5.128182883502E+02, 5.112616233064E+02);
    csum_ref[14] = dcmplx(5.127393733383E+02, 5.113203605551E+02);
    csum_ref[15] = dcmplx(5.126691062020E+02, 5.113735928093E+02);
    csum_ref[16] = dcmplx(5.126064276004E+02, 5.114218460548E+02);
    csum_ref[17] = dcmplx(5.125504076570E+02, 5.114656139760E+02);
    csum_ref[18] = dcmplx(5.125002331720E+02, 5.115053595966E+02);
    csum_ref[19] = dcmplx(5.124551951846E+02, 5.115415130407E+02);
    csum_ref[20] = dcmplx(5.124146770029E+02, 5.115744692211E+02);

  } else if (d1 == 512 && d2 == 512 && d3 == 512 && nt == 20) {
    //---------------------------------------------------------------------
    //   Class C size reference checksums
    //---------------------------------------------------------------------
    *Class = 'C';
    csum_ref[1]  = dcmplx(5.195078707457E+02, 5.149019699238E+02);
    csum_ref[2]  = dcmplx(5.155422171134E+02, 5.127578201997E+02);
    csum_ref[3]  = dcmplx(5.144678022222E+02, 5.122251847514E+02);
    csum_ref[4]  = dcmplx(5.140150594328E+02, 5.121090289018E+02);
    csum_ref[5]  = dcmplx(5.137550426810E+02, 5.121143685824E+02);
    csum_ref[6]  = dcmplx(5.135811056728E+02, 5.121496764568E+02);
    csum_ref[7]  = dcmplx(5.134569343165E+02, 5.121870921893E+02);
    csum_ref[8]  = dcmplx(5.133651975661E+02, 5.122193250322E+02);
    csum_ref[9]  = dcmplx(5.132955192805E+02, 5.122454735794E+02);
    csum_ref[10] = dcmplx(5.132410471738E+02, 5.122663649603E+02);
    csum_ref[11] = dcmplx(5.131971141679E+02, 5.122830879827E+02);
    csum_ref[12] = dcmplx(5.131605205716E+02, 5.122965869718E+02);
    csum_ref[13] = dcmplx(5.131290734194E+02, 5.123075927445E+02);
    csum_ref[14] = dcmplx(5.131012720314E+02, 5.123166486553E+02);
    csum_ref[15] = dcmplx(5.130760908195E+02, 5.123241541685E+02);
    csum_ref[16] = dcmplx(5.130528295923E+02, 5.123304037599E+02);
    csum_ref[17] = dcmplx(5.130310107773E+02, 5.123356167976E+02);
    csum_ref[18] = dcmplx(5.130103090133E+02, 5.123399592211E+02);
    csum_ref[19] = dcmplx(5.129905029333E+02, 5.123435588985E+02);
    csum_ref[20] = dcmplx(5.129714421109E+02, 5.123465164008E+02);

  } else if (d1 == 2048 && d2 == 1024 && d3 == 1024 && nt == 25) {
    //---------------------------------------------------------------------
    //   Class D size reference checksums
    //---------------------------------------------------------------------
    *Class = 'D';
    csum_ref[1]  = dcmplx(5.122230065252E+02, 5.118534037109E+02);
    csum_ref[2]  = dcmplx(5.120463975765E+02, 5.117061181082E+02);
    csum_ref[3]  = dcmplx(5.119865766760E+02, 5.117096364601E+02);
    csum_ref[4]  = dcmplx(5.119518799488E+02, 5.117373863950E+02);
    csum_ref[5]  = dcmplx(5.119269088223E+02, 5.117680347632E+02);
    csum_ref[6]  = dcmplx(5.119082416858E+02, 5.117967875532E+02);
    csum_ref[7]  = dcmplx(5.118943814638E+02, 5.118225281841E+02);
    csum_ref[8]  = dcmplx(5.118842385057E+02, 5.118451629348E+02);
    csum_ref[9]  = dcmplx(5.118769435632E+02, 5.118649119387E+02);
    csum_ref[10] = dcmplx(5.118718203448E+02, 5.118820803844E+02);
    csum_ref[11] = dcmplx(5.118683569061E+02, 5.118969781011E+02);
    csum_ref[12] = dcmplx(5.118661708593E+02, 5.119098918835E+02);
    csum_ref[13] = dcmplx(5.118649768950E+02, 5.119210777066E+02);
    csum_ref[14] = dcmplx(5.118645605626E+02, 5.119307604484E+02);
    csum_ref[15] = dcmplx(5.118647586618E+02, 5.119391362671E+02);
    csum_ref[16] = dcmplx(5.118654451572E+02, 5.119463757241E+02);
    csum_ref[17] = dcmplx(5.118665212451E+02, 5.119526269238E+02);
    csum_ref[18] = dcmplx(5.118679083821E+02, 5.119580184108E+02);
    csum_ref[19] = dcmplx(5.118695433664E+02, 5.119626617538E+02);
    csum_ref[20] = dcmplx(5.118713748264E+02, 5.119666538138E+02);
    csum_ref[21] = dcmplx(5.118733606701E+02, 5.119700787219E+02);
    csum_ref[22] = dcmplx(5.118754661974E+02, 5.119730095953E+02);
    csum_ref[23] = dcmplx(5.118776626738E+02, 5.119755100241E+02);
    csum_ref[24] = dcmplx(5.118799262314E+02, 5.119776353561E+02);
    csum_ref[25] = dcmplx(5.118822370068E+02, 5.119794338060E+02);

  } else if (d1 == 4096 && d2 == 2048 && d3 == 2048 && nt == 25) {
    //---------------------------------------------------------------------
    //   Class E size reference checksums
    //---------------------------------------------------------------------
    *Class = 'E';
    csum_ref[1]  = dcmplx(5.121601045346E+02, 5.117395998266E+02);
    csum_ref[2]  = dcmplx(5.120905403678E+02, 5.118614716182E+02);
    csum_ref[3]  = dcmplx(5.120623229306E+02, 5.119074203747E+02);
    csum_ref[4]  = dcmplx(5.120438418997E+02, 5.119345900733E+02);
    csum_ref[5]  = dcmplx(5.120311521872E+02, 5.119551325550E+02);
    csum_ref[6]  = dcmplx(5.120226088809E+02, 5.119720179919E+02);
    csum_ref[7]  = dcmplx(5.120169296534E+02, 5.119861371665E+02);
    csum_ref[8]  = dcmplx(5.120131225172E+02, 5.119979364402E+02);
    csum_ref[9]  = dcmplx(5.120104767108E+02, 5.120077674092E+02);
    csum_ref[10] = dcmplx(5.120085127969E+02, 5.120159443121E+02);
    csum_ref[11] = dcmplx(5.120069224127E+02, 5.120227453670E+02);
    csum_ref[12] = dcmplx(5.120055158164E+02, 5.120284096041E+02);
    csum_ref[13] = dcmplx(5.120041820159E+02, 5.120331373793E+02);
    csum_ref[14] = dcmplx(5.120028605402E+02, 5.120370938679E+02);
    csum_ref[15] = dcmplx(5.120015223011E+02, 5.120404138831E+02);
    csum_ref[16] = dcmplx(5.120001570022E+02, 5.120432068837E+02);
    csum_ref[17] = dcmplx(5.119987650555E+02, 5.120455615860E+02);
    csum_ref[18] = dcmplx(5.119973525091E+02, 5.120475499442E+02);
    csum_ref[19] = dcmplx(5.119959279472E+02, 5.120492304629E+02);
    csum_ref[20] = dcmplx(5.119945006558E+02, 5.120506508902E+02);
    csum_ref[21] = dcmplx(5.119930795911E+02, 5.120518503782E+02);
    csum_ref[22] = dcmplx(5.119916728462E+02, 5.120528612016E+02);
    csum_ref[23] = dcmplx(5.119902874185E+02, 5.120537101195E+02);
    csum_ref[24] = dcmplx(5.119889291565E+02, 5.120544194514E+02);
    csum_ref[25] = dcmplx(5.119876028049E+02, 5.120550079284E+02);
  }

  if (*Class != 'U') {
    *verified = true;
    for (i = 1; i <= nt; i++) {
      err = dcmplx_abs(dcmplx_div(dcmplx_sub(sums[i], csum_ref[i]),
                                  csum_ref[i]));
      if (!(err <= epsilon)) {
        *verified = false;
        break;
      }
    }
  }

  if (*Class != 'U') {
    if (*verified) {
      printf(" Result verification successful\n");
    } else {
      printf(" Result verification failed\n");
    }
  }
  printf(" class = %c\n", *Class);
}


########## NEXT FILE ##########
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB LU code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS LU code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

//---------------------------------------------------------------------
//   program applu
//---------------------------------------------------------------------

//---------------------------------------------------------------------
//
//   driver for the performance evaluation of the solver for
//   five coupled parabolic/elliptic partial differential equations.
//
//---------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include "applu.incl"
#include "timers.h"
#include "print_results.h"
#include <openacc.h>

//---------------------------------------------------------------------
// grid
//---------------------------------------------------------------------
/* common/cgcon/ */
double dxi, deta, dzeta;
double tx1, tx2, tx3;
double ty1, ty2, ty3;
double tz1, tz2, tz3;
int nx, ny, nz;
int nx0, ny0, nz0;
int ist, iend;
int jst, jend;
int ii1, ii2;
int ji1, ji2;
int ki1, ki2;

//---------------------------------------------------------------------
// dissipation
//---------------------------------------------------------------------
/* common/disp/ */
double dx1, dx2, dx3, dx4, dx5;
double dy1, dy2, dy3, dy4, dy5;
double dz1, dz2, dz3, dz4, dz5;
double dssp;

//---------------------------------------------------------------------
// field variables and residuals
// to improve cache performance, second two dimensions padded by 1 
// for even number sizes only.
// Note: corresponding array (called "v") in routines blts, buts, 
// and l2norm are similarly padded
//---------------------------------------------------------------------
/* common/cvar/ */
double u[5][ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1];
double rsd[5][ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1];
double frct[5][ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1];
double flux_G[5][ISIZ3][ISIZ2][ISIZ1];
double qs   [ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1];
double rho_i[ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1];

//---------------------------------------------------------------------
// output control parameters
//---------------------------------------------------------------------
/* common/cprcon/ */
int ipr, inorm;

//---------------------------------------------------------------------
// newton-raphson iteration control parameters
//---------------------------------------------------------------------
/* common/ctscon/ */
double dt, omega, tolrsd[5], rsdnm[5], errnm[5], frc, ttotal;
int itmax, invert;

/* common/cjac/ */
double a[5][5][ISIZ1*ISIZ2];
double b[5][5][ISIZ1*ISIZ2];
double c[5][5][ISIZ1*ISIZ2];
double d[5][5][ISIZ1*ISIZ2];

int np[ISIZ1+ISIZ2+ISIZ3-5];
int indxp[ISIZ1+ISIZ2+ISIZ3-5][ISIZ1*ISIZ2*3/4];
int jndxp[ISIZ1+ISIZ2+ISIZ3-5][ISIZ1*ISIZ2*3/4];
double tmat[5][5][ISIZ1*ISIZ2*3/4];
double tv[5][ISIZ1*ISIZ2*3/4];
double utmp_G[6][ISIZ2][ISIZ1][ISIZ3];
double rtmp_G[5][ISIZ2][ISIZ1][ISIZ3];

//---------------------------------------------------------------------
// coefficients of the exact solution
//---------------------------------------------------------------------
/* common/cexact/ */
double ce[5][13];


//---------------------------------------------------------------------
// timers
//---------------------------------------------------------------------
/* common/timer/ */
double maxtime;
logical timeron;


int main(int argc, char *argv[])
{
  char Class;
  logical verified;
  double mflops;

  double t, tmax, trecs[t_last+1];
  int i;
  char *t_names[t_last+1];
  acc_init(acc_device_default);

  //---------------------------------------------------------------------
  // Setup info for timers
  //---------------------------------------------------------------------
  FILE *fp;
  if ((fp = fopen("timer.flag", "r")) != NULL) {
    timeron = true;
    t_names[t_total] = "total";
    t_names[t_rhsx] = "rhsx";
    t_names[t_rhsy] = "rhsy";
    t_names[t_rhsz] = "rhsz";
    t_names[t_rhs] = "rhs";
    t_names[t_jacld] = "jacld";
    t_names[t_blts] = "blts";
    t_names[t_jacu] = "jacu";
    t_names[t_buts] = "buts";
    t_names[t_add] = "add";
    t_names[t_l2norm] = "l2norm";
    fclose(fp);
  } else {
    timeron = false;
  }

  //---------------------------------------------------------------------
  // read input data
  //---------------------------------------------------------------------
  read_input();
  //---------------------------------------------------------------------
  // set up domain sizes
  //---------------------------------------------------------------------
  domain();

  //---------------------------------------------------------------------
  // set up coefficients
  //---------------------------------------------------------------------
  setcoeff();

#pragma acc data create(a,b,c,d,flux_G,indxp,jndxp,np,rho_i,frct,qs,rsd,u,tmat,tv,utmp_G,rtmp_G) \
			     copyout(rsdnm)
{
  //---------------------------------------------------------------------
  // set the boundary values for dependent variables
  //---------------------------------------------------------------------
  setbv();

  //---------------------------------------------------------------------
  // set the initial values for dependent variables
  //---------------------------------------------------------------------
  setiv();
  #pragma acc update device(u)
  //---------------------------------------------------------------------
  // compute the forcing term based on prescribed exact solution
  //---------------------------------------------------------------------
  erhs();

  //---------------------------------------------------------------------
  // perform one SSOR iteration to touch all pages
  //---------------------------------------------------------------------
  ssor(1);

  //---------------------------------------------------------------------
  // reset the boundary and initial values
  //---------------------------------------------------------------------
  setbv();
  setiv();
  #pragma acc update device(u)

  //---------------------------------------------------------------------
  // perform the SSOR iterations
  //---------------------------------------------------------------------
  ssor(itmax);


  //---------------------------------------------------------------------
  // compute the solution error
  //---------------------------------------------------------------------
  #pragma acc update host(u)
  error();

  //---------------------------------------------------------------------
  // compute the surface integral
  //---------------------------------------------------------------------
  pintgr();
}/*end acc data*/
  //---------------------------------------------------------------------
  // verification test
  //---------------------------------------------------------------------
  verify ( rsdnm, errnm, frc, &Class, &verified );
  mflops = (double)itmax * (1984.77 * (double)nx0
      * (double)ny0
      * (double)nz0
      - 10923.3 * pow(((double)(nx0+ny0+nz0)/3.0), 2.0) 
      + 27770.9 * (double)(nx0+ny0+nz0)/3.0
      - 144010.0)
    / (maxtime*1000000.0);

  print_results("LU", Class, nx0,
                ny0, nz0, itmax,
                maxtime, mflops, "          floating point", verified, 
                NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, 
                "(none)");

  //---------------------------------------------------------------------
  // More timers
  //---------------------------------------------------------------------
  if (timeron) {
    for (i = 1; i <= t_last; i++) {
      trecs[i] = timer_read(i);
    }
    tmax = maxtime;
    if (tmax == 0.0) tmax = 1.0;

    printf("  SECTION     Time (secs)\n");
    for (i = 1; i <= t_last; i++) {
      printf("  %-8s:%9.3f  (%6.2f%%)\n",
          t_names[i], trecs[i], trecs[i]*100./tmax);
      if (i == t_rhs) {
        t = trecs[t_rhsx] + trecs[t_rhsy] + trecs[t_rhsz];
        printf("     --> %8s:%9.3f  (%6.2f%%)\n", "sub-rhs", t, t*100./tmax);
        t = trecs[i] - t;
        printf("     --> %8s:%9.3f  (%6.2f%%)\n", "rest-rhs", t, t*100./tmax);
      }
    }
  }

  acc_shutdown(acc_device_default);
  return 0;
}


########## NEXT FILE ##########
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB MG code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS MG code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

//---------------------------------------------------------------------
//  program mg
//---------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include "globals.h"
//#include "randdp.h"
#include "timers.h"
#include "print_results.h"
#include <openacc.h>

#define I3D(array,n1,n2,i3,i2,i1) (array[(i3)*n2*n1 + (i2)*n1 + (i1)])

static void setup(int *n1, int *n2, int *n3);
static void mg3P(double u[], double v[], double r[],
                 double a[4], double c[4], int n1, int n2, int n3);
static void psinv(double *or, double *ou, int n1, int n2, int n3,
                  double c[4], int k);
static void resid(double *ou, double *ov, double *or, int n1, int n2, int n3,
                  double a[4], int k);
static void rprj3(double *or, int m1k, int m2k, int m3k,
                  double *os, int m1j, int m2j, int m3j, int k);
static void interp(double *oz, int mm1, int mm2, int mm3,
                   double *ou, int n1, int n2, int n3, int k);
static void norm2u3(double *or, int n1, int n2, int n3,
                    double *rnm2, double *rnmu,
                    int nx, int ny, int nz);
static void rep_nrm(double *u, int n1, int n2, int n3, char *title, int kk);
static void comm3(double *ou, int n1, int n2, int n3, int kk);
static void zran3(double *oz, int n1, int n2, int n3, int nx, int ny, int k);
static void showall(double *oz, int n1, int n2, int n3);
static double power(double a, int n);
static void bubble(double ten[][2], int j1[][2], int j2[][2], int j3[][2],
                   int m, int ind);
static void zero3(double *oz, int n1, int n2, int n3);


//-------------------------------------------------------------------------c
// These arrays are in common because they are quite large
// and probably shouldn't be allocated on the stack. They
// are always passed as subroutine args. 
//-------------------------------------------------------------------------c
/* commcon /noautom/ */
static double u[NR];
static double v[NR];
static double r[NR];
int gnr = NR;

/* common /grid/ */
static int is1, is2, is3, ie1, ie2, ie3;


int main()
{
  //-------------------------------------------------------------------------c
  // k is the current level. It is passed down through subroutine args
  // and is NOT global. it is the current iteration
  //-------------------------------------------------------------------------c
  int k, it;
  double t, tinit, mflops;

  double a[4], c[4];

  double rnm2, rnmu, old2, oldu, epsilon;
  int n1, n2, n3, nit;
  double nn, verify_value, err;
  logical verified;

  int i;
  char *t_names[T_last];
  double tmax;

  for (i = T_init; i < T_last; i++) {
    timer_clear(i);
  }
  acc_init(acc_device_default);
  timer_start(T_init);

  //---------------------------------------------------------------------
  // Read in and broadcast input data
  //---------------------------------------------------------------------
  FILE *fp;
  if ((fp = fopen("timer.flag", "r")) != NULL) {
    timeron = true;
    t_names[T_init] = "init";
    t_names[T_bench] = "benchmk";
    t_names[T_mg3P] = "mg3P";
    t_names[T_psinv] = "psinv";
    t_names[T_resid] = "resid";
    t_names[T_rprj3] = "rprj3";
    t_names[T_interp] = "interp";
    t_names[T_norm2] = "norm2";
    t_names[T_comm3] = "comm3";
    fclose(fp);
  } else {
    timeron = false;
  }

  printf("\n\n NAS Parallel Benchmarks (NPB3.3-ACC-C) - MG Benchmark\n\n");

  if ((fp = fopen("mg.input", "r")) != NULL) {
    int result;
    printf(" Reading from input file mg.input\n");
    result = fscanf(fp, "%d\n", &lt);
    while (fgetc(fp) != '\n');
    result = fscanf(fp, "%d%d%d", &nx[lt], &ny[lt], &nz[lt]);
    while (fgetc(fp) != '\n');
    result = fscanf(fp, "%d", &nit);
    while (fgetc(fp) != '\n');
    for (i = 0; i <= 7; i++) {
      result = fscanf(fp, "%d", &debug_vec[i]);
    }
    fclose(fp);
  } else {
    printf(" No input file. Using compiled defaults \n");
    lt = LT_DEFAULT;
    nit = NIT_DEFAULT;
    nx[lt] = NX_DEFAULT;
    ny[lt] = NY_DEFAULT;
    nz[lt] = NZ_DEFAULT;
	//  debug_vec[0] = 1;
    for (i = 0; i <= 7; i++) {
      debug_vec[i] = DEBUG_DEFAULT;
    }
  }

  if ( (nx[lt] != ny[lt]) || (nx[lt] != nz[lt]) ) {
    Class = 'U';
  } else if ( nx[lt] == 32 && nit == 4 ) {
    Class = 'S';
  } else if ( nx[lt] == 128 && nit == 4 ) {
    Class = 'W';
  } else if ( nx[lt] == 256 && nit == 4 ) {  
    Class = 'A';
  } else if ( nx[lt] == 256 && nit == 20 ) {
    Class = 'B';
  } else if ( nx[lt] == 512 && nit == 20 ) {  
    Class = 'C';
  } else if ( nx[lt] == 1024 && nit == 50 ) {  
    Class = 'D';
  } else if ( nx[lt] == 2048 && nit == 50 ) {  
    Class = 'E';
  } else {
    Class = 'U';
  }

  //---------------------------------------------------------------------
  // Use these for debug info:
  //---------------------------------------------------------------------
  //    debug_vec(0) = 1 !=> report all norms
  //    debug_vec(1) = 1 !=> some setup information
  //    debug_vec(1) = 2 !=> more setup information
  //    debug_vec(2) = k => at level k or below, show result of resid
  //    debug_vec(3) = k => at level k or below, show result of psinv
  //    debug_vec(4) = k => at level k or below, show result of rprj
  //    debug_vec(5) = k => at level k or below, show result of interp
  //    debug_vec(6) = 1 => (unused)
  //    debug_vec(7) = 1 => (unused)
  //---------------------------------------------------------------------
  a[0] = -8.0/3.0;
  a[1] =  0.0;
  a[2] =  1.0/6.0;
  a[3] =  1.0/12.0;
      
  if (Class == 'A' || Class == 'S' || Class =='W') {
    //---------------------------------------------------------------------
    // Coefficients for the S(a) smoother
    //---------------------------------------------------------------------
    c[0] =  -3.0/8.0;
    c[1] =  +1.0/32.0;
    c[2] =  -1.0/64.0;
    c[3] =   0.0;
  } else {
    //---------------------------------------------------------------------
    // Coefficients for the S(b) smoother
    //---------------------------------------------------------------------
    c[0] =  -3.0/17.0;
    c[1] =  +1.0/33.0;
    c[2] =  -1.0/61.0;
    c[3] =   0.0;
  }
  lb = 1;
  k  = lt;
//  printf("NR=%u\n", NR);

#pragma acc data create(u[0:gnr],v[0:gnr],r[0:gnr])
{
  setup(&n1, &n2, &n3);
  zero3(u, n1, n2, n3);
  zran3(v, n1, n2, n3, nx[lt], ny[lt], k);

  norm2u3(v, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);

  printf(" Size: %4dx%4dx%4d  (class %c)\n", nx[lt], ny[lt], nz[lt], Class);
  printf(" Iterations: %3d\n", nit);
  printf("\n");

  resid(u, v, r, n1, n2, n3, a, k);
  norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
  old2 = rnm2;
  oldu = rnmu;

  //---------------------------------------------------------------------
  // One iteration for startup
  //---------------------------------------------------------------------
  mg3P(u, v, r, a, c, n1, n2, n3);
  resid(u, v, r, n1, n2, n3, a, k);
  setup(&n1, &n2, &n3);
  zero3(u, n1, n2, n3);
  zran3(v, n1, n2, n3, nx[lt], ny[lt], k);

  timer_stop(T_init);
  tinit = timer_read(T_init);

  printf(" Initialization time: %15.3f seconds\n\n", tinit);

  for (i = T_bench; i < T_last; i++) {
    timer_clear(i);
  }

  timer_start(T_bench);

  resid(u, v, r, n1, n2, n3, a, k);
  norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
  old2 = rnm2;
  oldu = rnmu;

  for (it = 1; it <= nit; it++) {
    if ((it == 1) || (it == nit) || ((it % 100) == 0)) {
      printf("  iter %3d\n", it);
    }
    mg3P(u, v, r, a, c, n1, n2, n3);
    resid(u, v, r, n1, n2, n3, a, k);
  }

  norm2u3(r, n1, n2, n3, &rnm2, &rnmu, nx[lt], ny[lt], nz[lt]);
}/*end acc data*/
  timer_stop(T_bench);

  t = timer_read(T_bench);

  verified = false;
  verify_value = 0.0;

  printf("\n Benchmark completed\n");

  epsilon = 1.0e-8;
  if (Class != 'U') {
    if (Class == 'S') {
      verify_value = 0.5307707005734e-04;
    } else if (Class == 'W') {
      verify_value = 0.6467329375339e-05;
    } else if (Class == 'A') {
      verify_value = 0.2433365309069e-05;
    } else if (Class == 'B') {
      verify_value = 0.1800564401355e-05;
    } else if (Class == 'C') {
      verify_value = 0.5706732285740e-06;
    } else if (Class == 'D') {
      verify_value = 0.1583275060440e-09;
    } else if (Class == 'E') {
      verify_value = 0.8157592357404e-10;
    }

    err = fabs( rnm2 - verify_value ) / verify_value;
    // err = fabs( rnm2 - verify_value );
    if (err <= epsilon) {
      verified = true;
      printf(" VERIFICATION SUCCESSFUL\n");
      printf(" L2 Norm is %20.13E\n", rnm2);
      printf(" Error is   %20.13E\n", err);
    } else {
      verified = false;
      printf(" VERIFICATION FAILED\n");
      printf(" L2 Norm is             %20.13E\n", rnm2);
      printf(" The correct L2 Norm is %20.13E\n", verify_value);
    }
  } else {
    verified = false;
    printf(" Problem size unknown\n");
    printf(" NO VERIFICATION PERFORMED\n");
    printf(" L2 Norm is %20.13E\n", rnm2);
  }

  nn = 1.0 * nx[lt] * ny[lt] * nz[lt];

  if (t != 0.0) {
    mflops = 58.0 * nit * nn * 1.0e-6 / t;
  } else {
    mflops = 0.0;
  }

  print_results("MG", Class, nx[lt], ny[lt], nz[lt], 
                nit, t,
                mflops, "          floating point", 
                verified, NPBVERSION, COMPILETIME,
                CS1, CS2, CS3, CS4, CS5, CS6, CS7);

  //---------------------------------------------------------------------
  // More timers
  //---------------------------------------------------------------------
  if (timeron) {
    tmax = timer_read(T_bench);
    if (tmax == 0.0) tmax = 1.0;

    printf("  SECTION   Time (secs)\n");
    for (i = T_bench; i < T_last; i++) {
      t = timer_read(i);
      if (i == T_resid2) {
        t = timer_read(T_resid) - t;
        printf("    --> %8s:%9.3f  (%6.2f%%)\n", "mg-resid", t, t*100./tmax);
      } else {
        printf("  %-8s:%9.3f  (%6.2f%%)\n", t_names[i], t, t*100./tmax);
      }
    }
  }
  acc_shutdown(acc_device_default);
  return 0;
}


static void setup(int *n1, int *n2, int *n3)
{
  int k, j;

  int ax, mi[MAXLEVEL+1][3];
  int ng[MAXLEVEL+1][3];

  ng[lt][0] = nx[lt];
  ng[lt][1] = ny[lt];
  ng[lt][2] = nz[lt];
  for (k = lt-1; k >= 1; k--) {
    for (ax = 0; ax < 3; ax++) {
      ng[k][ax] = ng[k+1][ax]/2;
    }
  }
  for (k = lt; k >= 1; k--) {
    nx[k] = ng[k][0];
    ny[k] = ng[k][1];
    nz[k] = ng[k][2];
  }

  for (k = lt; k >= 1; k--) {
    for (ax = 0; ax < 3; ax++) {
      mi[k][ax] = 2 + ng[k][ax];
    }

    m1[k] = mi[k][0];
    m2[k] = mi[k][1];
    m3[k] = mi[k][2];
  }

  k = lt;
  is1 = 2 + ng[k][0] - ng[lt][0];
  ie1 = 1 + ng[k][0];
  *n1 = 3 + ie1 - is1;
  is2 = 2 + ng[k][1] - ng[lt][1];
  ie2 = 1 + ng[k][1];
  *n2 = 3 + ie2 - is2;
  is3 = 2 + ng[k][2] - ng[lt][2];
  ie3 = 1 + ng[k][2];
  *n3 = 3 + ie3 - is3;

  ir[lt] = 0;
  for (j = lt-1; j >= 1; j--) {
    ir[j] = ir[j+1]+ONE*m1[j+1]*m2[j+1]*m3[j+1];
  }

  if (debug_vec[1] >= 1) {
    printf(" in setup, \n");
    printf(" k  lt  nx  ny  nz  n1  n2  n3 is1 is2 is3 ie1 ie2 ie3\n");
    printf("%4d%4d%4d%4d%4d%4d%4d%4d%4d%4d%4d%4d%4d%4d\n", 
        k,lt,ng[k][0],ng[k][1],ng[k][2],*n1,*n2,*n3,is1,is2,is3,ie1,ie2,ie3);
  }
}


//---------------------------------------------------------------------
// multigrid V-cycle routine
//---------------------------------------------------------------------
static void mg3P(double u[], double v[], double r[],
                 double a[4], double c[4], int n1, int n2, int n3)
{
  int j, k;

  //---------------------------------------------------------------------
  // down cycle.
  // restrict the residual from the find grid to the coarse
  //---------------------------------------------------------------------
  for (k = lt; k >= lb+1; k--) {
    j = k - 1;
    rprj3(&r[ir[k]], m1[k], m2[k], m3[k], 
          &r[ir[j]], m1[j], m2[j], m3[j], k);
  }
  
  k = lb;
  //---------------------------------------------------------------------
  // compute an approximate solution on the coarsest grid
  //---------------------------------------------------------------------
  zero3(&u[ir[k]], m1[k], m2[k], m3[k]);
  psinv(&r[ir[k]], &u[ir[k]], m1[k], m2[k], m3[k], c, k);

  for (k = lb+1; k <= lt-1; k++) {
    j = k - 1;

    //---------------------------------------------------------------------
    // prolongate from level k-1  to k
    //---------------------------------------------------------------------
    zero3(&u[ir[k]], m1[k], m2[k], m3[k]);
    interp(&u[ir[j]], m1[j], m2[j], m3[j], &u[ir[k]], m1[k], m2[k], m3[k], k);

    //---------------------------------------------------------------------
    // compute residual for level k
    //---------------------------------------------------------------------
    resid(&u[ir[k]], &r[ir[k]], &r[ir[k]], m1[k], m2[k], m3[k], a, k);

    //---------------------------------------------------------------------
    // apply smoother
    //---------------------------------------------------------------------
    psinv(&r[ir[k]], &u[ir[k]], m1[k], m2[k], m3[k], c, k);
  }

  j = lt - 1;
  k = lt;
  interp(&u[ir[j]], m1[j], m2[j], m3[j], u, n1, n2, n3, k);
  resid(u, v, r, n1, n2, n3, a, k);
  psinv(r, u, n1, n2, n3, c, k);
}


//---------------------------------------------------------------------
// psinv applies an approximate inverse as smoother:  u = u + Cr
//
// This  implementation costs  15A + 4M per result, where
// A and M denote the costs of Addition and Multiplication.  
// Presuming coefficient c(3) is zero (the NPB assumes this,
// but it is thus not a general case), 2A + 1M may be eliminated,
// resulting in 13A + 3M.
// Note that this vectorizes, and is also fine for cache 
// based machines.  
//---------------------------------------------------------------------
static void psinv(double * __restrict__ or, double * __restrict__ ou, int n1, int n2, int n3, double c[4], int k)
{
/*
  double (*r)[n2][n1] = (double (*)[n2][n1])or;
  double (*u)[n2][n1] = (double (*)[n2][n1])ou;
*/
  int i3, i2, i1;
  double c0, c1, c2;

  //double r1[M], r2[M];
  double * __restrict__ r1, * __restrict__ r2;

  c0 = c[0];
  c1 = c[1];
  c2 = c[2];

  #ifdef _OPENACC
  	r1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
  	r2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
  #else
  	r1 = (double*)malloc(n3*n2*n1*sizeof(double));
  	r2 = (double*)malloc(n3*n2*n1*sizeof(double));
  #endif


  if (timeron) timer_start(T_psinv);
  #pragma acc data deviceptr(r1,r2) \
  		   present(ou[0:n3*n2*n1]) \
		   present(or[0:n3*n2*n1])  
 {
  #pragma acc parallel loop gang num_gangs(n3-2) num_workers(16) vector_length(64)
  for (i3 = 1; i3 < n3-1; i3++) {
    #pragma acc loop worker
    for (i2 = 1; i2 < n2-1; i2++) {
      #pragma acc loop vector
      for (i1 = 0; i1 < n1; i1++) {
	  /*
        r1[i1] = r[i3][i2-1][i1] + r[i3][i2+1][i1]
               + r[i3-1][i2][i1] + r[i3+1][i2][i1];
        r2[i1] = r[i3-1][i2-1][i1] + r[i3-1][i2+1][i1]
               + r[i3+1][i2-1][i1] + r[i3+1][i2+1][i1];
	  */
        I3D(r1, n1, n2, i3, i2, i1) = I3D(or, n1, n2, i3, i2-1, i1) + I3D(or, n1, n2, i3, i2+1, i1)
			   + I3D(or, n1, n2, i3-1, i2, i1) + I3D(or, n1, n2, i3+1, i2, i1);
		I3D(r2, n1, n2, i3, i2, i1) = I3D(or, n1, n2, i3-1, i2-1, i1) + I3D(or, n1, n2, i3-1, i2+1, i1)
			   + I3D(or, n1, n2, i3+1, i2-1, i1) + I3D(or, n1, n2, i3+1, i2+1, i1);

      }
    }
  }
  #pragma acc parallel loop gang num_gangs(n3-2) num_workers(16) vector_length(64)
  for (i3 = 1; i3 < n3-1; i3++) {
    #pragma acc loop worker
    for (i2 = 1; i2 < n2-1; i2++) {
    #pragma acc loop vector
      for (i1 = 1; i1 < n1-1; i1++) {
	  /*
        u[i3][i2][i1] = u[i3][i2][i1]
                      + c[0] * r[i3][i2][i1]
                      + c[1] * ( r[i3][i2][i1-1] + r[i3][i2][i1+1]
                               + r1[i1] )
                      + c[2] * ( r2[i1] + r1[i1-1] + r1[i1+1] );
	  */
		I3D(ou, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2, i1)
									+ c0 * I3D(or, n1, n2, i3, i2, i1)
									+ c1 * ( I3D(or, n1, n2, i3, i2, i1-1)
									         + I3D(or, n1, n2, i3, i2, i1+1)
											 + I3D(r1, n1, n2, i3, i2, i1) )
									+ c2 * ( I3D(r2, n1, n2, i3, i2, i1)
									         + I3D(r1, n1, n2, i3, i2, i1-1)
											 + I3D(r1, n1, n2, i3, i2, i1+1));
								    //+ c[2] * ( r2[i1] + r1[i1-1] + r1[i1+1] );

        //--------------------------------------------------------------------
        // Assume c[3] = 0    (Enable line below if c[3] not= 0)
        //--------------------------------------------------------------------
        //            + c[3] * ( r2[i1-1] + r2[i1+1] )
        //--------------------------------------------------------------------
      }
    }
  }
  }/*end acc parallel*/
  if (timeron) timer_stop(T_psinv);
  #ifdef _OPENACC
  	acc_free(r1);
  	acc_free(r2);
  #else
  	free(r1);
  	free(r2);
  #endif

  //---------------------------------------------------------------------
  // exchange boundary points
  //---------------------------------------------------------------------
  //comm3(u, n1, n2, n3, k);
  comm3(ou, n1, n2, n3, k);

  if (debug_vec[0] >= 1) {
    //rep_nrm(u, n1, n2, n3, "   psinv", k);
    rep_nrm(ou, n1, n2, n3, "   psinv", k);
  }

  if (debug_vec[3] >= k) {
    //showall(u, n1, n2, n3);
    showall(ou, n1, n2, n3);
  }
}


//---------------------------------------------------------------------
// resid computes the residual:  r = v - Au
//
// This  implementation costs  15A + 4M per result, where
// A and M denote the costs of Addition (or Subtraction) and 
// Multiplication, respectively. 
// Presuming coefficient a(1) is zero (the NPB assumes this,
// but it is thus not a general case), 3A + 1M may be eliminated,
// resulting in 12A + 3M.
// Note that this vectorizes, and is also fine for cache 
// based machines.  
//---------------------------------------------------------------------
static void resid(double * ou, double * ov, double * or, int n1, int n2, int n3,
                  double a[4], int k)
{
/*
  double (*u)[n2][n1] = (double (*)[n2][n1])ou;
  double (*v)[n2][n1] = (double (*)[n2][n1])ov;
  double (*r)[n2][n1] = (double (*)[n2][n1])or;
*/
  int i3, i2, i1;
  double a0, a2, a3;
  //double u1[M], u2[M];
  double * __restrict__ u1, * __restrict__ u2;

  a0 = a[0];
  a2 = a[2];
  a3 = a[3];

  if (timeron) timer_start(T_resid);
  #ifdef _OPENACC
  	u1 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
  	u2 = (double*)acc_malloc(n3*n2*n1*sizeof(double));
  #else
  	u1 = (double*)malloc(n3*n2*n1*sizeof(double));
  	u2 = (double*)malloc(n3*n2*n1*sizeof(double));
  #endif

//	printf("n1=%d, n2=%d, n3=%d\n", n1, n2, n3);
  #pragma acc data deviceptr(u1,u2)  \
  		   present(ou[0:n3*n2*n1]) \
		   present(ov[0:n3*n2*n1], or[0:n3*n2*n1])
  {
#pragma acc parallel num_gangs(n3-2) num_workers(8) vector_length(128) 
{ 
  #pragma acc loop gang
  for (i3 = 1; i3 < n3-1; i3++) {
  #pragma acc loop worker
    for (i2 = 1; i2 < n2-1; i2++) {
  #pragma acc loop vector
      for (i1 = 0; i1 < n1; i1++) {
	  /*
        u1[i1] = u[i3][i2-1][i1] + u[i3][i2+1][i1]
               + u[i3-1][i2][i1] + u[i3+1][i2][i1];
        u2[i1] = u[i3-1][i2-1][i1] + u[i3-1][i2+1][i1]
               + u[i3+1][i2-1][i1] + u[i3+1][i2+1][i1];
	  */
        I3D(u1, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3, i2-1, i1) + I3D(ou, n1, n2, i3, i2+1, i1)
               + I3D(ou, n1, n2, i3-1, i2, i1) + I3D(ou, n1, n2, i3+1, i2, i1);
        I3D(u2, n1, n2, i3, i2, i1) = I3D(ou, n1, n2, i3-1, i2-1, i1) + I3D(ou, n1, n2, i3-1, i2+1, i1)
               + I3D(ou, n1, n2, i3+1, i2-1, i1) + I3D(ou, n1, n2, i3+1, i2+1, i1);

      }
    }
  }
}
#pragma acc parallel num_gangs(n3-2) num_workers(8) vector_length(128)
{
  #pragma acc loop gang
  for (i3 = 1; i3 < n3-1; i3++) {
  #pragma acc loop worker
    for (i2 = 1; i2 < n2-1; i2++) {
  #pragma acc loop vector
      for (i1 = 1; i1 < n1-1; i1++) {
	  /*
        r[i3][i2][i1] = v[i3][i2][i1]
                      - a[0] * u[i3][i2][i1]
	  */
		I3D(or, n1, n2, i3, i2, i1) = I3D(ov, n1, n2, i3, i2, i1) 
							 -a0 * I3D(ou, n1, n2, i3, i2, i1)

        //-------------------------------------------------------------------
        //  Assume a[1] = 0      (Enable 2 lines below if a[1] not= 0)
        //-------------------------------------------------------------------
        //            - a[1] * ( u[i3][i2][i1-1] + u[i3][i2][i1+1]
        //                     + u1[i1] )
        //-------------------------------------------------------------------
                     // - a[2] * ( u2[i3][i2][i1] + u1[i3][i2][i1-1] + u1[i3][i2][i1+1] )
                     // - a[3] * ( u2[i3][i2][i1-1] + u2[i3][i2][i1+1] );
					 - a2 * ( I3D(u2, n1, n2, i3, i2, i1) + I3D(u1, n1, n2, i3, i2, i1-1)
					 			+ I3D(u1, n1, n2, i3, i2, i1+1))
					 - a3 * ( I3D(u2, n1, n2, i3, i2, i1-1) + I3D(u2, n1, n2, i3, i2, i1+1));
      }
    }
  }
  } /*end acc parallel */
  } /*end acc data */
  
  #ifdef _OPENACC
  	acc_free(u1);
  	acc_free(u2);
  #else
  	free(u1);
  	free(u2);
  #endif
  if (timeron) timer_stop(T_resid);

  //---------------------------------------------------------------------
  // exchange boundary data
  //---------------------------------------------------------------------
  //comm3(r, n1, n2, n3, k);
  comm3(or, n1, n2, n3, k);

  if (debug_vec[0] >= 1) {
    //rep_nrm(r, n1, n2, n3, "   resid", k);
    rep_nrm(or, n1, n2, n3, "   resid", k);
  }

  if (debug_vec[2] >= k) {
    //showall(r, n1, n2, n3);
    showall(or, n1, n2, n3);
  }
}


//---------------------------------------------------------------------
// rprj3 projects onto the next coarser grid, 
// using a trilinear Finite Element projection:  s = r' = P r
//     
// This  implementation costs  20A + 4M per result, where
// A and M denote the costs of Addition and Multiplication.  
// Note that this vectorizes, and is also fine for cache 
// based machines.  
//---------------------------------------------------------------------
static void rprj3(double *or, int m1k, int m2k, int m3k,
                  double *os, int m1j, int m2j, int m3j, int k)
{
/*
  double (*r)[m2k][m1k] = (double (*)[m2k][m1k])or;
  double (*s)[m2j][m1j] = (double (*)[m2j][m1j])os;
*/
  int j3, j2, j1, i3, i2, i1, d1, d2, d3, j;

  //double x1[M], y1[M], x2, y2;
  double *x1, *y1, x2, y2;
  #ifdef _OPENACC
  	x1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
  	y1 = (double*)acc_malloc(m3k*m2k*m1k*sizeof(double));
  #else
  	x1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
  	y1 = (double*)malloc(m3k*m2k*m1k*sizeof(double));
  #endif

  if (timeron) timer_start(T_rprj3);
  if (m1k == 3) {
    d1 = 2;
  } else {
    d1 = 1;
  }

  if (m2k == 3) {
    d2 = 2;
  } else {
    d2 = 1;
  }

  if (m3k == 3) {
    d3 = 2;
  } else {
    d3 = 1;
  }

  #pragma acc data deviceptr(x1,y1) \
  		   present(or[0:m3k*m2k*m1k]) \
		   present(os[0:m3j*m2j*m1j])
  {
  #pragma acc parallel loop gang num_gangs(m3j-2) num_workers(8) vector_length(128)
  for (j3 = 1; j3 < m3j-1; j3++) {
    i3 = 2*j3-d3;
      #pragma acc loop worker
    for (j2 = 1; j2 < m2j-1; j2++) {
      i2 = 2*j2-d2;
      #pragma acc loop vector
      for (j1 = 1; j1 < m1j; j1++) {
        i1 = 2*j1-d1;
		/*
        x1[i1] = r[i3+1][i2  ][i1] + r[i3+1][i2+2][i1]
               + r[i3  ][i2+1][i1] + r[i3+2][i2+1][i1];
        y1[i1] = r[i3  ][i2  ][i1] + r[i3+2][i2  ][i1]
               + r[i3  ][i2+2][i1] + r[i3+2][i2+2][i1];
	    */
		I3D(x1, m1k, m2k, i3, i2, i1) = I3D(or, m1k, m2k, i3+1, i2, i1) + I3D(or, m1k, m2k, i3+1, i2+2, i1)
		       + I3D(or, m1k, m2k, i3, i2+1, i1) + I3D(or, m1k, m2k, i3+2, i2+1, i1);
		I3D(y1, m1k, m2k, i3, i2, i1) = I3D(or, m1k, m2k, i3, i2, i1)   + I3D(or, m1k, m2k, i3+2, i2, i1)
		       + I3D(or, m1k, m2k, i3, i2+2, i1) + I3D(or, m1k, m2k, i3+2, i2+2, i1);
				
      }
    }
  }
  #pragma acc parallel loop gang num_gangs(m3j-2) num_workers(8) vector_length(128)
  for (j3 = 1; j3 < m3j-1; j3++) {
    i3 = 2*j3-d3;
      #pragma acc loop worker
    for (j2 = 1; j2 < m2j-1; j2++) {
      i2 = 2*j2-d2;
      #pragma acc loop vector
      for (j1 = 1; j1 < m1j-1; j1++) {
        i1 = 2*j1-d1;
		/*
        y2 = r[i3  ][i2  ][i1+1] + r[i3+2][i2  ][i1+1]
           + r[i3  ][i2+2][i1+1] + r[i3+2][i2+2][i1+1];
        x2 = r[i3+1][i2  ][i1+1] + r[i3+1][i2+2][i1+1]
           + r[i3  ][i2+1][i1+1] + r[i3+2][i2+1][i1+1];
        s[j3][j2][j1] =
                0.5 * r[i3+1][i2+1][i1+1]
              + 0.25 * (r[i3+1][i2+1][i1] + r[i3+1][i2+1][i1+2] + x2)
              + 0.125 * (x1[i1] + x1[i1+2] + y2)
              + 0.0625 * (y1[i1] + y1[i1+2]);
	    */
		y2 = I3D(or, m1k, m2k, i3, i2, i1+1)   + I3D(or, m1k, m2k, i3+2, i2, i1+1)
		   + I3D(or, m1k, m2k, i3, i2+2, i1+1) + I3D(or, m1k, m2k, i3+2, i2+2, i1+1);
		x2 = I3D(or, m1k, m2k, i3+1, i2, i1+1) + I3D(or, m1k, m2k, i3+1, i2+2, i1+1)
		   + I3D(or, m1k, m2k, i3, i2+1, i1+1) + I3D(or, m1k, m2k, i3+2, i2+1, i1+1);
		I3D(os, m1j, m2j, j3, j2, j1) = 
				0.5 * I3D(or, m1k, m2k, i3+1, i2+1, i1+1)
			  + 0.25 * (I3D(or, m1k, m2k, i3+1, i2+1, i1) + I3D(or, m1k, m2k, i3+1, i2+1, i1+2) + x2)
              + 0.125 * ( I3D(x1, m1k, m2k, i3, i2, i1)+ I3D(x1, m1k, m2k, i3, i2, i1+2) + y2)
              + 0.0625 * (I3D(y1, m1k, m2k, i3, i2, i1) + I3D(y1, m1k, m2k, i3, i2, i1+2));
      }
    }
  }
  }/*end acc parallel*/
  if (timeron) timer_stop(T_rprj3);

  j = k-1;
  //comm3(s, m1j, m2j, m3j, j);
  comm3(os, m1j, m2j, m3j, j);

  if (debug_vec[0] >= 1) {
    //rep_nrm(s, m1j, m2j, m3j, "   rprj3", k-1);
    rep_nrm(os, m1j, m2j, m3j, "   rprj3", k-1);
  }

  if (debug_vec[4] >= k) {
    //showall(s, m1j, m2j, m3j);
    showall(os, m1j, m2j, m3j);
  }
  #ifdef _OPENACC
  	acc_free(x1);
  	acc_free(y1);
  #else
  	free(x1);
	free(y1);
  #endif
}


//---------------------------------------------------------------------
// interp adds the trilinear interpolation of the correction
// from the coarser grid to the current approximation:  u = u + Qu'
//     
// Observe that this  implementation costs  16A + 4M, where
// A and M denote the costs of Addition and Multiplication.  
// Note that this vectorizes, and is also fine for cache 
// based machines.  Vector machines may get slightly better 
// performance however, with 8 separate "do i1" loops, rather than 4.
//---------------------------------------------------------------------
static void interp(double *oz, int mm1, int mm2, int mm3,
                   double *ou, int n1, int n2, int n3, int k)
{
/*
  double (*z)[mm2][mm1] = (double (*)[mm2][mm1])oz;
  double (*u)[n2][n1] = (double (*)[n2][n1])ou;
*/
  int i3, i2, i1, d1, d2, d3, t1, t2, t3;

  // note that m = 1037 in globals.h but for this only need to be
  // 535 to handle up to 1024^3
  //      integer m
  //      parameter( m=535 )
  //double z1[M], z2[M], z3[M];
  static double *z1, *z2, *z3;

  #ifdef _OPENACC
	//if(z1==NULL)
  	z1 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
	//if(z2==NULL)
  	z2 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
	//if(z3 == NULL)
  	z3 = (double*)acc_malloc(mm3*mm2*mm1*sizeof(double));
  #else
  	z1 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
  	z2 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
  	z3 = (double*)malloc(mm3*mm2*mm1*sizeof(double));
  #endif

  if (timeron) timer_start(T_interp);

  #pragma acc data deviceptr(z1,z2,z3) \
  		   present(oz[0:mm3*mm2*mm1]) \
		   present(ou[0:n3*n2*n1])
  {

  if (n1 != 3 && n2 != 3 && n3 != 3) {

    #pragma acc parallel loop gang num_gangs(mm3-1) num_workers(8) vector_length(128)
    for (i3 = 0; i3 < mm3-1; i3++) {
    #pragma acc loop worker
      for (i2 = 0; i2 < mm2-1; i2++) {
        #pragma acc loop vector
        for (i1 = 0; i1 < mm1; i1++) {
		/*
          z1[i1] = z[i3][i2+1][i1] + z[i3][i2][i1];
          z2[i1] = z[i3+1][i2][i1] + z[i3][i2][i1];
          z3[i1] = z[i3+1][i2+1][i1] + z[i3+1][i2][i1] + z1[i1];
		*/
          I3D(z1, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3, i2+1, i1)   
		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
		  I3D(z2, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2, i1)   
		  								+ I3D(oz, mm1, mm2, i3, i2, i1);
		  I3D(z3, mm1, mm2, i3, i2, i1) = I3D(oz, mm1, mm2, i3+1, i2+1, i1) 
		  								+ I3D(oz, mm1, mm2, i3+1, i2, i1)
										+ I3D(z1, mm1, mm2, i3, i2, i1);

        }
      }
    }
#pragma acc parallel loop gang num_gangs(mm3-1) num_workers(8) vector_length(128)
    for (i3 = 0; i3 < mm3-1; i3++) {
    #pragma acc loop worker
      for (i2 = 0; i2 < mm2-1; i2++) {
	  #pragma acc loop vector
        for (i1 = 0; i1 < mm1-1; i1++) {
		/*
          u[2*i3][2*i2][2*i1] = u[2*i3][2*i2][2*i1]
                              + z[i3][i2][i1];
          u[2*i3][2*i2][2*i1+1] = u[2*i3][2*i2][2*i1+1]
                                + 0.5 * (z[i3][i2][i1+1] + z[i3][i2][i1]);
	    */
		  I3D(ou, n1, n2, 2*i3, 2*i2, 2*i1)   = I3D(ou, n1, n2, 2*i3, 2*i2, 2*i1)
		  									  + I3D(oz, mm1, mm2, i3, i2, i1);
		  I3D(ou, n1, n2, 2*i3, 2*i2, 2*i1+1) = I3D(ou, n1, n2, 2*i3, 2*i2, 2*i1+1)
		  									  + 0.5*(I3D(oz, mm1, mm2, i3, i2, i1+1)
											       + I3D(oz, mm1, mm2, i3, i2, i1));
        }
      }
    }

#pragma acc parallel loop gang num_gangs(mm3-1) num_workers(8) vector_length(128)
    for (i3 = 0; i3 < mm3-1; i3++) {
    #pragma acc loop worker
      for (i2 = 0; i2 < mm2-1; i2++) {
        #pragma acc loop vector
        for (i1 = 0; i1 < mm1-1; i1++) {
		/*
          u[2*i3][2*i2+1][2*i1] = u[2*i3][2*i2+1][2*i1]
                                + 0.5 * z1[i1];
          u[2*i3][2*i2+1][2*i1+1] = u[2*i3][2*i2+1][2*i1+1]
                                  + 0.25 * (z1[i1] + z1[i1+1]);
	    */
		  I3D(ou, n1, n2, 2*i3, 2*i2+1, 2*i1) = I3D(ou, n1, n2, 2*i3, 2*i2+1, 2*i1)
											+ 0.5 * I3D(z1, mm1, mm2, i3, i2, i1);
		  I3D(ou, n1, n2, 2*i3, 2*i2+1, 2*i1+1) = I3D(ou, n1, n2, 2*i3, 2*i2+1, 2*i1+1)
		  										+ 0.25 * (I3D(z1, mm1, mm2, i3, i2, i1)
														+ I3D(z1, mm1, mm2, i3, i2, i1+1));
        }
      }
    }
#pragma acc parallel loop gang num_gangs(mm3-1) num_workers(8) vector_length(128)
    for (i3 = 0; i3 < mm3-1; i3++) {
    #pragma acc loop worker
      for (i2 = 0; i2 < mm2-1; i2++) {
	    #pragma acc loop vector
        for (i1 = 0; i1 < mm1-1; i1++) {
		/*
          u[2*i3+1][2*i2][2*i1] = u[2*i3+1][2*i2][2*i1]
                                  + 0.5 * z2[i1];
          u[2*i3+1][2*i2][2*i1+1] = u[2*i3+1][2*i2][2*i1+1]
                                  + 0.25 * (z2[i1] + z2[i1+1]);
		*/
		  I3D(ou, n1, n2, 2*i3+1, 2*i2, 2*i1) = I3D(ou, n1, n2, 2*i3+1, 2*i2, 2*i1)
		  									  + 0.5 * I3D(z2, mm1, mm2, i3, i2, i1);
		  I3D(ou, n1, n2, 2*i3+1, 2*i2, 2*i1+1) = I3D(ou, n1, n2, 2*i3+1, 2*i2, 2*i1+1)
		  										+ 0.25 * (I3D(z2, mm1, mm2, i3, i2, i1)
														+ I3D(z2, mm1, mm2, i3, i2, i1+1));
         }
       }
     }
 
#pragma acc parallel loop gang num_gangs(mm3-1) num_workers(8) vector_length(128)
    for (i3 = 0; i3 < mm3-1; i3++) {
    #pragma acc loop worker
      for (i2 = 0; i2 < mm2-1; i2++) {
	   #pragma acc loop vector
        for (i1 = 0; i1 < mm1-1; i1++) {
		/*
          u[2*i3+1][2*i2+1][2*i1] = u[2*i3+1][2*i2+1][2*i1]
                                  + 0.25 * z3[i1];
          u[2*i3+1][2*i2+1][2*i1+1] = u[2*i3+1][2*i2+1][2*i1+1]
                                    + 0.125 * (z3[i1] + z3[i1+1]);
		*/
		  I3D(ou, n1, n2, 2*i3+1, 2*i2+1, 2*i1) = I3D(ou, n1, n2, 2*i3+1, 2*i2+1, 2*i1)
		  										+ 0.25 * I3D(z3, mm1, mm2, i3, i2, i1);
		  I3D(ou, n1, n2, 2*i3+1, 2*i2+1, 2*i1+1) = I3D(ou, n1, n2, 2*i3+1, 2*i2+1, 2*i1+1)
		  										  + 0.125 * (I3D(z3, mm1, mm2, i3, i2, i1)
												  		   + I3D(z3, mm1, mm2, i3, i2, i1+1));
        }
      }
    }
  } else {
    if (n1 == 3) {
      d1 = 2;
      t1 = 1;
    } else {
      d1 = 1;
      t1 = 0;
    }

    if (n2 == 3) {
      d2 = 2;
      t2 = 1;
    } else {
      d2 = 1;
      t2 = 0;
    }

    if (n3 == 3) {
      d3 = 2;
      t3 = 1;
    } else {
      d3 = 1;
      t3 = 0;
    }

    #pragma acc parallel loop gang num_gangs(mm3-d3) num_workers(8) vector_length(128)
    for (i3 = d3; i3 <= mm3-1; i3++) {
    #pragma acc loop worker
      for (i2 = d2; i2 <= mm2-1; i2++) {
        #pragma acc loop vector
        for (i1 = d1; i1 <= mm1-1; i1++) {
		/*
          u[2*i3-d3-1][2*i2-d2-1][2*i1-d1-1] = 
            u[2*i3-d3-1][2*i2-d2-1][2*i1-d1-1]
            + z[i3-1][i2-1][i1-1];
		*/
		 I3D(ou, n1, n2, 2*i3-d3-1, 2*i2-d2-1, 2*i1-d1-1) = 
		 	I3D(ou, n1, n2, 2*i3-d3-1, 2*i2-d2-1, 2*i1-d1-1)
			+ I3D(ou, mm1, mm2, i3-1, i2-1, i1-1);
        }
       }
    }
    #pragma acc parallel loop gang num_gangs(mm3-d3) num_workers(8) vector_length(128)
    for (i3 = d3; i3 <= mm3-1; i3++) {
    #pragma acc loop worker
      for (i2 = d2; i2 <= mm2-1; i2++) {
        #pragma acc loop vector
        for (i1 = 1; i1 <= mm1-1; i1++) {
		/*
          u[2*i3-d3-1][2*i2-d2-1][2*i1-t1-1] = 
            u[2*i3-d3-1][2*i2-d2-1][2*i1-t1-1]
            + 0.5 * (z[i3-1][i2-1][i1] + z[i3-1][i2-1][i1-1]);
		*/
		  I3D(ou, n1, n2, 2*i3-d3-1, 2*i2-d2-1, 2*i1-t1-1) = 
		  	I3D(ou, n1, n2, 2*i3-d3-1, 2*i2-d2-1, 2*i1-t1-1)
			+ 0.5 * (I3D(oz, mm1, mm2, i3-1, i2-1, i1) 
				   + I3D(oz, mm1, mm2, i3-1, i2-1, i1-1));
        }
      }
    }
    #pragma acc parallel loop gang num_gangs(mm3-d3) num_workers(8) vector_length(128)
    for (i3 = d3; i3 <= mm3-1; i3++) {
      #pragma acc loop worker
      for (i2 = 1; i2 <= mm2-1; i2++) {
        #pragma acc loop vector
        for (i1 = d1; i1 <= mm1-1; i1++) {
		/*
          u[2*i3-d3-1][2*i2-t2-1][2*i1-d1-1] = 
            u[2*i3-d3-1][2*i2-t2-1][2*i1-d1-1]
            + 0.5 * (z[i3-1][i2][i1-1] + z[i3-1][i2-1][i1-1]);
		*/
		  I3D(ou, n1, n2, 2*i3-d3-1, 2*i2-t2-1, 2*i1-d1-1) = 
		    I3D(ou, n1, n2, 2*i3-d3-1, 2*i2-t2-1, 2*i1-d1-1)
			+ 0.5 * (I3D(oz, mm1, mm2, i3-1, i2,   i1-1)
				   + I3D(oz, mm1, mm2, i3-1, i2-1, i1-1));
        }
	  }
	 }
    #pragma acc parallel loop gang num_gangs(mm3-d3) num_workers(8) vector_length(128)
    for (i3 = d3; i3 <= mm3-1; i3++) {
      #pragma acc loop worker
      for (i2 = 1; i2 <= mm2-1; i2++) {
        #pragma acc loop vector
        for (i1 = 1; i1 <= mm1-1; i1++) {
		/*
          u[2*i3-d3-1][2*i2-t2-1][2*i1-t1-1] = 
            u[2*i3-d3-1][2*i2-t2-1][2*i1-t1-1]
            + 0.25 * (z[i3-1][i2][i1] + z[i3-1][i2-1][i1]
                    + z[i3-1][i2][i1-1] + z[i3-1][i2-1][i1-1]);
		*/
		  I3D(ou, n1, n2, 2*i3-d3-1, 2*i2-t2-1, 2*i1-t1-1) = 
		    I3D(ou, n1, n2, 2*i3-d3-1, 2*i2-t2-1, 2*i1-t1-1)
			+ 0.25 * (I3D(oz, mm1, mm2, i3-1, i2,   i1)
			        + I3D(oz, mm1, mm2, i3-1, i2-1, i1)
					+ I3D(oz, mm1, mm2, i3-1, i2,   i1-1)
					+ I3D(oz, mm1, mm2, i3-1, i2-1, i1-1));
        }
      }
    }

    #pragma acc parallel loop gang num_gangs(mm3-1) num_workers(8) vector_length(128)
    for (i3 = 1; i3 <= mm3-1; i3++) {
      #pragma acc loop worker
      for (i2 = d2; i2 <= mm2-1; i2++) {
	#pragma acc loop vector
        for (i1 = d1; i1 <= mm1-1; i1++) {
		/*
          u[2*i3-t3-1][2*i2-d2-1][2*i1-d1-1] = 
            u[2*i3-t3-1][2*i2-d2-1][2*i1-d1-1]
            + 0.5 * (z[i3][i2-1][i1-1] + z[i3-1][i2-1][i1-1]);
		*/
		  I3D(ou, n1, n2, 2*i3-t3-1, 2*i2-d2-1, 2*i1-d1-1) =
		    I3D(ou, n1, n2, 2*i3-t3-1, 2*i2-d2-1, 2*i1-d1-1)
			+ 0.5 * (I3D(oz, mm1, mm2, i3,   i2-1, i1-1)
			       + I3D(oz, mm1, mm2, i3-1, i2-1, i1-1));
        }
      }
    }
    #pragma acc parallel loop gang num_gangs(mm3-1) num_workers(8) vector_length(128)
    for (i3 = 1; i3 <= mm3-1; i3++) {
      #pragma acc loop worker
      for (i2 = d2; i2 <= mm2-1; i2++) {
	#pragma acc loop vector
        for (i1 = 1; i1 <= mm1-1; i1++) {
		/*
          u[2*i3-t3-1][2*i2-d2-1][2*i1-t1-1] = 
            u[2*i3-t3-1][2*i2-d2-1][2*i1-t1-1]
            + 0.25 * (z[i3  ][i2-1][i1] + z[i3  ][i2-1][i1-1]
                    + z[i3-1][i2-1][i1] + z[i3-1][i2-1][i1-1]);
		*/
		  I3D(ou, n1, n2, 2*i3-t3-1, 2*i2-d2-1, 2*i1-t1-1) =
		    I3D(ou, n1, n2, 2*i3-t3-1, 2*i2-d2-1, 2*i1-t1-1)
			+ 0.25 * (I3D(oz, mm1, mm2, i3,   i2-1, i1)
			        + I3D(oz, mm1, mm2, i3,   i2-1, i1-1)
					+ I3D(oz, mm1, mm2, i3-1, i2-1, i1)
					+ I3D(oz, mm1, mm2, i3-1, i2-1, i1-1));
        }
      }
    }
    #pragma acc parallel loop gang num_gangs(mm3-1) num_workers(8) vector_length(128)
    for (i3 = 1; i3 <= mm3-1; i3++) {
      #pragma acc loop worker
      for (i2 = 1; i2 <= mm2-1; i2++) {
	#pragma acc loop vector
        for (i1 = d1; i1 <= mm1-1; i1++) {
		/*
          u[2*i3-t3-1][2*i2-t2-1][2*i1-d1-1] = 
            u[2*i3-t3-1][2*i2-t2-1][2*i1-d1-1]
            + 0.25 * (z[i3  ][i2][i1-1] + z[i3  ][i2-1][i1-1]
                    + z[i3-1][i2][i1-1] + z[i3-1][i2-1][i1-1]);
		*/
		  I3D(ou, n1, n2, 2*i3-t3-1, 2*i2-t2-1, 2*i1-d1-1) = 
		    I3D(ou, n1, n2, 2*i3-t3-1, 2*i2-t2-1, 2*i1-d1-1)
			+ 0.25 * (I3D(oz, mm1, mm2, i3,   i2,   i1-1)
			        + I3D(oz, mm1, mm2, i3,   i2-1, i1-1)
					+ I3D(oz, mm1, mm2, i3-1, i2,   i1-1)
					+ I3D(oz, mm1, mm2, i3-1, i2-1, i1-1));
        }
       }
     }
    #pragma acc parallel loop gang num_gangs(mm3-1) num_workers(8) vector_length(128)
    for (i3 = 1; i3 <= mm3-1; i3++) {
      #pragma acc loop worker
      for (i2 = 1; i2 <= mm2-1; i2++) {
	#pragma acc loop vector
        for (i1 = 1; i1 <= mm1-1; i1++) {
		/*
          u[2*i3-t3-1][2*i2-t2-1][2*i1-t1-1] = 
            u[2*i3-t3-1][2*i2-t2-1][2*i1-t1-1]
            + 0.125 * (z[i3  ][i2][i1  ] + z[i3  ][i2-1][i1  ]
                     + z[i3  ][i2][i1-1] + z[i3  ][i2-1][i1-1]
                     + z[i3-1][i2][i1  ] + z[i3-1][i2-1][i1  ]
                     + z[i3-1][i2][i1-1] + z[i3-1][i2-1][i1-1]);
		*/
		  I3D(ou, n1, n2, 2*i3-t3-1, 2*i2-t2-1, 2*i1-t1-1) = 
		    I3D(ou, n1, n2, 2*i3-t3-1, 2*i2-t2-1, 2*i1-t1-1)
			+ 0.125 * (I3D(oz, mm1, mm2, i3,   i2,   i1)
			         + I3D(oz, mm1, mm2, i3,   i2-1, i1)
					 + I3D(oz, mm1, mm2, i3,   i2,   i1-1)
					 + I3D(oz, mm1, mm2, i3,   i2-1, i1-1)
					 + I3D(oz, mm1, mm2, i3-1, i2,   i1)
					 + I3D(oz, mm1, mm2, i3-1, i2-1, i1)
					 + I3D(oz, mm1, mm2, i3-1, i2,   i1-1)
					 + I3D(oz, mm1, mm2, i3-1, i2-1, i1-1));
        }
      }
    }

  }
   }/*end acc data */

  #ifdef _OPENACC
  	acc_free(z1);
  	acc_free(z2);
  	acc_free(z3);
  #else
  	free(z1);
	free(z2);
	free(z3);
  #endif
  if (timeron) timer_stop(T_interp);

  if (debug_vec[0] >= 1) {
    //rep_nrm(z, mm1, mm2, mm3, "z: inter", k-1);
    //rep_nrm(u, n1, n2, n3, "u: inter", k);
    rep_nrm(oz, mm1, mm2, mm3, "z: inter", k-1);
    rep_nrm(ou, n1, n2, n3, "u: inter", k);
  }

  if (debug_vec[5] >= k) {
    //showall(z, mm1, mm2, mm3);
    //showall(u, n1, n2, n3);
    showall(oz, mm1, mm2, mm3);
    showall(ou, n1, n2, n3);
  }
}


//---------------------------------------------------------------------
// norm2u3 evaluates approximations to the L2 norm and the
// uniform (or L-infinity or Chebyshev) norm, under the
// assumption that the boundaries are periodic or zero.  Add the
// boundaries in with half weight (quarter weight on the edges
// and eighth weight at the corners) for inhomogeneous boundaries.
//---------------------------------------------------------------------
static void norm2u3(double *or, int n1, int n2, int n3,
                    double *rnm2, double *rnmu,
                    int nx, int ny, int nz)
{
  //double (*r)[n2][n1] = (double (*)[n2][n1])or;

  double s, a;
  double temp;
  int i3, i2, i1;

  double dn;

  if (timeron) timer_start(T_norm2);
  dn = 1.0*nx*ny*nz;

  s = 0.0;
  *rnmu = 0.0;
  temp = *rnmu;
#pragma acc data pcopyin(or[0:n3*n2*n1])
{
 #pragma acc parallel loop gang reduction(+:s) reduction(max:temp) \
                    num_gangs(n3-2) num_workers(8) vector_length(128)
  for (i3 = 1; i3 < n3-1; i3++) {
   #pragma acc loop worker
    for (i2 = 1; i2 < n2-1; i2++) {
     #pragma acc loop vector 
      for (i1 = 1; i1 < n1-1; i1++) {
        //s = s + pow(r[i3][i2][i1], 2.0);
        //a = fabs(r[i3][i2][i1]);
        s = s + pow(I3D(or, n1, n2, i3, i2, i1), 2.0);
        a = fabs(I3D(or, n1, n2, i3, i2, i1));
        //if (a > temp) temp = a;
        temp = max(temp, a);
      }
    }
  }
}/*end acc data*/
  *rnmu = temp;
  *rnm2 = sqrt(s / dn);
  if (timeron) timer_stop(T_norm2);
}


//---------------------------------------------------------------------
// report on norm
//---------------------------------------------------------------------
static void rep_nrm(double *u, int n1, int n2, int n3, char *title, int kk)
{
  double rnm2, rnmu;

  norm2u3(u, n1, n2, n3, &rnm2, &rnmu, nx[kk], ny[kk], nz[kk]);
  printf(" Level%2d in %8s: norms =%21.14E%21.14E\n", kk, title, rnm2, rnmu);
}


//---------------------------------------------------------------------
// comm3 organizes the communication on all borders 
//---------------------------------------------------------------------
static void comm3(double *ou, int n1, int n2, int n3, int kk)
{
//  double (*u)[n2][n1] = (double (*)[n2][n1])ou;

  int i1, i2, i3;
  if (timeron) timer_start(T_comm3);
  #pragma acc data present(ou[0:n3*n2*n1])
  {
  #pragma acc parallel loop gang num_gangs(n3-2) vector_length(128)
  for (i3 = 1; i3 < n3-1; i3++) {
    #pragma acc loop vector
    for (i2 = 1; i2 < n2-1; i2++) {
	/*
      u[i3][i2][   0] = u[i3][i2][n1-2];
      u[i3][i2][n1-1] = u[i3][i2][   1];
	*/
	  I3D(ou, n1, n2, i3, i2, 0)    = I3D(ou, n1, n2, i3, i2, n1-2);
	  I3D(ou, n1, n2, i3, i2, n1-1) = I3D(ou, n1, n2, i3, i2, 1);
    }
  }

  #pragma acc parallel loop gang num_gangs(n3-2) vector_length(128)
  for (i3 = 1; i3 < n3-1; i3++) {
    #pragma acc loop vector
    for (i1 = 0; i1 < n1; i1++) {
	/*
      u[i3][   0][i1] = u[i3][n2-2][i1];
      u[i3][n2-1][i1] = u[i3][   1][i1];
	*/
	 I3D(ou, n1, n2, i3, 0, i1)    = I3D(ou, n1, n2, i3, n2-2, i1);
	 I3D(ou, n1, n2, i3, n2-1, i1) = I3D(ou, n1, n2, i3, 1, i1);
    }
  }

  #pragma acc parallel loop gang num_gangs(n2) vector_length(128)
  for (i2 = 0; i2 < n2; i2++) {
    #pragma acc loop vector
    for (i1 = 0; i1 < n1; i1++) {
	/*
      u[   0][i2][i1] = u[n3-2][i2][i1];
      u[n3-1][i2][i1] = u[   1][i2][i1];
	*/
	  I3D(ou, n1, n2, 0, i2, i1) = I3D(ou, n1, n2, n3-2, i2, i1);
	  I3D(ou, n1, n2, n3-1, i2, i1) = I3D(ou, n1, n2, 1, i2, i1);
    }
  }
  } /* end acc data */
  if (timeron) timer_stop(T_comm3);
}


inline double randlc( double *x, double a )
{
  const double r23 = 1.1920928955078125e-07;
  const double r46 = r23 * r23;
  const double t23 = 8.388608e+06;
  const double t46 = t23 * t23;

  double t1, t2, t3, t4, a1, a2, x1, x2, z;
  double r;
  t1 = r23 * a;
  a1 = (int) t1;
  a2 = a - t23 * a1;
  
  t1 = r23 * (*x);
  x1 = (int) t1;
  x2 = *x - t23 * x1;
  t1 = a1 * x2 + a2 * x1;
  t2 = (int) (r23 * t1);
  z = t1 - t23 * t2;
  t3 = t23 * z + a2 * x2;
  t4 = (int) (r46 * t3);
  *x = t3 - t46 * t4;
  r = r46 * (*x);
  
  return r;
}

inline void vranlc( int n, double *x, double a, double y[] )
{
	
  const double r23 = 1.1920928955078125e-07;
  const double r46 = r23 * r23;
  const double t23 = 8.388608e+06;
  const double t46 = t23 * t23;

  double t1, t2, t3, t4, a1, a2, x1, x2, z;

  int i;
  t1 = r23 * a;
  a1 = (int) t1;
  a2 = a - t23 * a1;
  for ( i = 0; i < n; i++ ) {
    t1 = r23 * (*x);
    x1 = (int) t1;
    x2 = *x - t23 * x1;
    t1 = a1 * x2 + a2 * x1;
    t2 = (int) (r23 * t1);
    z = t1 - t23 * t2;
    t3 = t23 * z + a2 * x2;
    t4 = (int) (r46 * t3) ;
    *x = t3 - t46 * t4;
    y[i] = r46 * (*x);
  }
}

//---------------------------------------------------------------------
// zran3  loads +1 at ten randomly chosen points,
// loads -1 at a different ten random points,
// and zero elsewhere.
//---------------------------------------------------------------------
static void zran3(double *oz, int n1, int n2, int n3, int nx, int ny, int k)
{
  //double (*z)[n2][n1] = (double (*)[n2][n1])oz;

  int i0, m0, m1;

  int i1, i2, i3, d1, e1, e2, e3;
  double xx, x0, x1, a1, a2, ai;

  const int mm = 10;
  const double a = pow(5.0, 13.0);
  const double x = 314159265.0;
  double ten[mm][2], best;
  int i, j1[mm][2], j2[mm][2], j3[mm][2];
  int jg[4][mm][2];

  double rdummy;

  a1 = power(a, nx);
  a2 = power(a, nx*ny);

  //zero3(z, n1, n2, n3);
  zero3(oz, n1, n2, n3);
  //#pragma acc update host(oz[0:n3*n2*n1])
  i = is1-2+nx*(is2-2+ny*(is3-2));

  ai = power(a, i);
  d1 = ie1 - is1 + 1;
  e1 = ie1 - is1 + 2;
  e2 = ie2 - is2 + 2;
  e3 = ie3 - is3 + 2;
  x0 = x;
  rdummy = randlc(&x0, ai);

  for (i3 = 1; i3 < e3; i3++) {
    x1 = x0;
    for (i2 = 1; i2 < e2; i2++) {
      xx = x1;
      //vranlc(d1, &xx, a, &(z[i3][i2][1]));
      vranlc(d1, &xx, a, &(I3D(oz, n1, n2, i3, i2, 1)));
      rdummy = randlc(&x1,a1);
    }
    rdummy = randlc(&x0, a2);
  }

  //---------------------------------------------------------------------
  // comm3(z,n1,n2,n3);
  // showall(z,n1,n2,n3);
  //---------------------------------------------------------------------

  //---------------------------------------------------------------------
  // each processor looks for twenty candidates
  //---------------------------------------------------------------------
  for (i = 0; i < mm; i++) {
    ten[i][1] = 0.0;
    j1[i][1] = 0;
    j2[i][1] = 0;
    j3[i][1] = 0;
    ten[i][0] = 1.0;
    j1[i][0] = 0;
    j2[i][0] = 0;
    j3[i][0] = 0;
  }
  
  for (i3 = 1; i3 < n3-1; i3++) {
    for (i2 = 1; i2 < n2-1; i2++) {
      for (i1 = 1; i1 < n1-1; i1++) {
        //if (z[i3][i2][i1] > ten[0][1]) {
		if(I3D(oz, n1, n2, i3, i2, i1) > ten[0][1]){
          //ten[0][1] = z[i3][i2][i1];
          ten[0][1] = I3D(oz, n1, n2, i3, i2, i1);
          j1[0][1] = i1;
          j2[0][1] = i2;
          j3[0][1] = i3;
          bubble(ten, j1, j2, j3, mm, 1);
        }
        //if (z[i3][i2][i1] < ten[0][0]) {
        if (I3D(oz, n1, n2, i3, i2, i1) < ten[0][0]) {
          //ten[0][0] = z[i3][i2][i1];
          ten[0][0] = I3D(oz, n1, n2, i3, i2, i1);
          j1[0][0] = i1;
          j2[0][0] = i2;
          j3[0][0] = i3;
          bubble(ten, j1, j2, j3, mm, 0);
        }
      }
    }
  }


  //---------------------------------------------------------------------
  // Now which of these are globally best?
  //---------------------------------------------------------------------
  i1 = mm - 1;
  i0 = mm - 1; 
  for (i = mm - 1; i >= 0; i--) {
    best = 0.0;
    if (best < ten[i1][1]) {
      jg[0][i][1] = 0;
      jg[1][i][1] = is1 - 2 + j1[i1][1];
      jg[2][i][1] = is2 - 2 + j2[i1][1];
      jg[3][i][1] = is3 - 2 + j3[i1][1];
      i1 = i1-1;
    } else {
      jg[0][i][1] = 0;
      jg[1][i][1] = 0;
      jg[2][i][1] = 0;
      jg[3][i][1] = 0;
    }

    best = 1.0;
    if (best > ten[i0][0]) {
      jg[0][i][0] = 0;
      jg[1][i][0] = is1 - 2 + j1[i0][0];
      jg[2][i][0] = is2 - 2 + j2[i0][0];
      jg[3][i][0] = is3 - 2 + j3[i0][0];
      i0 = i0-1;
    } else {
      jg[0][i][0] = 0;
      jg[1][i][0] = 0;
      jg[2][i][0] = 0;
      jg[3][i][0] = 0;
    }

  }
  //  m1 = i1+1;
  //  m0 = i0+1;
  m1 = 0;
  m0 = 0;

  /*
  int cnt = 0;
  printf("  \n");
  printf("  negative charges at\n");
  for (i = 0; i < mm; i++) {
    printf(" (%3d,%3d,%3d)", jg[1][i][0], jg[2][i][0], jg[3][i][0]);
    if (++cnt % 5 == 0) printf("\n");
  }

  cnt = 0;
  printf("  positive charges at\n");
  for (i = 0; i < mm; i++) {
    printf(" (%3d,%3d,%3d)", jg[1][i][1], jg[2][i][1], jg[3][i][1]);
    if (++cnt % 5 == 0) printf("\n");
  }

  cnt = 0;
  printf("  small random numbers were\n");
  for (i = mm-1; i >= 0; i--) {
    printf(" %15.8E", ten[i][0]);
    if (++cnt % 5 == 0) printf("\n");
  }

  cnt = 0;
  printf("  and they were found on processor number\n");
  for (i = mm-1; i >= 0; i--) {
    printf(" %4d", jg[0][i][0]);
    if (++cnt % 10 == 0) printf("\n");
  }

  cnt = 0;
  printf("  large random numbers were\n");
  for (i = mm-1; i >= 0; i--) {
    printf(" %15.8E", ten[i][1]);
    if (++cnt % 5 == 0) printf("\n");
  }

  cnt = 0;
  printf("  and they were found on processor number\n");
  for (i = mm-1; i >= 0; i--) {
    printf(" %4d", jg[0][i][1]);
    if (++cnt % 10 == 0) printf("\n");
  }
  */

  for (i3 = 0; i3 < n3; i3++) {
    for (i2 = 0; i2 < n2; i2++) {
      for (i1 = 0; i1 < n1; i1++) {
        //z[i3][i2][i1] = 0.0;
        I3D(oz, n1, n2, i3, i2, i1) = 0.0;
      }
    }
  }
  
  for (i = mm-1; i >= m0; i--) {
    //z[jg[3][i][0]][jg[2][i][0]][jg[1][i][0]] = -1.0;
	i3 = jg[3][i][0];
	i2 = jg[2][i][0];
	i1 = jg[1][i][0];
    I3D(oz, n1, n2, i3, i2, i1) = -1.0;
  }

  for (i = mm-1; i >= m1; i--) {
    //z[jg[3][i][1]][jg[2][i][1]][jg[1][i][1]] = +1.0;
	i3 = jg[3][i][1];
	i2 = jg[2][i][1];
	i1 = jg[1][i][1];
    I3D(oz, n1, n2, i3, i2, i1) = +1.0;
  }
  #pragma acc update device(oz[0:n3*n2*n1])

  //comm3(z, n1, n2, n3, k);
  comm3(oz, n1, n2, n3, k);

  //---------------------------------------------------------------------
  // showall(z,n1,n2,n3);
  //---------------------------------------------------------------------
}


static void showall(double *oz, int n1, int n2, int n3)
{
  //double (*z)[n2][n1] = (double (*)[n2][n1])oz;

  int i1, i2, i3;
  int m1, m2, m3;

  m1 = min(n1, 18);
  m2 = min(n2, 14);
  m3 = min(n3, 18);

  printf("   \n");
  for (i3 = 0; i3 < m3; i3++) {
    for (i1 = 0; i1 < m1; i1++) {
      for (i2 = 0; i2 < m2; i2++) {
    //    printf("%6.3f", z[i3][i2][i1]);
		  printf("%6.3f", I3D(oz, n1, n2, i3, i2, i2));
      }
      printf("\n");
    }
    printf("  - - - - - - - \n");
  }
  printf("   \n");
}


//---------------------------------------------------------------------
// power  raises an integer, disguised as a double
// precision real, to an integer power
//---------------------------------------------------------------------
static double power(double a, int n)
{
  double aj;
  int nj;
  double rdummy;
  double power;

  power = 1.0;
  nj = n;
  aj = a;

  while (nj != 0) {
    if ((nj % 2) == 1) rdummy = randlc(&power, aj);
    rdummy = randlc(&aj, aj);
    nj = nj/2;
  }

  return power;
}


//---------------------------------------------------------------------
// bubble        does a bubble sort in direction dir
//---------------------------------------------------------------------
static void bubble(double ten[][2], int j1[][2], int j2[][2], int j3[][2],
                   int m, int ind)
{
  double temp;
  int i, j_temp;

  if (ind == 1) {
    for (i = 0; i < m-1; i++) {
      if (ten[i][ind] > ten[i+1][ind]) {
        temp = ten[i+1][ind];
        ten[i+1][ind] = ten[i][ind];
        ten[i][ind] = temp;

        j_temp = j1[i+1][ind];
        j1[i+1][ind] = j1[i][ind];
        j1[i][ind] = j_temp;

        j_temp = j2[i+1][ind];
        j2[i+1][ind] = j2[i][ind];
        j2[i][ind] = j_temp;

        j_temp = j3[i+1][ind];
        j3[i+1][ind] = j3[i][ind];
        j3[i][ind] = j_temp;
      } else {
        return;
      }
    }
  } else {
    for (i = 0; i < m-1; i++) {
      if (ten[i][ind] < ten[i+1][ind]) {

        temp = ten[i+1][ind];
        ten[i+1][ind] = ten[i][ind];
        ten[i][ind] = temp;

        j_temp = j1[i+1][ind];
        j1[i+1][ind] = j1[i][ind];
        j1[i][ind] = j_temp;

        j_temp = j2[i+1][ind];
        j2[i+1][ind] = j2[i][ind];
        j2[i][ind] = j_temp;

        j_temp = j3[i+1][ind];
        j3[i+1][ind] = j3[i][ind];
        j3[i][ind] = j_temp;
      } else {
        return;
      }
    }
  }
}


static void zero3(double *oz, int n1, int n2, int n3)
{
  //double (*z)[n2][n1] = (double (*)[n2][n1])oz;

  int i1, i2, i3;

#pragma acc parallel present(oz[0:n3*n2*n1]) num_gangs(n3) num_workers(8) vector_length(128)
{
  #pragma acc loop gang
  for (i3 = 0; i3 < n3; i3++) {
    #pragma acc loop worker
    for (i2 = 0; i2 < n2; i2++) {
      #pragma acc loop vector
      for (i1 = 0; i1 < n1; i1++) {
   //     z[i3][i2][i1] = 0.0;
   		I3D(oz, n1, n2, i3, i2, i1) = 0.0;
      }
    }
  }
}
}


########## NEXT FILE ##########
//-------------------------------------------------------------------------//
//                                                                         //
//  This benchmark is a serial C version of the NPB SP code. This C        //
//  version is developed by the Center for Manycore Programming at Seoul   //
//  National University and derived from the serial Fortran versions in    //
//  "NPB3.3-SER" developed by NAS.                                         //
//                                                                         //
//  Permission to use, copy, distribute and modify this software for any   //
//  purpose with or without fee is hereby granted. This software is        //
//  provided "as is" without express or implied warranty.                  //
//                                                                         //
//  Information on NPB 3.3, including the technical report, the original   //
//  specifications, source code, results and information on how to submit  //
//  new results, is available at:                                          //
//                                                                         //
//           http://www.nas.nasa.gov/Software/NPB/                         //
//                                                                         //
//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
//                                                                         //
//          Center for Manycore Programming                                //
//          School of Computer Science and Engineering                     //
//          Seoul National University                                      //
//          Seoul 151-744, Korea                                           //
//                                                                         //
//          E-mail:  cmp@aces.snu.ac.kr                                    //
//                                                                         //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
//          and Jaejin Lee                                                 //
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
////                                                                         //
////  The OpenACC C version of the NAS SP code is developed by the           //
////  HPCTools Group of University of Houston and derived from the serial    //
////  C version developed by SNU and Fortran versions in "NPB3.3-SER"        //
////  developed by NAS.                                                      //
////                                                                         //
////  Permission to use, copy, distribute and modify this software for any   //
////  purpose with or without fee is hereby granted. This software is        //
////  provided "as is" without express or implied warranty.                  //
////                                                                         //
////  Send comments or suggestions for this OpenACC version to               //
////                      hpctools@cs.uh.edu                                 //
////
////  Information on NPB 3.3, including the technical report, the original   //
////  specifications, source code, results and information on how to submit  //
////  new results, is available at:                                          //
////                                                                         //
////           http://www.nas.nasa.gov/Software/NPB/                         //
////                                                                         //
////-------------------------------------------------------------------------//
//
////-------------------------------------------------------------------------//
//// Authors: Rengan Xu, Sunita Chandrasekaran, Barbara Chapman              //
////-------------------------------------------------------------------------//

//---------------------------------------------------------------------
// program SP
//---------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>

#include "header.h"
#include "print_results.h"
#include <openacc.h>

/* common /global/ */
int grid_points[3], nx2, ny2, nz2;
logical timeron;

/* common /constants/ */
double tx1, tx2, tx3, ty1, ty2, ty3, tz1, tz2, tz3, 
       dx1, dx2, dx3, dx4, dx5, dy1, dy2, dy3, dy4, 
       dy5, dz1, dz2, dz3, dz4, dz5, dssp, dt, 
       ce[5][13], dxmax, dymax, dzmax, xxcon1, xxcon2, 
       xxcon3, xxcon4, xxcon5, dx1tx1, dx2tx1, dx3tx1,
       dx4tx1, dx5tx1, yycon1, yycon2, yycon3, yycon4,
       yycon5, dy1ty1, dy2ty1, dy3ty1, dy4ty1, dy5ty1,
       zzcon1, zzcon2, zzcon3, zzcon4, zzcon5, dz1tz1, 
       dz2tz1, dz3tz1, dz4tz1, dz5tz1, dnxm1, dnym1, 
       dnzm1, c1c2, c1c5, c3c4, c1345, conz1, c1, c2, 
       c3, c4, c5, c4dssp, c5dssp, dtdssp, dttx1, bt,
       dttx2, dtty1, dtty2, dttz1, dttz2, c2dttx1, 
       c2dtty1, c2dttz1, comz1, comz4, comz5, comz6, 
       c3c4tx3, c3c4ty3, c3c4tz3, c2iv, con43, con16;

/* common /fields/ */
double u[5][KMAX][JMAXP+1][IMAXP+1];
double us     [KMAX][JMAXP+1][IMAXP+1];
double vs     [KMAX][JMAXP+1][IMAXP+1];
double ws     [KMAX][JMAXP+1][IMAXP+1];
double qs     [KMAX][JMAXP+1][IMAXP+1];
double rho_i  [KMAX][JMAXP+1][IMAXP+1];
double speed  [KMAX][JMAXP+1][IMAXP+1];
double square [KMAX][JMAXP+1][IMAXP+1];
double rhs[5][KMAX][JMAXP+1][IMAXP+1];
double forcing[5][KMAX][JMAXP+1][IMAXP+1];

/* common /work_1d/ */
double cv  [PROBLEM_SIZE];
double rhon[PROBLEM_SIZE];
double rhos[PROBLEM_SIZE];
double rhoq[PROBLEM_SIZE];
double cuf [PROBLEM_SIZE];
double q   [PROBLEM_SIZE];
double ue [PROBLEM_SIZE][5];
double buf[PROBLEM_SIZE][5];

/* common /work_lhs/ */
double lhs [IMAXP+1][IMAXP+1][5];
double lhsp[IMAXP+1][IMAXP+1][5];
double lhsm[IMAXP+1][IMAXP+1][5];


int main(int argc, char *argv[])
{
  int i, niter, step, n3;
  double mflops, t, tmax, trecs[t_last+1];
  logical verified;
  char Class;
  char *t_names[t_last+1];

  //---------------------------------------------------------------------
  // Read input file (if it exists), else take
  // defaults from parameters
  //---------------------------------------------------------------------
  FILE *fp;
  if ((fp = fopen("timer.flag", "r")) != NULL) {
    timeron = true;
    t_names[t_total] = "total";
    t_names[t_rhsx] = "rhsx";
    t_names[t_rhsy] = "rhsy";
    t_names[t_rhsz] = "rhsz";
    t_names[t_rhs] = "rhs";
    t_names[t_xsolve] = "xsolve";
    t_names[t_ysolve] = "ysolve";
    t_names[t_zsolve] = "zsolve";
    t_names[t_rdis1] = "redist1";
    t_names[t_rdis2] = "redist2";
    t_names[t_tzetar] = "tzetar";
    t_names[t_ninvr] = "ninvr";
    t_names[t_pinvr] = "pinvr";
    t_names[t_txinvr] = "txinvr";
    t_names[t_add] = "add";
    fclose(fp);
  } else {
    timeron = false;
  }

  printf("\n\n NAS Parallel Benchmarks (NPB3.3-ACC) - SP Benchmark\n\n");

  if ((fp = fopen("inputsp.data", "r")) != NULL) {
    int result;
    printf(" Reading from input file inputsp.data\n");
    result = fscanf(fp, "%d", &niter);
    while (fgetc(fp) != '\n');
    result = fscanf(fp, "%lf", &dt);
    while (fgetc(fp) != '\n');
    result = fscanf(fp, "%d%d%d", &grid_points[0], &grid_points[1], &grid_points[2]);
    fclose(fp);
  } else {
    printf(" No input file inputsp.data. Using compiled defaults\n");
    niter = NITER_DEFAULT;
    dt    = DT_DEFAULT;
    grid_points[0] = PROBLEM_SIZE;
    grid_points[1] = PROBLEM_SIZE;
    grid_points[2] = PROBLEM_SIZE;
  }


  printf(" Size: %4dx%4dx%4d\n", 
      grid_points[0], grid_points[1], grid_points[2]);
  printf(" Iterations: %4d    dt: %10.6f\n", niter, dt);
  printf("\n");

  if ((grid_points[0] > IMAX) ||
      (grid_points[1] > JMAX) ||
      (grid_points[2] > KMAX) ) {
    printf(" %d, %d, %d\n", grid_points[0], grid_points[1], grid_points[2]);
    printf(" Problem size too big for compiled array sizes\n");
    return 0;
  }
  nx2 = grid_points[0] - 2;
  ny2 = grid_points[1] - 2;
  nz2 = grid_points[2] - 2;

  set_constants();
  
  for (i = 1; i <= t_last; i++) {
    timer_clear(i);
  }
  acc_init(acc_device_default);

#pragma acc data create(u,us,vs,ws,qs,rho_i,speed,square,forcing,rhs)
{
  exact_rhs();
  #pragma acc update device(forcing)

  initialize();
  #pragma acc update device(u)

  //---------------------------------------------------------------------
  // do one time step to touch all code, and reinitialize
  //---------------------------------------------------------------------
  adi();
  initialize();
  #pragma acc update device(u)
  
  for (i = 1; i <= t_last; i++) {
    timer_clear(i);
  }
  timer_start(1);

  for (step = 1; step <= niter; step++) {
    if ((step % 20) == 0 || step == 1) {
      printf(" Time step %4d\n", step);
    }

    adi();
  }
  
  #pragma acc update host(u)
  timer_stop(1);
  tmax = timer_read(1);
  
  verify(niter, &Class, &verified);
  mflops = 0.0;
} /*end acc data*/

  print_results("SP", Class, grid_points[0], 
                grid_points[1], grid_points[2], niter, 
                tmax, mflops, "          floating point", 
                verified, NPBVERSION,COMPILETIME, CS1, CS2, CS3, CS4, CS5, 
                CS6, CS7);

  acc_shutdown(acc_device_default);

  return 0;
}


########## NEXT FILE ##########
